Testing C Programs for Buffer Overflow Vulnerabilities
EricHaugh MattBishop
haugh@cs.ucdavis.edu
(cid:0)
bishop@cs.ucdavis.edu
UniversityofCaliforniaatDavis
Abstract
Security vulnerabilities often result from bufferover-
flows. A testing technique that instruments programs
withcodethatkeepstrackofmemorybuffers,andchecks
arguments to functions to determine if they satisfy cer-
tain conditions, warns when a buffer overflow may oc-
cur. It does so when executed with ”normal” test data
asopposedtotestdatadesignedto triggerbufferover-
flows. Atoolusingthismethodwasdevelopedandeval-
uatedbytestingthreewidelyused,opensourcesoftware
packages. This evaluationshowsthat the tool is useful
forfindingbufferoverflowflaws, thatithasalowfalse
positiverate,andcompareswellwithothertechniques.
1 Introduction
Buffer overflow vulnerabilities are one of the most
common security flaws [6]. Over the past few years,
theyhaveaccountedforupto50%oftheadvisoriesis-
sued by CERT, demonstrating just how serious the is-
sueis. TheinfamousInternetwormof1988exploiteda
bufferoverflowvulnerabilityinthe (cid:1)(cid:3) (cid:2)(cid:5) (cid:4)(cid:7) (cid:6)(cid:9) (cid:8)(cid:11) (cid:10)(cid:7) (cid:12)(cid:14) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17) server
program[8].
A buffer overflow flaw typically results when a pro-
grammerfailstodoboundscheckingwhenwritingdata
into a fixed length buffer, or does the bounds check-
ing incorrectly (for example, the check is off-by-one)
[15,20].
Intheclassicscenario,thebufferislocatedonthepro-
gram stack, and thevaluewritten overisthe returnad-
dressforthecurrentstackframe[1,23]. Thereturnad-
dressischangedtopointbackintothebuffer,andwhen
thefunctioninwhichtheoverflowoccurredreturns,the
program jumps to the bogus return address and begins
executingthecontentsofthebuffer. Sincethecontents
of the buffer were determined by the attacker, she can
(cid:19)
then executeany code that fits into the buffer, with the
sameprivilegesastheprogram.
Overflowablebuffersallocatedontheheaporthedata
segment also pose a threat, though they are typically
harderforanattackertoexploit. Theattackermustfind
somevalueinmemoryshecanoverwritethatissecurity
critical, such as a user id or a filename. Sometimes a
function pointer stored on the heap can be changed to
point to an arbitrary location, so that when the pointer
is dereferenced,codeoftheattacker’schoosingwillbe
executed. Suchattackshaveoccurred[4,19].
Traditional testing methods, such as statement or
branchcoverage,dolittletofindbufferoverflowvulner-
abilities [25]. The problem is that the program values
andexecutionpathsneededtorevealasecurityflawdo
not show up during regular operation; hence, they are
alsounlikelytoshowupduringtesting. Weproposeus-
ing a testing method that tracks possible bufferlengths
as the program executes. Library functions have pre-
conditionsdefiningwhenbufferoverflowwillnotoccur.
If the lengths could cause these conditions to be vio-
lated,bufferoverflowcouldoccur(evenifitdoesnotin
thisparticularexecution). Thisamelioratestheproblem
above.
Section 2 reviews some of the many approaches to
theproblemofdetectingbufferoverflowflawsinsource
code. Section 3 presents an approach to aid a tester to
find buffer overflow vulnerabilities. This involves in-
strumentingasourceprogram,testingtheprogram,and
then using the warnings generated by the instrumenta-
tionasanindicatoroflikelybufferoverflowconditions.
Section4describesatoolthatimplementsthisapproach.
Section5presentstheresultsofusingthistoolonthree
opensourcesoftwarepackages,andsection6discusses
these results and compares the approach with previous
approaches. Section7concludes.
Throughout this paper we focus on the C program-
ming language. C provides little syntactic checking of
bounds, and C programs and functions tend to be very
terse, with (unfortunately) a minimum of error check-
ThisworkwasfundedbytheNationalAeronauticsandSpaceAd- ing. HencetherearemanyCprogramsthatsufferfrom
ministration’sJetPropulsionLaboratorythroughcontract1215858to security problems, including buffer overflows. But the
theUniversityofCaliforniaatDavis.
1methodworksforanysimilarlanguage.
2 Previous Work
Work analyzing programs for buffer overflows falls
intotwoclasses: staticanalysisanddynamicanalysis.
2.1 StaticAnalysis
A number of tools examine source code for buffer
overflow.
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
, typical of a large class of these tools,
scans C and C++ source code for known dangerous li-
brarycalls[22]. Italsodoesasmallamountofchecking
on the arguments to these calls and reports the sever-
ity of the threat. For example, library calls that copy a
fixed-lengthstring intoa bufferare rated as less severe
thanlibrarycallsthatcopythecontentsofanarrayintoa
buffer(presumably,becausetheprogrammerknowsthe
lengthofthestringandnotthenumberofcharactersin
thearray).Italsolooksforotherpotentialproblemssuch
asraceconditions.Othersimilartoolsinclude
(cid:7)(cid:9) (cid:8)(cid:9) (cid:1)(cid:4) (cid:3)
[21]
andSplint[16].
Wagner et al. used an integer range analysis to lo-
catepotentialbufferoverflows[25].TheytreatCstrings
as an abstract data type, and assume that they are only
manipulatedbythe C Standard Libraryfunctions, such
as
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) and
(cid:10)(cid:2) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13)(cid:20) (cid:19)(cid:18) (cid:17)
do so, it instrumentsgthe compiled program with code
thatperformsdifferentkindsofmemorybookkeeping.
An alternate approach is to test programs. A tool
calledFuzzwasusedtoteststandardUNIXutilitiesby
giving them input consisting of large, random streams
of characters[17]. 25-33% of the programs crashed or
hung. The dominantcauses were problems with point-
ers and array dereferencing, including buffer overflow
flaws. Property-based testing [9, 11] checks that pro-
grams satisfy certain properties, including security re-
latedproperties. Forexample,thepropertythatthepro-
gramisfreeofbufferoverflowvulnerabilitiesisapplica-
bletomostprogramsandcanbespecifiedinTASPEC.
During testing, violations of the specification are de-
tected. Software fault injection testing methods make
syntactic changes to the code under test. If the change
canresultinaviolationofthesystemsecuritypolicy,the
tester has found a portion of code that must be correct
inordertoavoidthepresenceofavulnerability. Ghosh
andO’Connorusethistechniquetofindbufferoverflows
[12].
Themainproblemwithdynamicanalysisistheneed
for test data that causes the overflows. Unless the data
giventotheprogramcausesanoverflow,thesedynamic
techniques will not detect any possible cases where
bufferoverflowoccurs.
. They track allocated
memory and the possible length of strings, and when- 3 UsingBuffer SizesinDynamicAnalysis
ever the maximum length of a string can exceed the
minimum allocated space, a buffer overflow may oc- WeextendWagneretal.’smethodtodynamicexecu-
cur. Pointer aliasing, the flow-insensitiveanalysis, and tion.Thisenablesustodetectpotentialbufferoverflows
the way functioncallsare handledmean that thestring thatdonotactuallyoccurduringtesting,butmighthave
length and allocated memory amount are approxima- occurredhaddifferenttestdatabeenused[14].
tions,ratherthantheactualvaluesforeachpossibleex- Consider the library function
ecution. Hencethismethodisimprecise. Doretal. im-
provedthisscheme,butrequiredannotation[7].
Theproblemwithstaticanalysismethodsistheirim-
precision. Because the general problem of detecting
bufferoverflowvulnerabilitiesbyscanningsourcecode
isingeneralundecidable,allsuchtoolsuseheuristicsto
determinewherebufferoverflowmightoccur. Dynamic
toolstakeadifferentapproach.
2.2 DynamicAnalysis
Dynamicanalysisexaminesprogramexecutiontode-
terminewhetherbufferoverflowsoccurduringthatexe-
cution.Compilerscanaddcodetocheckboundsortoar-
rangedatastructuresinmemorytocausehardwarefaults
ifboundsareexceeded;however,thisadditionalinstru-
mentation is often turned off in the name of efficiency.
Various tools augment, or replace, this ability. For ex-
ample, Purify [13] can detect many kinds of memory
errors, includingaccessinga bufferpast its bounds. To
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:23) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) (cid:13) (cid:12)
(cid:10)(cid:12) (cid:11)(cid:25) (cid:24)(cid:26) (cid:10)
(cid:10)(cid:14) (cid:13)(cid:7) (cid:17) ,
which copies a string from
(cid:10)
(cid:10)(cid:14) (cid:13) to (cid:12)
(cid:10)(cid:12) (cid:11)
. Because this
libraryfunctiondoesnotdoanyboundschecking,ifthe
lengthof
(cid:10)
(cid:10)(cid:14) (cid:13) islongerthanthespaceallocatedto (cid:12)
(cid:10)(cid:12) (cid:11)
,
the data at the end of
(cid:10)
(cid:10)(cid:14) (cid:13) that didn’tfit into (cid:12)
(cid:10)(cid:2) (cid:11)
over-
writesthememorylocationsthatfollow (cid:12)
(cid:10)(cid:12) (cid:11)
.Thisisthe
quintessentialbufferoverflow[1],andifthecontentsof
(cid:10)
(cid:10)(cid:23) (cid:13) are determined by user input, an attacker may be
able to exploit this to execute arbitrary code or change
datavalues.
During normal testing, if the string stored in
(cid:10)
(cid:10)(cid:23) (cid:13) is
not long enough, the potential buffer overflowwill not
bedetected. But, supposethespaceallocatedto
(cid:10)
(cid:10)(cid:14) (cid:13) is
longer thanthe space allocatedto (cid:12)
(cid:10)(cid:2) (cid:11)
for someexecu-
tionoftheprogram.Thiscanbedetectedatruntime,and
it may indicate a vulnerability. Consider the program
fragment shown in table 1. This has a buffer overflow
condition,becauseiftheuserentersmorethan100char-
acters, the library function
(cid:10)(cid:2) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) will overflow (cid:12)
(cid:10)(cid:2) (cid:11)
.
Thiscanbedetectedatruntime,when
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) iscalled,
bynoticingthattheamountofspaceallocatedto
(cid:10)
(cid:10)(cid:14) (cid:13) is(cid:1)(cid:13)
(cid:1)(cid:13)
(cid:1)
(cid:10)(cid:12)
(cid:0)
(cid:0)
(cid:6)(cid:9)
(cid:11)
(cid:21)(cid:11)
(cid:21)(cid:11)
(cid:8)
(cid:10)(cid:23)
(cid:10)
(cid:10)
(cid:11)(cid:14)
(cid:13)(cid:2)
(cid:10)
(cid:15)(cid:18)
(cid:10) (cid:12)
(cid:13)
(cid:17)
(cid:10)(cid:14)
(cid:10)(cid:12)
(cid:10)
(cid:13)
(cid:3)(cid:13)
(cid:11)
(cid:10)(cid:23)
(cid:12)
(cid:2)(cid:5)
(cid:2)(cid:13)
(cid:13)
(cid:10)(cid:12)
(cid:4)(cid:7)
(cid:12)(cid:1)
(cid:24)
(cid:11)(cid:25)
(cid:6)(cid:8)
(cid:6)(cid:8)
(cid:24)(cid:26)
(cid:6)(cid:8)
(cid:6)(cid:8)
(cid:4)(cid:7)
(cid:9)(cid:11)
(cid:9)(cid:11)
(cid:6)(cid:8)
(cid:10)
(cid:10)
(cid:10)
(cid:6)
(cid:10)(cid:14)
(cid:24)
(cid:13)(cid:7) (cid:14)(cid:17)
(cid:10)(cid:12)
(cid:10)
(cid:11)
(cid:12)(cid:3) (cid:2)(cid:5) (cid:4) (cid:14)(cid:17) (cid:10)
Table1.Unsafecallto (cid:10)(cid:12) (cid:11) (cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:9) (cid:17) (cid:13) (cid:17)
lessthantheamountofspaceallocatedto (cid:12) (cid:10)(cid:12) (cid:11) .
If the program is instrumented to keep track of how
much space is allocated to each buffer, this potential
overflow can be detected during testing, even if the
bufferoverflowdidnotoccurduringtesting.
Thisapproachdoesnoteliminatefalsepositives. For
example:
(cid:1)(cid:13)
(cid:1)(cid:13)
(cid:1)
(cid:10)
(cid:10)(cid:12)
(cid:0)
(cid:0)
(cid:6)(cid:9)
(cid:10)(cid:14)
(cid:11)
(cid:21)(cid:11)
(cid:21)(cid:11)
(cid:8)
(cid:15)(cid:13)
(cid:10)(cid:23)
(cid:10)
(cid:10)
(cid:11)(cid:14)
(cid:2)(cid:5)
(cid:13)(cid:2)
(cid:10)
(cid:16)(cid:7)
(cid:15)(cid:18)
(cid:10)
(cid:12)
(cid:13)
(cid:16)(cid:8)
(cid:17)
(cid:10)(cid:14)
(cid:10)(cid:12)
(cid:10)
(cid:9)(cid:18)
(cid:13)
(cid:3)(cid:13)
(cid:11)
(cid:10)(cid:23)
(cid:12)
(cid:2)(cid:5)
(cid:2)(cid:13)
(cid:13)
(cid:17)(cid:20)
(cid:10)(cid:12)
(cid:4)(cid:7)
(cid:12)(cid:1)
(cid:24)
(cid:11)(cid:25)
(cid:6)(cid:8)
(cid:6)(cid:8)
(cid:19)(cid:22)
(cid:24)(cid:26)
(cid:6)(cid:8)
(cid:6)(cid:8)
(cid:4)(cid:7)
(cid:21)(cid:8)
(cid:9)(cid:11)
(cid:9)(cid:11)
(cid:6)(cid:8)
(cid:6)(cid:3)
(cid:10)
(cid:10)
(cid:10)
(cid:6)
(cid:19)(cid:8)
(cid:10)(cid:14)
(cid:24)
(cid:10)
(cid:13)(cid:7) (cid:14)(cid:17)
(cid:10)(cid:12)
(cid:10)
(cid:11)
(cid:12)(cid:3) (cid:2)(cid:5) (cid:4) (cid:14)(cid:17) (cid:10)
Even though the call to (cid:1) (cid:6)(cid:9) (cid:8)
(cid:11)(cid:14) (cid:10)
can place a string of
lengthupto199in
(cid:10)
(cid:10)(cid:14) (cid:13) ,thenullassignmentjustbefore
the callto
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) means that
(cid:10)
(cid:10)(cid:14) (cid:13) always contains
astringoflength99orless. Soin thiscase, thecallto
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:23) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) issafe.
If the buffers passed to
(cid:10)(cid:2) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) are dynamically al-
located, it may not be possible to compute their actual
allocationsuntilexecution.Considerthiscode:
(cid:1)(cid:13)
(cid:1)(cid:13)
(cid:1)
(cid:12)
(cid:10)(cid:12)
(cid:0)
(cid:0)
(cid:6)(cid:9)
(cid:10)(cid:12)
(cid:11)
(cid:21)(cid:11)
(cid:21)(cid:11)
(cid:8)
(cid:11)
(cid:10)(cid:23)
(cid:10)
(cid:24)(cid:10)
(cid:11)(cid:14)
(cid:13)(cid:2)
(cid:23)
(cid:10)
(cid:17)(cid:26)
(cid:15)(cid:18)
(cid:10)
(cid:13)
(cid:17)
(cid:10)(cid:14)
(cid:12)
(cid:10)
(cid:25)
(cid:13)
(cid:3)(cid:13)
(cid:10)(cid:12)
(cid:10)(cid:23)
(cid:28)(cid:21)
(cid:12)
(cid:2)(cid:5)
(cid:11)
(cid:13)
(cid:27)(cid:7)
(cid:10)(cid:12)
(cid:4)(cid:7)
(cid:10)
(cid:24)
(cid:27)(cid:8)
(cid:11)(cid:25)
(cid:6)(cid:8)
(cid:29)(cid:4)
(cid:24)(cid:26)
(cid:6)(cid:8)
(cid:4)(cid:7)
(cid:13)
(cid:9)(cid:11)
(cid:6)(cid:8)
(cid:13)
(cid:10)
(cid:10)
(cid:6)
(cid:10)
(cid:10)(cid:14)
(cid:24)
(cid:31)(cid:2)
(cid:13)(cid:7)
(cid:30)
(cid:14)(cid:17)
(cid:10)(cid:12)
(cid:7)(cid:8)
(cid:10)
(cid:11)
(cid:29)
(cid:12)(cid:3)
(cid:1)(cid:14)
(cid:2)(cid:5)
(cid:13)
(cid:4)
(cid:13)
(cid:14)(cid:17)
(cid:0)
(cid:10)
(cid:21)(cid:11) (cid:10)(cid:3) (cid:8)(cid:17) (cid:23) (cid:13)
(cid:10)(cid:16) (cid:11)
!(cid:10) (cid:27)(cid:11) (cid:8)(cid:11) (cid:4) (cid:13)
(cid:10)
(cid:10)(cid:23) (cid:13)(cid:7) #(cid:17) "$ (cid:12)(cid:11) (cid:17) %(cid:17) (cid:10)
Iftheinputis199characters,thespaceallocatedto (cid:12)
(cid:10)(cid:12) (cid:11)
willbelessthanthespaceallocatedto
(cid:10)
(cid:10)(cid:23) (cid:13) ,andawarn-
ingwillbeissued. However,nobufferoverflowcanoc-
curbecausetheamountofspaceallocatedto (cid:12)
(cid:10)(cid:12) (cid:11)
isallo-
cateddynamicallytobethelengthofthestringin
(cid:10)
(cid:10)(cid:14) (cid:13) .
Other common C library functions amenable to this
analysis are listed below. The property to be tested is
alsoshown.Werefertotheseas“interestingfunctions.”
For our purposes, we limited our analysis to these; the
interested reader is encouraged to find other functions
andderivetherelevantproperty.Inthislist,thenotation
&( ’# )(cid:11) *
(cid:31)(cid:10) +
meansthelengthofthestringstoredinthebuffer
(cid:10)
,and
,
&( &( -(cid:31) ./ *
0(cid:10) +
meanstheamountofspaceallocatedto
(cid:10)
1.
.
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:23) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13)
(cid:10) (cid:24)(cid:26) (cid:1)(cid:10) 1
(cid:1) (cid:1)(cid:3) (cid:1)(cid:2) 2 (cid:14)(cid:17) (cid:10) is
, &( &3 -(cid:31) .0 * (cid:1)(cid:10) 1 (cid:1) (cid:1)(cid:3) #(cid:2) 2 + ,
&( &3 -(cid:31) .0 *
(cid:31)(cid:10) +5 4
&3 ’ )(cid:11) *
(cid:31)(cid:10) +7 6 ?
2.
(cid:10)(cid:12) (cid:11)
(cid:10) (cid:4) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13) (cid:12)
(cid:10)(cid:12) (cid:11)(cid:25) (cid:24) (cid:10)
(cid:10)(cid:14) (cid:13)
(cid:24)
(cid:4) %(cid:17) (cid:10) is
,
&( &3 -(cid:31) .0 * (cid:12)
(cid:10)(cid:12) @(cid:11) +
(cid:4)
6
&3 ’# )(cid:11) *( 8(cid:7) 9; :
+= <? >
?
3. (cid:10) (cid:15)(cid:7) (cid:10)(cid:3) (cid:2)(cid:5) (cid:4) (cid:11) (cid:1)(cid:14) (cid:13) (cid:12) (cid:10)(cid:12) (cid:11)(cid:25) B(cid:24) A# C(cid:23) !(cid:10) A (cid:24) (cid:10) (cid:10)(cid:14) (cid:13)(cid:7) (cid:14)(cid:17) (cid:10) is
,
&( &3 -(cid:31) .0 *
(cid:10)
(cid:10)(cid:14) (cid:13)
+
, &( &3 -(cid:31) .0 * (cid:12) (cid:10)(cid:12) @(cid:11) +D 4 ?
4.
(cid:10)
(cid:4)(cid:9) (cid:15) (cid:10) (cid:2)(cid:5) (cid:4)
(cid:11)
(cid:1) (cid:13) (cid:12)
(cid:10)(cid:12) (cid:11)(cid:25) (cid:24)
(cid:4)
E(cid:24) A# C(cid:23) F(cid:10) A (cid:24) (cid:10)
(cid:10)(cid:14) (cid:13)(cid:7) (cid:14)(cid:17) (cid:10) is
(cid:4)
<G ,
&( &3 -(cid:31) .0 * (cid:12)
(cid:10)(cid:12) (cid:8)(cid:11) +
?
5. (cid:1) (cid:6)(cid:9) (cid:8)
(cid:11)(cid:14) (cid:10)
(cid:13)
(cid:10) (cid:24)
(cid:4)
F(cid:24) H(cid:7) H(cid:7) H
(cid:14)(cid:17) (cid:10) is
,
&( &( -(cid:31) ./ *
0(cid:10) +I 4
(cid:4) ?
6. (cid:25) (cid:1)(cid:8) (cid:25) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) (cid:13) (cid:12)
(cid:10)(cid:12) (cid:11)(cid:25) (cid:24)(cid:26) (cid:10)
(cid:10)(cid:14) (cid:13)
(cid:24)
(cid:4) (cid:14)(cid:17) (cid:10) is (cid:4)
<J ,
&3 &( -(cid:31) .0 * (cid:12)
(cid:10)(cid:12) (cid:7)(cid:11) +
?
7. (cid:25) (cid:1)(cid:8) (cid:25) (cid:13)(cid:9) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) (cid:13) (cid:12)
(cid:10)(cid:12) (cid:11)(cid:25) (cid:24) (cid:10)
(cid:10)(cid:14) (cid:13)
(cid:24)
(cid:13)
(cid:24)
(cid:4) (cid:14)(cid:17) (cid:10) is
,
&( &3 -(cid:31) .0 * (cid:12)
(cid:10)(cid:12) @(cid:11) +
(cid:4)
< ?
8. (cid:25) (cid:1)(cid:8) (cid:25)(cid:8) (cid:25)K (cid:29)@ L(cid:9) (cid:8) (cid:13) (cid:12)
(cid:10)(cid:12) (cid:11)(cid:25) (cid:24) (cid:10)
(cid:10)(cid:14) (cid:13)
(cid:24)
(cid:4) %(cid:17) (cid:10) is (cid:4)
<(cid:26) ,
&( &3 -(cid:31) .0 * (cid:12)
(cid:10)(cid:12) (cid:8)(cid:11) +
?
9.
M
/(cid:13) (cid:29) (cid:15)(cid:18) (cid:17) (cid:13)
(cid:10)
(cid:10)(cid:23) (cid:13)
(cid:24)
(cid:12)
(cid:10)(cid:2) (cid:11)(cid:25) (cid:24)
(cid:4) (cid:14)(cid:17) (cid:10) is (cid:4)
<G ,
&( &( -(cid:31) ./ * (cid:12)
(cid:10)(cid:12) (cid:8)(cid:11) +
?
When a security analyst obtains a report of possible
security problems, she may wishto prioritize the order
inwhichsheinvestigatesproblems.
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
prioritizedthe
list of vulnerabilities it found, and we employ a sim-
ilar technique. For example, when the destination of
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) is dynamically allocated, the programmer had
to calculate how much space to allocate. If the alloca-
tionistoosmallforonecase,webelieveitislikelythe
case for all executions of the program. Then the pro-
gramwillmisbehaveduringnormaltestinganyway. Of
course,therewillbeexceptions,butourexperienceindi-
catesthatoverflowsinvolvingdynamicallocationoccur
less often than those involving one or more buffers of
static size. A similar argument applies to
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13) (cid:19)(cid:18) (cid:17)
and
(cid:10)
(cid:15)(cid:7) (cid:10) (cid:2)(cid:5) (cid:4)
(cid:11)
(cid:1)(cid:14) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) . Whenthedestinationandthesource
buffers are both statically allocated, a “type 0” warn-
ing is issued. When the destination is dynamically al-
located, a“type2”warningoccurs(whetherthesource
isdynamicallyorstaticallyallocated). Whenthesource
isdynamicallyallocatedbutthedestinationisstatically
allocated, a “type 1” error arises. Table 2 summarizes
thesewarnings.
Thebenefitofthisdynamicapproachisthatthereisno
needto makeapproximationstodeal with pointersand
casts, which make C difficult to analyze statically. At
Type Description
0 sourceanddestinationstaticallyallocated
1 sourcedynamicallyallocated,destination
staticallyallocated
2 destinationdynamicallyallocated
Table2.WarningTypesanypoint in the executionof the program, the valueof
anyvariableisknown. Becauseofthenecessaryimpre-
cisionwithastaticapproachforalanguagelikeC,any
warning generated by a static overflow detection tool
must be investigated by inspection. With the dynamic
approachoutlinedabove,thetestermuststillinvestigate
eachwarningbyinspection,aswellasgenerateasetof
testcasestosatisfysomecoveragemetric. Butbecause
thedynamicapproachwillsufferfromlessimprecision,
the number of false positives is potentially less. If the
test set must be generated for functional testing of the
application,thisapproachismorelikelytoresultinless
work for the tester, while still providinga similar level
ofaccuracy.
4 TheTool
Thetool
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
(SystematicTestingOf BufferOver-
flows) implements these ideas. It takes as input the
sourcefiles of a program
(cid:5)
to be tested, andgenerates
aninstrumentedversionofeachfile, whichwhencom-
piled creates
(cid:5)(cid:7) (cid:6)
. The input files must be preprocessed
beforebeinginputto
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
.Whenexecuted,
(cid:5)(cid:9) (cid:6)
hasthe
same behavioras
(cid:5)
, exceptinformation about the test-
ingcoverageachievedandthe warnings thatwere gen-
erated are emitted to a trace file. The coverage metric
usedby
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
iscalled“interestingfunctioncoverage.”
Thisisasimplemetricthatissatisfiedwheneveryfunc-
tioncalltooneoftheinterestingfunctionsisexecuted.
Clearly, interesting function coverage is subsumed by
statementcoverage. Thismetricwaschosenforitssim-
plicity, and because it is relatively easy for a tester to
satisfy.
Tokeeptrackofthebuffersthattheprogrammermay
pass to an interesting function,
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
creates special
function calls which appear in
(cid:5)(cid:9) (cid:6)
. One call is added
for eachvariabledeclarationthat declaresa buffer,and
onefor eachCStandardLibraryfunctionthatmanages
dynamicallyallocatedmemory.Also,eachcalltoanin-
teresting function is replaced with a call to a wrapper
function,whichtheninvokestheinterestingfunction.
Consider how
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
would modify the following
codefragment:
LF
(cid:11)
(cid:13)
(cid:29)(cid:18) (cid:2) (cid:12)
(cid:1)(cid:13)
(cid:12)
(cid:1)
(cid:0)(cid:4)
(cid:23)
1
(cid:21)
(cid:4)
(cid:10)
(cid:28)(cid:12)
(cid:13)
(cid:29)
(cid:13)
M(cid:7)
(cid:17)
1
(cid:10)(cid:12)
$(cid:1)
(cid:8)(cid:11)
(cid:12)
1
(cid:2)
(cid:1)
(cid:12)(cid:1)
5(cid:1)
(cid:6)(cid:7) (cid:6)(cid:8)
(cid:23)
(cid:9)
(cid:12)
(cid:24) M(cid:7) 1
(cid:28)(cid:1) (cid:4) (cid:2) (cid:12)(cid:1) (cid:6)(cid:7) (cid:6)(cid:8) (cid:9)
(cid:24) M(cid:7) 1
(cid:1)(cid:18) (cid:19) (cid:2)(cid:5) (cid:4)(cid:7) (cid:6)(cid:7) (cid:6)(cid:8) (cid:9)(cid:3) (cid:10)
Inthe
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
output,thiswillappearas:
LF (cid:29)(cid:18) (cid:2) (cid:12)
(cid:1)(cid:13)
(cid:1)
(cid:0)(cid:4)
1
(cid:21)
(cid:4)
(cid:10)
!(cid:13) (cid:12)
M(cid:7)
(cid:13)
1
(cid:17)
$(cid:1) (cid:12)
(cid:11)
(cid:2) (cid:12)(cid:1) (cid:6)(cid:7) (cid:6)(cid:8) (cid:9)
(cid:24) M(cid:7) 1
(cid:28)(cid:1) (cid:4) (cid:2) (cid:12)(cid:1) (cid:6)(cid:7) (cid:6)(cid:8) (cid:9)
(cid:24) M(cid:7) 1
(cid:1)(cid:18) (cid:19) (cid:2)(cid:5) (cid:4)(cid:7) (cid:6)(cid:7) (cid:6)(cid:8) (cid:9)(cid:3) (cid:10)
(cid:14)(cid:15)
(cid:14)(cid:15)
(cid:14)(cid:15)
(cid:13)
(cid:14)
(cid:14)
(cid:14)
(cid:3)(cid:6)
(cid:3)(cid:6)
(cid:3)(cid:6)
(cid:1)(cid:1)
(cid:1)(cid:1)
(cid:1)(cid:1)
(cid:12)
(cid:0)(cid:3)
(cid:0)(cid:3)
(cid:0)(cid:3)
(cid:23)
(cid:2)(cid:4)
(cid:2)(cid:4)
(cid:2)(cid:4)
(cid:0)
(cid:0)
(cid:0)
(cid:28)(cid:12)
(cid:14)
(cid:14)
(cid:14)(cid:29)
(cid:1)(cid:3)
(cid:10)(cid:12)
(cid:10)(cid:12)
(cid:2)
(cid:11)
(cid:11)
(cid:10)(cid:12)
(cid:10)
(cid:21)
(cid:21)
(cid:8)(cid:11)
(cid:10)(cid:2)
(cid:13)(cid:17)
(cid:13)(cid:17)
1
(cid:11)
(cid:16)
(cid:16)
(cid:1)
(cid:14)
(cid:14)
(cid:14)5(cid:1)
(cid:10)(cid:12)
M(cid:7)
M(cid:7)
(cid:11)
1
1
(cid:23)
(cid:21)(cid:18)
(cid:1)
(cid:1)
(cid:12)
(cid:13)(cid:10)
(cid:13)
(cid:13)
(cid:16)
M(cid:7)
M(cid:7)
(cid:14)
1
1
M(cid:7)
(cid:28)(cid:1)
(cid:1)(cid:18)
1
(cid:4)
(cid:19)
(cid:1)(cid:14)
(cid:24)
(cid:24)
(cid:13)
M(cid:8)
(cid:10)
(cid:10)
(cid:10)
1 (cid:31)(cid:2)
(cid:31)(cid:2)
(cid:31)(cid:2)
(cid:24)(cid:1)
(cid:30)(cid:7)
(cid:30)(cid:7)
(cid:30)(cid:7)
(cid:12)
(cid:8)(cid:8)
(cid:8)(cid:8)
(cid:8)(cid:8)
(cid:24) (cid:29)
(cid:29)
(cid:29)
(cid:1)(cid:14)
(cid:1)(cid:14)
(cid:1)(cid:14)
(cid:13)
(cid:13)
(cid:13)
M(cid:7)
M(cid:7)
M(cid:7)
1
1
1
$(cid:1)
(cid:28)(cid:1)
(cid:1)(cid:18)
(cid:12)
(cid:4)(cid:18)
(cid:19)(cid:18)
(cid:17)
(cid:17)
(cid:17)
(cid:14)(cid:17)
(cid:14)(cid:17)
(cid:14)(cid:17)
(cid:10)
(cid:10)
(cid:10)
The newfunction calls record the fact that newbuffers
havecomeintoscope.Eachofthesecallsplacethestart-
ingaddressofabufferontoalist,alongwiththesizeof
thebuffer.
The function
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
(cid:1)(cid:3) (cid:2) (cid:10)
(cid:10)(cid:12) (cid:11) (cid:10)(cid:12) (cid:11)
(cid:21)(cid:4) (cid:13)(cid:10) (cid:16)
M(cid:7) 1
(cid:1)(cid:14) (cid:13) (cid:17)
does some additional work compared to
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0) (cid:10)(cid:12) (cid:11)
(cid:21) (cid:13)(cid:17) (cid:16)
M(cid:7) 1
(cid:1)(cid:14) (cid:13) (cid:17) : it scans the list of already
recorded statically allocated buffers, and removes any
entries for buffers whose lifetime has ended. An alter-
native for removing expired buffers would be to insert
instrumentationatthepointeachbufferexpires(e.g.,at
allreturnstatementswithinthefunction). However,the
use of non-local jumps, such as (cid:27)(cid:8) (cid:29)(cid:11) (cid:4) (cid:6)(cid:8) (cid:1)(cid:18) (cid:25) (cid:15) (cid:13) (cid:19)(cid:18) (cid:17) , means
that some buffers would not be removed from the list
whentheyarenolongerinuse.
To keep track of dynamic memory, each call to
one of the C Standard Library functions (cid:25)(cid:14) (cid:28)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) ,
(cid:13)(cid:22) (cid:7)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13) (cid:19)(cid:18) (cid:17) , (cid:10)(cid:9) (cid:8)(cid:9) (cid:7)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13) (cid:19)(cid:18) (cid:17) , and (cid:1) (cid:10)(cid:9) (cid:8) (cid:8) (cid:13) (cid:19)(cid:18) (cid:17) are replaced
with a wrapperfunction. Thefirst of these threewrap-
pers record the starting address paired with the buffer
length,whichisplacedonalistofdynamicallyallocated
buffers. Thislistisseparatefromthetwolists usedfor
statically allocated buffers. The wrapper for (cid:1) (cid:10)(cid:9) (cid:8) (cid:8) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17)
removesthefreedbufferfromthelist.
Sometimesa programmer will allocate an amount of
memory using (cid:25) (cid:7)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13) (cid:19)(cid:18) (cid:17) or (cid:13) (cid:28)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) that is con-
stantacrossdifferentexecutionsoftheprogram.Forex-
ample:
(cid:15)
(cid:11)
5(cid:10) (cid:17)J (cid:25) (cid:28)(cid:21) (cid:27)(cid:7) (cid:27)@ (cid:29) (cid:13) (cid:13)(cid:20) (cid:7)(cid:19) (cid:6) (cid:14)(cid:17) (cid:10)
Itisbettertotreatthememorypointedtoby (cid:15)
(cid:11)
(cid:10) asstat-
icallyallocated,withrespecttoissuingwarnings. When
theamountofmemoryallocatedbyacallto (cid:25)(cid:14) (cid:28)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17)
or (cid:13)(cid:22) (cid:28)(cid:21) (cid:27)(cid:7) (cid:27)(cid:8) (cid:29)(cid:4) (cid:13) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) isdeterminedbyaconstantexpression,a
differentwrapperfunctionisusedthattracksthatmem-
oryseperatelyfrommemorydynamicallyallocatedwith
anon-constantexpression.
Consider the output from
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
in table 3. The
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) (cid:13) (cid:19)(cid:18) (cid:17) wrapperfirstscanseachbufferlist,compar-
ing (cid:15)
(cid:11)
$(cid:10) (cid:12) with each entry of each list until a match is
found. Each entry consists of a buffer starting address
andlength,soitiseasytocomputewhetherornot (cid:15) (cid:11) %(cid:10) (cid:12)
pointstoanelementofthebufferrepresentedbytheen-
try. Since (cid:15)
(cid:11)
%(cid:10) (cid:12) points to the 19th element of
M(cid:7) 1
(cid:1) , the(cid:1)(cid:13)
(cid:1)(cid:13)
(cid:14)(cid:15)
(cid:15)
H(cid:7)
(cid:15)
(cid:14)(cid:15)
(cid:0)(cid:4)
(cid:0)(cid:4)
(cid:14)
(cid:11)
H(cid:8)
(cid:11)
(cid:14)
(cid:21)
(cid:21)
(cid:3)(cid:6)
F(cid:10)
H
%(cid:10)
(cid:3)(cid:6)
(cid:10)
(cid:10)
(cid:1)(cid:1)
(cid:4)(cid:18)
(cid:12)E
(cid:1)(cid:1)
(cid:0)(cid:3)
(cid:0)(cid:3)
M(cid:7)
(cid:23)(cid:2)
(cid:2)(cid:4)
(cid:17)
(cid:17)
(cid:2)(cid:4)
1
(cid:15)
(cid:0)
(cid:0)
I(cid:1)
(cid:11)
(cid:14)
(cid:14)(cid:15)
M(cid:7)
(cid:14)
(cid:2)
%(cid:10)
(cid:10)(cid:12)
(cid:14)
1
(cid:10)(cid:12)
(cid:8)(cid:19)
(cid:12)
(cid:11)
(cid:3)(cid:6)
(cid:1)
(cid:11)
(cid:6)(cid:8)
(cid:24)
(cid:21)
(cid:1)(cid:1)
(cid:10)(cid:14)
(cid:9)(cid:11)
(cid:13)(cid:17)
(cid:0)(cid:3)
"
(cid:13)(cid:16)
(cid:10)
(cid:23)(cid:2)
(cid:16)
(cid:2)(cid:4)
(cid:15)(cid:18)
(cid:15)
(cid:14)
(cid:0)
(cid:4)(cid:7)
(cid:17)
(cid:11)
M(cid:7)
(cid:14)
(cid:6)(cid:3)
(cid:13)
F(cid:10)
1
/(cid:13)
(cid:10)
(cid:15)
(cid:4)(cid:15)
(cid:1)
(cid:29)(cid:11)
(cid:11)
(cid:10)
(cid:13)
(cid:4)
%(cid:10)
M(cid:8)
(cid:10)(cid:2)
(cid:12)
1
(cid:11)
(cid:24)
(cid:1)
(cid:14)
(cid:24)
(cid:25)
(cid:15)
(cid:1)(cid:8)
(cid:11)
(cid:10)
(cid:25)
(cid:28)(cid:10)
(cid:31)(cid:2)
(cid:14)
(cid:4)(cid:18)
(cid:30)(cid:7)
(cid:25)
(cid:14)(cid:17)
(cid:7)(cid:8)
(cid:8)(cid:21)
(cid:10)
(cid:29)
(cid:27)(cid:7)
(cid:1)(cid:14)
(cid:27)@
(cid:13)
(cid:29)
M(cid:7)
(cid:13)
1
(cid:13)
(cid:1)(cid:18)
(cid:4)(cid:7)
(cid:17)
(cid:6)(cid:9)
(cid:14)(cid:17)
(cid:14)(cid:17)
(cid:10)
(cid:10)
Table3.Sample
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
output
wrapper computes the effective buffer size of (cid:15)
(cid:11)
$(cid:10) (cid:12) to
be10,andremembersthat (cid:15)
(cid:11)
%(cid:10) (cid:12) matchedanentryfrom
the list of statically allocated buffers. Then each list is
scanned again for (cid:15)
(cid:11)
F(cid:10) (cid:4) , which is found on the list of
dynamically allocated buffers of constant size, and has
a length of 20. Then the wrapper compares 20 to 10,
finds that (cid:15)
(cid:11)
F(cid:10) (cid:4) points to a bufferof static length that’s
largerthanthe one ofstatic length pointed to by (cid:15)
(cid:11)
%(cid:10) (cid:12) ,
andgeneratesatype0warning.
5 Evaluation
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
was used to test three versions of the popluar
ftpserverwu-ftpd: 2.4.2-beta-18,2.5.0,and2.6.2. The
first two were chosen to see if
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
could uncover
theirknownvulnerabilities,andthethirdtoseeif
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
could uncover new ones.
(cid:0)(cid:2) (cid:1)(cid:18) (cid:3)(cid:6) (cid:5)
was also used to ana-
lyze2.6.2,sothat
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
and
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
couldbecompared.
The net-tools-1.46 package for Linux was tested next.
This package consists of several commands related to
networking, along with a support library. It was cho-
sensothattestingwith
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
couldbecomparedtothe
tooldevelopedbyWagner[25],whichfoundanumberof
bufferoverflowflawsin net-tools-1.46. Alltestingwas
doneusingRedhat7.2forthei386.
5.1 wu-ftpd
2.4.2-beta-18 is known to have an exploitable buffer
overflow flaw due to a misuse of
(cid:10)(cid:2) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13)(cid:20) (cid:19)(cid:18) (cid:17) [2]. This
call to
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13)(cid:20) (cid:19)(cid:18) (cid:17) was flagged by
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
with a “type
0”warning.Twoknownoverflowflawsexistin2.5.0[3],
the first of which was another misuse of
(cid:10)(cid:2) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13)(cid:20) (cid:19)(cid:18) (cid:17) ,
which was again uncovered with a “type 0” warning.
The second flaw was caused by a series of calls to
(cid:10)
(cid:15)(cid:7) (cid:10)(cid:3) (cid:2)(cid:5) (cid:4)
(cid:11)
(cid:1)(cid:14) (cid:13) (cid:19)(cid:18) (cid:17) and
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:2) (cid:15)(cid:9) (cid:17) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) . Two of the calls to
(cid:10)
(cid:15)(cid:7) (cid:10)(cid:3) (cid:2)(cid:5) (cid:4)
(cid:11)
(cid:1)(cid:14) (cid:13) (cid:19)(cid:18) (cid:17) were flagged by
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
Function TruePositives FalsePositives Total
sprintf 8 5 13
strcat 5 5 10
strcpy 20 22 42
All 33 32 65
Table 4.
,one with a “type
0”warningandtheotherwitha“type1”warning.
A number of buffer overflow flaws in wu-ftpd-2.6.2
wereuncovered,butnoneofthemappearedtoresultin
anyseriousvulnerability.Nonetheless,theabilitytoun-
covertheseflawsstilldemonstratestheusefulnessofthe
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
results for wu-ftpd-2.6.2, all
warningtypes
Function TruePositives FalsePositives Total
sprintf 6 1 7
strcat 1 1 2
strcpy 4 3 7
All 11 5 16
Table5.
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
resultsforwu-ftpd-2.6.2,warn-
ingtype0
Function TruePositives FalsePositives Total
sprintf 2 3 5
strcat 4 4 8
strcpy 16 10 26
All 22 17 39
Table6.
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
resultsforwu-ftpd-2.6.2,warn-
ingtype1
Function TruePositives FalsePositives Total
sprintf 0 1 1
strcpy 0 9 9
All 0 10 10
Table7.
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
resultsforwu-ftpd-2.6.2,warn-
ingtype2
tool.
Tables4,5,6,and7summarizethenumberandtypes
of warnings generated by the tool. For the purpose of
thispaper,a“truepositive”meansthereexistssomein-
puttotheprogramundertestthatresultsinthefunction
call writing data past the end of the destination buffer
(evenifitturnsoutthisflawdoesn’trepresentasecurity
vulnerability,forthereasonstatedabove). “Falseposi-
tive”meansthatfornoinputtotheprogramundertest,
doesthefunctioncallwritepasttheendofitsdestination
buffer.
On thisprogram, a “type2” warning neverindicated
thepresenceofaflaw.Overall,testingwith
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
found
33 buffer overflows, while incurring 32 false positives.
Ignoring “type 2” warnings, the number of false posi-
tivesis22,or0.67falsepositivesforeverybufferover-Function TruePositives FalsePositives Total
bcopy 0 3 3
fgets 0 17 17
memcpy 0 5 5
snprintf 0 36 36
sprintf 8 49 57
strcat 5 10 15
strcpy 23 59 82
All 36 179 215
Table8.
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:22) (cid:5)
resultsforwu-ftpd-2.6.2
flowdiscovered.
Table8showstheresultsoftestingwith
(cid:0)(cid:2) (cid:1)(cid:18) (cid:3)(cid:6) (cid:5)
. Itwas
run with a command line parameter that set the sen-
sitivity cutoff to 1. At this cutoff, all vulnerabilities
in the
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
database are reported, except ones at the
levelof
(cid:0)(cid:1) (cid:0) (cid:7)(cid:14) (cid:0) (cid:2)(cid:3) (cid:1)
.Thiscutoffwaschosenbecauseitwas
thehighestthat includesallof theinteresting functions
checkedby
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
.
5.2 net-tools
A test set was developed for each command. The
union of these test sets was considered to satisfy inter-
esting function coverage for the support library, even
though different parts of the support library were cov-
eredbydifferenttestsets.
A number of overflow flaws were uncovered. The
results are shown in tables 9, 10, 11, and 12. Ignor-
ing“type2”warnings,
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
found19bufferoverflow
flawsandgenerated3falsealarms. Thisisafalseposi-
tiverateof0.158falsepositivespertruepositive.
ForeachofthevulnerabilitiesfoundbyWagner’stool,
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
emitteda“type1”warning. Thefirstflawfound
by Wagner’s tool appears in (cid:2)(cid:5) (cid:4) (cid:8)
(cid:11) H
(cid:13) , from the support
library[24]:
(cid:2)
(cid:13)
(cid:1)
(cid:10)
(cid:10)(cid:12)
(cid:10)(cid:9)
(cid:13)
(cid:2)(cid:5)
(cid:11)
(cid:8)
(cid:13)
(cid:13)
(cid:10)(cid:4)
(cid:10)(cid:14)
(cid:8)(cid:11)
(cid:4)(cid:9)
(cid:10)(cid:2)
(cid:9)(cid:8)
(cid:13)(cid:2)
1
(cid:15)
(cid:11)
(cid:11)
(cid:15)(cid:9)
(cid:10)
(cid:10)
(cid:10) (cid:17)
(cid:4)
(cid:17)
1
(cid:2)(cid:5)
(cid:13)
(cid:13)
(cid:4)
(cid:4)
(cid:12)$
(cid:6)(cid:9)
(cid:11)
(cid:14) (cid:1)(cid:21)
(cid:10)
(cid:8)
(cid:21)
(cid:25)(cid:3)
(cid:11)
(cid:4)(cid:9)
(cid:12)
(cid:8)
(cid:4)(cid:9)
(cid:8)
(cid:12)
(cid:24)
(cid:8)
(cid:11)
(cid:10)
(cid:8) M(cid:11)
(cid:8)(cid:11) (cid:4)
H(cid:20) (cid:10) (cid:7)(cid:4)(cid:9) (cid:15)
(cid:17)
(cid:11)
(cid:14)(cid:9)(cid:8)
(cid:4)(cid:4)
(cid:21)
(cid:11)
(cid:1)(cid:21)
(cid:23)
(cid:12)
(cid:4)
(cid:25)
(cid:17)
(cid:12)(cid:11)
(cid:14)
(cid:8)
(cid:0)(cid:2)
(cid:10)
(cid:4)(cid:4)
(cid:13)
(cid:5)(cid:7)
(cid:1)(cid:21)
(cid:4)(cid:4)
(cid:6)(cid:8)
(cid:17)=
(cid:25)
(cid:1)(cid:21)
(cid:6)
(cid:8)(cid:18)
(cid:25)(cid:3)
(cid:17)
(cid:0)
(cid:14)(cid:17)
(cid:8)(cid:18)
(cid:11) (cid:10)
(cid:17)
(cid:11)
(cid:29)
(cid:4)(cid:17)
(cid:4) (cid:27)
(cid:3)
(cid:13)
(cid:17)
(cid:4)(cid:9) (cid:7)(cid:15) (cid:9)(cid:8) (cid:11) (cid:4)
(cid:14)
(cid:4)(cid:9) (cid:8)
(cid:11)
(cid:14)(cid:17) (cid:10)
The call to (cid:6)(cid:7) (cid:8)
(cid:11)
(cid:4) (cid:8)
@(cid:11) M
(cid:17) (cid:4) (cid:1)(cid:21) (cid:25)(cid:3) (cid:8) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) returns a struct whose
field (cid:4) (cid:4) (cid:1)(cid:21) (cid:25)(cid:3) (cid:8) can have an arbitrary length. This field
is copied by
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:23) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) (cid:13)(cid:20) (cid:19) (cid:17) into (cid:4) (cid:1)(cid:21) (cid:25)(cid:3) (cid:8) , which may have
a length of only 64 bytes. Since the data returned by
(cid:6)(cid:9) (cid:8)
(cid:11)
(cid:4) (cid:8)
(cid:8)(cid:11) M
(cid:17) (cid:4) (cid:1)(cid:21) (cid:25) (cid:8) (cid:13) (cid:19)(cid:18) (cid:17) cancomefromoverthenetwork,an
attackermaybeabletoarrangefor (cid:4)(cid:9) (cid:10)(cid:15) (cid:9)(cid:12) (cid:11) (cid:4) (cid:4) #(cid:21) (cid:25) (cid:8)
Function TruePositives FalsePositives Total
sprintf 3 0 3
strcat 6 0 6
strcpy 10 3 13
All 19 3 22
Table 9.
tohave
alengthlongerthan64.
A few other flaws that appear exploitable were also
foundinnet-tools-1.46,whicharesimilartotheonejust
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
results for net-tools-1.46, all
warningtypes
Function TruePositives FalsePositives Total
strcat 6 0 6
strcpy 4 2 6
All 10 2 12
Table 10.
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
results for net-tools-1.46,
warningtype0
Function TruePositives FalsePositives Total
sprintf 3 0 3
strcpy 6 0 6
All 9 0 9
Table 11.
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
results for net-tools-1.46,
warningtype1
Function TruePositives FalsePositives Total
strcpy 0 1 1
All 0 1 1
Table 12.
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
results for net-tools-1.46,
warningtype2described. Unfortunately, data on the number of false
positivesandknownfalsenegativesgeneratedbyWag-
ner’stoolwasnotavailable.
6 Discussion
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
wasabletoidentifyknownsecurityvulnerabil-
itiesinpastversionsofwu-ftpd,demonstratingitsabil-
itytofindknownproblems. Withrespecttothelimited
sample of programs presented here,
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
did a good
job of keeping false positives low while still finding
flaws.Forwu-ftpd-2.6.2,thefalsepositiveratewas0.67
false positives per true positives, while for net-tools, it
was 0.158. Compare this to a simple tool like
(cid:0)(cid:2) (cid:1)(cid:18) (cid:3)(cid:6) (cid:5)
,
whichhadafalsepositiverateof4.97forwu-ftpd-2.6.2.
Sincefalsepositivesmeanmoreworkonthepartofthe
analystwhomustmanuallyinspectallwarnings,itisim-
portanttominimizefalsepositives.Further,thetestdata
usedforfunctionaltestingmaybeusedfor
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
,thus
reducingthetimeneededtotestforbufferoverflows.
Theknownfalsenegativeswith
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:1) (cid:0)
werealsolow,
with zero for wu-ftpd-2.6.2. (Because it is difficult to
knowhowmanyflawsexistinanon-trivialprogram,this
discussion is necessarily about known false negatives,
notallfalsenegatives.)
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
requires that the buffer overflows arise from
programmer misuse of library functions. A test run
on sudodid not uncovera knownbufferoverflowflaw.
Upon inspection, the knownflaw arose because a vari-
ablewasnotproperlyre-initializedbeforeuse. Asare-
sult,
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
couldnotdetectthatthe(meaningless)value
in the variable bore no relation to the value needed for
testingthepreconditiontotheinterestingfunction.Such
ananalysisisbeyondthescopeof
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
.
Some obervationsabout the interesting functions are
pertinent. First, in all the
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
tests, the “type 2”
warnings indicated false positives. This supports the
claimmadeearlier,thatprogrammersusuallydetermine
theamountofdynamicallyallocateddestinationstorage
correctly. Secondly, all of the flaws found by
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
involved
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) ,
(cid:10)(cid:12) (cid:11)
(cid:10)(cid:14) (cid:13)(cid:22) (cid:21)
(cid:11)
(cid:13) (cid:19)(cid:18) (cid:17) , and
(cid:10)
(cid:15) (cid:10) (cid:2)(cid:5) (cid:4)
(cid:11)
(cid:1) (cid:13)(cid:20) (cid:19)(cid:18) (cid:17) .
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
foundnoneinvolvingfunctionsthattakeabuffer
lengthparameter.Thissuggeststhatwhenprogrammers
fillbuffersusingfunctionsthattakealengthparameter,
theytendtousethelengthparametercorrectly.
We should point out that functions like
(cid:10)(cid:12) (cid:11)
(cid:10) (cid:4)(cid:14) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) ,
whichtakesalengthparameter,suffersfromotherprob-
lems. Inmanyplacesinthetestedprograms,theauthors
forgot to add a terminating NULL byte to the destina-
tion.Theproblemisthatifthelengthofthesourcestring
is the same as the length parameter,
(cid:10)(cid:12) (cid:11)
(cid:10) (cid:4) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17)
results.
The authors of [18] recommend replacing
does not
addaNULLbyte. Theresultinthedestinationisthere-
foresemanticallynotastring,soanyfutureoperationsor
functions that assume it is a string produce unexpected
(cid:10)(cid:12) (cid:11)
(cid:10) (cid:4) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17)
with
(cid:10)(cid:12) (cid:11)
!(cid:10) (cid:27)(cid:4) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17) , which takes a length parameter whose
value should be equal to the length of the destination
buffer, making it harder to commit off-by-one errors.
The function also guarantees that the destination will
be null-terminated. None of the functions tested with
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
thathavesimilarsemanticswerefoundtobein-
volved with any buffer overflow flaws. This provides
indirect, empirical evidence that (cid:10)(cid:12) (cid:11) F(cid:10) (cid:27)(cid:4) (cid:13)(cid:2) (cid:15)(cid:18) (cid:17) is harder to
misusethan
(cid:10)(cid:12) (cid:11)
(cid:10) (cid:4) (cid:13)(cid:16) (cid:15)(cid:18) (cid:17) .
Testing using
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
is a special case of property-
basedtesting[9,11].Inproperty-basedtesting,thetester
writesaspecificationthatassociatescodelocationswith
specifications in a language called TASPEC[10]. The
programbeingtested istheninstrumentedaccordingto
the specification. In TASPEC, a tester can say, “in-
strumentallcallsto (cid:25) (cid:28)(cid:21) (cid:27)(cid:8) (cid:27)(cid:8) (cid:29) (cid:13) (cid:13) (cid:17) .”
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
instrumentsall
callsto (cid:25) (cid:28)(cid:21) (cid:27)(cid:7) (cid:27)@ (cid:29) (cid:13) (cid:13) (cid:17) ,butdoessodifferentlydependingon
whethertheparameterpassedinisrepresentedasacon-
stant expression. Also, TASPEC has no formal mech-
anism for describingdifferentkindsofwarnings. It re-
portsallviolationsconsistently. Itwouldbestraightfor-
wardtoextendTASPECtosupportthis,though.
Aspect-orientedprogrammingisawaytomodularize
cross-cutting concerns. Programming tasks like error-
checkingandlogging,whichareusuallyspreadthrough-
out source code in object-oriented or procedural lan-
guages, are put intotheir own module. AspectC[5], an
aspect-oriented extension for C, could be used to par-
tially implement the functionality of (cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0) . However,
AspectCdoesnotprovideamechanismforinstrument-
ingvariabledeclarations,whichwouldberequiredtoin-
strument statically declared buffers. This suggests that
an aspect extension for C that includes the ability to
specifyvariabledeclarationswouldbeuseful.
7 ConclusionandFuture Work
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
provides a dynamic technique to look for
buffer overflows that the test data does not exercise.
It compares favorably to other tools such as
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
and
Wagneretal.’sstaticanalysistoolbecause
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:10) (cid:2)(cid:4) (cid:0)
takes
advantage of values computed during the execution of
theprogram.
Although obvious in retrospect,
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
failed to re-
port several errors that
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
reported. Upon examina-
tion,the
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:22) (cid:5)
reportsweregeneratedbypotentialbuffer
overflowsarisingfromsegmentsofcodethatcouldnot
both be compiled (because they were guarded by
H(cid:7) H(cid:8) H(cid:1) (cid:0)
(cid:28)(cid:8) (cid:27)
(cid:10)
(cid:8)
H(cid:7) H(cid:8) H(cid:1) (cid:0)
(cid:8)(cid:11) (cid:4)(cid:9) (cid:12)(cid:3) (cid:2) (cid:1)
(cid:0)
(cid:2) (cid:1)
preprocessor statements).
Thesefalsepositivesdidnotoccurwith
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
because
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
reportedproblemsfromexecutingcode,andthe
codethat
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
flaggedwasnevercompiled. Hence,onsystems where the code was not compiled,
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:6) (cid:5)
’s re-
ports were false positives. On systems where the code
was compiled,
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
reported the same problems that
(cid:0)(cid:2) (cid:1)(cid:4) (cid:3)(cid:22) (cid:5)
reported.
Severalextensionsare possible. Extending
(cid:3)(cid:6) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
to
findvulnerabilitiesinvolvingdirectassignmenttobuffer
elementswouldallowittouncoveroverflowsnotrelated
to functions. This would require
(cid:3)(cid:22) (cid:1)(cid:1) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
to determine
thepossibleintegerrangeoftheexpressionusedforthe
index into the buffer, along the lines of what Wagner’s
tool does. It is hard to see how this information could
beobtaineddynamicallywith“normal”userinput,since
suchinputwillprobablynotcausethevalueoftheindex
tobeoutsidetheboundsofthebuffer.
Lowering the false positive rate is another interest-
ing question. Most false positives arose when flow of
control constructs properly guarded otherwise danger-
ous function calls. Consider this code from wu-ftpd-
2.6.2:
(cid:2) (cid:1) (cid:13)
(cid:10)(cid:12)
(cid:10)
(cid:11)
(cid:15)
F(cid:10)
(cid:10)
(cid:27)
(cid:2)(cid:5)
(cid:8)(cid:11)
(cid:4)
(cid:4)
(cid:11)
(cid:13)(cid:1)
(cid:1)
(cid:0)(cid:3)
(cid:13)
(cid:18)(cid:2)
M(cid:7)
(cid:17)
1
(cid:1)
"(cid:5)
(cid:24)
(cid:4)(cid:7)
A
(cid:2)(cid:5)
/(cid:6)
(cid:4)(cid:9)
(cid:17)
(cid:12) @(cid:8)
(cid:10)
2
(cid:1)(cid:2) (cid:30)(cid:7)
C(cid:23)
(cid:7)(cid:8)
!(cid:10)
(cid:29)
A
(cid:1)(cid:14)
(cid:24)
(cid:13)
M(cid:7)
(cid:13)
1
#(cid:13)
(cid:1)(cid:3)
(cid:0)
(cid:17)
(cid:21)
(cid:17)
(cid:10)
(cid:11)
(cid:23)(cid:7) (cid:17)(cid:8) (cid:0)(cid:9) (cid:18)(cid:2) (cid:14)(cid:17) (cid:10)
Thiscallto
(cid:10)
(cid:15)(cid:7) (cid:10) (cid:2)(cid:5) (cid:4)
(cid:11)
(cid:1) wasflaggedby
(cid:3)(cid:6) (cid:1)(cid:8) (cid:0)(cid:3) (cid:2)(cid:4) (cid:0)
,butbecause
itappearsinthebodyofthe (cid:2) (cid:1) statement,itisexecuted
only when the buffer cannot be overflowed(due to the
condition in the (cid:2) (cid:1)
InProceedingsofthe1989IEEEComputerSocietySym-
posiumonSecurityandPrivacy,1989.
[9] G.FinkandM.Bishop. Propertybasedtesting: Anew
approachtotestingforassurance. ACMSIGSOFTSoft-
wareEngineeringNotes,22(4),July1997.
[10] G. Fink, M. Helmke, M. Bishop, and K. Levitt. An
interface language between specifications and testing.
Technical Report CSE-95-15, University of California,
Davis,1995.
[11] G. Fink, C. Ko, M. Archer, and K. Levitt. Toward a
property-based testing environment with application to
security critical software. In Proceedings of the 4th
IrvineSoftwareSymposium,pages39–48,April1994.
[12] A.Ghosh,T.O’Connor,andG.McGraw. Anautomated
approachforidentifyingpotentialvulnerabilitiesinsoft-
ware. InProceedingsofthe1998IEEESymposiumon
SecurityandPrivacy,pages104–114,May1998. Oak-
land,CA.
[13] R.HastingsandB.Joyce.Purify:Fastdetectionofmem-
oryleaksandaccesserrors.InProceedingsoftheWinter
USENIXConference,1992.
[14] E.Haugh. Testingcprogramsforbufferoverflowvul-
nerabilities. Master’sthesis,UniversityofCaliforniaat
Davis,September2002.
[15] O. Kirch. The poisoned nul byte, post
to the bugtraq mailing list, October 1998.
http://www.securityfocus.com/archive/1/10884.
[16] D.LarochelleandD.Evans. Staticallydetectinglikely
buffer overflow vulnerabilities. In USENIX Security
statement). A more complex flow
Symposium,Washington,D.C.,August2001.
analysismightdetectthis,allowingthe(spurious)warn- [17] B.Miller,L.Fredricksen,andB.So. Empiricalstudyof
ingtobesuppressed. the reliability ofunix utilities. Communicationsof the
ACM,33(12):32–44,December1990.
References [18] T.C.MillerandT.deRaadt.strlcpyandstrlcat-consis-
tent,safe,stringcopyandconcatenation.InProceedings
[1] AlephOne. Smashing the stack for fun and profit. ofthe1999USENIXAnnualTechnicalConference,June
Phrack,7(49),November1996. 1999. Monterey,California,USA.
[2] Cert coordination center, advisory ca-1999-03. [19] Nsfocus security advisory, sun so-
http://www.cert.org/advisories/CA-99-03.html. laris xsun “-co” heap overflow.
[3] Cert coordination center, advisory ca-1999-13. http://online.securityfocus.com/archive/1/265370.
http://www.cert.org/advisories/CA-1999-13.html. [20] Openbsd developers, single-byte buffer over-
[4] Certcoordinationcenter,vulnerabilitynotevu#363715. flow vulnerability in ftpd, December 2000.
http://www.kb.cert.org/vuls/id/363715. http://www.openbsd.org/advisories/ftpd replydirname.txt.
[5] Y.Coady,G.Kiczales,M.Feeley,andG.Smolyn. Us- [21] Securesoftwaresolutions, rats, theroughauditingtool
ing aspectc to improve the modularity of path-specific forsecurity. http://www.securesw.com/rats/.
customization in operating system code. In 9th ACM [22] J.Viega,J.Bloch,T.Kohno, andG.McGraw. Its4: A
SIGSOFT Symposium on the Foundations of Software staticvulnerabilityscannerforcandc++code. InPro-
Engineering, ViennaUniversity ofTechnology, Austria, ceedingsofthe16thAnnualComputerSecurityApplica-
September2001. tionsConference,December2000.
[6] C.Cowan, P.Wagle,C.Pu, S.Beattie, andJ.Walpole. [23] J. Viega and G. McGraw. Building Secure Software.
Bufferoverflows: Attacksanddefensesforthevulnera- Addison-Wesley,Boston,2002.
bilityofthedecade.InProceedingsoftheDARPAInfor- [24] D.Wagner. Personalcommunication,May2002.
mationSurvivabilityConferenceandExpo,1999. [25] D.Wagner, J.Foster,E.Brewer,andA.Aiken. Afirst
[7] N.Dor,M.Rodeh,andM.Sagiv.Cleannesscheckingof steptowardsautomateddetectionofbufferoverrunvul-
stringmanipulationsincprogramsviaintegeranalysis. nerabilities. InSymposiumonNetworkandDistributed
InProceedingsoftheEightInternationalStaticAnalysis Systems Security (NDSS ’00), pages 3–17, February
Symposium,June2001. 2000. SanDiegoCA.
[8] M.EichinandJ.Rochlis. Withmicroscopeandtweez-
ers:Ananalysisoftheinternetvirusofnovember1988.