Constant Round
Maliciously Secure 2PC
with Func8on-independent
Preprocessing using LEGO
Jesper Buus Nielsen, Thomas Schneider and Roberto TrifileIOutline
1. Intro to Secure Two-party Computa5on
2. Protocol Overview
3. Experimental Results
2Secure 2PC
â€‹ð‘ƒâ†“1 â€‹ð‘ƒâ†“2
ð‘¥
ð‘¦
â€‹
ð‘“(ð‘¥,ð‘¦) â„±â†“2PC ð‘“(ð‘¥,ð‘¦)
â†‘ð‘“
Nothing but the output ð‘“(ð‘¥,ð‘¦) is revealed to the par5es.
Task: realize above scenario using a cryptographic protocol.
Powerful: can build most other crypto from secure computa5on.
Applica5ons:
â—¦ Privacy preserving data analysis
â—¦ Secure outsourcing
â—¦ Company benchmarking
â—¦ Satellite collision detec5on
3Example Applica8on: Secure outsourcing
ð‘¦
ð‘§
â€‹ð‘§â†“1
â€‹ð‘¦â†“2
â€‹ð‘¥â†“2
â€‹ð‘¦â†“1
â€‹ð‘§â†“2
ð‘¥
â€‹ð‘¥â†“1
ð‘“(ð‘¥,ð‘¦,ð‘§)
â€‹ð‘†â†“1 â€‹ð‘†â†“2
1 honest server: No client info can leak
Secret sharing: ð‘¥=â€‹ð‘¥â†“1 +â€‹ð‘¥â†“2
2PC
4Security models
Two main types
â—¦ Semi-honest: The servers run the protocol/code as prescribed. Guaranteed that data cannot leak if
servers do not collude.
â—¦ Protects against breaches â€œaPer-the-factâ€, but not if a server is taken over during computa5on.
â—¦ Malicious: No assump5ons on server behavior. As long as one server is honest, data cannot leak.
â—¦ Protects against online aTacks, robustness.
Security at a price
â—¦ Malicious security much harder/expensive than semi-honest. OPen 10-100x in computa5on/
communica5on.
5In this Work
First implementa5on of constant round malicious 2PC with func,on-independent preprocessing
â—¦ Allows the servers to run up to 90% of the total computa5on independent of clients and func5on(s).
â—¦ Func5on-dependent computa5on matches the semi-honest se\ng.
â—¦ Improves clientsâ€™ experience as latency is significantly reduced.
Show for the first 5me that LEGO technique for malicious 2PC is highly prac5cal.
â—¦ Up to 50x faster than previous protocols if ignoring cost of independent preprocessing.
â—¦ Within factor 3x if comparing total costs.
6Garbling Schemes [BHR12]
G=(ðºð‘,ð¸ð‘›ð‘,ð¸ð‘£,ð·ð‘’ð‘)
ð‘‘
ð¶ ð·ð‘’ð‘
ðºð‘ ð‘§=ð¶(ð‘¥)
ð¹ ð‘
ð¸ð‘£
ð‘’
ð‘‹
ð¸ð‘›ð‘
ð‘¥
â€¢ Privacy: Given (ð¹,ð‘‹,ð‘‘), only learn ð¶(ð‘¥).
â€¢ Op5miza5on: Free-XOR [KS08], no data
transfer for XOR gates.
7Semi-honest: Yaoâ€™s garbled circuits
(ð¹,ð‘’,ð‘‘)â†ðºð‘(ð¶)
(â€‹ð‘‹â†“1â†‘0 ,â€‹ð‘‹â†“1â†‘1 ,â€¦,â€‹ð‘‹â†“ð‘›â†‘0 ,â€‹ð‘‹â†“ð‘›â†‘1 )â†ð‘’
â€‹ð‘ƒâ†“ð¶ â€‹ð‘ƒâ†“ð¸
ð‘‹â†ð¸ð‘›ð‘(ð‘¥,ð‘’)
ð‘¥ ð‘¦
(ð¹,ð‘‹,ð‘‘)
â€‹ð‘‹â†“ð‘—â†‘0
â€‹ð‘¦â†“ð‘—
â€‹â„±â†“OT
â€‹ð‘‹â†“ð‘—â†‘â€‹ð‘¦â†“ð‘— ð‘Œâ†(â€‹ð‘‹â†“1 ,â€‹ð‘‹â†“2 ,â€‹ð‘‹â†“ð‘› )
â€‹ð‘‹â†“ð‘—â†‘1
ð‘â†ð¸ð‘£(ð¹,ð‘Œ)
ð‘§â†ð·ð‘’ð‘(ð‘,ð‘‘)
ð‘§=ð¶(ð‘¥,ð‘¦)
8Malicious adversary
Yaoâ€™s garbled circuits completely break against malicious behavior.
â—¦ â€‹ð‘ƒâ†“ð¶ can garble â€‹ð¶â†‘â€² â‰ ð¶ and â€‹ð‘ƒâ†“ð¸ would never know.
â—¦ Selec5ve Failure ATack: Make â€‹ð‘ƒâ†“ð¸ abort depending on his input (thus leaking informa5on about ð‘¦).
9Malicious: â€œStandardâ€ Cut-and-choose
Main idea
â—¦ Send mul5ple garblings â€‹ð¹â†“1 ,â€‹ð¹â†“2 ,â€¦,â€‹ð¹â†“ð‘š , check some, evaluate the rest.
â—¦ Not trivial to ensure nothing can go wrong.
Replica5on cost
â—¦ [Bra13,HKE13,Lin13]: ð‘  circuits gives â€‹2â†‘âˆ’ð‘  security.
â—¦ 40-80x blowup in communica5on/computa5on.
Amor5za5on
â—¦ [LR15,RR16]: ð‘‚(â€‹ð‘ â„logâ€‹(#ð¶) ) circuits gives â€‹2â†‘âˆ’ð‘  , i.e. cut-and-choose overhead is amor5zed over
mul5ple individual computa5ons of ð¶.
10LEGO
[NO09] introduced LEGO technique for maliciously secure 2PC based on cut-and-choose of Garbled Circuits.
Considers gates instead of circuits for cut-and-choose.
â—¦ Asympto5c improvement, ð’ª(â€‹ð‘ â„â€‹log(â |ð¶|) ) vs ð’ª(ð‘ ).
â—¦ Allows preprocessing that is independent of ð¶.
â—¦ Requires â€œsolderingâ€ individual gates to form a circuit using homomorphic commitments.
[NO09] downsides
â—¦ Expensive public-key opera5ons for each gate of the circuit.
â—¦ Incompa5ble with op5miza5ons of Yaoâ€™s garbled circuits.
[FJNNO13, FJNT15, FJNT16] Improvements
â—¦ Eliminate public-key opera5ons for each gate.
â—¦ Compa5ble with all known op5miza5ons.
â—¦ Efficient XOR-homomorphic commitment scheme based on ECC and OT.
Folklore: LEGO is asympto,cally efficient, but not prac,cal due to the commitment overhead.
11Outline
1. Intro to Secure Two-party Computa5on
2. Protocol Overview
3. Experimental Results
12Phase 1: Preprocessing
ð‘›â‹… AND â€‹ð‘ƒâ†“ð¶ â€‹ð‘ƒâ†“ð¸ ð‘›â‹… AND
Send Gates G={â€‹ðºâ†“ð‘– } and commit to all inp/out wires
Send check-set ð‘‰âŠ‚ðº
Check that they
Decommit to input and output wires of gates in ð‘‰
correspond to AND gates
Permuta5on ðµ specifying bucke5ng If OK!
Decommit solderings of remaining gates in according to ðµ
Very parallelizable!
X ð‘›
Everything so far independent of final func,onality ð¶
13Phase 2: Func8on soldering
ð¶ â€‹ð‘ƒâ†“ð¶ â€‹ð‘ƒâ†“ð¸ ð¶
Decommit solderings of |ð¶| buckets so they compute ð¶
X ð‘›
Data transfer cost:
â—¦ 2â‹…|ð¶| decommits
â—¦ With [FJNT16] commit scheme: 2â‹…|ð¶|â‹…ð‘˜+ð‘ (~1 garbled circuit).
ðºð‘(ð¶)=
â—¦ Non-LEGO: ð’ª(ð‘ â‹…|ð¶|â‹…ð‘˜)
ð‘˜ comp. security param, ð‘  stat. security param.
14Phase 3: Evalua8on
ð‘¥ â€‹ð‘ƒâ†“ð¶ â€‹ð‘ƒâ†“ð¸ ð‘¦
â€‹ð‘‹â†“ð‘—â†‘0
â€‹ð‘¦â†“ð‘—
â€‹â„±â†“OT
â€‹ð‘‹â†“ð‘—â†‘â€‹ð‘¦â†“ð‘—
â€‹ð‘‹â†“ð‘—â†‘1
â€‹(ð‘‹â†“ð‘–â†‘â€‹ð‘¥â†“ð‘– ,ð‘‘)
ð‘‹
Highlights:
â—¦ LEGO: Single set of input keys vs. non-LEGO: one per eval circuit.
â—¦ Op5mal 2 rounds (3 if â€‹ð‘ƒâ†“ð¶ gets output)
ðºð‘(ð¶)=
â—¦ Computa5on: Evalua5ng ð’ª(â€‹ð‘ â„â€‹log(â |ð¶|) ) garbled circuits.
ð‘=ð¸ð‘£(ð¹,ð‘‹)
ð‘§=ð·ð‘’ð‘(ð‘,ð‘‘)
15Outline
1. Intro to Secure Two-party Computa5on
2. Protocol Overview
3. Experimental Results
16Observa8ons
The overhead of the commitments dominate the preprocessing phase, ~70% of total 5me.
â—¦ Spent great care op5mizing the commitment scheme implementa5on.
â—¦ Includes u5lizing efficient BitMatrix transposi5on and Intel AVX instruc5ons for compu5ng several linear
combina5ons in parallel over hundreds of millions of values.
Clear that network bandwidth is the major boTleneck.
17Performance Comparison (AES-128)
ms/AES
0 10 20 30 40 50
1
32
128
1024
[WMK17]: â€œFaster Two-Party Computa5on Secure Against Malicious Adversaries in the Single-Execu5on Se\ngâ€, Eurocrypt 17
[RR16]: â€œFaster Malicious 2-party Secure Computa5on with Online/Offline Dual Execu5onâ€, USENIX 16
Source: h"ps://github.com/AarhusCrypto/TinyLEGO
18
SEA#
Amor5zed Func5on-Dependent Time
ms/AES
0 20 40 60 80 100 120
1
[WMK17]
[RR16]
32
This
128
1024
SEA#
Amor5zed Total Time
[WMK17]
[RR16]
This
AWS c4.8x instances, LANIn Conclusion
LEGO is compe,,ve with state-of-the-art 2PC,
and even surpasses previous best results if u,lizing func,on-independent preprocessing.
19Thank you
20References
[BHR12] Mihir Bellare, Viet Tung Hoang, Phillip Rogaway: Founda>ons of Garbled Circuits, CCS 2012.
[KS08] Vladimir Kolesnikov, Thomas Schnieder: Improved Garbled Circuit: Free XOR Gates and Applica>ons,
ICALP 2008
[NO09] Jesper Buus Nielsen, Claudio Orlandi: LEGO for Two Party Secure Computa>on, TCC 2009.
[FJNNO13] Tore Kasper Frederiksen, Thomas P. Jakobsen, Jesper Buus Nielsen, Peter Sebas5an Nordholt, Claudio
Orlandi: MiniLEGO: Efficient Secure Two-Party Computa>on From General Assump>ons, Eurocrypt
2013.
[FJNT15] Tore Kasper Frederiksen, Thomas P. Jakobsen, Jesper Buus Nielsen, Roberto Trifile\:
TinyLEGO: An Interac>ve Garbling Scheme for Maliciously Secure Two-party Computa>on, ePrint
2015.
[FJNT16] Tore Kasper Frederiksen, Thomas P. Jakobsen, Jesper Buus Nielsen, Roberto Trifile\: On the
Complexity of Addi>vely Homomorphic UC Commitments, TCC-A 2016.
[RR16] Peter Rindal, Mike Rosulek: Faster Malicious 2-Party Secure Computa>on with
Online/Offline Dual Execu>on, USENIX 2016.
[WMK17] Xiao Wang, Alex J. Malozemoff, Jonathan Katz: Faster Two-Party Computa>on Secure Against
Malicious Adversaries in the Single-Execu>on Se[ng, Eurocrypt 2017.
21