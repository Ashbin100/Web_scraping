PT-Rand: Practical Mitigation of Data-only Attacks
against Page Tables
Lucas Davi,∗ David Gens,† Christopher Liebchen,† Ahmad-Reza Sadeghi†
∗University of Duisburg-Essen, Germany. lucas.davi@uni-due.de
†CYSEC/Technische Universität Darmstadt, Germany.
{david.gens,christopher.liebchen,ahmad.sadeghi}@trust.tu-darmstadt.de
Abstract—Kernel exploits constitute a powerful attack class kernel exploit. Second, the kernel implements a major part of
allowing attackers to gain full control over a system. Various thesecuritysubsystem.Hence,toescalateexecutionprivileges
kernel hardening solutions have been proposed or deployed in to root orescape fromapplication sandboxesinbrowsers, itis
practice to protect the kernel against code injection (e.g., DEP) often inevitable to compromise the kernel. Kernel exploits are
or code-reuse exploits (e.g., CFI). However, the security of all
leveraged in (i) all of the latest iOS jailbreaks, (ii) browser
these hardening techniques relies heavily on the assumption that
sandbox exploits against Chrome [37], and (iii) large-scale
kernelpagetablescannotbemanipulated,e.g.,bymeansofdata-
attacks by nation-state adversaries to obtain full control over
only attacks. Ensuring kernel page tables integrity is not only
the targeted system, as in the infamous case of Stuxnet [42].
essentialforkernelsecuritybutalsoachallengingtaskinpractice
since existing solutions require hardware trust anchors, costly Typical means for program code exploitation are memory
hypervisors, or inefficient integrity checks. corruptionvulnerabilities.Theyallowattackerstoaltercontrol
In this paper, we first motivate the importance of protecting and data structures in memory to execute (injected) malicious
kernel page tables by presenting a data-only attack against page code,ortolaunchcode-reuseattacksusingtechniquessuchas
tables to bypass the recently released CFI-based (Linux) kernel return-orientedprogramming[25,46].Oneofthemainreasons
hardeningtechniqueRAP.Thereafter,wepresentthedesignand for the prevalence of memory corruption vulnerabilities is
implementationofPT-Rand,thefirstpracticalsolutiontoprotect that a vast amount of software is programmed in unsafe
kernel page tables that does not suffer from the mentioned defi- languages such as C and C++. In particular, kernel code is
ciencies of previous proposals. PT-Rand randomizes the location
typically completely written in these languages for better per-
of page tables and tackles a number of challenges to ensure that
formance, legacy reasons, and hardware-close programming.
thelocationofpagetablesisnotleaked.Thiseffectivelyprevents
Themonolithicdesignofthecommoditykernelsandnumerous
theattackerfrommanipulatingaccesspermissionsofcodepages,
device drivers increase the attack surface compared to user-
thereby enabling secure enforcement of kernel exploit mitigation
technologies such as CFI. We extensively evaluate our prototype mode applications. For instance, over the last 17 years 1526
implementation of PT-Rand for the current Linux kernel on the vulnerabilitieshavebeendocumentedintheLinuxkernel[14].
popular Linux distribution Debian and report a low overhead
Various solutions have been proposed or deployed in practice
of 0.22% for common benchmarks. Moreover, we combine RAP
to protect software systems against code-injection or code-
withPT-RandtoprotectRAPagainstdata-onlyattacksonkernel
reuse exploits: modern kernel hardening solutions like Su-
page tables.
pervisor Mode Execution Protection (SMEP) and Supervi-
sor Mode Access Protection (SMAP) [27] prevent access to
I. INTRODUCTION
user-mode memory while the CPU executes code in kernel
Operatingsystemkernelsareessentialcomponentsinmod- mode [3, 27]. This prevents the attacker from executing code
ern computing platforms since they provide the interface be- withkernelprivilegesinusermode.ThedeploymentofW⊕X
tweenuserapplicationsandhardware.Theyalsofeaturemany (Writable⊕Executable)preventstheadversaryfromexecuting
importantservicessuchasmemoryanddiskmanagement.Typ- code in the data memory. Indeed, W⊕X has dramatically
ically, the kernel is separated from user applications by means reducedthethreatofcode-injectionattacks.However,attackers
ofmemoryprotection,i.e.,less-privilegeduserapplicationscan have already eluded to more sophisticated exploitation tech-
only access the higher-privileged kernel through well-defined niques such as code reuse to bypass these measures and to
interfaces, such as system calls. Attacks against kernels are hijackthecontrolflowofthetargetedcode.Mitigatingcontrol-
gaining more and more prominence for two reasons: first, flow hijacking attacks is currently a hot topic of research [51].
the kernel executes with high privileges, often allowing the The most promising and effective defenses at the time of
attacker to compromise the entire system based on a single writing are control-flow integrity (CFI) [1], fine-grained code
randomization [31], and code-pointer integrity (CPI) [30].
However,alldefensesagainstcontrol-flowhijackingarebased
Permission to freely reproduce all or part of this paper for noncommercial on the following assumptions: firstly, they assume that code
purposes is granted provided that copies bear this notice and the full citation
pagescannotbemanipulated.Otherwise,theadversarycanre-
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author place existing code with malicious code or overwrite CFI/CPI
(for reproduction of an entire paper only), and the author’s employer if the checks. Secondly, they assume that critical data structures
paper was prepared within the scope of employment. containing code pointers (e.g., the shadow stack for CFI, the
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
saferegionforCPI)areisolated.Otherwise,theadversarycan
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23421 manipulate them by overwriting code pointers.However, as observed by Ge et al. [19], defenses against memory pages. As we will show in Section V, PT-Rand
control-flow hijacking in the kernel additionally require the tackles all these challenges, while remaining compatible to
protection of page tables against data-only attacks. Otherwise existing software, like kernel drivers.
the assumptions mentioned above will not hold and these
Prototype Implementation: We provide a fully working
defenses can simply be bypassed by manipulating the page
prototype implementation for a recent Linux kernel (v4.6).
tables.
We also combine Linux kernel CFI protection (RAP) with
PT-Rand to protect RAP against data-only attacks on page
Data-only attacks do not change the control flow of the
tables.
program. Instead they direct the control flow to certain nodes
withinthecontrol-flowgraph(CFG)oftheunderlyingprogram PerformanceEvaluation:Weprovideanextensivesecurity
byalteringtheinputdata.Hence,theexecutedpathintheCFG and performance evaluation. In particular, we show that
is indistinguishable from any other benign execution. Page the attacker cannot bypass the randomization by means
tablesaredatastructuresthatmapvirtualaddressestophysical of guessing attacks. Our performance measurements for
addresses.Theydefineread-write-executepermissionsforcode popular benchmarking suites SPEC CPU2006, LMBench,
and data memory pages, where a page is simply a contiguous Phoronix, and Chromium browser benchmarks show that
4KB memory area. Hence, attackers can launch data-only PT-Rand incurs almost no measurable overhead (0.22% on
attacks (based on memory corruption vulnerabilities in the average for SPEC), successfully applies to many complex,
kernel) to alter page tables, and consequently disable mem- modern system configurations, and is highly practical as it
ory protection, manipulate code pages, and inject malicious supports a variety of applications and kernel code.
code[38].Recentlyindustryresearchershavepresentedseveral
page-table based attacks [16] stressing that these attacks are PT-Rand effectively enables memory protection and paves the
possiblebecausetheattackercaneasilydeterminethelocation way for secure deployment of defenses to thwart code-reuse
of the page tables. attacks on the kernel.
To tackle data-only attacks on page tables, previous work
II. BACKGROUND:MEMORYPROTECTIONANDPAGING
suggested kernel instrumentation to mediate any access to
memory-management structures according to a security pol- In this section, we recall the basic principles of memory
icy [4, 5, 13, 20, 43, 49]. However, as we elaborate on protectionandpagingthatareneededfortheunderstandingof
related work in Section VIII, all these solutions suffer from the following sections.
at least one of the following shortcomings: high performance
Memoryprotectionensuresthat(i)privilegedkernelcodeis
overhead, require additional and higher privileged execution
isolatedfromless-privilegedusercode,(ii)oneprocesscannot
modes (e.g., hypervisors), or depend on architecture-specific
accessthememoryspaceofanotherprocess,and(iii)read-only
hardware features. Recently, Microsoft released a patch for
data memory cannot be tampered with by unauthorized write
Windows 10 [28] that randomizes the base address used to
operations. To enforce memory protection, modern operating
calculatethevirtualaddressofpagetableentries.However,this
systems leverage a widely-deployed CPU feature called pag-
patch does not protect against crucial information disclosure
ing.Althoughtheimplementationdetailsvaryamongdifferent
attacks that have been frequently shown to circumvent any
architectures,thebasicprinciplesarethesame.Hence,without
(even fine-grained) randomization scheme [15, 48].
loss of generality, we focus our discussion on paging for the
contemporary x86_64 architecture.
Goal and Contributions. In this paper, we present the design
andimplementationofanovelmemoryprotectionscheme,PT- Paging creates an indirection layer to access physical
Rand,thatpreventstheattackerfrommanipulatingpagetables. memory. Once enabled, the CPU will only operate on virtual
We highlight the importance of page table protection by im- memory (VM), i.e., it can no longer access physical memory.
plementing a real-world exploit, based on a vulnerable kernel The advantage of paging is that processes start working with
driver (CVE-2013-2595), to directly manipulate the code of a largecontiguousmemoryareas.However,physically,themem-
kernel function. Using this attack, we circumvent a recently oryareasarescatteredthroughouttheRAM,orswappedouton
released CFI kernel hardening scheme, Linux RAP [52], and hard disk. As a consequence, each access to a virtual memory
execute arbitrary code with kernel privileges. In summary, our address needs to be translated to a physical address. This
contributions are as follows: is achieved by a dedicated hardware engine called Memory
Management Unit (MMU). The translation is performed by
PageTableProtection:Wepresentapracticalandeffective
means of page tables that operate at the granularity of pages,
protection of page tables against data-only attacks without
where a typical page size is 4KB. Specifically, the operating
requiring additional hardware or a hypervisor. Rather than
system stores mapping information from virtual to physical
applying expensive policy enforcement checks, we random-
addresses into these page tables thereby enabling efficient
ize page tables when they are allocated and ensure that
translation. To isolate processes from each other, the kernel
no information related to the location of page tables is
assigns each process to its own set of page tables. In addition,
leaked.Toachievethis,weneedtotackleseveralchallenges.
page tables maintain read-write-execute permissions for each
(1)Therearemanydatapointersthattheattackercanexploit
memory page. These permissions are enforced at the time of
to locate page tables. (2) The physical memory (including
translation,e.g.,allowingtheoperatingsystemtopreventwrite
page tables) is usually mapped 1:1 into the virtual address
operations to code pages or executing data pages.
space. Hence, the attacker can easily locate and access
this section. (3) The kernel still needs to efficiently access Figure 1 provides high-level insights into the translation
pagetables,anddistinguishbetweenrandomizedandregular process. First, the memory subsystem of the CPU receives the
2physicalmemorytoafixedaddressintothevirtualmemory.To
CPU
quicklytranslateaphysicaltoavirtualaddress,thekerneladds
the physical address to the start address of the 1:1 mapping,
Execution Access Virtual Page Table and can then use the resulting virtual address to access the
Unit Mode Address Pointer (CR3)
memory.
6 1 2
III. ONTHENECESSITYOFPAGETABLESPROTECTION
PTE
Memory
Cache MMU In the adversary setting of kernel exploits the attacker
Subsystem 5
has full control over the user mode, and hence, can execute
arbitrarycodewithuser-modeprivileges,andinteractwiththe
3 kernel through system calls and driver APIs. The attacker’s
goal is to gain higher privilege level to be able to execute
Page Tables Physical arbitrary code with kernel-mode privileges. To do so, the
Memory
attacker needs to hijack a control-flow path of kernel code
Page Table Root by overwriting a kernel code pointer, e.g., a return address or
Page Tables function pointer, using a memory-corruption vulnerability that
isexposedeitherthroughthekernelitselforoneoftheloaded
Page Table Hierarchy
drivers.
4 Physical Page
In the following, we briefly provide an overview of the
Page Table Page Table
Entry (PTE) Entry (PTE) main kernel-related exploitation techniques as well as the de-
fenses that are deployed or proposed against these attacks. To
mitigate kernel code-injection and kernel code-reuse attacks,
Figure 1: Paging - translation of virtual addresses to physical
the kernel must be hardened with a variety of protection
addresses.
measures such as W⊕X and Control-Flow Integrity (CFI),
fine-grained randomization or Code-Pointer Integrity (CPI).
However, as we elaborate in the following the security of all
accessmodeandavirtualmemoryaddressfromtheexecution thesedefensesreliesontheintegrityofpagetablesthatcanbe
unit as input 1. To access the page tables, the MMU reads attackedbymeansofdata-onlyattacks–Weshowthisusinga
outthepointertothepagetablerootwhichisalwaysstoredin real-worldexploitthatmanipulatespagetablesagainstakernel
the third control register (CR3) on x86_64 2. This pointer is CFI protection.
already a physical memory address pointing to the root of the
Traditional Kernel Attacks. To escalate the attacker’s privi-
page table hierarchy 3. That said, page tables are organized
leges to kernel privileges, a common exploitation technique
in a tree-like hierarchy for space optimization reasons. The
is as follows: first, the attacker allocates a new buffer in
MMU traverses the page table hierarchy until it reaches the
memory, writes malicious code into this buffer, and sets the
page table entry (PTE) which contains the physical address
memory page on which the buffer is located to executable.
for the given virtual memory address 4. In addition, the PTE
The latter can be achieved by common user space library
holdstheaccesspermissionsandownership(userorkernel)of
functions such as mprotect() on Linux and VirtualProtect()
theassociatedmemorypage.Thememorysubsystemleverages
on Windows. Recall that these actions are possible because
this information to validate whether the target operation (read,
the attacker has already gained control over the user space.
write,orexecute)adherestothepermissionsetandownership
Second, the attacker overwrites a kernel code pointer with
ofthepage.Ifvalidationissuccessful,thetranslationinforma-
the start address of the malicious code based on a memory
tion is used to fetch the data from the physical memory slot
corruptionvulnerabilityinsidethekernel.Thesevulnerabilities
and stored into the cache 5. Note that the cache internally
are typically triggered by abusing the kernel’s interfaces such
consists of a data and a instruction cache. For read and write
as system calls and driver APIs. Third, the attacker triggers
operations the fetched data is stored into the data cache. In
the execution of a function that executes a branch on the
contrast,executerequestsleadtoawriteofthefetcheddatato
corruptedkernelcodepointer.Asaresult,thekernel’sinternal
the instruction cache. Finally, the fetched data is forwarded to
control flow will be dispatched to the previously injected,
the execution unit of the CPU 6. If the MMU either does not
malicious code. Although this code resides in user space, it
find a valid mapping in the page table hierarchy or observes
will be executed with kernel privileges because the control-
anunauthorizedaccessin 4,thememorysubsystemgenerates
flow hijacking occurred in the kernel mode. In a similar vein,
an exception 6.
the attacker can launch code-reuse attacks using the return-
It is important to note that the page tables only contain oriented programming (ROP) [46] technique. These attacks
physical addresses. This becomes a performance bottleneck combineandchainshortinstructionsequences(calledgadgets)
whenthekernelaimsatchangingthepagepermissions.Asthe that end in an indirect branch instruction. They are typically
kerneloperatesonvirtual addresses,allthephysicaladdresses leveraged if the attacker cannot allocate new malicious code
belonging to a page would need to be mapped to virtual on an executable page. Thus, the user-mode buffer will hold
addresses dynamically before the permission update can be a ROP payload consisting of code pointers to gadgets. Upon
performed. To tackle this bottleneck, the kernel maintains a corruption of the kernel pointer, the ROP gadget chain will be
so-called 1:1 mapping which permanently maps the whole executed under kernel privileges [18].
3Code-injection and Code-reuse Attacks. Modern CPUs fea- kernelfunctioncouldbereplacedwithmaliciouscode.Finally,
ture hardware extensions Supervisor Mode Execution Protec- the attacker triggers the kernel function from user space to
tion (SMEP) and Supervisor Mode Access Protection (SMAP) execute the injected code with kernel privileges.
that prevent access to user-mode memory while the CPU
executes code in the kernel mode [3, 27]. Alternatively, Generic Bypass of Kernel CFI. To demonstrate the potential
if these extensions are not present, the kernel can simply of data-only attacks against page tables, we first hardened the
unmap the entire user space memory when kernel code is currentLinuxkernelwiththeopensourceversionofRAP[52].
executed [34]. Such protections force the attacker to directly RAP is a state-of-the-art CFI implementation that instruments
inject malicious code or the ROP payload into the kernel’s the Linux kernel during compile-time to enforce fine-grained
memory space which is a challenging task since the attacker CFI at run-time. In particular, RAP ensures that the attacker
cannot directly write into kernel memory. However, several cannot overwrite code pointers (used for indirect branches)
kernel functions accept and process user-mode buffers. A with arbitrary values. This is achieved by emitting CFI checks
prominent example is the msgsnd() system call which allows before all indirect branches that validate whether the program
exchange of messages. The attacker can exploit this function flowtargetsavaliddestination.However,asmentionedbefore,
to cause the kernel to copy the user-mode exploit buffer afundamentalassumptionofRAPistheintegrityofthekernel
(the message) into kernel memory. By leveraging a memory code. If code integrity is not ensured, the attacker can simply
disclosure attack inside the kernel, the attacker can determine overwrite the CFI checks with NOP instructions or directly
the address where the buffer is located in kernel memory and overwrite existing kernel code with malicious code.
launch the exploit thereafter [40]. Several techniques are de-
We undermine this assumption by using a data-only attack
ployed or proposed to harden the kernel against these attacks:
to first modify the page tables and change the memory per-
W⊕X (Writable ⊕ Executable) is leveraged by many modern
mission of the kernel code to writable. Next, we overwrite an
operating systems to prevent code to be executed from data
existing system call with our attack payload which elevates
memory.Fine-grainedcoderandomizationdiversifiesthecode
theprivilegesofthecurrentprocesstoroot.Aftersuccessfully
address layout to complicate code-reuse attacks [31]. Many
overwriting the kernel code, we invoke the modified system
modernoperatingsystemsapplyKernelAddressSpaceLayout
call from user mode to eventually obtain root access. The
Randomization(KASLR)[17,34].Control-flowintegrity(CFI)
detailsofthisexploitaredescribedinSectionVI-A.Whilethe
mitigates control-flow hijacking attacks by validating that the
impact of the attack itself is not surprising (CFI does not aim
application’scontrolflowremainswithinastaticallycomputed
to prevent code-injection attacks), it highlights the importance
control-flow graph [1]. CFI has been also adapted to kernel
of having an effective protection against data-only attacks that
code [13, 19]. Recently a CFI-based protection for Linux
target page tables. We note that this attack is not limited to
kernel (RAP [52]) has been released. Code pointer integrity
RAP but can also be applied to randomization or isolation-
(CPI) [30] prevents control-flow hijacking by ensuring the
based defenses (CPI) against code-reuse attacks.
integrity of code pointers.
Existing Kernel Page Tables Protections. As we discuss
Principally all these defenses significantly raise the bar.
in detail in the related work Section VIII, the existing pro-
However, as observed in [13, 19] these defenses heavily
posals for protecting kernel page tables suffer from various
rely on the assumption that the instrumented code cannot be
shortcomings: they either require a hardware trust anchor, or
manipulated, i.e., the attacker cannot compromise integrity
privileged software (e.g., hypervisor), or are costly due to
checks or exploit information leakage against randomization
integrity checks.
schemes, and replace existing code with malicious code. On
the other hand, this assumption is easily undermined by data-
Summary. All known exploit mitigation schemes strongly
only attacks that tamper with the page tables as we describe
depend on memory protection to prevent the attacker from
next.
injecting code or corrupting existing code. Even with these
schemes in place, page tables managing memory permis-
Data-only Attacks against Page Tables. In contrast to sions can be compromised through data-only attacks. Hence,
control-flow hijacking attacks, data-only attacks abstain from designing a defense against data-only attacks is vital and
compromising code pointers. For example, the attacker can complements the existing mitigation technologies allowing
overwrite the is_admin variable of an application at run- their secure deployment for kernel code.
time [10]. Although no code pointer has been compromised,
the attacker can now execute benign functionality with higher
IV. PT-RAND:DESIGNOFOURPAGETABLEPROTECTION
privileges.Inthecontextofthekernel,data-onlyattacksallow
code injection attacks by modifying page table entries (PTEs) In this section, we present the adversarial model, ex-
whichweexplainedinSectionII.Toinitiatedata-onlyattacks, plain the high-level design of our scheme, and elaborate on
theattackerfirstexploitsamemory-corruptionvulnerabilityin challenges for implementing practical and secure page table
the kernel or a device driver to gain read and write access to protection.
kernel memory. Since kernel memory contains references to
page tables, the attacker can carefully read those references
A. Adversary Model and Assumptions
and locate them [38]. In particular, the attacker can disclose
the virtual address of a PTE corresponding to a page that The adversary setting for our protection scheme PT-Rand
encapsulatesakernelfunctionwhichcanbetriggeredfromthe againstthecorruptionofpagetablesisbasedonthefollowing
user space. Next, the attacker modifies the page permissions assumptions (which are along the lines of the assumptions of
towritableandexecutable.Forinstance,theentirecodeofthe related literature):
4• MemoryCorruption:Thereexistsamemorycorrup- Figure 2 depicts the overall architecture and workflow of
tion vulnerability in either the kernel or a driver. The PT-Rand. During the early boot phase, the kernel operates
attackercanexploitthisvulnerabilitytoreadandwrite only on physical memory. To guarantee a successful switch
arbitrary memory (e.g., [38]). to virtual memory, contemporary kernels allocate an initial set
• ControllingUserSpace:Theattackerhasfullcontrol of page tables at a constant and fixed address. These page
over the user space, and consequently can execute tables manage the kernel’s core functions as well as data
arbitrary code in user space and call kernel API areas, and remain valid for the rest of the kernel’s life-time.
functions. To prevent the attacker from tampering with page tables, PT-
Randgeneratesarandomizationsecret 1,andrandomizesthe
• User Space Access: User-mode pages are not acces-
locationoftheinitialpagetables 2.Therandomizationsecret
sible when the CPU is in the kernel mode. This is
is stored in a privileged CPU register which is neither used
enforced by modern CPU features such as SMAP/S-
during normal operation of the kernel nor accessible from
MEP [3, 27] or by simply unmapping the user space
user mode. Recall from Section IV-A that the attacker can
during kernel code execution [34].
only access the kernel memory, but not the kernel’s registers.
• W⊕X:Kernelcodepagesarenotper-sewritable.This The latter would require the attacker to either launch a code-
is enforced by W⊕X protection inside the kernel. As injection attack (prevented by W⊕X) or a code-reuse attack
a consequence, the attacker needs to resort to a data- (mitigated by CFI [1], code randomization [31] or CPI [30]).
onlyattacktomanipulatecodepagepermissions,and After relocating the initial page tables to a random address,
inject code thereafter. the kernel can no longer access these page tables through the
• Code-reuse Defense: A defense mechanism against 1:1 mapping. In particular, PT-Rand relocates the initial page
kernel-related code-reuse attacks is enforced, such tables in an unused memory region. As we will evaluate in
as control-flow integrity (CFI) [1, 19], fine-grained detail in Section VI-A, the entropy for this memory region
code randomization [12, 31], or code-pointer integrity is reasonably high for contemporary 64-bit systems rendering
(CPI)[30].Specifically,ourprototypeimplementation brute-force attacks infeasible A.
of PT-Rand incorporates RAP [52], a public state-
Note that the kernel features dedicated allocator functions
of-the-art CFI implementation for the Linux kernel.
for page table memory. For PT-Rand, we instrument these
As mentioned before, existing defenses against code-
functions to (i) move the initial page tables to a random
reuse attacks cannot prevent data-only attacks against
address,and(ii)alwaysreturnphysicaladdressesforanypage
the page tables. (Our solution serves as a building
table related memory allocation. In contrast, the default allo-
block to prevent these protection frameworks from
cators always return a virtual address as a reference to newly
being undermined by data-only attacks against page
allocated page table memory. This small adjustment allows
tables.)
us to obfuscate the location of page tables from user-level
• DMAProtection:DirectMemoryAccess(DMA)[44,
attackers,becausethekernelcodeoperatesonvirtualaddresses
55] cannot be exploited to bypass virtual memory
when accessing page tables. Hence, at this stage, neither the
permissions because an IOMMU [27] is configured
attacker nor the kernel itself can access the page tables. In
to prevent DMA to security-critical memory.
ordertoallowbenignkernelcodetostillaccessthepagetables,
• Safe Initialization: The attacker cannot attack the wemodifyallkernelfunctionsthataccesspagetablememory:
kernel prior the initialization of PT-Rand. This is not for each of these functions we convert the physical address to
alimitationbecausePT-Randisinitializedattheearly a virtual address based on the randomization secret generated
boot phase during which the attacker cannot interact in 1.
with the kernel.
However, during the early boot phase, the kernel has
• Source of randomness: A secure (hardware) random
already saved references to the initial page tables in various
number generator is available [3, 27, 53].
data structures. Since the initial tables were not allocated with
• Side-channels:Timingandcachesidechannelattacks our modified allocator, the references contain obsolete virtual
aswellashardwareattacks,likerowhammer[29],are addresses. To avoid a kernel crash, PT-Rand updates all these
orthogonal problems, and hence, beyond the scope of references(virtualaddresses)withthenewphysicaladdress 3.
this paper. Nevertheless, we discuss in Section VI-A To this end, every reference to page tables now contains
how we can adopt known techniques from Apple’s a physical address rather than a virtual address. Thus, the
iOS to prevent practical side-channel attacks. attackeraimingtolocatepagetablesbyreadingthedesignated
places of page table pointers [38] only retrieves physical
B. Overview of PT-Rand addresses.Sincethereisnodirectcorrelationbetweenphysical
and virtual addresses, the attacker cannot use any leaked ref-
Our goal is to mitigate data-only attacks against the kernel
erences to infer the corresponding virtual address B. We also
page tables in the adversary setting explained in Section
implemented PT-Rand such that no intermediate computation
IV-A. To do so, we introduce the design and implementation
result that includes the randomization secret is ever written
of a novel kernel extension called PT-Rand. The main idea
into memory. Specifically, we instruct the compiler to keep
of PT-Rand is to (i) randomize the location of page tables
intermediate and the end result that include the randomization
securely, i.e., prevent the leakage of the randomization secret,
secret in registers, and prevent them from getting spilled.
and (ii) substitute pointers that reference page tables with
physical addresses to obfuscate these references and prevent Ourmodifiedpagetablememoryallocatoralsorandomizes
their leakage. any future page table allocations into the PT-Rand memory
5Random
CPU PT-Rand Virtual Memory
Source
Priv-
1 Generate Randomization Secret
Reg Boot 1:1 Mapping C
Time 2 Relocate Existing Page Tables
Initial Page Tables
3 Substitute Page Table Pointers (constant address)
Adversary
Run 4 Allocate Page Table Memory
Time Kernel Data
5 Access Page Tables
Physical Addresses B
PT-Rand Region A
Kernel
Figure 2: Overview of the different components of PT-Rand.
region 4. Further, we ensure that every physical memory Handling of 1:1 Mapping. As we discussed in Section II,
pagethatcontainspagetableentriesisunmappedfromthe1:1 the kernel maintains a 1:1 mapping for fast translation from
mapping. Hence, if the attacker discloses a physical address virtual to physical addresses. 4 in Figure 2 removes the
of a page table pointer, she cannot exploit the 1:1 mapping page tables from this 1:1 mapping to prevent the attacker
to read out page tables C. Finally, PT-Rand provides an from learning the page table location. However, removal of
interface for the kernel to access and manage page tables 5. page tables is not per-se possible. This is due to the fact that
Inparticular,PT-Randtranslatesthephysicaladdressesofpage the 1:1 mapping deploys so-called large pages of 2MB by
table pointers to virtual addresses based on the randomization default. Hence, simply removing the page leads to deletion of
offset. adjacent data not related to page tables. In addition, we need
to identify all functions that access page tables via the 1:1
C. Challenges mapping, and patch them to perform the translation based on
the randomization secret.
ToenablePT-Randwehadtotackleanumberofchallenges
as we explain in the following. In Section V, we describe in
Translation of Physical Addresses. At run-time, the kernel
detail how we address each challenge.
needs to repeatedly translate physical addresses to virtual
addresses, e.g., during a page walk or when creating a page
Page Table Allocation. Page tables are data objects that are
table entry. As we explained in Section II, this is efficiently
dynamically allocated in the kernel. These objects are created
performedbasedonthe1:1mapping.However,whenPT-Rand
by the page allocator, which is a central, low-level service
is in place, the kernel cannot use the 1:1 mapping anymore
in the kernel that manages physical pages. To randomize
to translate physical addresses of page tables, because PT-
the memory pages where page tables are stored, we need to
Rand removed them from the 1:1 mapping. Consequently,
determineandinstrumentallkernelfunctionsthatallocatepage
the kernel has to distinguish between physical addresses of
tables.
normal memory and physical addresses of page table memory
Generating a Randomized Space. While the kernel needs as each of them needs a different translation mechanism. This
to be able to locate randomized pages for performing benign distinction must be efficiently performed at run time to not
changes, the attacker must not learn the new mapping. Con- impede the system’s run-time performance.
sequently, we need to provide high entropy to avoid simple
brute-force search. Furthermore, the new location of the page V. IMPLEMENTATION
tables must not collide with other existing mappings in the
OurdesignaspresentedinSectionIV-Brequireslow-level
virtual address space. This area must also be large enough to
system modifications to the operating system kernel. We de-
holdthepagetablesofalltheprocessesrunningonthesystem.
cided to prototype PT-Rand for the open-source Linux kernel.
However, the concepts underlying our work on PT-Rand can
Page Table References. Memory disclosure vulnerabilities
be integrated into other contemporary operating systems. To
allow the attacker to leak information about code and data
this end, our kernel patch is comprised of 1382 insertions and
pointers. Even fine-grained randomization schemes can be
15 deletions across 45 source files.
undermined if the attacker can map a single pointer to an
instruction [48]. Hence, one of the main challenges in our Figure 3 shows how we integrate PT-Rand into the Linux
design is to ensure that all references to page tables and the kernel.Wecreatewrapperfunctionsforthepagetableallocator
base address of the PT-Rand region are not leaked to the to randomize the virtual address of pages that contain page
attacker. For this, we need to locate all page table references table entries. If the wrapper function is called to allocate
and replace them with physical addresses (3 in Figure 2). memory which will be used to store page table entries, it
Furthermore, we need to carefully handle benign page table allocates the memory at a random address in the PT-Rand
changes by the kernel. Typically, the kernel processes page region.Thevirtualaddress,pointingtothisregion,canonlybe
table pointers using virtual addresses on the kernel’s stack. computed by adding the randomization secret, which is stored
Sincethestackisreadablebytheattacker,weneedtoprovide in the third debug register. Pages for regular memory are still
a new mechanism to prevent leakage of these pointers. allocatedinthe1:1mappingandtheirvirtualaddresseswithin
6Virtual Memory Address Size Purpose
0x00000000000 47 Bits User Space
1:1 Mapping
Physical Address + (physmap) hole caused by [48:63] sign extension
Base Address of
0xffff8000000 43 Bits Hypervisor
CPU physmap (constant)
Regular Page 0xffff8800000 43 Bits 1:1 Mapping
DR3
0xffffc800000 40 Bits PT-Rand (Hole)
0xffffc900000 45 Bits vmalloc/ioremap
0xffffe900000 40 Bits Hole
Linux Kernel
0xffffea00000 40 Bits Memory Map
PT-Rand Region
Virtual Memory Management
unused hole
PT-Rand
0xffffec00000 44 Bits Kasan
Physical Address +
Page Allocator DR3 (randomized) unused hole
Page Table Page
0xffffff00000 39 Bits Fixup Stacks
Memory Map
unused hole
0xffffffff800 512M Kernel Text
Figure 3: We modify the virtual memory location of page 0xffffffffa00 1525M Modules
table pages by providing a randomization wrapper around 0xffffffffff6 8M vsyscalls
the standard page allocator in the kernel. While randomized 0xffffffffffe 2M Hole
pages are removed from 1:1 mapping, regular page allocation
requests still fall within this region. Figure4:Thex86_64virtualmemorymapforLinuxwithfour
level page tables.
the 1:1 mapping are calculated by adding the base address
of the 1:1 mapping, called physmap in Linux, to the physical execution continued normally. In our extensive evaluation on
address of the regular page. different suites of benchmarks and complex software such
as the Chrome browser (see Section VI-B) we have not
We create wrapper functions for those kernel functions
experienced any kernel crashes.
that need to access page table memory. When the kernel
starts executing, the PT-Rand initialization function will first To handle the second step, we extend the page table
generatetherandomizationsecretbasedonthestandardkernel management functions in the kernel. Specifically, we create a
function get_random_bytes(). We enable the kernel to wrapperfunctionaroundthememoryallocatorforpagetables.
use the hardware-based random number generator (HW-RNG) This allows us to modify their return values, i.e., they return
toavoidlowentropyduringboottime.Note,thatsinceversion physical addresses as a reference to the allocated memory
3.16theLinuxkernelincorporatestheoutputofHW-RNGsfor ratherthanvirtualaddresses.Sincethereisnorelationbetween
generating random numbers by default1. physical and virtual memory addresses, the attacker cannot
inferthelocationinthevirtualmemorybyleakingthephysical
In the following, we present the implementation details
address.
of PT-Rand according to the challenges we outlined in Sec-
tion IV-C.
We also create wrapper functions for every other kernel
function that interacts with page tables to translate page table
A. Page Table Allocations
references (physical addresses) to virtual memory addresses
The main task of PT-Rand is to map memory which before accessing the page tables.
contains page tables to a random location within the PT-Rand
region. Page table allocation involves two steps: (i) random-
B. Generating a Randomized Area
ization of the initial pages, and (ii) randomization of memory
allocations which are used to store newly created page tables.
In order to provide sufficient protection against guessing
To complete the first step, we need precise knowledge attacks we require a high randomization entropy. While 64 bit
of all existing references to the initial page tables, because architectures have a theoretical limit of 16EB of memory,
after randomization these references need to be updated. The currenthardwareislimitedtosupport256TBresultingin48bit
mainchallengewefacedisidentifyingallthosereferences.To randomization entropy.
tackle this challenge, we followed a pragmatic approach: we
The Linux kernel organizes the available virtual memory
reverse-engineeredthekernelcodeexecutionafterthelocation
into different regions. Figure 4 is taken from the Linux kernel
of the initial page tables have been randomized. Since every
documentation [2] and reveals that the Linux kernel currently
page table access based on an old reference leads to a kernel
does not use all of the available virtual memory. In particular,
crash, we could determine the point of execution and asso-
we identified two memory holes of which each offers 1TB
ciated kernel function which caused the crash. Thereafter, we
(40 Bit) free memory. Our proof-of-concept implementation
inspectedthekernel’ssourcefilesandupdatedallreferencesto
of PT-Rand utilizes one of these holes for the PT-Rand region
useournewbaseaddress.Afterupdatingallreferences,kernel
tostorethepagetables.Notethatsuchlargeholeswillalways
1 https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id= exist for 64 Bit systems due to the vast amount of available
be4000 virtual memory.
7C. Page Table References E. Translation of Physical Addresses
As described in Section IV-A, the attacker can exploit Since the page tables are relocated by PT-Rand, they
kernelvulnerabilitiestoreadfromandwritetokernelmemory. are no longer accessible through the 1:1 mapping. Hence,
However, these vulnerabilities do not allow the attacker to as described in Section IV-C, the kernel has to utilize two
access content stored in registers. Hence, we can securely different mechanisms when translating physical addresses to
store the randomization secret into a dedicated register. For virtual addresses, namely one for physical addresses of pages
ourproof-of-concept,wechosethefourthdebugregisterDR3. that contain page table entries, and another one to translate
We selected this register since it is only used for debugging physical addresses for non-page table related memory. Fortu-
purposes. It is noteworthy to mention that application debug- nately, the kernel already keeps track of the properties of each
ging is still supported under PT-Rand. Typically, debuggers individual physical page in a dedicated data structure called
can use software and hardware breakpoints. The former are memory map. When we analyzed this structure, we noticed
the default breakpoints and not affected by PT-Rand. For the thatcertainbitsoftheflagfieldarenotused.Thisallowsus
latter, we only use one of the four available hardware break- to quickly distinguish among the two different types of pages.
points. Note that exploiting debugging facilities is a widely- Specifically, we reserve one bit to mark if a physical page
accepted strategy when building defenses, e.g., TRESOR [36] hasbeen removedfrom the1:1mapping byPT-Rand. Inother
or kBouncer [39]. Alternatively, we are currently exploring words, if the bit is set, the kernel knows that the requested
thefeasibilityofdeployinganyoftheso-calledmodel-specific access is a page table related access which requires handling
registers (MSRs). based on the PT-Rand region.
At run-time, kernel functions that need to translate a phys-
However, even though we store the base address in a
ical to a virtual memory address will check the flag field of
privileged register, certain events (e.g., function calls) can
thememorymap.Ifthephysicalpageisnotaccessiblethrough
spill temporary registers for several cycles to memory. As
the1:1mapping,thekernelfunctionwillusetherandomization
recently shown, this short time window can be exploited to
secret provided by PT-Rand to determine the virtual memory
undermine CFI checks [11]. PT-Rand tackles the attack by
address. Otherwise, the function uses the default translation
instructing the compiler to never spill registers which contain
through the 1:1 mapping. Hence, PT-Rand preserves the high
a randomized address. This is enabled by a GCC feature,
efficiency for the majority of the page requests through the
called explicit register variables, which will always keep local
1:1 mapping. In particular, we modified the __va macro to
variablesinregisters.However,giventhecomplexityandmany
perform the check on the flag field. This function is the
optimization techniques deployed by modern compilers, we
central point for translating physical to virtual addresses. PT-
canonlyguaranteethattheaboveGCCcompilerfeaturenever
Rand does not cause any problems for external drivers, since
leaks accordingly flagged variables, but not any intermediate
externalkerneldrivers(e.g.,graphiccarddrivers)aresupposed
calculation results. As a consequence, we are currently work-
to use these kernel functions to translate addresses.
ing on a GCC compiler extension that explicitly clears any
intermediate results held in other registers. Duringtheimplementation,weencounteredthatmodifying
__va raises another challenge: in the early boot phase, i.e.,
before PT-Rand relocates the initial page tables, a few kernel
D. Handling of 1:1 Mapping functions already invoke the modified macro. However, at this
point of system state, the memory map is not yet initialized.
The typical page size is 4KB. However, the kernel also
Hence,themacrocannotyetaccesstheflagfield.Wesolved
supportspagesizesof2MBor1GB.Inparticular,fortheLinux
thisproblembyutilizinganunusedmacrocalled__boot_va
kernel, the 1:1 mapping is configured to use 2MB pages by
which performs the same operation as the uninstrumented
default.
version of the __va macro. We patched all functions that
are executed before the memory map is initialized to use the
In PT-Rand, we rely on unmapping memory that contains
unmodified __boot_va macro.
page tables from the 1:1 mapping. This becomes challenging
when 2MB pages are used because the page might contain
otherdatathanpagetablememorythatshouldnotberemoved VI. EVALUATION
from the1:1 mapping. Wetackle this challengeby reconfigur-
In this section, we present the evaluation results for PT-
ing the page size to 4KB pages at run time. However, in order
Rand. We first analyze security aspects such as randomization
to split a 2MB page into 4KB pages, we need to previously
entropy and leakage resilience. Thereafter, we present a thor-
allocate512(i.e.,2MBdividedby4KB)newpagetableentries
ough investigation of the performance overhead incurred by
withinthe1:1mapping.Notethatthe4KBsplituponlyaffects
PT-Rand. For this, we conducted micro-benchmarks on hot
memory that contains page tables. For other memory parts,
code paths, measure performance overhead based on SPEC
the kernel will continue to use large pages. Our performance
CPUindustrybenchmarks,andquantifytheimpactoncomplex
evaluation in Section VI-B indicates that this change has no
applications such as browsers.
impact on the overall performance. Next, we configure each
entrytomapthecorrespondingmemoryofthe2MBpage,and
A. Security Considerations
adopt the permissions and other metadata. Finally, we update
the page table hierarchy to use the 4KB page tables entries Our main goal is to prevent data-only attacks against
instead of the one 2MB entry. After the conversion, we can the kernel page tables at run time. For this, we random-
relocate and delete only those 4KB pages that contained page ize the location of page tables per boot. In general, any
table entries. randomization-based scheme must resist the following attack
8vectors: (i) guessing attacks, (ii) memory disclosure through
code and data pointers, and (iii) memory disclosure through
spilledregisters.Inthefollowing,wediscusseachattackvector
3,7264E-09
to demonstrate the effectiveness of PT-Rand. We also include
an exploit in our study to demonstrate that exploit hardening
3,7262E-09
mechanismsatthekernel-levelcanbebypassedwhenPT-Rand
is not applied.
3,7260E-09
Guessing Attacks. Low randomization entropy allows the 3,7258E-09
attacker to guess the randomization secret with high probabil-
3,7256E-09
ity [47]. The randomization entropy of PT-Rand depends on:
(1)thenumberofguesses,(2)thesizeoftheregionwherethe
3,7254E-09
page tables are allocated, and (3) the overall size of memory
that is required to store all page tables. 3,7252E-09
0 10000 20000 30000 40000 50000 60000 70000
We limit the number of attacker’s guesses by configuring
the kernel to initiate a shutdown in case of an invalid memory
access in kernel memory. Note that this has no impact on
the kernel’s execution. In fact, this was the default behavior
of previous versions of the Linux kernel. As described in
Section V-B, we utilize an unused memory region of 1TB
(40 Bit) to randomize the memory allocations for the page
tables. However, the smallest memory unit in paging is a
4KB (12 Bit) page. This means when one page table entry
is placed randomly into the PT-Rand region, 4KB of memory
become readable. Hence, the attacker does not have to guess
the correct address of a particular page table entry but only
the start address of the page which contains the entry. As a
consequence,thetotalrandomizationentropyavailableforPT-
Rand is 28 Bit.
For a deterministic attack, the attacker has to manipulate a
specific page table entry S that protects a specific function
of the kernel. Alternatively, it might be sufficient for the
attackertocorruptanarbitraryvalidentryAofthepagetable.
However, it is not guaranteed that this modification will allow
the attacker to compromise the kernel, thus, the attack success
is probabilistic. Hence, we calculate the success probability
that the attacker can correctly guess the address of the page
which contains S. We denote this probability with p(x) which
depends on the number of pages, denoted by x that contain
page table entries.
We can reduce the problem of calculating the success
probability sp(x) to a classical urn experiment without re-
placement and with three different colored balls: black, red,
andgreen.Theblack ballsrepresenttheunmappedpages.The
attackerlosestheexperimentbydrawingablackball(because
accessing an unmapped page crashes the operating system).
The red balls represent the valid pages, however, they do not
contain the attacker’s target page table entry S. The attacker
is allowed to continue and draw another ball, as long as the
attackerdrawsaredball(accesstoavalidpage).Agreenball
represents the page containing the page table entry S that the
attacker aims to modify. With SG we denote the event that
the attacker draws the green ball eventually without drawing a
blackball(guessingthecorrectaddressofS withoutaccessing
an unmapped page). Hence, the probability of SG is the sum
oftheprobabilitiesthattheattackerdrawsthegreenballinthe
first try plus the probability that the attacker draws the green
ball after drawing the i-th red ball where i≥1. The resulting
probability of SG is computed as follows:
ytilibaborP
Probability sp(x): An attacker can successfully guess the
address of a specific PTE
Number of Pages
Figure5:Probabilityforguessingattacksbasedonthenumber
of mapped pages in the PT-Rand region.
1
(cid:88)x (cid:0)x(cid:1)
1
Pr[SG]=p(x)= + i ∗
228 (cid:0)228(cid:1) 228−i
i=1 i
Figure 5 plots the probability that the attacker can succeed
in guessing a specific page table entry if up to 216 memory
pagesforpagetablesareallocated.Thegraphshowsthateven
if a high number of page table entries (PTEs) are allocated,
theattacker’ssuccessprobabilityisstillverylowrangingfrom
3.725∗10−9 to3.726∗10−9.Wemeasuredthenumberofpage
tables for a variety of different systems and configurations.
Foranormaldesktopsystem,weobservedthatbetween2,000
and 4,000 PTE pages were allocated. If we start a virtual
machineupto16,000pagesforPTEsareallocated.Lastly,our
server (24 cores and 64GB RAM) running 9 virtual machines
in parallel allocates up to 33,000 pages for PTEs. As shown
in Figure 5, the probability grows linearly. Therefore, even
if the attacker attempts to decrease the entropy by forcing the
operatingsystemtoallocatemorepagesthatcontainpagetable
entries2 the attacker’s success probability is very low. Further,
PT-Rand can prevent attacks on the entropy by limiting the
amount of page tables to a number that will guarantee a user
configurable amount of entropy.
For this reason, even if the attacker tries to decrease
the randomization entropy by forcing PT-Rand to allocate a
large amount of memory within the PT-Rand region, e.g.,
by spawning new processes, the success probability will not
increase significantly before such an attack can be detected,
e.g., by only allowing a fixed number of allocated pages.
Memory References. Memory disclosure is another severe
threat to any kind of randomization scheme. For PT-Rand, we
assumethattheattackercandiscloseanykerneldatastructure,
and therefore, possible references to page tables. Hence, we
obfuscate the references to page tables in all kernel data
structures by substituting the virtual addresses with physical
2theattackercanforcetheoperatingsystemtocreatenewpagetableentries
bystartingnewprocesses.
9addresses. Note, there is no correlation between virtual and Based on these attack primitives, we develop an attack which
physical addresses. Therefore, the attacker does not gain any allowsustoexecutearbitrarycodeinthekernel,despitehaving
information about the real location of the page tables by the kernel protected with state-of-the-art CFI for the kernel.
disclosing obfuscated addresses. Since our modified memory Thegoalofourattackisto(i)changethememorypermissions
allocator for page-table memory only returns obfuscated ref- ofapagethatcontainsthecodeofapre-definedkernelfunction
erences, the attacker cannot access page tables by reading to writable, (ii) overwrite the function with our shellcode, and
those pointers. The remaining potential source of leakage are (iii)finallytriggertheexecutionofthisfunctiontoinstructthe
functions that did not use our modified allocator. Recall, all kernel to execute our shellcode with kernel privileges.
functions that access the page tables now expect a physical
To retrieve the KASLR offset, we use the aforementioned
address. Hence, if these functions receive a virtual memory
information disclosure vulnerability. The vulnerability allows
address of a page table entry, they will automatically try to
the attacker to disclose the absolute address of a kernel
translate them using the randomization secret. The result is
function. Since we can determine the relative offset of this
verylikelyaninvalidaddresswhichwillleadtoakernelcrash.
function to the start address of the kernel code section, we
can compute the absolute address of the kernel after KASLR.
Spilled Registers. As recently demonstrated in [11], even
Based on this address, we can compute the address of every
temporarily spilled registers which contain a security-critical
function or global variable of the kernel since KASLR only
value can compromise PT-Rand. To prevent any access to the
debugregister(DR3)thatcontainstherandomizationsecret,we shifts the whole kernel by a randomized offset during boot.
patched the Linux kernel code to never access DR3, i.e., DR3 In an offline analysis of the kernel image, we discovered a
global variable that holds a reference to the task_struct
cannotbeaccessedthroughanykernelAPI.NotethattheCPU
of the initial process. The task_struct is a kernel data
does not spill debug registers during interrupts [27]. Further,
structure in which the kernel maintains information about
wepreventthecompilerfromwritingtherandomizationsecret
each process, like id, name and assigned virtual memory.
to the stack by performing all computations in registers and
Specifically, it contains a pointer to the mm_struct which
neversaveorspilltheresulttomemory.However,theremight
maintainsinformationaboutthememorythatisassignedtothe
be cases, where a register that contains an intermediate value
process.Withinthisstructure,wediscoveredavirtualmemory
is spilled on the stack due to a hardware interrupt. In contrast
pointer to the root of the page table of the corresponding
to software interrupts, which we disable during page walks,
process.
hardwareinterruptscannotbedisabled.Thisopensaverysmall
time window that may enable the attacker to use a concurrent Using the arbitrary read capability and the 1:1 mapping,
thread to disclose register values, and potentially recover we traverse the page table to the entry that maintains the
parts of the randomization secret. We performed preliminary permissionsforthesystemcallsys_setns.Next,wesetthis
experimentswithasettingthatfavorstheattackertoimplement page to writable and overwrite the beginning of sys_setns
thisattack,anddidnotsucceed.Nevertheless,wearecurrently with our shellcode. In our proof-of-concept exploit, we re-
exploringtwodifferentstrategiestomitigatesuchattacks.The write the function to elevate the current process’ privileges
first strategy is to further decrease the already small time to root. Naturally, other payloads are possible as well, like
window where register values could potentially be leaked. In installing a kernel rootkit. After we modified the system call
particular, we envision to instrument the page table reads, function,wesetthecorrespondingpagetableentryagainback
by rewriting them with inline assembly, such that the de- to readable and executable, and invoke the system call to
obfuscated address is only present in the register for a couple trigger the execution of our shellcode.
ofinstructions.Afteraccessingthepage-tablememoryallreg-
Asexplainedindetail,thisattackdoesnotinvolvechanging
isters that contain (intermediate values of) the randomization
any code pointer. Hence, it resembles a data-only attack that
secretaresettozero.Alternatively,thesecondstrategyensures
cannotbemitigatedbydefensesagainstcontrol-flowhijacking.
that the attacker cannot use a concurrent thread to access the
However, after hardening the kernel with PT-Rand, this attack
stackofavictimthreadthatgotinterruptedandwhoseregisters
failssincewecannotreliablylocatethecorrectpagetableentry
got temporarily spilled to memory. This can be achieved by
for system call task_struct.
using different page tables per kernel thread. Specifically, this
allows us to assign stack memory per kernel thread which
Side-channel Attacks. As stated in Section IV-A, preventing
cannot be accessed by other (concurrent) threads. Therefore,
side-channel attacks is beyond the scope of this paper. How-
even if intermediate values are spilled to memory, the attacker
ever,sinceside-channelattackshavethepotentialtoundermine
cannot leak them using concurrent threads. A simpler version
the security guarantees of PT-Rand, we will shortly discuss
of this technique, where the kernel uses a different page table
how these attacks work and how the kernel could be extended
per CPU, is already deployed in the grsecurity patch [50].
to prevent them.
Real-world Exploit. We evaluated the effectiveness of PT-
Through side channels the attacker can disclose informa-
Rand against a set of real-world vulnerabilities. In particular,
tionaboutthekernelmemorylayout.Inparticular,theattacker
we use an information disclosure vulnerability in the Linux
discloseswhetherakernelmemorypageismapped.Hence,the
kernel to bypass KASLR3, and a vulnerable driver which
attacker,inusermode,willattempttoreadorwritetoakernel
doesnotsanitizepointersprovidedbyauser-modeapplication
memorypage.Sincekernelmemorycannotbeaccessedbythe
(CVE-2013-2595) to read and write arbitrary kernel memory.
user-mode programs such an attempt will result in an access
violation. However, the time elapsing between the attempted
3. This vulnerability was silently fixed by the Linux kernel maintainers
access and the access violation depends on whether the page
whichiswhytherewasnoofficialCVEnumberassigned: https://git.kernel.
org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b2f739 is mapped. Hund et al. [26] first demonstrated the feasibility
10ofthisattackbymeasuringthedifferenttimingsthepagefault Benchmark Name Relative Overhead
handler needs to deliver an exception to the user mode to
bypass kernel ASLR. Wojtczuk [56] improved this attack by IOZone 1.0%
using Intel’s Transactional Synchronization Extensions (TSX) PostMark 1.8%
which provides new instructions for hardware-aided transac- OpenSSL -2%
tional memory. The advantage of using TSX instructions to PyBench -0.9%
access kernel memory is that the faulting access does not PHPBench -0.2%
invokethepagefaulthandler,andhence,allowstoexecutethe Apache 0.8%
previousattackofHundetal.fasterandwithhigherprecision.
Table I: Phoronix benchmark results.
These timing-side channels exist because the user and
kernel mode share the same address space, i.e., they use the
same page tables. Hence, we can prevent such attacks by
ensuringthattheuserandkernelmodeusedifferentpagetables LMBench also includes other benchmarks, e.g., perfor-
similar to Apple’s iOS [34]. mance impact on memory accesses, system calls or floating
pointoperations.Wesuccessfullyexecutedallbenchmarksand
Code-reuse attacks. PT-Rand is complementary to defenses observed no measurable impact on the performance.
against code-reuse attacks, like CFI [1, 19], CPI [30], or fine-
grained randomization [12, 31]. We applied the open-source Phoronix. Besides SPEC CPU2006 and LMBench we mea-
version of the CFI kernel protection for Linux RAP [52] to sured the performance impact of PT-Rand with the Phoronix
prevent the attacker from hijacking the control flow. Hence, benchmark suite [41] which is widely used to benchmark
the attacker cannot use code-reuse attacks like ROP to leak the performance of operating systems. Table I4 summarizes
the randomization secret. the results which are consistent with the results of the SPEC
CPU2006 benchmarks.
Chromium. Finally, we measured the performance overhead
B. Performance
forGoogle’sChromiumintwoscenarios:1)weranthepopular
We measured the performance overhead incurred by PT- browser benchmarking frameworks JetStream, Octane, and
Rand based on SPEC CPU2006, LMBench, Phoronix, and Kraken,tomeasuretherun-timeoverheadfordailyusage,and
Chromium benchmarks. All measurements are taken on an 2)wemodifiedChromiumsuchthatitterminatesdirectlyafter
Intel Core i7-4790 CPU running at 3.60GHz with 8 GB RAM loading to measure the load-time overhead. We repeated both
using Debian 8.2 with a recent Linux kernel, version 4.6. experimentsthreetimesanddeterminedthemediantoaccount
for small variances.
SPEC CPU 2006.TheSPECCPU2006benchmarksmeasure
For the Chromium web browser, we report a run-time
theperformanceimpactofPT-RandonCPU-intensiveapplica-
overhead of -0.294% and a load-time overhead of 9.1%. The
tions.Weexecutedtheentirebenchmarksuitewiththedefault
run-timeoverheadrepresentsthearithmeticmeanof0.76%for
parameters for reference tests: three iterations with reference
JetStream, 1.183% for Kraken, and -2.825% for Octane.
input. We did neither encounter any problems during the
execution (i.e., crashes) nor strong deviations in the results of The browser frameworks measure browser engine latency
the benchmarks. Figure 6 summarizes the performance impact and load, with a focus on JavaScript execution. While these
of PT-Rand compared to a non-modified kernel. The average tests do not accurately measure the direct performance over-
performance overhead of PT-Rand is only 0.22% with worst- head of PT-Rand, they provide a first estimation of the per-
case overhead of only 1.7%. This confirms the high efficiency formance impact on the popular end-user applications such
and practicality of PT-Rand for contemporary systems. as a web browser. Given only -0.294% overhead, we confirm
that PT-Rand does not negatively impact performance of user
Note that a few benchmarks perform marginally better
applications.
when PT-Rand is applied. Such deviations have been also
observed in prior work, and can be attributed to negligible To measure the load-time overhead, we simply added a
measurement variances. return instruction in the main function of Chromium. This
ensures that Chromium immediately terminates after it is
LMBench. Most of our modifications affect the launch and completely loaded. We measured the elapsed time based on
termination phase of an application’s lifecycle. This is due to the Unix tool time. With less than 1 ms load-time overhead
the fact that PT-Rand needs to randomize the page tables at we assert that PT-Rand does not impair the user experience.
program start and remove them from the 1:1 mapping. When We find these results to be in line with our LMBench test
an application terminates, PT-Rand needs to de-randomize its results for process creation and termination.
pagetablesandmakethismemoryagainaccessiblethroughthe
1:1mapping.Hence,weadditionallytestedourapproachusing C. Robustness
the popular LMBench micro benchmark suite [35] to assess
To evaluate the robustness of PT-Rand we executed a
the overhead for these critical phases. Specifically, LMBench
large number of popular user-mode applications, and the three
collects timing information for process launch, fork, and exit.
aforementioned benchmarking suites. We did not encounter
We measured an absolute overhead of less than 0.1 ms on
average which is hardly noticeable to the end-user of a PT- 4 Note that we excluded some of the benchmarks because we got errors
Rand-hardened system whenexecutingthemonavanillasystem.
114
3
2
1
0
-1
milc n a m d d e alII so ple x p o vra y lb m sp hin px e3 rlb e n c h bzip 2 g cc m cf g o b m k h m m er sj lie bn qg u a ntu m h 2 6 4re of m n etp p as xt alar a n c b m k M e a n G e o M e a n
)%(
nwodwolS
ecnamrofreP
PT-Rand
Figure 6: Overhead of page table randomization on SPEC CPU2006
any crashes during these tests, and all applications behaved as forensic tools to identify critical data structures such as the
expected.Tofurtherstresstestourimplementationweexecuted page tables in the case of PT-Rand. However, they require
the Linux Test Project (LTP) [32]. The LTP is comprised physical access to the RAM. Creating a memory snapshot
of different stress tests that can be used to evaluate the remotely to detect the location of page tables is not feasible
robustness and stability of the Linux kernel. We executed the becausetheremoteattackerhasonlyaccesstovirtualmemory,
most important tests under PT-Rand, and did not encounter i.e.,linearlyscanningvirtualmemorywilleventuallyleadtoa
any deviation in the behavior compared to the vanilla kernel. system crash since we move the page tables to a memory re-
Finally, we did not encounter any compatibility issues or gionwherethemajorityofsurroundingpagesarenotmapped.
crashes when combining PT-Rand with RAP [52].
No Disturbance of Workflow. As described in Section V, we
VII. DISCUSSION use a debug register to store the randomization secret. This
prevents the attacker from leaking the secret by means of a
Choice of 64-bit. The choice of 64 bit architectures is not memory disclosure. As a consequence, the chosen debug reg-
a conceptual limitation. PT-Rand can be ported to 32 bit ister is no longer available for debugging purposes. However,
architectures. However, similar to ASLR, PT-Rand relies on debug registers (DR0-DR2) are still available. Furthermore,
the available randomization entropy which is known to be these debug registers are only used for hardware breakpoints.
low for 32 bit systems [47]. Hence, we focused our efforts Software breakpoints, which are far more common during
on hardening 64 bit-based architectures because nearly all debugging, are not affected by our change.
commodity desktops and servers feature 64 bit CPUs. Even
Lastly, it is noteworthy to mention that PT-Rand does not
mobile devices are increasingly deploying 64 bit CPUs. As
depend on any specific operating system features and can be
of 2013, Apple’s iPhone embeds a 64 bit processor and iOS 9
ported to other operating systems.
runsexclusivelyon64bitprocessors.Inasimilarvein,Google
runs 64 bit processors for their latest Nexus smartphone.
VIII. RELATEDWORK
Malicious Drivers. Our threat model does not consider in- A. Data-only Attack and Defenses
jection of malicious drivers. These would allow the attacker
Chenetal.[10]demonstratedtheeffectivenessofdata-only
to execute arbitrary code in kernel mode without requiring
attacks against server applications. In particular, they showed
exploitation of a memory corruption vulnerability. As such,
how to bypass authentication checks, and escalate privileges
malicious drivers could access and leak the randomization se-
to root without the need to hijack the application’s control
cret. However, note that all modern operating systems support
flow. Hu et al. [23] created FLOWSTITCH to automatically
driver signing to prevent the loading of such malicious drivers
generate such data-only attacks. This is achieved by first ana-
therebyensuringthattherandomizationsecretisnotleakedto
lyzing the execution flow that leads to the memory-corruption
the attacker.
vulnerability, and then exploring how this vulnerability can be
exploitedtomanipulatingexistingdataflowsoftheapplication
Physical Attacks. Similar to previous work [13], the main
toleaksensitiveinformationorescalateprivileges.Inafollow-
focus of this work is to prevent remote attacks against the
up work, Hu et al. [24] introduced the notion of data-oriented
kernel. As a result, attacks that rely on physical access to
programming (DOP) which extends these attacks to a Turing-
the victim system are beyond the scope of this work. For
complete machine.
instance, several attacks in the past utilized special hardware
(e.g., FireWire [44]) to create a snapshot of the physical To mitigate data-only attacks a number of data-
memory [22]. Such snapshots can be analyzed by means of randomizationapproacheshavebeenproposed.Cadaretal.[9]
12and Bhatkar et al. [7] apply static analysis to divide data theextraoverheadofSecVisorandHyperSafecanbeattributed
accesses into equivalence classes. Next, they instrument all toadditionalchecksthatgobeyondtableprotection.However,
data accesses to use a xor key per equivalence-classes for the hypervisor itself will always add some extra execution
reading and writing data from/to memory. This prevents the overhead.Inaddition,theseapproachesrelyonextrahardware
attackertoexploitamemory-corruptionvulnerabilitytoaccess features such as virtualization extensions.
arbitrary data. However, the instrumentation of data accesses
Another recent example for a hypervisor-based approach
is expensive with up to 30% run-time overhead.
is KCoFI [13] which enables full-system CFI enforcement
Giuffrida et al. constantly re-randomize the addresses of for an operating system kernel. It also securely stores the
data at run-time [21]. They implemented a live randomization policiesforsafeguardingitsvirtualizedguestsinsideamemory
system for Minix3 and report a modest overhead of 5%. region that is only accessible by the hypervisor. However, this
However,betweeneachrandomizationtheattackerhasasmall solution also comes with significant overhead of up to 200%,
time window where the attacker can leak the address, and and suffers from the constraints mentioned already above,
manipulate content of the targeted data. Bigelow et al. [8] i.e., requiring virtualization extensions and deployment of a
avoid this time windows in the context of server applications hypervisor.
by re-randomizing the address space after the data was sent
SPROBES and TZ-RKP both leverage hardware trust an-
overthenetwork.Hence,allpotentiallyleakedinformationare
chors [5, 20]. In particular, both issue run-time checks for
re-randomized when they reach the attacker.
the kernel’s memory management functions. These checks
are executed inside the hardware-enabled secure environment
B. Register-based Information Hiding ARMTrustZone.Thissecureenvironmentcannotbetampered
with by any other software. The overhead of TZ-RKP is up
Many defenses rely on a secret value that should not be
to 7.56%. In addition to the higher overhead, SPROBES and
disclosedtotheattacker.Todoso,onepossibilityistostorethe
TZ-RKP rely on dedicated hardware trust anchors to protect
secret value in a register. TRESOR [36] uses a debug register
page tables.
of x86 to hide an AES key from attackers. Similar to PT-
Rand, Oxymoron [6], Code-Pointer Integrity [30], and ASLR- SKEE implements similar run-time checks to SPROBES
Guard[33]usearegistertohidethebaseaddressofamemory and TZ-RKP [4]. It utilizes the fact that ARM provides two
regionthatcontainssensitivedata.Inparticular,thesedefenses registersforpaging.ThisenablesSKEEtoisolatetherun-time
useasegmentationregistertohidetheirtrustedcomputingbase checks from the kernel. The overhead for protecting memory
from the attacker. management varies between 3% and 15%.
Policy-based approaches like HyperSafe [54] and
C. Kernel and Page Table Protection
SPROBES/TZ-RKP [5, 20] mark pages that contain the
Several kernel defenses have been proposed that also page table structures as read-only to prevent malicious
protect the page table against malicious manipulations [4, modifications. However, when the operating system needs to
13, 20, 45, 54]. In general, existing approaches are based update the page tables these defenses mark the corresponding
on a dedicated kernel monitor that enforces a set of pre- pages temporarily writable which opens a time window in
defined policies at run time, including integrity policies for whichtheattackercanconcurrentlymodifypagetablesentries
page tables. To the best of our knowledge, PT-Rand is the on the same page.
first approach which follows a randomization-based approach
PaX/Grsecurity [50] provide a patch with various tech-
to defend against data-only attacks against page tables.
niques to further harden the Linux kernel. Amongst others
SecVisor [45] and HyperSafe [54] follow a hypervisor- the patch aims to prevent information leaks, and randomizes
based approach. SecVisor enforces W⊕X for the kernel space importantdatastructuresatcompiletime.However,itdoesnot
toensuretheintegrityofthekernelcode.Thisisdonebyusing deploy any techniques to explicitly prevent data-only attacks
memory virtualization to allow only certain physical pages to against the page table.
be executable. SecVisor provides an interface to the kernel to
Windows10[28]recentlyreleasedanupdatetorandomize
allow new physical pages to be marked as executable. These
the base address which is used to compute the address of
requests are checked against a user-provided policy which is
page table entries. However, the randomized base address is
not further specified. HyperSafe protects its page tables by
not protected against information disclosure attacks which is
marking them read-only, and checks before updating the page
why the attack we implemented in Section VI-A will also
tables if the update conforms to a immutable set of policies
work against Windows 10. In contrast, PT-Rand mitigates
which should prevent malicious changes of page tables. Since
information-disclosure attacks by keeping the randomization
the hypervisor maintains its own memory domain, virtualized
secret in a register, which cannot be accessed by the attacker,
guests cannot compromise its integrity by means of data-only
and by obfuscating all pointers to the page tables.
attacks.However,thepagetablesmaintainedinthehypervisor
itself can be compromised by the attacker. For instance,
IX. CONCLUSION
evasionattackscanbedeployedtoattackthehypervisorfroma
virtualizedguestsystem[55].Anotherpracticalshortcomingof Exploitation of software is a pre-dominant attack vector
hypervisor approaches is the incurred performance overhead. against modern computing platforms. In particular, exploits
SecVisor reports 14.58% average overhead (SPECInt) and against the kernel are highly dangerous as they allow the
HyperSafe5%overhead(custombenchmarks).Incontrast,PT- attacker to execute malicious code with operating system
Randonlyincurs0.22%forSPECCPUbenchmarks.Someof privileges. The research community has introduced several
13classes of exploit mitigation techniques that significantly raise [13] J. Criswell, N. Dautenhahn, and V. Adve. Kcofi: Complete control-
the bar of such attacks. However, these defenses build on the flow integrity for commodity operating system kernels. In 35th IEEE
assumption that the attacker cannot alter the kernel’s page SymposiumonSecurityandPrivacy,S&P,2014.
tables which is the main place to manage access permissions [14] CVE Details. Linux kernel: Vulnerability statistics. http://www.
of code and data memory. For the first time, we introduce a cvedetails.com/product/47/Linux-Linux-Kernel.html,2016.
highly-efficient randomization technique that enables effective [15] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, and F. Monrose.
protection against page table corruption attacks for a contem- Isomeron:Coderandomizationresilientto(Just-In-Time)return-oriented
programming.In22ndAnnualNetworkandDistributedSystemSecurity
porary Linux-based system. Our open-source solution, called
Symposium,NDSS,2015.
PT-Rand,randomizesthelocationofallpagetables,andobfus-
[16] N. A. Economou and E. E. Nissim. Getting physical extreme abuse
cates all references to the page tables without requiring extra
of intel based paging systems. https://www.coresecurity.com/system/
hardware, costly hypervisors, or inefficient integrity checks. files/publications/2016/05/CSW2016%20-%20Getting%20Physical%
PT-Randisapracticalandnecessaryextensiontocomplement 20-%20Extended%20Version.pdf,2016.
existing mitigation technologies such as control-flow integrity, [17] J. Edge. Kernel address space layout randomization. http://lwn.net/
code randomization, and code pointer integrity. Articles/569635,2013.
[18] S.Esser. iOSkernelexploitation. InBlackhatEurope,BHEU,2011.
[19] X. Ge, N. Talele, M. Payer, and T. Jaeger. Fine-grained control-flow
ACKNOWLEDGMENT
integrity for kernel software. In 1st IEEE European Symposium on
SecurityandPrivacy,EuroS&P,2016.
This work was supported in part by the German Sci-
[20] X.Ge,H.Vijayakumar,andT.Jaeger.SPROBES:Enforcingkernelcode
ence Foundation (project S2, CRC 1119 CROSSING), the
integrityonthetrustzonearchitecture. InMobileSecurityTechnologies,
European Union’s Seventh Framework Programme (609611,
MoST,2014.
PRACTICE), and the German Federal Ministry of Education
[21] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum. Enhanced operating
and Research within CRISP.
systemsecuritythroughefficientandfine-grainedaddressspacerandom-
ization. In21stUSENIXSecuritySymposium,USENIXSec,2012.
[22] Y.Gu,Y.Fu,A.Prakash,Z.Lin,andH.Yin. Os-sommelier:Memory-
REFERENCES
onlyoperatingsystemfingerprintinginthecloud. In3rdACMSympo-
siumonCloudComputing,SoCC,2012.
[1] M.Abadi,M.Budiu,Ú.Erlingsson,andJ.Ligatti.Control-flowintegrity
principles, implementations, and applications. ACM Transactions on [23] H.Hu,Z.L.Chua,S.Adrian,P.Saxena,andZ.Liang. Automaticgen-
InformationSystemSecurity,13,2009. erationofdata-orientedexploits. In24thUSENIXSecuritySymposium,
USENIXSec,2015.
[2] Andi Kleen. x86_64 Linux Virtual Memory Map. http://www.kernel.
org/doc/Documentation/x86/x86_64/mm.txt,2004. [24] H. Hu, S. Shinde, A. Sendroiu, Z. L. Chua, P. Saxena, and Z. Liang.
Data-orientedprogramming:Ontheexpressivenessofnon-controldata
[3] ARM. ARM architecture reference manual. http://silver.arm.com/ attacks. In37thIEEESymposiumonSecurityandPrivacy,S&P,2016.
download/ARM_and_AMBA_Architecture/AR150-DA-70000-r0p0-
00bet9/DDI0487A_h_armv8_arm.pdf,2015. [25] R.Hund,T.Holz,andF.C.Freiling.Return-orientedrootkits:Bypassing
kernelcodeintegrityprotectionmechanisms. In18thUSENIXSecurity
[4] A. Azab, K. Swidowski, R. Bhutkar, J. Ma, W. Shen, R. Wang, and Symposium,USENIXSec,2009.
P.Ning. Skee:Alightweightsecurekernel-levelexecutionenvironment
for arm. In 23rd Annual Network and Distributed System Security [26] R.Hund,C.Willems,andT.Holz. Practicaltimingsidechannelattacks
Symposium,NDSS,2016. againstkernelspaceASLR. In34thIEEESymposiumonSecurityand
Privacy,S&P,2013.
[5] A.M.Azab,P.Ning,J.Shah,Q.Chen,R.Bhutkar,G.Ganesh,J.Ma,
and W. Shen. Hypervision across worlds: Real-time kernel protection [27] Intel. Intel 64 and IA-32 architectures software developer’s manual.
from the arm trustzone secure world. In ACM SIGSAC Conference on http://www-ssl.intel.com/content/www/us/en/processors/architectures-
ComputerandCommunicationsSecurity,CCS,2014. software-developer-manuals.html,2015.
[6] M.BackesandS.Nürnberger.Oxymoron:Makingfine-grainedmemory [28] A.Ionescu.Owningtheimageobjectfileformat,thecompilertoolchain,
randomization practical by allowing code sharing. In 23rd USENIX and the operating system: Solving intractable performance problems
SecuritySymposium,USENIXSec,2014. throughverticalengineering. www.alex-ionescu.com/?p=323,2016.
[7] S.BhatkarandR.Sekar. Dataspacerandomization. In5thConference [29] Y. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee, C. Wilkerson,
on Detection of Intrusions and Malware and Vulnerability Assessment, K.Lai,andO.Mutlu. Flippingbitsinmemorywithoutaccessingthem:
DIMVA,2008. An experimental study of dram disturbance errors. In 41st Annual
InternationalSymposiumonComputerArchitecture,ISCA,2014.
[8] D.Bigelow,T.Hobson,R.Rudd,W.Streilein,andH.Okhravi. Timely
rerandomization for mitigating memory disclosures. In ACM SIGSAC [30] V.Kuznetsov,L.Szekeres,M.Payer,G.Candea,R.Sekar,andD.Song.
ConferenceonComputerandCommunicationsSecurity,CCS,2015. Code-pointer integrity. In 11th USENIX Symposium on Operating
SystemsDesignandImplementation,OSDI,2014.
[9] C.Cadar,P.Akritidis,M.Costa,J.-P.Martin,andM.Castro. Dataran-
domization. TechnicalReportMSR-TR-2008-120,MicrosoftResearch, [31] P.Larsen,A.Homescu,S.Brunthaler,andM.Franz. SoK:Automated
2008. software diversity. In 35th IEEE Symposium on Security and Privacy,
S&P,2014.
[10] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer. Non-control-
dataattacksarerealisticthreats. In14thUSENIXSecuritySymposium, [32] LTPdeveloper. Thelinuxtestproject. https://linux-test-project.github.
USENIXSec,2005. io/,2016.
[11] M.Conti,S.Crane,L.Davi,M.Franz,P.Larsen,C.Liebchen,M.Negro, [33] K.Lu,C.Song,B.Lee,S.P.Chung,T.Kim,andW.Lee. Aslr-guard:
M.Qunaibit,andA.-R.Sadeghi.Losingcontrol:Ontheeffectivenessof Stoppingaddressspaceleakageforcodereuseattacks.InACMSIGSAC
control-flowintegrityunderstackattacks. InACMSIGSACConference ConferenceonComputerandCommunicationsSecurity,CCS,2015.
onComputerandCommunicationsSecurity,CCS,2015. [34] T. Mandt. Attacking the ios kernel: A look at "evasi0n". http://www.
[12] S.Crane,C.Liebchen,A.Homescu,L.Davi,P.Larsen,A.-R.Sadeghi, nislab.no/content/download/38610/481190/file/NISlecture201303.pdf,
S. Brunthaler, and M. Franz. Readactor: Practical code randomization 2013.
resilient to memory disclosure. In 36th IEEE Symposium on Security [35] L. McVoy and C. Staelin. Lmbench: Portable tools for performance
andPrivacy,S&P,2015.
14analysis. InUSENIXTechnicalConference,ATEC,1996. [46] H.Shacham. Thegeometryofinnocentfleshonthebone:return-into-
libc without function calls (on the x86). In ACM SIGSAC Conference
[36] T.Müller,F.C.Freiling,andA.Dewald.Tresorrunsencryptionsecurely
onComputerandCommunicationsSecurity,CCS,2007.
outsideram. In20thUSENIXSecuritySymposium,USENIXSec,2011.
[47] H.Shacham,M.Page,B.Pfaff,E.Goh,N.Modadugu,andD.Boneh.
[37] MWR Labs. MWR Labs Pwn2Own 2013 write-up - kernel exploit.
Ontheeffectivenessofaddress-spacerandomization. InACMSIGSAC
http://labs.mwrinfosecurity.com/blog/2013/09/06/mwr-labs-pwn2own-
ConferenceonComputerandCommunicationsSecurity,CCS,2004.
2013-write-up---kernel-exploit,2013.
[48] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and
[38] MWR Labs. Windows 8 kernel memory protections bypass. http://
A. Sadeghi. Just-in-time code reuse: On the effectiveness of fine-
labs.mwrinfosecurity.com/blog/2014/08/15/windows-8-kernel-memory-
grained address space layout randomization. In 34th IEEE Symposium
protections-bypass,2014.
onSecurityandPrivacy,S&P,2013.
[39] V. Pappas, M. Polychronakis, and A. D. Keromytis. Transparent ROP
[49] C.Song,B.Lee,K.Lu,W.R.Harris,T.Kim,andW.Lee. Enforcing
exploit mitigation using indirect branch tracing. In 22nd USENIX
kernel security invariants with data flow integrity. In 23rd Annual
SecuritySymposium,USENIXSec,2013.
NetworkandDistributedSystemSecuritySymposium,NDSS,2016.
[40] Perception Point Research Team. Analysis and exploitation of a linux
[50] B. Spengler. Grsecurity. Internet [May, 2016]. Available on:
kernel vulnerability (cve-2016-0728). http://perception-point.io/2016/
http://grsecurity.net,2016.
01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-
2016-0728/,2016. [51] L. Szekeres, M. Payer, T. Wei, and D. Song. SoK: Eternal war in
memory. In34thIEEESymposiumonSecurityandPrivacy,S&P,2013.
[41] Phoronix. Phoronix test suite. http://www.phoronix-test-suite.com/,
2016. [52] P. Team. RAP: RIP ROP. https://pax.grsecurity.net/docs/PaXTeam-
H2HC15-RAP-RIP-ROP.pdf,2015.
[42] S.Renaud.Technicalanalysisofthewindowswin32k.syskeyboardlay-
out stuxnet exploit. http://web.archive.org/web/20141015182927/http: [53] Trusted Computing Group. Tpm 1.2 protection profile. https://www.
//www.vupen.com/blog/20101018.Stuxnet_Win32k_Windows_Kernel_ trustedcomputinggroup.org/tpm-1-2-protection-profile/,2016.
0Day_Exploit_CVE-2010-2743.php,2010.
[54] Z. Wang and X. Jiang. Hypersafe: A lightweight approach to provide
[43] R. Riley, X. Jiang, and D. Xu. Guest-transparent prevention of kernel lifetimehypervisorcontrol-flowintegrity. InSecurityandPrivacy(SP),
rootkits with vmm-based memory shadowing. In 11th International 2010IEEESymposiumon,pages380–395.IEEE,2010.
Symposium on Research in Attacks, Intrusions and Defenses, RAID,
[55] R.Wojtczuk. Subvertingthexenhypervisor. InBlackhatUSA,BHUS,
2008.
2008.
[44] F.L.Sang,V.Nicomette,andY.Deswarte.I/OattacksinIntelPC-based
[56] R. Wojtczuk. Tsx improves timing attacks against kaslr. https://labs.
architecturesandcountermeasures. InSysSecWorkshop,SysSec,2011.
bromium.com/2014/10/27/tsx-improves-timing-attacks-against-kaslr/,
[45] A.Seshadri,M.Luk,N.Qu,andA.Perrig. Secvisor:Atinyhypervisor 2014.
to provide lifetime kernel code integrity for commodity oses. ACM
SIGOPSOperatingSystemsReview,41(6):335–350,2007.
15