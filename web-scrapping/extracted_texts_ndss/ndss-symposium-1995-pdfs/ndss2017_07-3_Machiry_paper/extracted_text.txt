BOOMERANG: Exploiting the Semantic Gap in Trusted Execution Environments
Aravind Machiry1, Eric Gustafson1,2, Chad Spensky1, Chris Salls1, Nick Stephens1,
Ruoyu Wang1, Antonio Bianchi1, Yung Ryn Choe2, Christopher Kruegel1, and Giovanni Vigna1
1University of California, Santa Barbara
{machiry, edg, cspensky, salls, stephens, fish, antoniob, chris, vigna}@cs.ucsb.edu
2Sandia National Laboratories
{edgusta, yrchoe}@sandia.gov
Abstract—Inthepastdecade,wehavecometorelyoncomput- I. INTRODUCTION
ersforvarioussafetyandsecurity-criticaltasks,suchassecuring
Today’scomputersystems,includinghouseholdappliances,
our homes, operating our vehicles, and controlling our finances.
Tofacilitatethesetasks,chipmanufacturershavebegunincluding cars, and mobile phones, are subjected to an increasing range
trustedexecutionenvironments(TEEs)intheirprocessors,which of attacks. While legacy security mechanisms, including priv-
enable critical code (e.g., cryptographic functions) to run in ilege levels and process isolation, continue to work for the
an isolated hardware environment that is protected from the general case, they are unable to defend against sophisticated
traditional operating system (OS) and its applications. While attacksthatarecapableofcompromisingtheoperatingsystem
code in the untrusted environment (e.g., Android or Linux) is (OS) itself. The ability to compromise the OS and the lack of
forbidden from accessing any memory or state within the TEE,
securityinthefaceofcompromisebothstem,inpart,fromthe
the code running in the TEE, by design, has unrestricted access
lack of segregation between the normal and security-critical
tothememoryoftheuntrustedOSanditsapplications.However,
applications. To thwart these sophisticated attacks, hardware
duetotheisolationbetweenthesetwoenvironments,theTEEhas
manufacturers have introduced a new security mechanism,
very limited visibility into the untrusted environment’s security
mechanisms (e.g., kernel vs. application memory). knownasatrustedexecutionenvironment(TEE)(e.g.,ARM’s
TrustZone [2]). These new architectures permit the existence
In this paper, we introduce BOOMERANG, a class of vulner- of two separate worlds on the same system on a chip (SoC),
abilities that arises due to this semantic separation between the called the secure world (i.e., the world inside the TEE) and
TEEandtheuntrustedenvironment.Thesevulnerabilitiespermit thenon-secureworld (i.e.,thesandboxedworldcontainingthe
untrusted user-level applications to read and write any memory
main OS). Each of these worlds contains its own dedicated
locationintheuntrustedenvironment,includingsecurity-sensitive
OS and applications, and the software on the system is thus
kernel memory, by leveraging the TEE’s privileged position to
considered to be either trusted (i.e., in the secure world) or
perform the operations on its behalf. BOOMERANG can be used
untrusted (i.e., in the non-secure world). The TEE works by
to steal sensitive data from other applications, bypass security
checks, or even gain full control of the untrusted OS. facilitating the creation of a non-secure world for untrusted
software, which is completely isolated from any critical code
To quantify the extent of this vulnerability, we developed an within the secure world by hardware-enforced mechanisms.
automated framework for detecting BOOMERANG bugs within Thus,bydesign,thesecureworldnecessarilyhasaccesstoall
the TEEs of popular mobile phones. Using this framework, of the non-secure world’s memory.
we were able to confirm the existence of BOOMERANG on
four different TEE platforms, affecting hundreds of millions In practice, these two worlds frequently need to communi-
of devices on the market today. Moreover, we confirmed that, catewitheachother(e.g.,toencryptordecryptdatawithkeys
in at least two instances, BOOMERANG could be leveraged to stored inside the TEE). This communication is facilitated by
completely compromise the untrusted OS (i.e., Android). While the OSes in both worlds, which leverage specialized memory
theimplicationsofthesevulnerabilitiesaresevere,defensescanbe
regionsandcentralprocessingunit(CPU)registerstoestablish
quicklyimplementedbyvendors,andwearecurrentlyincontact
an application programming interface (API) for the exchange
with the affected TEE vendors to deploy adequate fixes. To this
of data. Moreover, most trusted OSes also permit the instal-
end, we evaluated the two most promising defense proposals
lation of trusted applications (TAs) to expand functionality,
and their inherent trade-offs. This analysis led the proposal of a
novel BOOMERANG defense, addressing the major shortcomings and offer services to the untrusted applications in the non-
oftheexistingdefenseswithminimalperformanceoverhead.Our secure world. In cases where larger volumes of data must be
findingshavebeenreportedtoandverifiedbythecorresponding processedinthesecureworld(e.g.,whensigningorencrypting
vendors, who are currently in the process of creating security bulk data), it is convenient to permit the secure world to read
patches. fromandwritetonon-secureworldmemorydirectly.Whilethe
secure world can protect itself from disclosing or overwriting
itsownmemoryspace,thereisnoinherentmechanismforthe
Permission to freely reproduce all or part of this paper for noncommercial secure world to guarantee the safety of operations on the non-
purposes is granted provided that copies bear this notice and the full citation
secure world’s memory. This lack of information, or semantic
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author gap, about the non-secure world from within the secure world
(for reproduction of an entire paper only), and the author’s employer if the places a great deal of responsibility on the untrusted OS to
paper was prepared within the scope of employment. sanitizeanyinputs,especiallypointers,thatarepassedintothe
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
secureworld.However,theAPIsanddataformatsforeachTA
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23227 tend to be application-specific, and are unknown to both theuntrusted and trusted OS. II. BACKGROUNDANDRELATEDWORK
A TEE is a separate execution environment for code
In this paper, we present BOOMERANG, a class of vulner-
and its associated data that requires a higher level of trust
abilities that stem from the semantic gap between the non-
than the typical operating system. TEEs can be implemented
secure and secure worlds. BOOMERANG is a type of confused
as either a physically separated environment (i.e., dedicated
deputy attack, wherein a user-level application in the non-
CPU and memory) or on the same SoC as the normal CPU
secure world can leverage a TA to read from or write to
with specialized hardware-isolation mechanisms (e.g., ARM’s
non-secure world memory that it does not own, including
TrustZone [2]). Because of this strict hardware isolation (e.g.,
the untrusted OS’s. More specifically, a malicious user-level
separate registers, memory, and peripheral access), the two
application can send inputs to the TA, which are not properly
execution environments are typically referred to as different
checked, that will trick the TA into manipulating memory
worlds: the secure world (i.e., the world within the TEE) and
locationsthatshouldotherwisebeinaccessibletothemalicious
thenon-secureworld.Becausethesoftwareinthesecureworld
application. BOOMERANG vulnerabilities can be used to steal
is assumed to have a higher level of trust than the software
or corrupt data in other user-level applications, or, in the
executing in the non-secure world, we refer to all software
worst case, to completely compromise the untrusted OS. We
in the secure world as trusted and the software in the non-
found exploitable BOOMERANG vulnerabilities in four TEE
secure as untrusted. Each world has its own OS, which we
implementations. These vulnerabilities were detected using
refer to as the untrusted and trusted OSes, and each OS runs
a combination of manual analysis and an automated static
its own respective accompanying applications, which we refer
analysis tool, which is capable of locating potential vectors
to as untrusted applications (UAs) and trusted applications
for exploiting BOOMERANG in a given TA. We were able
(TAs). Similar to traditional execution environments, both the
to leverage vulnerabilities in two commercial TEE implemen-
secure and non-secure worlds segregate the applications and
tations to create proof-of-concept exploits: an arbitrary non-
their OSes using different execution privileges (i.e., user and
secure world memory read and root-level privilege escalation.
supervisor mode).
These vulnerabilities, and our corresponding exploits, affect
hundredsofmillionsofdevicesthatarecurrentlyinproduction In TEE implementations where the secure and non-secure
today. worlds exist on the same SoC (e.g., TrustZone), the hardware
enforces isolation between the two worlds through the use of
TheseverityofBOOMERANGisevident,andwehavebeen specialized CPU registers and a non-secure (NS) bit. Specifi-
working with Google and the affected handset manufacturer cally, the NS bit is used to restrict access to memory and all
partners(e.g.,Qualcomm)toimplementadequatedefenses.We peripherals accessible on the Advanced eXtensible Interface
will present recommendations for future TEE designs, as well (AXI) bus. The context switching between the two worlds is
as immediate fixes for the already-deployed TEE infrastruc- handledbyaSecureMonitorthatisinstantiatedwhenasecure
ture.Tothisend,weevaluatedtheeffectivenessandthetrade- monitor call (SMC), or a special exception, is issued by either
offs of the two most promising defenses proposals: shared a privileged (supervisor mode) application in the non-secure
memoryandpagetableintrospection.Additionally,wepropose world or any secure world application. To share information,
a novel defense, called Cooperative Semantic Reconstruction the worlds can pass a limited amount of information using
(CSR), which addresses the functionality shortcomings of eitherregistersormemoryregions,whichcaneitherbedictated
existing defenses with minimal performance overhead in the by the secure world or passed by pointer reference.
general case. Our experiments suggest that CSR is the only
solution capable of providing the desired security guarantees, The principal idea of the TEE is to minimize the trusted
whilebalancingbothperformanceandease-of-implementation. computing base (TCB), in that the code running in the TEE
is intended to be a small, more easily verified subset of
In summary, our contributions1 are as follows: the overall system that is used for security-sensitive tasks.
However, in practice, there is a strong desire to have the
TEE offer rich functionality to the non-secure world (e.g.,
• We present BOOMERANG, a new class of vulnerabilities
digital rights management (DRM) [28], Trusted Input [3], or
that arises from the semantic gap present between TEE
authentication [23]). All of these applications require that a
and the untrusted OS.
communicationchannelbetweenthetwoworldsisestablished
• We developed a static analysis technique capable of
to share data over. This presents a major security risk to the
locating BOOMERANG vulnerabilities in TAs.
TEE, as it must accept input from the non-secure world and
• We evaluated the extent and severity of BOOMERANG by
itsuntrustedsoftware.Indeed,numerousTEEimplementations
examining the most popular TEE implementations and
have been exploited in practice [21], [25], [38], [43], which
their accompanying TAs.
resulted in a complete compromise of the secure world.
• We developed a proof-of-concept memory leak and
Consequently, there has been significant work to secure this
privilege-escalation exploit to verify the hypothesized
channel[19]andformalizetheAPIs[13]tothwartthesetypes
severity of BOOMERANG.
of attacks. Nevertheless, existing implementations still depend
• We evaluated the two existing BOOMERANG defenses,
on the non-secure world’s OS to sanitize any inputs before
and present CSR, a novel defense against BOOMERANG,
passingthemintothesecureworld,assanitizationinthesecure
whichoutperformstheotherproposalsinallofthemetrics
world is hindered by the semantic gap.
that we examined.
When the secure and non-secure worlds are on the same
1Wereleasedourproof-of-concepts,staticanalysistool,anddefenseimple- SoC, as in TrustZone, at boot, the processor will always
mentationathttps://github.com/ucsb-seclab/boomerang/ start in the secure world. The secure world software is then
2TEEDaemon UserApplication
Library
UserMode UserMode
DriverInterface(ioctl)
Rich OS
SupervisorMode SupervisorMode
ecafretnIEET
Non-secure World
TrustedApplication
TrustedOS
SecureMonitor
III. THEBOOMERANGVULNERABILITY
Secure World
BOOMERANG exploits the semantic gap inherent to the
design of all the current TEE implementations, where the
4 secure world and its associated TAs have the ability to read
and write to non-secure world memory. However, most TAs
have a legitimate need to interact with the non-secure world’s
1a 1b 1c 3 memory,andthisfunctionalityisroutinelyofferedasafeature
of the architecture. While the untrusted OS is able to protect
itself and its applications within the non-secure world, all
of these security mechanisms can be trivially bypassed from
2 withinthesecureworld.ThetrustedOShasnoinherentability
to determine the provenance or security properties of any
non-secure memory regions that are passed from untrusted
applications, due to the separation provided by the TrustZone
mechanism. More precisely, while the trusted OS can analyze
Fig. 1: High-level interactions when a user-level untrusted secure world pointer values to protect itself and other secure-
application exchanges data with a trusted application in a world applications, it has no insight into the memory permis-
TrustZone-enabled SoC. sionsofthenon-secureworld.Thus,whenaTAreceivesanon-
secure world memory address as a parameter to a command,
responsible for initializing the sandboxed, non-secure, world it has no choice but to blindly act on that memory.
and switching the process state to the non-secure mode. From
The untrusted OS is the most obvious place to implement
thenon-secureworld’sperspective,theexistenceofthesecure
a defense, as it is already enforcing the non-secure world
world is completely hidden, and the hardware architecture
security mechanisms, and, in fact, all current implementations
presents itself as if the system had just booted, without any
do employ some form of pointer sanitization (PTRSAN)
evidenceoftheunderlyingsecureworld.However,byvirtueof
functions when handling pointers. However, the trusted OSes
the architecture, the secure world always maintains complete
and their applications frequently define their own structures
control over and visibility into the non-secure world (similar
fortheexchangeofcommandsanddata,makingitimpractical
to a hypervisor and its guests). In fact, this feature has been
fortheuntrustedOStodeterminewhichvaluesinthedataare
utilized to implement a variety of interesting systems, such
pointersandneedtobesanitized.Thissemanticgapforcesthe
as: real-time kernel protection [4], transparent memory acqui-
untrusted OS to obliviously pass unknown data structures to
sition [52], kernel-code integrity checking [11], TZ-enforced
thesecureworldandsimilarlyforcesthesecureworldtoacton
Linux containers [42], and memory introspection [57].
non-securememorywithoutanyverificationofwhetherornot
Mobile phones have been one of the most prominent the untrusted OS has authorized those actions. Thus, in these
adopters of this technology, and almost every modern smart- scenarios, an untrusted application is able to issue requests to
phone comes equipped with a TrustZone-enabled Advanced the secure world for memory that it does not own, which the
RISC Machine (ARM) processor. However, despite efforts to secureworldwillmanipulate,permittingunauthorizedreading
enforce strict standards (e.g., GlobalPlatform [12]) on TEE and writing of another application’s memory, including the
interactions, most of the software running inside these TEEs untrusted OS’s kernel. Even when such pointer sanitizations
istypicallycustom-built,andthetrustedanduntrustedsoftware occur in the untrusted kernel, most of the PTRSAN functions
are commonly developed by completely disjoint entities. For are implemented incorrectly, making them easy to bypass,
example, on Android devices, while Google is responsible resulting in BOOMERANG vulnerabilities.
for the untrusted OS, the secure world OS is commonly We demonstrate this interaction graphically at a high level
developedbyotherpartieslikeQualcomm[37],Trustonic[53], in Figure 1 and briefly walk through a specific example in
Nvidia [34], and the open-source community [34], [51]. How- TrustZone; however, this general data flow holds for all TEE
ever, it does appear that Google may eventually deploy their implementations.Notethattherearethreedistinctsecurityand
own trusted OS, which they call Trusty [16]. semanticboundariesthatmustbeproperlyhandled:usermode
to supervisor mode in the non-secure world 1 , supervisor
The existence of BOOMERANG is fundamentally due to
mode in the non-secure world to supervisor mode in the
the desire to share memory between untrusted and trusted
secure world 2 , and supervisor mode to user mode in the
applications. The lack of well-defined, secure, standards and
secure world 3 . Since the SMC instruction, which is used
mechanisms for secure world applications to verify security
to change between the two worlds, is a protected call, the
propertiesofnon-securememoryaddressesresultsinscenarios
untrusted OS must either implement a long-running service
wherein untrusted applications can convince trusted applica-
that user applications can use as an arbiter to interact with the
tions to read or modify the contents of any physical memory
secure world 1a or expose an API to applications and permit
address within the non-secure world. These BOOMERANG
interaction with the TEE driver directly 1b (most vendors
flaws are specific instantiations of the confused deputy prob-
lem [6], [8], [9], [17], [40]. Nevertheless, BOOMERANG
provide a library in this case for convenience, shown as 1c).
presentsaparticularlydangerousmanifestationofthisproblem All TEE implementations rely on an agreed-upon standard
as it exploits a fundamental design choice in the security between the untrusted OS and the trusted OS for passing
architectureofTEEsthatcurrentlyaffectshundredsofmillions information 2 . However, as mentioned previously, there are
of devices. various trusted OSes in circulation and there is no global
3standard, as of yet, that has been agreed upon by these trusted
OS vendors. Thus, each trusted OS is accompanied by a spe-
cialized untrusted kernel driver for interacting with the secure
world, each driver using its own unique calling convention. TEEDaemon
What is worse, while the protocol for exchanging information PTRSAN
between the trusted OS and the trusted application 3 is well-
defined, the structure of this information is not standardized.
Therefore, most TA vendors are required to devise their own UserMode UserMode
unique data structures for sharing data between the untrusted
application and the trusted-world application 4 . Note that
whiletheuntrustedOScansanitizethememoryaddressofthe
structure,ithasnoinsightintoitscontentsunlesstheuntrusted
applicationexplicitlyprovidesit.Similarly,TAscurrentlyhave
no way of conferring with the untrusted OS to validate the
authenticity of memory pointers and they have no choice but SupervisorMode SupervisorMode
to assume that all pointers have been sanitized.
Because of the isolation between secure and non-secure
worlds, the virtual memory addresses that applications use are
incomparable as the worlds utilize separate page tables within
the memory management unit (MMU). Thus, any reference to
memory must be converted to a common entity before being
shared with the other world. While it is possible for both
worlds to simply use a common memory map, this has been
shown to be a major security risk, as it allows the non-secure
world to control the execution of secure world by using page
faults [5]. Therefore, in practice, this commonly agreed-upon
representationistypicallyeitheraphysicalmemoryaddressor
a shared identifier (e.g., a virtual address in the secure world),
which permits each world to access the particular memory
region without any insight into the other world’s memory
mapping. We refer to this translation of memory addresses,
andanyassociatedsecuritychecks,asPTRSANanddepictits
various implementations in Figure 2.
By virtue of the implementation, any data being passed
between the two worlds 2 must go through a PTRSAN
function, which will convert pointers to this common entity.
ThisPTRSANstepistypicallyimplementedwithinahardened
application 1a or within the kernel (1b and 1c) for two
reasons: 1) the specific pointer translation procedure should
be transparent to the user application, which increases the
modularity of the code; and 2) the PTRSAN function can
perform the appropriate security checks to verify that the
pointer indeed belongs to the corresponding application and is
safe for applications in the secure world to access. PTRSAN
is intended to protect both the untrusted kernel and other
untrusted applications from a malicious application. However,
amongst the data being handled by PTRSAN, there is TA-
specific data, which the PTRSAN application has no insight
into. Any pointers within these TA-specific data structures
mustbeexplicitlyannotatedsothatthePTRSANcantranslate
them appropriately. Herein lies the problem, and the core flaw
being exploited by BOOMERANG. Specifically, the PTRSAN
function has no insight into the protocol agreed upon between
user application and the trusted application 4 , and thus it is
possiblefortheuserapplicationtopasspointersdirectly,which
evade the PTRSAN security checks. This critical semantic
gap is fundamentally what makes it so difficult to prevent
BOOMERANG attacks in practice.
To demonstrate how memory addresses can evade sani-
tization in practice, we will briefly walk through an example
RTP RTP RTP
UserApplication
RTP RTP RTP RTP
Non-secure World
Data Data
RichOS
PTRSAN
RTP RTP RTP RTP RTP RTP
TrustedOS
RTP RTP RTP
TrustedApplication
RTP RTP RTP RTP
Secure World
4 Data Data
1a 1b 1c 3
2
2
RTP NormalPointer RTP MaliciousPointer RTP SanitizedPointer UnkownData
Fig. 2: An example of BOOMERANG, where a malicious
memorypointerishiddenfrompointersanitization,ultimately
tricking a TA to act on that memory address.
fromFigure2.Notethat 4 istheboundarythatthedatamust
ultimatelycross;however,thearchitecturedoesnotpermitthis
particular interaction directly. So, the application prepares a
datapacketdestinedfortheTAinmemory,usingadatastruc-
ture that was specified by corresponding TA. When the user
application needs to share a large amount of variable length
data with the trusted application (e.g., encrypted content), it is
desirable to permit the TA to act on this data in place (versus
copying it into a separate memory region). The pointer to the
data to be manipulated is annotated using the specific API
for the TEE, and the PTRSAN function handles the pointer
appropriately. However, in most cases, this annotation can be
trivially omitted, permitting the user application to control
the pointer value that the trusted application will receive. For
example,whenphysicalmemoryisusedasthecommonentity
betweenthetwoworlds,theuserapplicationcouldpassaphys-
icaladdressintheTA-specificdatastructurewithoutreporting
this information to PTRSAN (i.e., a malicious pointer). The
TAhasnowayofvalidatingthesepointers,duetothesemantic
gap,andthushasnochoicebuttoperformtherequestedaction
resulting in a BOOMERANG vulnerability.
To the best of our knowledge, BOOMERANG was previ-
ously completely unknown. In fact, the most related security
issue that was mentioned in the documentation [12] was a
time-of-checkvs.time-of-usebugthatexistsinTEEs,wherein
the contents of non-secure memory may be changed while
the TEE is operating on the buffer. This limitation could lead
to situations where the data could be changed in malicious
waystoexhibitunintendedbehaviororpermituntrustedworld
applications to access each other’s data if the shared memory
regionisgloballyreadable.AsweshowinSectionVII-C,our
proposed defense, CSR, can be trivially augmented to address
this security concern as well.
It is worth noting that there is already a mechanism in
placeforqueryingthenon-secureworldfromTAs.Inaneffort
to decrease the TCB within the secure world, any high-level
operations (e.g., file operations, networking) that the secure
world needs to exercise are typically handled by the non-
secure world on behalf of the secure world. In practice, each
trusted OS is accompanied by a user space service (i.e., a
4TEE daemon) that is capable of handling these requests. In 1)Untrusted Application and Untrusted OS: QSEE ex-
some cases, this same daemon is also utilized as the arbiter poses a kernel driver /dev/qseecom to untrusted applica-
between untrusted applications and the untrusted kernel driver tions (1b and 1c in Figure 2). Interactions with this device
(1c inFigure1).WeshowinSectionVII-C,howwewereable are carried out using the ioctl system call with various
to leverage this mechanism (i.e., the trusted world requesting commands, which untrusted applications can use to interact
information from the untrusted world) to reconstruct the non- withthesecureworld.Qualcommalsoprovidesauser-spaceli-
secure world semantics and prevent BOOMERANG. brarylibQSEEComAPI.so,whichconvenientlyexposesthe
different ioctl commands as functions. Data is exchanged
between untrusted and trusted applications using a specialized
IV. BOOMERANG:THREATMODEL data structure (Figure 3). This data structure is then passed
through a PTRSAN function to resolve any pointers to non-
This work focuses primarily on TrustZone-enabled mo- secure world memory regions. In QSEE, physical memory
bile devices running Android, and thus our threat model addresses are used as the common entity between worlds,
is described in terms of the Android ecosystem for clarity; and the pointer translation from virtual to physical occurs
however, the same concepts are generally applicable. Android directly in the provided kernel driver (1b and 1c in Figure 2).
was chosen because of the variety of TEE implementations Sending commands to a TA happens in multiple steps, which
that exist on Android devices, and the sheer number of are described hereinafter.
devices that could potentially be implicated. Nevertheless, we
First, the untrusted application requests the allocation of a
note that BOOMERANG bugs are likely to exist in any TEE
shared memory region using a separate shared memory driver
implementation where the secure world can access non-secure
/dev/ion [1]. This region will be used for both requests
world memory.
and responses. The shared memory driver returns a shared
In the case of Android and TrustZone, we assume that an memory identifier (i.e., shmid), an opaque identifier that is
attacker can convince a user to install an app on her phone. usedtorefertothismemoryregion,independentofitslocation.
We also assume that this app has the ability to interact, using This identifier can then be used to map (i.e., using mmap)
proper system calls, with TEE applications. Depending on the the allocated memory into the untrusted application’s memory
implementation,thisrequireseithernopermissionsorasingle space.Thesharedmemoryregionisthensplitintotwobuffers,
permission to interact with a specific TEE application (e.g., one for sending data into the trusted world (i.e., send_buf)
the ACCESS_DRM permission to access the DRM application and one for the response (i.e., resp_buf).
in the trusted world). No root or system permissions are
Second, the application prepares the command to be ex-
required for the attacker application in the untrusted world.
ecuted, and stores it in send_buf (see Figure 3). Pointers
stored directly in the driver interface structure will always be
The presented attacks do not leverage arbitrary code exe-
validated and translated by the pointer translation function.
cution bugs in any secure world application nor in the trusted
However, the untrusted application can also pass pointers
kernel.Forthisreason,inthecontextofthispaper,weassume
within the body of the request itself that was previously
that the attacker cannot execute arbitrary code inside the
allocatedusing/dev/ion(i.e.,withinthesend_bufdata).
TEE. In fact, the attacker’s goal is not to compromise TEE
Since the request body is application-specific, these point-
computation, but it is to convince the code running within
ers cannot automatically be located or translated. To en-
the TEE to read and write non-secure world memory at the
able this, the application can supply a replacement vector
attacker’s will. In this way, the attacker is able to thwart
(i.e., QSEECom_io_fd_info), which is a list of offsets in
security mechanisms of the untrusted OS, and, for instance,
send_buf that should contain the pointers together with the
raise the privileges of the controlled malicious app to root.
corresponding shmids that should be translated and placed
there. The final command sent will contain the physical ad-
dressesforeachsharedmemoryregioninthedesiredlocations.
V. BOOMERANGONREALWORLDDEVICES
Third, the application either performs an ioctl
While BOOMERANG, in general, is applicable across all
directly on the /dev/qseecom device with the
TEE implementations, it is useful to examine various flavors
QSEECOM_IOCTL_SEND_MODFD_CMD_REQ command,
thatappearinreal-worldimplementations.Tothisend,wehave
or uses the QSEECom_send_modified_cmd command
examined the most popular TEE implementations to verify
provided by the libQSEEComAPI.so library to trigger the
the existence of BOOMERANG. In this section, we describe
execution of the command. This causes QSEECOM to copy
the architecture of each of the examined implementations,
the request buffer into a temporary buffer, and optionally
highlighting how their specific design choices affect their
perform pointer translation.
susceptibility to BOOMERANG.
2)Untrusted OS and Trusted OS: The untrusted OS and
trusted OS interact using Qualcomm’s secure channel manger
A. Qualcomm Secure Execution Environment (QSEE) (SCM), which defines a set of functions that prepare and
execute SMC calls with the provided data. All SMC calls are
Recent studies indicate that around 60% of all Android made with four parameters (i.e., send buf, sbuf len, resp buf,
phones in production are running Qualcomm’s QSEE [24], rbuf len), where send_buf and resp_buf are the buffers
makingitanexceptionallyhigh-impactimplementation,asany passed by the application. All of these parameters are packed
vulnerabilities could potentially lead to a complete compro- into an scm_command structure, and the physical address of
mise of these devices [25]. the packed structure is passed as an argument [36].
5to craft an arbitrary physical memory read exploit.
TEE Driver Interface unsigned char *ion_sbuffer
struct QSEECom_handle *handle While both QSEECom_send_modified_cmd
void *send_buf TA-specific Semantics and QSEECom_send_cmd are provided in the
uint32_t sbuf_len TA Input libQSEECom.so library, where additional checks could
void *resp_buf void *pointer be implemented, it would still be possible to perform the
uint32_t rbuf_len ??? same un-sanitized operations on the kernel driver directly.
struct QSEECom_ion_fd_info *ifd_data void *pointer Therefore, any fool-proof solution will require at least some
??? coordination with the secure world to ensure that it cannot be
PTRSAN void *pointer easily bypassed, such as the ones we examine in Section VII.
???
int32_t fd
uint32_t cmd_buf_offset; void *pointer B. Trustonic
int32_t fd TA Output Trustonic[53]isanotherverypopularvendorofTrustZone-
uint32_t cmd_buf_offset;
??? based TEE technology. Their TEE implementation is widely
int32_t fd
deployed across consumer hardware (over 400 million de-
uint32_t cmd_buf_offset;
vices[7]),withSamsungleveragingitaspartofitsKnox[41]
int32_t fd QSEECom_send_cmd
uint32_t cmd_buf_offset; QSEECom_send_modified_cmd platform. Trustonic encrypts and signs all of their trusted
applications and their trusted OS kernel, which makes it more
challenging to audit their functionality, although recent efforts
Fig. 3: The data structure used to communicate with the TEE
have made headway in recovering the decrypted code [14].
in QSEE [15].
1)Untrusted Application and Untrusted OS: Trustonic
3)Trusted OS and Trusted Application: TAs are executed
employs a kernel driver /dev/mobicore, similar to QSEE,
as user mode applications within the trusted world, with no
andaservicemcDaemon,whichuserapplicationsmust useto
access to any other secure world memory (e.g., other TAs or
communicate with the secure world. Due to its permissions,
the trusted OS). Consequently, TAs must issue system calls to
unprivileged user applications cannot communicate with the
the trusted OS kernel for any privileged tasks that they need
driver /dev/mobicore directly, as was possible in the case
to perform. For example, to access non-secure memory (i.e., a
of QSEE. In Trustonic’s implementation, communication with
physical address passed from the untrusted world), they must
the secure world must go through the mcDaemon service
utilize the qsee_register_shared_buffer() syscall.
using a write-and-notify mechanism known as world-shared
In this call, the trusted OS validates that the request mem-
memory (WSM). This communication is initiated when an
ory region is not inside the secure world (e.g., within the
untrustedapplicationregistersabuffer,calledasessionbuffer,
trusted OS), to protect itself from the untrusted world. If
with a TA to open a new session. Commands intended for
the physical memory address is indeed within the non-secure
the TA are then sent by writing data into the session buffer,
world’s memory, the kernel will map the requested physi-
and issuing a notify command through mcDaemon. Once the
cal memory region into the TA’s memory space. Note that
data is passed to the secure world, the trusted OS will then
qsee_register_shared_buffer() only verifies that
notify the TA that the contents are ready. Similarly, to receive
the memory is not in the secure world; it cannot verify that
responses, untrusted applications wait for a notification from
this physical address indeed belongs to the untrusted world
the TA (through mcDaemon).
application that initiated this request [25].
In the Trustonic implementation, opaque identifiers are
4)BOOMERANG on QSEE: As discussed
used instead of memory locations (i.e., physical memory
above, the untrusted application makes use of the
pointers). By examining the source of mcDaemon [56], we
QSEECom_send_modified_buffer function, which
confirmed that the opaque id is actually a virtual address that
updates the send_buf with physical addresses before
has been mapped into the memory space of the TA, within
sending it to the TA using the provided replacement vector
the secure world. If an untrusted application wants to share
(i.e., QSEECom_io_fd_info). However, this puts the
some memory with a TA, it must register the buffer using the
onus on the untrusted application to supply the necessary
processMapBulkBuf function in the mcDaemon service,
information for the appropriate pointer translation to occur.
which maps the corresponding physical memory region into
A malicious application that wishes to pass arbitrary
the TA’s memory space and returns an opaque identifier back
physical memory addresses could simply insert them into
to the untrusted application. processMapBulkBuf also
send_buf in the proper locations for the victim TA, and
verifies that the pointer being converted is indeed owned by
exclude them from the replacement vector. Alternatively, the
the requesting application, which thwarts the trivial instance
malicious application could simply utilize the un-sanitized
of BOOMERANG. From this point on, the only method for
QSEECom_send_cmdcommand,whichwillsendcommands
the untrusted application to interact with that shared memory
to the TA without any pointer translation (see Figure 3). The
region is using this opaque identifier and the mcDaemon
trusted OS only checks to confirm that these physical pointers
service (i.e., the untrusted application has no direct control
are not mapped into the secure world. Thus, any malicious
over the pointers that the TA will receive and operate on).
physical address placed within the send_buf buffer, and
kept hidden from PTRSAN, will be blindly acted upon by 2)Untrusted OS and Trusted OS: The interaction between
the TA (e.g., decrypted, copied, encoded), resulting in a the untrusted OS and the trusted OS is performed using the
BOOMERANG vulnerability. We show in Section VI-B how standardSMCTrustZoneinstruction.UnlikeQSEE,wherethe
we were able to leverage actual BOOMERANG vulnerabilities physical address of a packed structure is passed to the trusted
6Non-secure World
void processMapBulkBuf(Connection ∗connection) { Physical Memory
... Untrusted Application
// Trustonic’s PTRSAN function
User Mode
uint64 t pAddrL2 = device−>findWsmL2(cmd.handle ,
connection−>socketDescriptor); optee_to_msg_param Non-secure Memory
... struct tee_param *params
// Map bulk memory to secure world
size_t num_params
// BOOMERANG if the attacker can control pAddrL2
const struct optee_msg_param *msg_params
mcResult t mcResult = device−>mapBulk(connection ,
Supervisor Mode
cmd.sessionId , cmd.handle , pAddrL2, common-memory
Secure World
cmd.offsetPayload , cmd.lenBulkMem,
&secureVirtualAdr); tee_ta_verify_param
...
struct tee_ta_session *sess
if (mcResult != MCDRVOK) {
struct tee_ta_param *param
writeResult(connection , mcResult);
Supervisor Mode
return; Secure Memory
}
mcDrvRspMapBulkMem t rsp; Trusted Application
rsp.header.responseId = MCDRVOK; User Mode
rsp.payload.sessionId = cmd.sessionId;
rsp.payload.secureVirtualAdr = secureVirtualAdr; Fig. 5: Outline of interactions with the TEE in OP-TEE’s
connection−>writeData(&rsp , implementation using common-memory. [27], [35]
sizeof(mcDrvRspMapBulkMem t));
}
TAs. While OP-TEE has not yet been deployed on consumer
hardware, it was valuable for our research, as it provided us
Fig. 4: Code snippet from Trustonic’s MobiCore daemon that
with an implementation into which we had complete visibility
exhibits a potential BOOMERANG flaw [55].
and a platform for evaluating our defenses.
OS, Trustonic’s implementation explicitly passes parameters
1)Untrusted Application and Untrusted OS: Similar to
using values stored in registers (current implementations only
other implementations, the untrusted OS exposes a driver
support up to four unique parameters [54]). /dev/tee0 [47], which can be used by applications to
3)Trusted OS and Trusted Application: Given that the interact with the TAs. A client library libteec.so [49] is
secure world binaries are encrypted, we were not able to alsoprovidedtomakeiteasierforapplicationstocommunicate
completely reverse-engineer the interaction between TAs and with this driver. All parameters that are passed to the TA are
the trusted OS. However, based on our experience with other strongly typed. There are two broad types: a pointer type and
implementations,weassumethatitfollowsasimilarstructure, avaluetype(eitherofwhichcanbeinputtoaTA,outputfrom
where TAs in the trusted world run as normal user-space aTA,orboth).Everycalltothesecureworldcanonlysupport
applications, with no access to the trusted OS’s memory. uptofourparameters,whichmustconformtothestricttyping.
Similarly, all privileged tasks from TAs are likely handled
Untrusted applications again use opaque pointers (i.e.,
by system calls to the trusted OS. We hypothesize that they
shmids)torefertomemorythatisintendedtobesharedwith
also implement some checks on the pointers (i.e., opaque
a TA. To pass a pointer argument, the untrusted application
ids, virtual addresses) passed by the untrusted applications to
communicates with /dev/tee0 to request memory of a
validate that they indeed belong to the non-secure world, but
specificlength.Thekerneldriverthenallocatesthismemoryin
currently we have no way to confirm this.
a dedicated shared memory region (i.e., common-memory),
4)BOOMERANG on Trustonic: Although there is no ex- pairs it with a shmid, and returns it to the client. Untrusted
plicit PTRSAN mechanism in Trustonic’s implementation, the applicationscanusethisshmidtomapthememoryintotheir
use of opaque identifiers by mcDaemon for shared memory address space, where they can then write commands to and
inherently ensures that an untrusted user application does not read responses from the TA. This shared memory region is
have control over the resulting pointers. Figure 4 shows the accessiblebyboththenon-secureandsecureworlds.However,
exactcodethatisenforcingthiswithinthemcDaemonservice. becauseitisadedicatedmemoryregion,itgreatlyreducesthe
Note that this construction inherently makes the assumption risk of BOOMERANG vulnerabilities.
that all shared memory requests come from mcDaemon, and
that this daemon is not compromised. However, if an attacker 2)Untrusted OS and Trusted OS: Upon receiving a com-
wereabletogainaccessto/dev/mobicore,orcompromise mand from the untrusted application, the untrusted OS will
mcDaemon, pAddrL2 (in Listing 4) could be replaced with first perform the required pointer translations (i.e., PTRSAN).
an arbitrary non-secure world physical memory (just as in
Next,itpacksalloftheparametersintoanoptee_msg_arg
QSEE) resulting in a BOOMERANG vulnerability. We have
structureandcopiesitintoafreeregionincommon-memory.
confirmedthisissuewithTrustonic,andareworkingwiththem Lastly, it performs a world-switch using the SMC instruc-
toward an improved design for future releases. tion [48], with the physical address of this region as its
argument.
C. Open Source Trusted Execution Environment (OP-TEE)
3)Trusted OS and Trusted Application: TAs in OP-TEE
OP-TEE [33] is an open source TEE implementation, run as unprivileged applications within the secure world, each
which can run on a selection of hardware development plat- running in its own thread, which are only spawned when a
forms. OP-TEE adheres to the GlobalPlatform [13] specifi- request is issued from the non-secure world. All privileged
cation and provides libraries that ease the development of operationsmust,again,beperformedthroughsystemcallsinto
7the trusted OS (i.e., supervisor call (SVC) instructions). For PTRSAN by first checking that the corresponding address is
each memory parameter passed to a TA from the non-secure indeedintherequestingapplication’smemorybeforereplacing
world, the physical address is first checked to ensure that is the address with the corresponding physical address, incre-
contained within the common-memory region, and that this mented by the provided offset.
memory region is mapped to the thread that is handling the
2)Untrusted OS and Trusted OS: The interactions be-
request. More precisely, the trusted OS will take the physical
tween the untrusted world OS and the trusted world OS
address that was passed as a parameter and update it with
are, again, done using the standard SMC instruction. All
a corresponding virtual address within the memory space of
parameters to be passed are packed into a common structure
the handling thread (i.e., TA). Thus when the TA accesses
(TC_NS_SMC_CMD),andthephysicaladdressofthisstructure
any pointer arguments, it can access them as normal pointers
is passed as the argument to the SMC call (similar to QSEE).
(i.e., without any additional verification calls). However, the
TA must strictly ensure that the types of all of the arguments 3)Trusted OS and Trusted Application: As with other
areasexpected,orelsetype-confusionattackscouldbeutilized trusted world implementations, each TA runs in an isolated
to exploit the TA or trusted kernel. For example, if a memory process and interacts with the trusted OS through system calls
pointer could be disguised as a value, bypassing PTRSAN, (using SVC instructions). However, in this instance, the entire
memory regions outside of the shared memory region could non-secure world memory space is mapped into every TA,
be passed to a TA, which would result in a BOOMERANG which makes exploiting BOOMERANG vulnerabilities trivial.
vulnerability. This process is shown in Figure 5.
4)BOOMERANG on Huawei: BOOMERANG exists on this
4)BOOMERANG on OP-TEE: Although the use of implementation for a few reasons. First, PTRSAN fails to
common-memory prevents all TAs from accessing the un- validate the offset value; a malicious untrusted application
trusted OS’s memory, the shared memory ids (shmids) as- can use this to pass an arbitrary physical address to the TA.
signed to the different untrusted applications are stored in a Second, almost all the TAs we examined do not validate
global structure. This allows a malicious untrusted applica- the types of parameters, allowing one to bypass PTRSAN
tion to read and write the corresponding common-memory entirely, by misrepresenting the type of an argument to the
assigned to another untrusted application resulting in kernel driver as a non-pointer, while still being correctly
BOOMERANG vulnerabilities [31], [32]. As described above, interpreted as a pointer by the TA. Type-confusion attacks
common-memory provides a shared memory communica- within the TA are cumbersome to avoid, as each function that
tion channel between untrusted applications and TAs, and, handles the parameter must independently verify that the type
dependingontheTA,thismemoryregioncancontainsensitive of the argument is correct, since the parent function has no
information(e.g.,DRMdecryptedcontent,passwords,orcryp- insightintotheultimateuseofeachparameter.Wefoundboth
tographic keying material). Moreover, we also found a heap instances of BOOMERANG (i.e., PTRSAN bypass and type-
overflow [29] and an out-of-bounds read [30] in the PTRSAN confusion)indifferentcomponentswithinthisimplementation,
functionoftheuntrustedkerneldriver.TheOP-TEEdevelopers as we show in Section VI-A.
responded promptly, fixing all of these issues; however, these
various bugs demonstrate just how difficult a shared memory
E. Sierraware Trusted Execution Environment (SierraTEE)
management implementation can be to deploy in practice.
While shared memory regions can be used to defend against SierraTEE is a Trusted Execution Environment devel-
generalBOOMERANGvulnerabilities,theypresentasignificant oped by Sierraware [46]. They published an open source
degree of complexity and subtlety that must be overcome. version of their implementation under the Open Virtualiza-
There are also other technical limitations introduced with this tion project [45]. Similar to OP-TEE, this adheres to the
approach (e.g., performance, limited parameters), which we GlobalPlatform specification [13] and provides libraries to
discuss in detail in Section VI. supportdevelopment.AlthoughSierraTEEisusedinacademic
projects [39], we were unable to determine whether it is used
in any commercial device.
D. Huawei
1)Untrusted Application and Untrusted OS: Simi-
We analyzed the TrustZone implementation from Huawei,
lar to OP-TEE, SierraTEE employs a kernel driver
with tens of millions of devices in circulation.
/dev/otz_client and a client library libotzapi.so
1)Untrusted Application and Untrusted OS: This TEE foreaseofdevelopment.Applicationscaneitherusethedriver
implementation, like Trustonic, employs a kernel driver or library to interact with the TAs. Similar to OP-TEE, all
/dev/tc_ns_client and a service teecd, which all parameters to the TA are strongly typed, with three possible
user-space applications must use to communicate with the types: pointer, 32-bit value, or array. To pass a pointer,
secure world. The permissions are similarly set such that untrusted applications should first use mmap on the driver
untrusteduserapplicationscannotcommunicatewiththedriver to allocate memory of the required size. The kernel driver
directly.SimilartoOP-TEE,allparametersinthesecure-world thenallocatesthememoryandassociatesitwiththerequested
interface are one of two broad types: pointers and values, and address (i.e., usr_addr), which can be used by the corre-
all calls to secure world support up to four parameters, which spondingapplicationasasharedmemoryid(shmid).Similar
can take either of those types. toHuawei,apointerargumentispassedasatupleof(shmid,
length, offset).
However, in this instance, untrusted applications can di-
rectly pass an address with an offset as a pointer argument 2)Untrusted OS and Trusted OS: First, PTRSAN is per-
in their commands. The kernel driver attempts to perform formedonallthepointerargumentsbycomputingthephysical
8TABLE I: Summary of the various manifestations of
VI. FINDINGBOOMERANGVULNERABILITIES
BOOMERANG across the various TEE implementations.
To evaluate the severity of BOOMERANG, we explored
CommonEntity
Vendor PhysicalAddress SharedMemory UniqueIdentifier twoverypopularcommerciallyavailableTEEimplementations
QSEE BPtr (i.e., QSEE and Huawei) to see if exploitable BOOMERANG
Trustonic B∗ Ptr flaws existed in deployed TAs. We were unable to perform
OP-TEE bPtr
our analysis on Trustonic’s implementation because all of
Huawei BPtr,BType
SierraTEE BPtr their TAs are encrypted. Similarly, we did not evaluate any
TAs developed for the OP-TEE and SierraTEE architectures,
B-FullBOOMERANG(arbitrarynon-securememoryaccess)
B∗-FullBOOMERANG,butrequiresanadditionalexploit as they have not been deployed on any commercial devices.
b-PartialBOOMERANG(accesstospecificregionsofnon-securememory) We, indeed, found the BOOMERANG vulnerabilities in all of
Ptr -PTRSANbypassvectorpresent Type-Type-confusionvectorpresent the evaluated TAs that accepted pointers from the non-secure
world, some of which we used to craft exploits.
address corresponding to the provided shmid. The resulting
physicaladdressanditscorrespondinglengtharepackedas
A. Detecting Potential Vulnerabilities
the new pointer argument. Next, all the arguments are packed
into an otz_smc_cmd structure, and the physical address of As we showed in Section V, all of the TrustZone im-
thisstructureispassedastheargumenttotheSMCinstruction, plementations that we analyzed will, at some point, pass
and therefore to the trusted OS. commands from the untrusted application to the TA through
theuntrustedOSandthetrustedOS.Thisdatausuallycontains
3)Trusted OS and Trusted Application: Similar to anapplication-dependentstructure,and,inmaliciousinstances,
OP-TEE, each TA runs as an unprivileged application within its contents may contain un-sanitized memory pointers. Thus,
thesecureworld,initsownthread.Privilegedoperationsmust the general approach to our detection technique is to perform
beperformedthroughsystemcalls(SVCinstructions),andare data-flow analysis to track all of the data that is passed from
handled by the trusted OS. All parameters from the untrusted the non-secure world, and annotate any functions that use any
OS and applications are directly passed to the destination TA. portionofthisdataasapointer.Bycapturinganyfunctionthat
As mentioned above, these take the form of physical memory dereferences non-secure data as a pointer, an analyst could
addresses and region lengths, which must be mapped by the then trivially use manual analysis to see if that data can be
TA prior to use. controlled by an untrusted application in a way that bypasses
PTRSAN,whichwouldresultinaBOOMERANGvulnerability.
4)BOOMERANG on SierraTEE: Similar to Huawei,
We created a static analysis technique to locate these
PTRSAN in SierraTEE fails to validate the offset for
instances using simulated execution, which we implemented
pointer arguments. This allows a malicious untrusted appli-
using the angr [44] static analysis and reverse-engineering
cation to pass an arbitrary physical address to the TA leading
framework.Ouranalysisworksinthefollowingway:First,we
to a BOOMERANG vulnerability. Furthermore, we noticed that
analyze the control flow graph and perform function recovery
PTRSAN also fails to verify the length parameter, which
onagivenTA,whichidentifiesfunctionentrypointsbasedon
increases the exploitability of this flaw.
standard ARM calling conventions. This step requires that the
We notified Sierraware of our findings on multiple oc- binary is not obfuscated (e.g., encrypted or packed). Next, we
casions, beginning in October 2016, and received no reply. locate the source of any input data, by locating the primary
We suggest that the users of the open source version of the commanddispatcher oftheTA.ThisfunctionisTEE-specific,
SierraTEE be aware of this issue, and contact Sierraware to but can be found easily through reverse engineering (e.g.,
obtain an appropriate fix. identifying entry points in the program or using symbols) and
is applicable to every TA for that TEE implementation. In
QSEE’s implementation, we referenced prior work to locate
the command dispatcher [25], which accepts 4 arguments,
F. Observed Instances of BOOMERANG
consisting of the input and output buffers and their sizes
(i.e., send_buf, send_len, resp_buf, resp_len). On
In summary, we have observed two distinct instances of
Huawei, we were able to locate the symbol referring to the
BOOMERANG in practice: PTRSAN bypass attacks, where
command dispatcher, which takes a list of inputs, and a list of
the pointer sanitization function can be bypassed altogether,
the associated data types for each argument.
and type-confusion attacks, where TAs can be tricked into
treating a non-pointer value as a pointer. This general flaw Once the command dispatcher function is located, we then
(i.e., the secure world’s ability to freely influence non-secure perform data-flow analysis (similar to static taint tracking) on
memory) exists on each system, regardless of the common the data in the input buffers to detect any instances where any
entity used for passing memory references between worlds. partoftheinputisusedasapointer.Thispointerdereferencing
Table I demonstrates how the various bugs affect the vendors may be done explicitly in the code itself, but could also be
that we examined. It is worth noting that every analyzed TEE delegated to system calls within the trusted OS. Since the
implementation is affected by BOOMERANG to some degree. semantics of system calls are TEE-specific, we require that an
The table only outlines the bugs that we personally were able analystannotatesthosecallsthathandlethereadingorwriting
to verify; however, we have reasons to believe Trustonic also to non-secure memory for each TEE (e.g., cryptographic
likely contains a pointer-confusion attack, but we are unable operations or secure file-system operations). With the given
to verify this hypothesis without access to the un-encrypted system calls identified, our data-flow analysis can detect and
TAs. return relevant paths in the TA.
9request_buffer
(from untrusted world)
COMMAND_HANDLER1(command_data) read_syscall( address,
length,
COMMAND_DISPATCHER(request_buffer) read_syscall((void*)command_data->field1, length, output); output);
command_code = request_buffer->field1;
command_data = (void*) request_buffer->field2; COMMAND_HANDLER2(command_data) write_syscall( address,
length,
switch(command_code){ write_syscall((void*)command_data->field1, length, content); content);
case ‘1’:
COMMAND_HANDLER1(command_data); COMMAND_HANDLER3(command_data)
break;
case ‘2’: address = (int*)command_data->field1;
COMMAND_HANDLER2(command_data);
break; output_data = *address; Source
case ‘3’:
COMMAND_HANDLER3(command_data);
break; COMMAND_HANDLER4(command_data) Sink
case ‘4’:
COMMAND_HANDLER4(command_data); address = (int*)command_data->field1;
break; Attacker
} *address = data; Controlled
Fig. 6: Examples of the different types of data flows that our tool would detect as being vulnerable to BOOMERANG.
Our analysis starts with the input buffers or argument lists TAs described above, we found that all of them were vul-
as a source and performs a blanket execution [10] of the nerable to BOOMERANG attacks. KeyMaster contained three
program,whereallofthebasicblocksinthecontrol-flowgraph separatecall-chainsthatpermitanuntrustedapplicationtoread
(CFG) are executed, until the data from the source reaches a arbitrary physical memory from within the non-secure world,
sink (i.e.,anannotatedsystemcallormemoryoperation).TAs using functionality within the TA. Similarly, WideVine and
usuallycontainsmanypossiblecommands,selectablebyaTA- PlayReady both contained call-chains that permit an unprivi-
specific command identifier included as part of the request, legedapplicationtodecryptdatatoarbitraryphysicalmemory
which is typically checked by the TA at the beginning of within the non-secure world, which could be leveraged for an
execution. We can therefore locate a unique “handler” for arbitrary physical memory write.
the different commands (i.e., cases in the main switch-case
statement of the command dispatcher), by analyzing all of the 1)Proof-of-Concept (Memory Read): We were able to
callsitesinthecommanddispatcherfunction.Thisinformation easily leverage one of the three call chains located in QSEE’s
isusefulwhendeterminingexploitability,asithelpstoidentify KeyMaster to craft a proof-of-concept arbitrary memory leak
the major functionality of the TA that is exercised with the exploit. Figure 7 shows a graphical representation of the
identifiedvulnerability.Ourtoolwillproduceasoutputthecall discovered path, including the addresses of each function
chain from the input to the memory operation or system call, call instruction between the input and a controllable memory
and whether the final operation is a read or a write. Figure 6 operation, as well as the type of memory operation (e.g.,
provides a high-level overview of our technique. “read,” “write,” or in this case, “syscall”). The tool also
indicates the vulnerable “handler,” which is the start address
of the first unique function seen among the set of all the call
B. Vulnerabilities in QSEE
chains.
While hundreds of millions of devices use QSEE as their
In this case, the call chain terminates in QSEE system
TEE implementation, only a few TAs are actually widely
call number 0x06, which was identified as the system call
distributedfortheplatform.Wewereabletoobtainthebinaries
that prepares for memory read operations from the non-
for KeyMaster, WideVine, and PlayReady, which to the best
secure world. Using manual analysis, we were easily able to
ofknowledgearetheonly3QSEETAsthatacceptuserinput.
determine the purpose of the handler function on our chosen
KeyMaster is the standard cryptographic application that is
path, at 0x5ac, which generates cryptographic signatures of
included on all Android-based devices with a TEE. WideVine
data from the non-secure world. While the returned value
isaGoogle-ownedDRMtechnology,usedmostprominentlyin
is signed, the attacker can select the key, cipher, data, and
the Netflix and YouTube applications. PlayReady is a similar
datalength.Torecovertheoriginalnon-secureworlddata,the
DRMtechnologyprovidedbyMicrosoft,whichprovidesDRM
signatureisperformedonasinglebyte,withaknownkey,and
support for Windows Media files, amongst others.
the result checked against a pre-computed table of signatures
After running our static analysis technique on the three forallof256possiblevaluesofabytewiththatkey.Tocontrol
the data that is to be signed, we can bypass PTRSAN in the
non-secure world using QSEECom_send_cmd (as shown in
USER INPUT 0x3c6b: COMMAND DISPATCHER
Figure 3). The resulting exploit allows a malicious untrusted
application, in the non-secure world, to read any amount of
0x37aa: COMMAND HANDLER
(import_key_pair command) memory from an arbitrary location in the non-secure world,
including memory of all other applications and the kernel.
0x4a02: SYSCALL WRAPPER 1
0x6e80: SYSCALL
(prepare_read_buffer)
We disclosed this vulnerability, and proof-of-concept, to
Fig. 7: One of the three outputs of our data-flow analysis Qualcomm and Google in June 2016, and received the des-
described in Section VI-A for the KeyMaster TA on QSEE. ignation CVE-2016-5349. We are actively working with both
10companies on a fix and, as of December 2016, this critical A. Page Table Introspection
patch is still in development. Our tool also identified memory
An obvious and simple method capable of defending
writefunctionalityintheWideVineTA,whichcould,intheory,
against BOOMERANG is to leverage the trusted OS’s visibility
beleveragedintoafullexploit;however,wedidnotinvestthe
intothenon-secureworldtoverifytheownershipofthemem-
engineering time at this point to verify this exploit.
ory being accessed by simply reading the same page tables
thatareusedbytheuntrustedOS.Avariantofthisapproachis
C. Vulnerabilities in Huawei takenbyNVIDIA’sTrustedLittleKernel(TLK),theTEEused
byTegraprocessors[34].ThisdefenserequiresthetrustedOS
For our analysis of Huawei, we were able to obtain a to have a complete understanding of the page table structure
set of 10 TAs. Using our static-analysis tool, we found out within the untrusted OS. Thus, when an untrusted application
that only 6 of them accepted commands and all of these passes a memory reference, the trusted OS would first verify
6 TAs were vulnerable to BOOMERANG. We were able to that the memory actually belongs to the untrusted application
locatebotharbitraryreadandwritefunctionality,whichallows that made the call by doing a page-table walk, and, only then,
us to gain root privileges on any device running this TEE map that memory into the memory space of the requested TA.
implementation. We use a technique based on ret2dir [22],
which allows the execution of code as the root user, by This approach has a few notable advantages. It is entirely
overwriting kernel memory structures to include a malicious invisible to the untrusted OS, as the entire PTRSAN function
return-oriented programming (ROP) payload. This technique is implemented within the secure world. Additionally, it does
hasbeenimplementedandtestedonAndroid5.0.1,andworks not require any extra memory copy operations, which is an
regardless of Privileged eXecute Never (PXN) protections improvementovershared-memorydefenses,whichweexplain
deployed by the hardware. inSectionVII-B.However,theAchilles’heelofthisapproach
is the amount of work that must be performed by the trusted
These vulnerabilities were reported to Huawei, as part of OS to interpret the untrusted OS’s page table structure, and
oursubmissiontotheGeekPwn2016hackingcontest[18],and then make security decisions based on that interpretation. Re-
received the designations CVE-2016-8762, CVE-2016-8763, searchers have shown that page table walks can be extremely
and CVE-2016-8764. We were able to develop a full exploit, dangerous. For example, since the trusted OS is performing
which leveraged BOOMERANG and other techniques to obtain a walk on a page table controlled by the untrusted OS, a
full root privileges, as well as code execution within the TEE maliciousuntrustedOScouldpotentiallycraftamaliciouspage
itself2. Huawei has implemented a fix, and as of December table and obtain arbitrary code execution within the trusted
2016, updates to various Huawei devices are available to OS [5], [20].
address the problem.
Furthermore, this defense, while relatively easy to imple-
ment, does not satisfy our first requirement, as the trusted OS
VII. DEFENSES must be aware of the page table structure managed by the
untrusted OS. This approach is not generalizable and would
Before discussing the examined defenses, we first outline
likely require a customized trusted OS to accompany each
the requirements that we set forth to ensure that our proposed
untrusted OS, or at least a different instantiation based on
defense would be both practical to implement and usable for
the page table structure. Finally, this defense is likely not
developers. We identify the following minimum requirements
possible to implement while satisfying our third requirement
that any solution to BOOMERANG must satisfy to be usable:
of a minimal TCB, as an elegant and correct page table walk
requires a considerable amount of code, likely far more than
• Independence from the untrusted OS: The TEE imple-
100 lines.
mentation should not be dependent on the untrusted OS
(i.e., it should not leverage OS-specific functionality). For This approach works well for TLK, where the trusted OS
example,thetrustedOSshouldbeunaffectediftheuntrusted is a derivative of Linux and is therefore able to manage Linux
OSisupgradedorchangedentirely.Thisrequirementforces pagetablesusingthesamecodeastheuntrustedOS.However,
the solution to be generic, rather than depending on a wedonotconsideritaviablegenericapproachsinceitviolates
particular feature within the untrusted OS implementation. twoofourrequirements.Thus,wedidnotevaluateitsefficacy
• Minimal or no changes to user applications (untrusted in practice in Section VIII; however, we do not discredit its
andtrusted):Changestotrustedanduntrustedapplications viability as a defense against BOOMERANG, and we believe
shouldbeminimalornoneatall.Thisrequirementeasesthe that it could be a reasonable defense in specific instances.
adoption of the solution and ensures that existing applica-
tions will be automatically protected, without burdening the B. Dedicated Shared Memory Region
developers to re-write their applications.
• Minimal changes to the trusted kernel: No major archi- The heart of the BOOMERANG flaw stems from the fact
tecturalchangesshouldberequiredwithinthesecureworld. that the secure world can read from and write to any non-
This ensures that the TCB will remain small and that all secure memory it wishes. In the dedicated shared mem-
modifications can be sufficiently audited. Since minimal is ory region defense, a special physical memory region (e.g.,
subjective, we specify that any modifications to the trusted common-memory in the case of OP-TEE) is defined, which
OS abide by a soft ceiling of 100 lines of code. is the only region of memory that is readable and writable
by both worlds. To verify any pointers that are passed from
2Avideodemonstratingtheexploitcanbefoundathttps://www.youtube.c the non-secure world, the secure world then needs only to
om/watch?v=XjbGTZrg9DA verifythatthememoryiswithinthecommon-memory,which
11will protect both worlds. Note that this is the exact method Non-secure World Virtual Memory
employed by OP-TEE (see Figure 5). Untrusted Application Physical Memory
User Mode
1
This defense is easy to implement in the secure world. In
Non-secure Memory
fact, this defense actually makes the secure world’s PTRSAN TEE Daemon/Driver
function extremelysimple, asit needs onlyto confirm thatthe Append
PID PTRSAN Untrusted App. Memory
memoryiswithinthesharedregion.Nevertheless,thisdefense 6
has numerous drawbacks in the non-secure world: 2 5 7 Supervisor Mode Shared Buffer
Secure World
Trusted OS
• The untrusted OS is burdened with handling all of the
sharedmemoryregions(i.e.,sectionsofcommon-memory) PTRSAN 8 Shared Buffer
amongst the various untrusted user applications. This mem- 3 4 9Supervisor Mode Trusted App. Memory
ory management can be exceptionally complicated, and, Secure Memory
Trusted Application
indeed, we found at least 4 bugs [29]–[32] in different
User Mode
components of this mechanism in OP-TEE.
• For high-throughput applications (e.g., DRM video decryp- Fig. 8: Cooperative Semantic Reconstruction data-flow and
tion), this defense adds an undesirable overhead, since it pointer resolution technique.
requires all of the data to be copied into a special buffer,
which is not in the requesting application’s memory space. In this defense, the untrusted applications prepare requests
This global memory region also requires a global lock on to TAs exactly as they would without it. The call to the
memory, which can become a serious bottleneck in multi- TA would similarly be handled by an exposed kernel driver
threaded applications. In our tests (Section VIII-A), this or TEE 1 , which would handle the world switching. Note
global locking mechanism alone consumed approximately the there is no proactive PTRSAN necessary by either the
36% of the total overhead. daemon or the kernel driver. In fact, the buffer is passed
• Shared memory makes it extremely difficult, and in some directlyintothesecureworldwiththenon-secureworldvirtual
casesimpossible,toimplementcertaintypesofapplications. memory address intact. The only addition is that the process
Forexample,apopularuseofTrustZoneismemoryintegrity identificationnumber(PID)oftherequestingprocess(werefer
checking [11], where an untrusted application requests that to this as the req_pid) is now appended to the request
aTAmonitorsitsmemory,whichdoesnotworkwithshared structure by the untrusted OS during the SMC call 2 . Now,
memory. in the secure world, when a TA needs to access a pointer that
• This defense only thwarts the general BOOMERANG attack, was passed as an argument, which is a virtual address that
but can still permit applications to leverage BOOMERANG belongs to the untrusted application that initiated the call, the
toreadfromandwritetoarbitraryregionswithintheshared TA must first query the trusted OS to resolve the physical
memory, which may contain sensitive data. address 4 . This query is implemented as a callback to the
untrusted kernel with the pointer value (virtual address), the
We show in Section VIII-C how this currently advocated length of the buffer, and the corresponding req_pid 5 .
defense compares against our proposed solution. The untrusted OS kernel can trivially handle the callback by
checking that the buffer indeed belongs to the address space
C. Cooperative Semantic Reconstruction ofreq_pid 6 .Iftheverificationissuccessful,theuntrusted
OS then locks the corresponding pages (to avoid them being
Due to the limitations of existing BOOMERANG defenses, pagedout)andsendsthephysicaladdressesbacktothesecure
we propose a novel defense (CSR), which is capable of bridg- world 7 . At this point, the trusted OS will then implement
ing the semantic gap between the two worlds with minimal its own PTRSAN function to verify that the physical address
modificationandminimaloverhead.Inthisdefense,thetrusted from the untrusted OS is, in fact, in the non-secure world 8 .
OS and the untrusted OS both cooperate to verify memory Then, the trusted OS will map it into the TA’s memory space
pointers that are passed into the secure world to ensure that or allow the TA to access the physical address directly 9 . If
the untrusted application indeed has permission to access the verification fails, a corresponding error code is returned.
referenced memory region. This implementation was based
on one key insight: the untrusted OS already adequately GiventhateveryTEEimplementationalreadyhascallback
implements memory protection mechanisms; however, this supportforhigh-leveloperations(e.g.,fileoperations,network
information is not currently easily accessible to the trusted communication), this exact same channel can be leveraged to
OS. Thus, to implement this defense, the untrusted OS needs implementCSR.NotethatCSRprovidesagenericmechanism
only to expose a simple callback to the secure world that to bridge the semantic gap between the two worlds, and that
permits the trusted OS to query the untrusted OS’s PTRSAN it can also be extended to verify access to files, or other
function, where the memory address can be trivially verified. peripherals by the secure world.
This callback can be used from within the secure world any
timethatnon-securememoryistobeaccessed,thusthwarting At first glance, it may appear that this defense would
any unintended BOOMERANG vulnerabilities. Fundamentally, require modifications to all of the components (i.e., the
this defense bridges the semantic gap by allowing the secure untrusted application, the untrusted kernel, the trusted ker-
world, which has no insight into the layout of non-secure nel, and the trusted application). However, since all of the
memory,toquerytheuntrustedOSasasecurityoracle,which trusted applications that we observed use a client library,
is able to correctly respond. An overview of the approach can we believe that simply updating this client library would
be seen in Figure 8 be enough in practice. Similar to untrusted applications, ex-
12TABLE II: Total modifications required to implement CSR in
isting TAs would not require any modification, as this de-
OP-TEE, measured in LOC.
fense could be implemented in the trusted kernel functions
(e.g., qsee_register_shared_buffer() in the case Component AddedLOC ModifiedLOC TotalLOC
of QSEE) that are already used to access non-secure world
TrustedOS 88 3 91
memory. The only real modifications that would have to be
UntrustedOS 273 2 275
deployed would be the modifications to the untrusted and
trusted kernels, which would add the functionality to handle ClientLibrary 39 0 39
and perform the required callback, respectively.
TABLE III: Summary of benchmark results, showing the
The main overhead introduced by CSR is the addi- overhead of CSR over DSMR.
tional verification path (i.e., 4 - 9 ). However, we show in
Section VIII-B that this overhead is minimal and comparable Category Overhead
to other defenses. Avg.% Avg.Time(ms)
BasicFunctionality -0.58% -7.168
VIII. EVALUATIONOFDEFENSES Trusted-UntrustedCommunication 4.45% 0.510
Cryptooperations -1.72% -901.548
We evaluated the two most promising proposed defenses: SecureFileStorage 0.03% 0.694
TotalforallTests -0.0344 -189.919
Dedicated Shared Memory Region (DSMR) and CSR. We
decided not to include Page Table Introspection (PTI) in
B. Cooperative Semantic Reconstruction
our analysis, as it does not satisfy our requirements as a
generalBOOMERANGdefense.Similarly,wedidnotexplicitly
As we previously explained in Section V-C, in OP-TEE
compare our defenses against a vanilla TEE implementation,
all arguments to TA are typed (i.e., pointer or value), and all
as we do not see no defense as an option. We performed our
pointers are already checked to ensure that they are within
evaluation on the OP-TEE platform [51], with Linux as our the common-memory region. Thus, we were able to im-
untrusted OS. OP-TEE was chosen because it is completely
plement our CSR defense by simply adding a new pointer
open source, has a very well-maintained code base with clear parameter type, RAW_PTR, and modifying the trusted OS to
documentation,andincludesanexhaustivetestsuite,whichwe
perform the required callback to the untrusted OS for every
used to evaluate the performance overhead of our defenses. RAW_PTR. We also changed the untrusted OS’s client library
WechosetheHiKeydevelopmentboard(LemakerVersion) (i.e., libteec.so) to use the RAW_PTR as the default type
as the hardware platform for testing, which is one of the for all pointers. The untrusted kernel driver was similarly
boards recommended by the OP-TEE developers [51]. This modified to handle the callback function. We implemented
board includes a traditional ARM processor and associated our PTRSAN function in the callback, which verifies that
hardware, which are almost identical to what would be found the argument is a valid virtual address within the appropriate
onaconsumerAndroidhandset[26].OP-TEEhasanextensive untrusted application (referenced by its PID). Upon verifi-
test suite with 63 tests called xtest [50]. These tests cover cation, we then resolve the corresponding physical memory
both sanity and functionality check of various TAs, TEE pages, set them to be non-pageable, and return the physical
benchmarking, and Global Platform compliance. We modified addresses back to the secure world. All of our modifications
the test driver to record timings for each of the tests as well to OP-TEE are backward-compatible and can easily co-exist
as profiling information for the different phases of DSMR and withtheexistingDSMRdefense.Thesemodificationsresulted
CSR. All reported timing data are averaged across 30 runs of in only 91 modified lines of code in the OP-TEE trusted OS
xtest on the HiKey board, where the system was rebooted (see Table II to see the modifications per component).
between runs to avoid caching-related inconsistencies.
As explained in Section VII-C, most of the additional
overhead introduced by CSR is caused by the callbacks from
A. Dedicated Shared Memory Region
the trusted OS to the untrusted OS for every RAW_PTR
As explained in Section V-C, OP-TEE’s default configura- argument type. In OP-TEE, all of the pointer arguments are
tionusestheDSMRmethodastheonlymechanismforpassing firstsanitizedbythetrustedOSbeforeinvokingtheTA.Hence,
memoryarguments.Inthisimplementation,theuntrustedOS’s all of our results for CSR do not include the calls between
client library handles the allocation of the shared memory the TA and the trusted OS (i.e., 4 and 9 in Figure 8).
region, which consists of assigning an identifier (shmid), Nevertheless, we similarly measured the incurred overhead
copying of data to and from the corresponding shared buffer, of CSR by running the xtest suite, which made a total of
and ultimately releasing it. Recall that this shared memory 3,885 callbacks throughout its tests. The average time taken
management within the untrusted OS is the main overhead for the trusted OS to confer with the untrusted OS to sanitize
in this implementation. There is virtually no overhead in the pointers ( 5 - 6 - 7 - 8 ) over all 3,885 callbacks was 26.891
trusted OS, as it just needs to check that the pointer argument µs, 21.909 µs of which were spent within the untrusted OS
iscontainedwithinthecommon-memoryregion.Onaverage, doingvalidationandmemorypagepinning( 6 ).Thisisalmost
allocating shared memory took 13.795 µs, releasing memory identical to the 21.777 µs overhead incurred by the DSMR
took 7.982 µs, and the time it took to copy memory contents defense.
was negligible. Thus, the total incurred overhead was 21.777
µs per secure-world query. This low overhead is partially
C. Comparative Evaluation
attributedtothefactthatthemaximumsizebeingcopiedinthe
tests was only 4,097 bytes; however, we would expect these To get an idea of the specific performance of memory
numbers to rise significantly with larger memory regions. management operations with the two defenses, we analyzed
13theprofilingdataforthevariousoperationsperformedbyboth IX. CONCLUSION
approaches and found that performance for a single memory
In this work, we identified a previously unknown class of
accesswithDSMRisslightlybetter,5.113µsfaster,thanCSR.
However, the performance across the entire range of tests is
vulnerabilities, BOOMERANG, that affects systems where the
secure world (i.e., the TEEs) and the non-secure world (i.e.,
much more interesting.
the traditional OS) share resources. The vulnerability arises
A summary of the testing data, in terms of the average from the critical semantic gap when passing data between
overhead of CSR over DSMR for each test category, is shown the two worlds, specifically memory pointers, and flaws in
in Table III. Note that a negative value indicates CSR was sanitizing these pointers. We identified BOOMERANG vulner-
fasterthanDSMRforthecorrespondingcategory.TheTrusted- abilitiesinfourofthemostpopularcommercialTEEplatforms
Untrusted Communication category represents CSR’s worst (affecting hundreds of millions of devices world-wide). In
performance in terms of the percentage of overhead. There order to explore the generality and severity of BOOMERANG,
are 14 tests in this category and all of them primarily perform we developed a static-analysis tool to automatically identify
a lot of SMC operations (approximately 200) to test inter- BOOMERANG bugs in real-world TEE applications. These
worldcommunication.CSRallocatesanddeallocatesmemory- findings have resulted in major efforts from the respective
tracking structures during each SMC, as it cannot know ahead parties (e.g., Google and Qualcomm) to fix their implemen-
of time when memory arguments are to be used. This con- tations, as the identified vulnerabilities could be leveraged to
tributesaverysmalloverheadforeachSMC,whichisreflected completely compromise the untrusted OS (e.g., Android) of
as a larger percentage in these particular tests, although even the affected devices. We similarly analyzed three potential
here, this net overhead in terms of time is still low. BOOMERANG defenses, comparing the trade-offs and design
considerations of each. Due to the limitations of the existing
In the context of the other 49 tests performed, the percent-
defenses (i.e., shared memory and page table introspection),
age of overhead contributed by CSR versus DSMR is very
we devised a novel solution, Cooperative Semantic Recon-
small. CSR introduces no more than 0.03% overhead in the
struction, which addresses the shortcomings of the previous
worstcaseandimprovesperformancebyupto1.72%inothers.
proposals, while still offering an efficient and easy-to-use
For those tests with non-secure memory operations, we interface.
observedthattheDSMRoverheadvariedsignificantly,whereas
theoverheadofCSRremainedconstantforagivennumberof
ACKNOWLEDGEMENTS
memory operations. The main reasons for variance in DSMR
overhead are: This material is based on research sponsored by the Office
ofNavalResearchundergrantnumberN00014-15-1-2948and
• Synchronized access: The allocation and release of shared
by DARPA under agreement number N66001-13-2-4039. The
memory involves acquiring a global lock. For a multi-
U.S. Government is authorized to reproduce and distribute
threaded application making simultaneous shared memory
reprintsforGovernmentalpurposesnotwithstandinganycopy-
requests and releases will result in idle tasks as they wait
right notation thereon.
for the global lock, increasing the overhead of DSMR. We
observed this in one of the tests of the Basic Functionality This work is also sponsored by a gift from Google’s Anti-
category, which creates several threads, all of which make Abuse group.
requests to a TA. During this subtest, the overhead for a
Sandia National Laboratories is a multi-mission laboratory
shared memory allocation went up to 80 microseconds and
managedandoperatedbySandiaCorporation,awhollyowned
in total CSR beat DSMR by 11.72 seconds of execution
subsidiary of Lockheed Martin Corporation, for the U.S. De-
time.
partmentofEnergy’sNationalNuclearSecurityAdministration
• Additional copying: In DSMR, untrusted applications need
under contract DE-AC04-94AL85000.
tocopydatatoorfromsharedmemorytocommunicatewith
the TA. This copying time can be an overhead, if a large The views and conclusions contained herein are those of
amount of data is being exchanged between the untrusted the authors and should not be interpreted as necessarily repre-
application and the corresponding TA. For example, one of senting the official policies or endorsements, either expressed
the tests in the Trusted-Untrusted Communication category, or implied, of DARPA, Sandia National Laboratories, or the
which passes a large amount of data, suffered a 26% U.S. Government.
overhead because of this memory copying.
• MemoryFragmentation:Dependingonhowsharedmemory
REFERENCES
is allocated and released, it could get severely fragmented.
As DSMR in OP-TEE uses a best-fit algorithm to find free [1] AOSP,“/dev/iondriver!”https://lwn.net/Articles/480055/,2006.
regions of shared memory, fragmentation increases the time [2] ARM,“ARMTrustZone,”http://www.arm.com/products/processors/tec
tofindafreechunk,thusincreasingtheoverheadofDSMR. hnologies/trustzone/index.php,2015.
[3] ARM, “Securing the Future of Authentication with ARM TrustZone-
AlthoughCSRisslightlyoutperformedbyDSMRinsome based Trusted Execution Environment and Fast Identity Online
tests, in practice CSR is the best candidate for an all-around (FIDO),” https://www.arm.com/files/pdf/TrustZone-and-FIDO-white-
defense. CSR offers the best security properties, requires min- paper.pdf,2015.
imal modification for implementation, incurs minimal overall [4] A.M.Azab,P.Ning,J.Shah,Q.Chen,R.Bhutkar,G.Ganesh,J.Ma,
andW.Shen,“HypervisionAcrossWorlds:Real-timeKernelProtection
performance overhead, and actually boosts performance for
from the ARM TrustZone Secure World,” in Proceedings of the 2014
multi-threaded applications. Thus, per our evaluation, CSR
ACMSIGSACConferenceonComputerandCommunicationsSecurity
appears to be the ideal defense against BOOMERANG. (CCS),2014.
14[5] J. Bangert, S. Bratus, R. Shapiro, and S. W. Smith, “The Page- [31] ——,“Sharedmemoryallocatedbyteelinuxkerneldriverisnotzeroed
Fault Weird Machine: Lessons in Instruction-less Computation,” in out,”https://github.com/linaro-swg/linux/issues/13/,2016.
Proceedings of the 7th USENIX Workshop on Offensive Technologies [32] ——,“SharedMemoryIDsarestoredglobally,”https://github.com/lin
(WOOT),2013. aro-swg/linux/issues/14/,2016.
[6] A.Barth,C.Jackson,andJ.C.Mitchell,“RobustDefensesforCross- [33] B.McGillion,T.Dettenborn,T.Nyman,andN.Asokan,“Open-TEE–
Site Request Forgery,” in Proceedings of the 15th ACM SIGSAC An Open Virtual Trusted Execution Environment,” in Proceedings of
ConferenceonComputerandCommunicationsSecurity(CCS),2008. the14thIEEEInternationalConferenceonTrust,SecurityandPrivacy
[7] J.Bennett,“DeviceswithTrustonicTEE,”https://www.trustonic.com/n inComputingandCommunications,2015.
ews-events/blog/devices-trustonic-tee,2015. [34] H. Nahari, “TLK: A FOSS Stack for Secure Hardware To-
[8] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi, and kens,” http://www.w3.org/2012/webcrypto/webcrypto-next-workshop/
B.Shastry,“TowardsTamingPrivilege-EscalationAttacksonAndroid,” papers/webcrypto2014 submission 25.pdf,2012.
in Proceedings of the 19th Annual Network and Distributed System [35] OP-TEE, “optee os,” https://github.com/OP-TEE/optee os/blob/maste
SecuritySymposium(NDSS),2012. r/core/arch/arm/kernel/tee ta manager.c,May2016.
[9] M.Dietz,S.Shekhar,Y.Pisetsky,A.Shu,andD.S.Wallach,“Quire: [36] Qualcomm, “Msm scm communicator,” https://android.googlesource.c
LightweightProvenanceforSmartPhoneOperatingSystems,”inPro- om/kernel/msm/+/android-5.1.0 r0.6/arch/arm/mach-msm/scm.c.
ceedingsofthe20thUSENIXSecuritySymposium,2011. [37] ——, “Qualcomm Secure Execution Environment Communicator
[10] M.Egele,M.Woo,P.Chapman,andD.Brumley,“BlanketExecution: (QSEECOM) driver,” https://android.googlesource.com/kernel/msm.g
DynamicSimilarityTestingforProgramBinariesandComponents,”in it/+/77cac325253126dd9e6c480d885aa51f1abf3c40/drivers/misc/qseec
Proceedingsofthe23rdUSENIXSecuritySymposium,2014. om.c.
[11] X. Ge and T. Jaeger, “Sprobes: Enforcing Kernel Code Integrity on [38] D.Rosenberg,“ReflectionsonTrustingTrustZone,”inBlackHatUSA,
the TrustZone Architecture,” in Proceedings of the Mobile Security 2014.
Technologies2014Workshop(MoST),2014. [39] K.Rubinov,L.Rosculete,T.Mitra,andA.Roychoudhury,“Automated
[12] GlobalPlatform,TEESystemArchitecture,2011. Partitioning of Android Applications for Trusted Execution Environ-
ments,”inProceedingsofthe38thInternationalConferenceonSoftware
[13] ——,TEEInternalCoreAPISpecificationv.1.1.1,2016.
Engineering(ICSE),2016.
[14] N.GoldeandD.Komaromy,“BreakingBand:reverseengineeringand
[40] G.Rydstedt,E.Bursztein,D.Boneh,andC.Jackson,“Bustingframe
exploitingtheshannonbaseband,”inREcon,2016.
busting:astudyofclickjackingvulnerabilitiesatpopularsites,”IEEE
[15] Google, “QSEEComAPI.h,” https://android.googlesource.com/platfor OaklandWeb2.0SecurityandPrivacy(W2SP),2010.
m/hardware/qcom/keymaster/+/master/QSEEComAPI.h,2012.
[41] Samsung,“KnoxTechnology,”https://www.samsungknox.com/en/knox
[16] ——,“TrustyTEE,”http://source.android.com/security/trusty/,2016. -technology,2015.
[17] N.Hardy,“TheConfusedDeputy:(orwhycapabilitiesmighthavebeen [42] SamsungKnoxNews,“Real-timeKernelProtection(RKP),”https://ww
invented),”ACMSIGOPSOperatingSystemsReview,1988. w2.samsungknox.com/en/blog/real-time-kernel-protection-rkp,2016.
[18] Huawei, “Security Advisory - Multiple Security Vulnerabilities in [43] D. Shen, “Attacking your “Trusted Core,” Exploiting TrustZone on
Huawei Smart Phone Products,” http://www.huawei.com/en/psirt/secu Android,”inBlackHatUSA,2015.
rity-advisories/huawei-sa-20161123-01-smartphone-en,2016. [44] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
[19] J. Jang, S. Kong, M. Kim, D. Kim, and B. B. Kang, “SeCReT: A.Dutcher,J.Grosen,S.Feng,C.Hauser,C.Kruegel,andG.Vigna,
Secure Channel between Rich Execution Environment and Trusted “SoK: (State of) The Art of War: Offensive Techniques in Binary
Execution Environment,” in Proceedings of the 22nd Annual Network Analysis,” in Proceedings of the IEEE Symposium on Security and
andDistributedSystemSecuritySymposium(NDSS),2015. Privacy(SP),2016.
[20] Y. Jang, S. Lee, and T. Kim, “DrK: BreakingKernel Address Space [45] Sierraware,“OpenVirtualizationsSierraVisorandSierraTEE,”http://op
LayoutRandomizationwithIntelTSX,”inBlackHatUSA,2016. envirtualization.org,2016.
[21] N. Keltner, “Here Be Dragons: Vulnerabilities in TrustZone,” [46] ——, “SierraWare Trusted Execution Environment,” http://www.sierr
https://atredispartners.blogspot.com/2014/08/here-be-dragons-vulnerab aware.com/,2016.
ilities-in.html,2014. [47] STMicroelectronics and Linaro Security Working Group, “OP-TEE
non-secure world kernel driver,” https://github.com/linaro-swg/linux/tr
[22] V. P. Kemerlis, M. Polychronakis, and A. D. Keromytis, “ret2dir:
ee/optee/drivers/tee.
Rethinking Kernel Isolation,” in Proceedings of the 23rd USENIX
SecuritySymposium,2014. [48] ——,“OP-TEEnon-secureworld/secureworldSMCcall,”https://gith
ub.com/linaro-swg/linux/blob/optee/drivers/tee/optee/call.c#L117.
[23] K. Kostiainen, J.-E. Ekberg, N. Asokan, and A. Rantala, “On-board
Credentials with Open Provisioning,” in Proceedings of the 4th Inter- [49] ——,“OP-TEEnormalworldclientlibrary,”https://github.com/OP-TE
national Symposium on Information, Computer, and Communications E/optee client.
Security(AsiaCCS),2009. [50] ——,“OP-TEETestSuite,”https://github.com/OP-TEE/optee test.
[24] K. Lady, “Sixty Percent of Enterprise Android Phones Affected by [51] ——,“OpenSourceTEE,”https://github.com/OP-TEE/optee os.
CriticalQSEEVulnerability,”https://duo.com/blog/sixty-percent-of-ent
[52] H.Sun,K.Sun,Y.Wang,J.Jing,andS.Jajodia,“TrustDump:Reliable
erprise-android-phones-affected-by-critical-qsee-vulnerability,2016. Memory Acquisition on Smartphones,” in Proceedings of the 19th
[25] laginimaineb,“Bits,Please!”https://bits-please.blogspot.com/,2016. European Symposium on Research in Computer Security (ESORICS),
[26] Lenovator,“HiKey(LeMakerversion)2GBRAM,”http://www.lenovat 2014.
or.com/product/90.html. [53] Trustonic,“Trustonic,”https://www.trustonic.com/.
[27] Linaro Security Working Group, “Linux Kernel, OP-TEE driver,” [54] ——, “tee-mobicore-driver.kernel,” https://github.com/TrustonicNwd/
https://github.com/linaro-swg/linux/blob/optee/drivers/tee/optee/core.c, tee-mobicore-driver.kernel/blob/MC12/drivers/gud/MobiCoreDriver/f
2016. astcall.h,2015.
[28] M. Lu, “TrustZone, TEE and Trusted Video Path Implementation [55] ——, “trustonic-tee-user-space,” https://github.com/Trustonic/truston
Considerations,” http://www.arm.com/files/event/Developer Track 6 ic-tee-user-space/blob/e3b0b06025605b06fc1e19588098e5011f6afc83/
TrustZone TEEs and Trusted Video Path implementation considera MobiCoreDriverLib/Daemon/MobiCoreDriverDaemon.cpp,2015.
tions.pdf,2013. [56] ——,“tee-mobicore-driver.daemon,”https://github.com/TrustonicNwd/
[29] A.Machiry,“PotentialHeapBufferoverflowintee supp com.c,”https: tee-mobicore-driver.daemon,2016.
//github.com/OP-TEE/optee linuxdriver/issues/52/,2016. [57] J.Williams,“Inspectingdatafromthesafetyofyourtrustedexecution
[30] ——, “Potential invalid MEMREF translation, this could be used for
environment,”inBlackHatUSA,2015.
bad,”https://github.com/OP-TEE/optee linuxdriver/issues/53/,2016.
15