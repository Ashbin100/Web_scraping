Distillation Codes
and Applications to DoS Resistant Multicast Authentication
ChrisKarlof NaveenSastry YapingLi AdrianPerrig J.D.Tygar
UCBerkeley UCBerkeley UCBerkeley CMU UCBerkeley
Abstract consideration. Includingthe signature in everypacketis
robust to packet loss, but incurs high overhead. Includ-
ing a few bytes of the signature in each packet is space
Weintroducedistillationcodes,amethodforstreaming efficient,butisnotrobusttoloss. Signatureamortization
and storing data. Like erasure codes, distillation codes schemesdiffermainlyintheirsolutiontothisproblem.
allowinformationtobedecodedfromasufficientlylarge Three previous approaches are hash graphs [11, 18,
quorumofsymbols. Incontrasttoerasurecodes,distilla- 26, 33], the Wong-Lam scheme [35], and erasure codes
tioncodesarerobustagainstpollutionattacks,apowerful [21, 22]. All are vulnerableto denial of service attacks.
class of denial of service (DoS) attacks in which adver- Hashgraphprotocolsconstructadirectedgraphoverthe
sariesinjectinvalidsymbolsduringthedecodingprocess. packets where each node in the graph contains the hash
We examine applications of distillation codes to mul- valuesoftheneighborsonitsincomingedges. Thehash
ticast authentication. Previous applications of erasure graphterminateswithasignaturepacket,whichauthenti-
codes to multicast authentication are vulnerable to low catesahandfulofthenodesinthegraph. Ifthesignature
bandwidth pollution attacks. We demonstrate pollution packet is not lost and there exists a path from a particu-
attacks against previous approaches which prevent re- lar packet to the signature, the receiverauthenticatesthe
ceiversfromverifyinganyauthenticpackets.Toresistpol- packetbytraversingthehashpathtothedigitalsignature
lutionattacks,weintroducePollutionResistantAuthenti- andverifyingthesignature.
cated Block Streams, which have low overhead and can TheWong-Lam[35]schemeconstructsa Merklehash
tolerate arbitrary patterns of packet loss within a block treeoverthepacketsintheblockandsignstherootofthe
up to a predeterminednumberof packets. In the face of tree. Eachpacketcontainsthesignatureandthenodesin
40Mb/sofattacktraffic,PRABSreceiverssuccessfullyau- tree necessary to reconstruct the root. By including the
thenticatethestreamandconsumeonly10%oftheirCPU. signatureineverypacket,eachpacketisindividuallyveri-
fiable. Receiversauthenticateeachpacketbyreconstruct-
ingtherootvalueofthetreeandverifyingthesignature.
1.Introduction Hash graph protocols and the Wong-Lam scheme are
vulnerable to signature flooding attacks. An adversary
Single-source multicast enables a sender to efficiently flooding the stream with invalid signatures will over-
disseminate digital media to a large audience, but to de- whelmthe computationalresourcesofreceiversattempt-
fend against adversaries who inject bogus packets, re- ing to verify the signatures. Additionally, in hash graph
ceivers must verify the authenticity of packets. One ap- protocols,adversariallosspatternscancausedenialofser-
proachto multicast authenticationis signature amortiza- vice. For example, if an adversarycauses the loss of all
tion. Signatureamortizationschemesdividethemulticast signaturepackets,nothingisverifiable.
streamintoblocksofsequentialpacketsandauthenticate Several researchers advocate the use of erasure codes
all the packets in a block with a single signature. Sig- [15,16,28,29]forsignatureamortization[21,22]. Era-
nature amortization is a compelling approach to multi- surecodesareamechanismthatallowreceiverstodecode
castauthenticationbecauseitdistributesthecommunica- messages from a sufficiently large quorum of encoding
tionandcomputationoverheadofadigitalsignatureover symbols. Erasure codes are robust to arbitrary patterns
manypackets. of loss among the encoding symbols as long as the de-
Onechallengeinsignatureamortizationschemesisro- coderreceivesasufficientlylargesubsetofthem. Multi-
bustnesstopacketloss. Receiversneedthedigitalsigna- cast authenticationprotocols using erasure codes are ro-
turetoverifytheauthenticityofthepacketsintheblock, busttopacketlossandhavelowoverhead.However,era-
butthebestwaytoreliablytransmitthesignaturerequires sure codes are designed to handle only a specific threatmodel: packet loss. Erasure codes assume that symbols Scheme Overhead Denialofservice
aresometimeslostbutnotcorruptedintransit;thisisthe (bytes) vulnerabilities
erasurechannelmodel. Hashgraphs ≈40–50 Signatureflooding
Unfortunately, the assumptions that underlie erasure [11,18,26,33] &adversarialloss
codesareunrealisticinhostileenvironments.Adversaries Wong-Lam[35] 188 Signatureflooding
canpollutethemessagestreambyinjectinginvalidsym- SAIDA[23] 22 Pollutionattacks
bols. We call this a pollution attack. If an erasure code Pannetrat- 12 Pollutionattacks
usesaninvalidsymbolasinputtoitsdecodingalgorithm, Molva[21]
itwillreconstructinvaliddata.Thecommunicationmodel
PRABS 65 —
thatincorporatesthis morerealistic threatis thepolluted
erasurechannel,inwhichvalidsymbolscanbelost,and
Table 1. Comparison of PRABS to existing
anadversarycaninjectadditionalinvalidsymbolsclaim-
multicastauthenticationprotocols.
ingtobevalid.Pollutederasurechannelsmoreaccurately
model multicast environments: malicious end hosts and The overhead was computed assuming 80 bit cryptographic
routerscanobserve,inject,modify,delay,anddropmes- hashes, 128 byte RSA signatures, and 128 packet blocks. For
sagesinanerasureencodedmulticaststream. SAIDAandPRABS,weassumeupto64packetlossesperblock.
This paperintroducesandgivesefficientconstructions ForPRABS,weuse the optimization described inSection 4.6.
of distillation codes, which are robust against pollution Ourscheme,PRABS,isresistanttopollutionattacks,signature
attacks, signatureflooding, and adversarialloss patterns. flooding,andadversariallosspatterns.
Wemakethefollowingcontributions:
• Weintroducethenotionofpollutiontoerasurechan- aspaceefficientandcomputationallylightweightauthen-
nels, which allows us to more accuratelymodelthe ticationmechanism,especiallyifthereceiversareembed-
threatsof multicastdatadissemination. We also in- deddevices. Inunicastsettings, symmetrickeycryptog-
troduce pollution attacks and demonstrate how low raphycanprovideanefficientsolutionto theauthentica-
bandwidthpollutionattackscancausedenialofser- tion problem [5]. Naively extending such schemes to a
viceforerasurecodes. multicast setting by distributing the secret key to all the
receivers is not secure: any receivercan forgemessages
• We introduce distillation codes; we show that dis- usingthesecretkey.
tillation codes function well in the polluted erasure The goals and requirementsofbroadcast/multicastau-
channel model, and prove that they are resistant to thenticationareasfollows:
pollutionattacks.
• Packet authenticity. Each receiver can verify that
• Weusedistillationcodestoconstructanewmulticast packetsoriginatedfromthesenderandwereunmod-
authenticationprotocol: PollutionResistantAuthen- ifiedintransit. Receiversmustbeabletodistinguish
ticated Block Streams (PRABS). PRABS can toler- trafficinjectedbyotherparties,includinganyofthe
ate arbitrary patterns of packet loss within a block receivers.
uptoapredeterminednumberofpacketsandarere- • Packet loss robustness. Receivers can authenticate
sistant to pollution attacks on receivers. Figure 1
eachpacketdespitethelossofafixedfractionofthe
compares PRABS to existing multicast authentica-
totalpackets.
tionprotocols.
• Loss model independent. In addition to packet loss
• We present measurements of an implementation of robustness, receivers can verify packets even when
distillationcodesandPRABS. Thesemeasurements thelossisbursty,correlated,orinanyotherpattern.
demonstrate the effectiveness of distillation codes
againstpollutionattacks. • Denialofservice(DoS)resistant. Receiverscanre-
sistdenialofserviceattacksagainsttheirresources.
2 Preliminaries 2.2.Erasurecodes
Anerasurecode[15,16,28,29]isanencoderandde-
2.1.Broadcastandmulticastauthentication
coder that use forward error correction to tolerate loss.
Disseminatinginformationfromaserverinabroadcast The encoder redundantly encodes information into a set
setting to multiple receivers demands a mechanism for of symbols. If the decoder receives sufficiently many
guaranteeingtheauthenticityofthedatastream. Weneed symbols, it can reconstructthe original information. An(n,t) erasure encoder generates a set S of n symbols reconstruction is valid, we will erasure encode TAG(D)
{s 1,s 2,...,s n} from the input. The decoder can toler- ratherthanD. ThengivenacandidatereconstructionR,
ate a loss of up to t packets, i.e., it can reconstruct the adecoderdeterminesitsauthenticitybycheckingwhether
originaldatagivenanyn−tsymbolsfromS. VALIDATE(R)=true.Werefertotheprocessofapplying
Reed-Solomon, Tornado, and LT codes are examples VALIDATE(·)toacandidatereconstructionasreconstruc-
oferasurecodes. Reed-Solomon[29]codestypicallyre- tionvalidation.
quire O(n2) time to encode and decode; Tornado and
LT codes [15, 16] require O(n) time. Although Reed- 2.4.Pollutionattacks: DoSagainsterasurecodes
Solomon codes are slower, they have the advantage that
Adversariescandisruptthedecodingprocessbyintro-
reconstructing the original data is guaranteed to be suc-
cessfulifthedecoderhasatleastn−tencodingsymbols. ducing invalid symbols. If the decoder uses an invalid
symbol,itwillgenerateaninvalidreconstruction,causing
With Tornadoand LT codes, reconstructingwith at least
(n−t)·(1+(cid:1))encodingsymbolsissuccessfulwithhigh denialofservice.Wecallthisapollutionattack,andrefer
probabilityfor(cid:1)≈0.05. toanerasurechannelwithpollutionattacksasapolluted
erasurechannel.
Decoderscaneasilyrecoverfrompollutionattackswith
2.3.Terminologyandassumptions
onlyasmallnumberofinvalidsymbolsandnolostvalid
Weassumethereisasinglepartyauthorizedtoencode symbols. Sincebothvalidandinvalidsymbolscontainan
andsendmessages.Werefertothispartyasthelegitimate index,thedecodersimplylooksforduplicateindicesand
encoder. If the legitimate encoder encodes and sends a dropsbothsymbols. Ifatleastn−t symbolsremainaf-
messageD overthechannelto thedecoder,D is said to terdroppingduplicates,thedecoderwillrecoverthevalid
bevalid. IfamessageD wasneverencodedandsentby reconstruction.
the legitimate encoder over the channel, D is said to be Recoverybecomesmore difficult as the numberof in-
invalid. valid symbols increases. For example, suppose the de-
LetSbeasetofnsymbolsgeneratedbyanerasureen- coder receives only the first n−t valid symbols and an
coderwithinputD.Weassumenandthelossparametert adversaryinjectsoneinvalidsymbolineachofthosepo-
arefixedandknowntotheencoderandthedecoder.Each sitions. The decoder cannot simply drop the duplicates
symbolisanorderedpair(s i,i),1≤i≤n,soeachsym- sincenosymbolswillremain. Alternatively,thedecoder
bolcontainsits indexvalue. Thesymbolsin S arevalid could select one symbol from each position, executethe
symbolsof D ifthis encodingprocessis executedbythe decodingalgorithm,andapplyVALIDATE(·)toverifythe
legitimate encoder; other ordered pairs are invalid sym- authenticity of the candidate reconstruction. This ap-
bols.Weareconcernedaboutinvalidsymbolsinjectedby proach is ill-fated: the decoderis successful only if it is
anadversary.Givenasetofsymbolswhichincludesvalid luckyenoughtoselectthevalidsymbolineveryposition.
symbols and possibly invalid symbols, the decoder pro- Thiseventhasprobability 1 ,andintheworstcase,the
2n−t
duces a candidatereconstruction R. The reconstruction decoderwill produce2n−t candidatereconstructionsbe-
RisvalidwhenR=DforsomevalidDandinvalidoth- forethevalidoneisfound.
erwise. We assume erasuredecodingwith at least n−t
validsymbolsofD andnoothersymbolswillresultina 2.5.Threatmodel
validreconstructionofD.
Weassumethatanadversarycanobserve,inject,mod-
We assume the encoder and decoder have access to
TAG(·) and VALIDATE(·) algorithms, respectively. The ify, delay, and drop traffic in the channel between the
TAG(·) algorithm augments its input with some addi- sender and receiver. An adversary could be a compro-
tionalinformationthatenablestheVALIDATE(·)algorithm misedrouteronthepathbetweenthesenderandreceiver,
forexample.
to verify its authenticity. For correctness, we require
VALIDATE(TAG(R)) = true for all R. To guarantee au-
thenticity, we assume it is difficult for an adversary to Denialofserviceattacks DoSattackstakemanyforms,
forgeRsuchthatVALIDATE(R)=true. Wealsoassume dependingontheresourcetheyaretryingtoexhaust. An
the existenceof an algorithm STRIP(·) that strips off the adversary can attack the sender, the network infrastruc-
authenticationinformationadded by TAG(·). One possi- turebetweensenderandreceiver,andthereceiver. Inthe
ble instantiation of (TAG(·),VALIDATE(·)) is public key broadcastsetting,thesenderdoesnotacceptanydatafrom
signature generation and verification. See Appendix A thenetwork,sowewillassumethatthesenderisnotsus-
foraformaltreatmentofourauthenticityrequirementsfor ceptible to DoS attacks. We also do not consider band-
(TAG(·),VALIDATE(·)). widthexhaustionattacks,astheyareoutsideofthescope
To enable decoders to determine whether a candidate ofthispaper. Areceiverhaslittlerecourseifitslasthoprouterdropsallitstrafficorthousandsofzombiemachines
h
floodandoverloaditslasthoplink.Torecoverfromthese 1,8
attacks,receiversmustrelyonhelpfromtheinfrastructure
todetecttheproblemandtakeappropriateaction. Recent h h
1,4 5,8
researchresultsaddressthesechallenges[2,3,10]. How-
ever,wemustconsiderDoSattacksagainstthereceiver’s
h h h h
computation and storage resources. An attacker should 1,2 3,4 5,6 7,8
notbeabletoexhausttheseresourcestocauseDoS. h h h h h h h h
1 2 3 4 5 6 7 8
The attack factor is the ratio of the bandwidth of in-
jectedinvalidtraffictothebandwidthofvalidtraffic. For
s s s s s s s s
1 2 3 4 5 6 7 8
example, an attack factor of five implies that for every
1000 bytes of legitimate transmitted data, an adversary
Figure1.MerkleHashTrees.
injects 5000 bytes of invalid data. We are primarily in- Each leaf node h i is calculated by taking the hash of
terested in mediumbandwidthpollutionattacks, e.g., up the corresponding data item s i, and each internal node
to an attack factor of ten. We assume that beyondthese
is computed by taking the hash of the concatenation
values, theadversarywill saturatethechannelandcause of its two children. The shaded nodes h 4, h 1,2, and
largepacketlosswithinthenetwork. h 5,8 form a verification sequence of s 3. Given the leaf
element s and its verification sequence, one can re-
2.6.Cryptographicprimitives 3
construct and verify the root value h 1,8 by computing
Universalone-wayhashfunctions Weassumetheex- h(h(h 1,2,h(h(s 3),h 4)),h 5,8).
istence of families of universal one-way hash functions
(UOWHFs) [19]. UOWHFs satisfy a propertyknownas
target collision-resistance (TCR) [7]. U is called a fam-
ilyofUOWHFsifforallpolynomial-timeadversariesA,
Ahaslowprobabilityinwinningthefollowinggame: A
first chooses a message M, and then A is given a ran-
dom h(·) ∈ U. To win, A must output M(cid:1) (cid:4)= M such h i =h(s i),asleaves.Eachinternalnodeofthetreeisthe
that h(M(cid:1)) = h(M). This differs from any collision- hash of the concatenation of its two children, as in Fig-
resistance(ACR),inwhichtheadversaryhasthefreedom ure1.
to choose both M and M(cid:1) after she is given h(·). TCR Merkle hash trees have several nice properties. Each
hastwoadvantagesoverACR:(1)SinceTCRisaweaker internal node h i,j can be viewed as a hash digest of the
notion, it is believed to be easier to achieve in concrete dataitemss i,s i+1,...,s j,andtherootofthetreecanbe
instantiations. (2) Since M is specified before the hash viewedasthehashofthewholesetS. Iftheverifiercan
functionh(·), birthday paradoxattacks to find collisions verifytheauthenticityoftherootvalue,forexamplewith
donotdirectlyapply,andthehashoutputcanbehalfthe a signature, and has all of the data items overwhich the
sizeofanACRhashfunction. tree was constructed (and the corresponding positions),
In the multicast setting, adopting TCR allows adver- she can verify the authenticity of every data item by re-
saries to have complete control overthe underlyingdata constructing the hash tree and comparing the computed
in a stream, but only before transmission starts. If this rootvaluewiththeauthenticatedrootvalue.
assumptiondoesnothold,wemustreplacemostapplica- However,thedataitemsarenotindividuallyverifiable;
tionsofTCRhashfunctionswithACRhashfunctions,and torecalculatetherootvalue,theentiresetSisneeded.To
thatwouldincreaseouroverheadbyafactorlessthantwo. makeeachs iindividuallyverifiable,itmustbeaugmented
Fortheremainderofthis paper,we assumeall collision- withadditionalverificationinformation.Givenanitems,
resistanthashfunctionsareTCR. averifiercanrecalculatetherootofthetreeifitalsohas
the “sibling” nodes on the path from h(s) to the root of
Merklehashtrees Merklehashtrees[17]areamecha- the tree. We refer to this sequence of nodes as the ver-
nismforcomputingasinglecryptographicallysecurehash ification sequence of s. For example, in Figure 1, given
digestoverasetofdataitems. Merklehashtreesarecon- element s
3
and its verification sequence (h 4,h 1,2,h 5,8)
structedinthefollowingmanner. Leth(·)beacollision- (theshadednodes),onecanreconstructandverifytheroot
resistant hash function and let S = {s 1,s 2,...,s n} be value h 1,8 by computing h(h(h 1,2,h(h(s 3),h 4)),h 5,8).
a set of data items. For the sake of simplicity, suppose Ingeneral,eachverificationsequencerequiresθ(log(n))
that n = 2(cid:1)−1 for (cid:2) > 1. Then, we constructan (cid:2)-level space,andtheassociatedrootvaluecanbereconstructed
complete binary tree using the hashes of the data items, withθ(log(n))hashoperations.3.DistillationCodes mayadequatelyaddressoneortwooftheseproblems,but
untilthereisasignatureschemewithshortsignaturesthat
Weneedanewcodingschemetoaddresspollutedera-
arefasttogenerateandverifywithashortpublickey,dig-
surechannels.Wedefine
itallysigningeverysymbolisnotanoption.
DISTILLATIONCODING:
Errorcorrectingcodes Athirdapproachistouseerror
An(n,t)distillationcodeencodesamessageDintoa
correctingcodes(ECC).An(n,t)ECCencodesDinton
set ofn symbolsS = {s 1,s 2,...,s n} and transmits
symbolssuchthatthedecodercanrecoverD inthepres-
themoverapollutederasurechannel.Thecodeshould
enceofaalteredandeerasedsymbolsif2a+e≤t.ECC
satisfythefollowingproperties:
viewsinvalidsymbolssimplyaserrors.Thisapproachhas
Authenticity The distillation decoder should never several problems: ECC encoding produces longer sym-
outputaninvalidreconstruction. bols and ECC decoding is slower than in pure erasure
codes. Moreseriously,ECCisvulnerabletopollutionat-
Correctness SupposeforsomevalidD,T containsat tacks. Consideranattacksimilarto theonepresentedin
least n−t validsymbolsof D. Thenexecution Section 2.4, where the decoder has multiple choices for
ofthedistillationdecoderonT willoutputavalid the symbol to use at a particular position of the input to
reconstruction. the decodingalgorithm. If the numberof positions with
multiplechoicesis≥ t ,thenECCdecodingwillrequire
2
exponentialtimeaswell.
Wefirstpresentandanalyzethreenaivedistillationcodes.
3.1.Threestrawmanschemes 3.2.Ourapproach
Decode all possibilities One simple distillationcoding In this section, we introduce an efficient construction
schemeistomodifyanerasuredecodertotryallpossible ofdistillationcodes. Beforepresentingthedetailsofour
combinationsofn−tsymbolsandapplyVALIDATE(·)to construction, we review why the strawman schemes are
eachreconstructiontoidentifyavalidone. Ifthedecoder impracticalandmotivatehowweaddresstheirshortcom-
receives at least n − t valid symbols of some valid D, ings.
theneventuallyitwilluseacombinationcontainingonly Since adversaries can pollute the channel, decoders
validsymbolsofDandoutputavalidreconstruction.This must verifythe authenticityof reconstructions. Thesec-
approachhasaseriousproblem:anexponentialnumberof ondstrawmanapproachguaranteesthedecoderusesonly
executionsof the decodingalgorithmare requiredin the valid symbols in the decodingprocess, but under attack,
worstcasebeforeavalidreconstructionisfound. verifying every symbol overwhelms the receiver. To re-
ducethenumberofsignatureverificationsrequiredtoob-
tainavalidreconstruction,weauthenticatethereconstruc-
Digitally sign every symbol A second approach is to
tionsratherthanthesymbols.Wepartitionthesymbolsin
use a conventional erasure code and digitally sign each
awaythatdistillsthevalidsymbolsfromtheinvalidones,
symbol. The decoder authenticates each received sym-
and then decode each of the partitions and authenticate
bolandusesonlyvalidsymbolsinthedecodingprocess.
theresultingreconstructions.Sinceweonlyconsiderpar-
However, all knownsignature schemes have at least one
titionswithatleastn−tsymbols,adversariesmustinject
of following problems: (1) In most signature schemes,
atleastn−tsymbolstocauseanadditionaldecodingand
generatingsignatures is expensive. Digitally signingev-
verificationoperation.Ifthedecoderreceivesmsymbols,
ery symbol will overwhelm the computational resources
thenit executesat most(cid:6) m (cid:7) decodingandverification
oftheencoderforevenmodestvaluesofn. (2)Signature n−t
operationstorecoverthevalidreconstruction.
verificationcan also be expensive. Since, every injected
invalid symbol requires an additional signature verifica-
tion by the decoder, this creates a potential DoS attack. Partitioningthe symbols Suppose, givena set T con-
(3) Some digital signatures are large (e.g., 128 bytes for taining both valid and invalid symbols, the decoder can
RSA-1024). When the symbol size is relatively small, run an algorithm PARTITION SYMBOLS that partitions
includingalargesignaturewitheverysymbolisundesir- the symbols into Q = {Q 1,Q 2,...,Q k} satisfying the
able.(4)Someone-timesignatureschemeshaverelatively followingproperty:
smallsignaturesandfeaturefastsignaturegenerationand
verification. However, to enablemultiple signatures, the Definition1. [DistillationProperty]LetT beasetcon-
fastest variants require large public keys which are im- taining invalid and valid symbols. A set of partitions
practical to distribute [24, 30]. Some signature schemes Q = {Q 1,Q 2,...,Q k} of T satisfies the DistillationProperty if the following holds: if D = {D : D is valid the set S and produces a witness w for s. Verify(·,·,·)
and∃t ∈ T suchthatt isavalidsymbolofD},thenfor takes as input a conjectured element s of S, its wit-
all D ∈ D, one partition contains exactly all the valid ness w, and an accumulator a of S, and outputs b ∈
symbolsofD. {true,false}. Ifb = true,wedetermines ∈ S. Other-
wises∈/ S.
The distillation decoder can then erasure decode each
It must be hard to forge elements of S. That is,
Q i to obtain a set of candidate reconstructions. Assum- it must be hard to find an s(cid:1) ∈/ S and w(cid:1) such that
ing that for some valid D, at least n − t valid symbols
Verify(s(cid:1),w(cid:1),Accumulate(S)) = true, even if the at-
of D were receivedby the decoder, at least one of these
tackerhasseenothervalid(s,w)pairsanda.
candidates will be valid and can be found by running
Inmanyaccumulatorschemes,onecanrecovertheac-
VALIDATE(·).
cumulatora = Accumulate(S) ofa set S givenanele-
Thecompletespecificationforefficientdistillationde-
ments ∈ S anditswitnessw. Letthisprocessberepre-
codingisshowninFigure3.Whatremainsare:(1)anen-
sentedbythefunction
coding algorithm which enables the decoder to partition
the symbols, and (2) an efficient constructionof PARTI- Recover(s,w)→a.
TION SYMBOLS. Wedescribebothinthenextsection.
When Recover(·,·) exists for an accumulator scheme,
3.3.Distillation encodingusingone-wayaccumu- Verify(·,·,·) is typically implemented by verifying that
lators Recover(s,w) = a. In our instantiation of PARTITION
Inthissection,wepresentourimplementationsofdistil-
SYMBOLS,werelyontheRecover(·,·)functionanduse
itinaspecialway.Inparticular,withRecover(·,·)averi-
lationencodingandthealgorithmPARTITIONSYMBOLS.
fierdoesnotneedtoknowtheaccumulatoratodetermine
Inbothconstructionswemakeuseofone-wayaccumula-
tors. iftwoelementss i ands j belongtothesameset. Itonly
needstoverifythatRecover(s i,w i)=Recover(s j,w j).
Forthesakeofbrevity,wesaythatsandw hasaccumu-
3.3.1 One-wayaccumulators latorvalueaifRecover(s,w)=a.
Our construction of PARTITION SYMBOLS relies on a
secure set membership operation. We have a set T = 3.3.2 Implementing DISTILLATION ENCODE and
{t 1,t 2,...,t m} of received symbols and want to parti- PARTITION SYMBOLS
tion T into Q = {Q 1,Q 2,...,Q k} which satisfies the
To resist pollution attacks, the distillation encoder must
DistillationProperty. Notethattodothiswedonotneed
enablethedecoderto distill thevalidsymbolsofan era-
to determineif a givensymbolis valid. Instead, givena
validsymbol t of some D ∈ D and a set of symbolsQ, sure encodingfroma largerset of invalidones. Our en-
we would like to determine that t ∈ Q if Q is a set of coding algorithmaccomplishes this by accumulatingthe
validsymbolsofDandt∈/ Qotherwise.Iftisaninvalid set of valid symbols and then augmenting each symbol
symbolandQisasetofvalidsymbols,wewouldliketo with its witness. The full description of DISTILLATION
determinet∈/ Q. ENCODEisgiveninFigure2.
We can now use the Recover(·,·) algorithm of the
We build a secure set membership operation by using
one-way accumulator to implement PARTITION SYM-
one-wayaccumulators[4,8,9,12,20,32]. One-wayac-
BOLS. Recover(·,·) is evaluatedforeachreceivedsym-
cumulators combine a set of inputs into a single value
bol/witnesspair,andsymbolswiththesameaccumulator
calledan accumulator. Usingauxiliarywitness informa-
valueareputinthesamepartition. Thefullspecification
tion,onecanauthenticateanelementasamemberofthe
set.One-wayaccumulatorschemestypicallyincludethree
ofPARTITION SYMBOLS isgiveninFigure4. Foranad-
versarytocauseaninvalidsymboltobeplacedinthesame
functions:1
partition as the valid symbols implies that she is able to
Accumulate(S) → a breaktheone-wayaccumulatorscheme,i.e.,sheisableto
forgeanelementofthesetprotectedbytheaccumulator.
Witness(s,S) → w
Verify(s,w,a) → b
3.3.3 Merklehashtreesasaone-wayaccumulator
Accumulate(·) takes a set S of valuesas inputand out- Merkle hash trees [17] are attractive one-wayaccumula-
putsitsaccumulatora. Witness(·,·)takesans ∈ S and torsfordistillationcodes.2 WhenMerklehashtreesserve
1Fora more rigorous treatment of one-way accumulators, refer to 2There areseveral one-way accumulator schemes[4,8,9,12,32]
BenalohandMare[8]orBaricandPfitzmann[4]. basedonexponentiationmoduloanRSAmodulusandthe(strong)RSADISTILLATIONENCODE:
Input: AmessageD.
Output:An(n,t)distillationencodingofD,representedasasetS ={s 1,s 2,...,s n}.
1. LetD(cid:1) =TAG(D).
2. Constructan(n,t)erasureencoding(ERASURE ENCODE(·))ofD(cid:1). LetS(cid:1) = {s(cid:1) 1,s(cid:1) 2,...,s(cid:1) n}bethe
resultingsymbols.
3. Construct an augmented set of symbols S = {s 1,s 2,...,s n} where s i = (s(cid:1) i,w i) and w i =
Witness(s(cid:1),S(cid:1)). OutputS.
i
Figure2.Ouralgorithmfordistillationencoding.
DISTILLATIONDECODE:
Input: AsetT ={t 1,t 2,...,t m}containingvalidandinvalidsymbols.
Output:AvalidreconstructionorERROR.
1. InvokePARTITION SYMBOLSonT,resultinginpartitionsQ 1,Q 2,...,Q k.
2. Throw away all partitions containing less than n−t symbols. Let Q 1,Q 2,...,Q (cid:1) be the remaining
partitions.
3. (a) ForallQ i,replaceeachs=(s(cid:1),w)inQ iwiths(cid:1)(i.e.,stripoffwitnessinformation).
(b) Executetheerasuredecodingalgorithm(ERASUREDECODE(·))oneachQ i,resultingincandidate
reconstructionsR 1,R 2,...,R (cid:1).
4. RunVALIDATEoneachofR 1,R 2,...,R (cid:1). LetV ={R i : VALIDATE(R i)= true}. IfV = ∅,output
ERROR.Otherwise,randomlyselectanR i fromV andoutputSTRIP(R i).
Figure3.Ouralgorithmfordistillationdecoding.
PARTITION SYMBOLS:
Input: AsetT ={t 1,t 2,...,t m}containingvalidandinvalidsymbols,eachaugmentedwithwitnesses.
Validsymbolsarefroman(n,t)distillationencodingofD.
Output:AsetofpartitionsQ={Q 1,Q 2,...,Q k}ofT satisfyingtheDistillationProperty.
1. InitializeQtotheemptylist. LetAbealistofaccumulatorvalues,initializedtobeempty.
2. Fori=1tomdo
(a) Foreacht i =(s i,w i),calculatea=Recover(s i,w i).
(b) If a ∈/ A, adda to the endof A andadd{(s i,w i)} to the end ofQ. Otherwise, thereexists an
accumulatora j inAsuchthata=a j. Add(s i,w i)toQ j.
3. OutputQ.
Figure4.ImplementationofPARTITION SYMBOLS,usingone-wayaccumulators.as one-way accumulators [12, 17, 32], the size of wit- symbolsofD,thentheexecutionofDISTILLATION
nesses grows logarithmically with the size of the accu- DECODEonT willoutputavalidreconstruction.
mulated set. This is not a serious problemsince Merkle
DoS-resistance Distillation codes efficiently satisfy the
hashtreesrelyonlyoncryptographichashfunctions,and
above properties in the presence of medium band-
the accumulatorand witness generationandrecoveryal-
widthpollutionattacks(uptoanattackfactoroften).
gorithmsarefastandefficient.
Given a set S = {s 1,s 2,...,s n}, we implement the
one-wayaccumulatoroperationsasfollows: 3.4.1 Authenticity
Accumulate(S) → h
1,n
Theauthenticitypropertyisthatif(TAG(·),VALIDATE(·))
guaranteemessageauthenticity,thenDISTILLATIONDE-
Witness(s,S) → v
CODE willneveroutputinvalidreconstructions. Thisim-
Recover(s,v) → h(cid:1) 1,n plies that if DISTILLATION DECODE outputs R, then R
wasencodedandsentbythelegitimateencoder.Weprove
Theaccumulatorvalueh 1,n istherootvalueofaMerkle thispropertyinAppendixA.
hashtreeconstructedoverS asdescribedinSection2.6.
Thewitnessofanelementsistheverificationsequencev
3.4.2 Correctness
ofsinthesamehashtree. Recover(s,v)isimplemented
byreconstructingthecandidaterooth(cid:1) 1,n ofthehashtree To prove the correctness property, we must show that if
usingsanditsverificationsequencev. Givenanauthen- forsomevalidD,T containsatleastn−tvalidsymbols
ticated accumulator value h 1,n, Verify(s,v,h 1,n) is im- of D, then the executionof DISTILLATION DECODE on
plementedbyverifyingh(cid:1) 1,n = h 1,n. UsingMerklehash T willoutputavalidreconstruction.
trees,Accumulate(·)hasrunningtimeθ(n),andtheother
operationshaverunningtimeθ(log(n)). Theorem 1. Assume (TAG(·),VALIDATE(·)) guarantees
Even without an authenticated root, given the corre- authenticityofreconstructions,VALIDATE(D)=truefor
sponding verification sequences v i and v j, we can ver- all valid D, andthe underlyingone-way accumulatorin
ifythattwoelementss i ands j areelementsofthesame DISTILLATIONDECODEresistselementforgery.Suppose
setbycheckingthatRecover(s i,v i)=Recover(s j,v j). T containsatleastn−tvalidsymbolsofDforsomevalid
This is exactly the propertyneeded to implementStep 2 D. Thentheexecutionof DISTILLATION DECODE onT
in PARTITION SYMBOLS. Although the decoder cannot willoutputavalidreconstruction.
d Te ILte Lr Am Ti In Oe Nif Da En Ca Occ Du Em hu al sa cto or mv pa ll eu te edis ,Rau et ch oe vn eti rc (·u ,n ·)ti al lD loI wS-
s
Proof. Let Q = {Q 1,...,Q k} be the set of partitioned
symbols resulting from Step 1 of DISTILLATION DE-
PARTITION SYMBOLStocreateapartitionsofvalidsym-
CODE. Recall that the decoder partitions the symbols
bolswhichcontainnoinvalidones.
such that all the symbols in Q i share the same accumu-
lator value (i.e., there exists a such that for all (s(cid:1),w)
3.4.Securityanalysis: Pollutionresistanceofdis-
tillation codes
in Q i,Recover(s(cid:1),w) = a). In particular, if S(cid:1) is
a set of valid erasure code symbols created in Step 2
Weprovethreesecuritypropertiesofdistillationcodes: of DISTILLATION ENCODE applied to D, then for ev-
ery valid distillation code symbol (s(cid:1),w) resulting from
Authenticity If(TAG(·),VALIDATE(·))guaranteeauthen- Step 3 of DISTILLATION ENCODE, Recover(s(cid:1),w) =
ticity, then distillation codes also guaranteeauthen- Accumulate(S(cid:1)). Thus one partition, say Q v, contains
ticity.ThismeansthatDISTILLATIONDECODEwill
allthevaliddistillationcodesymbolsofD.
neveroutputinvalidreconstructions.
Now we show Q v contains no invalid symbols. Sup-
Correctness Suppose VALIDATE(D)=trueforallvalid pose,bycontradiction,thatQ vcontainsaninvalidsymbol
D, and (TAG(·),VALIDATE(·)) guarantee authentic- (s¯(cid:1),w¯). Ifa= Accumulate(S(cid:1)),thenRecover(s¯(cid:1),w¯)=
ity.IfforsomevalidD,T containsatleastn−tvalid a, implying Verify(s¯(cid:1),w¯,a) = true. However, since
s¯(cid:1) ∈/ S(cid:1), this violates the security condition for element
assumption. However, thesizeoftheaccumulator andwitnessareon forgery in one-way accumulators (Section 3.3.1). Thus,
t wh ie tno er sd se er so af nt dhe veR rS ifA yem leo mdu enlu tss, ia sn rd outh ge hlc yo em qp uu ivta at li eo nn tr te oq su igir ne ad tuto reg ge en ne era rate - Q v containsnoinvalidsymbolsandallthereceivedvalid
tionandverification.Wehavealreadyarguedthatthislevelofoverhead
symbolsofD.
isinfeasible. Since, by assumption |Q v| ≥ n − t, then
Nyberg [20] proposed a one-way accumulator scheme using only D(cid:1) = ERASURE DECODE(Q v) is successful. Since
h Ta hs ehi mng ainan dd rap wse bu ad co kra on fd Nom yben ru gm ’sb se cr hg ee mn eer ia sti to hn atb ta hs eed aco cn umBl uo lo am torfi vlt ae lr us e. VALIDATE(D(cid:1)) = true, then V (cid:4)= ∅ (from Step 4 of
mustbeontheorderofseveralthousandbytes. DISTILLATION DECODE), and the authenticity propertyofdistillationcodesimpliesV containsnoinvalidrecon- most(cid:6) nf −·n t(cid:7)+1erasuredecodingsandVALIDATE(·)calls.
struction. Therefore, DISTILLATION DECODE outputs a
validreconstruction. Thus, the most computation an adversary can cause
with a pollution attack with attack factor f is (f + 1)·
n·(log(n)+1)hashfunctionapplicationsand(cid:6) f·n(cid:7)+1
3.4.3 DoS-resistance n−t
erasuredecodingsandVALIDATE(·)executions.
Inthissection,we showdistillationcodescanefficiently
This analysis demonstrates a nice property of distilla-
satisfy the authenticity and correctness properties in the
tioncodes:thecomputationalworkloadofDISTILLATION
presence of medium bandwidth pollution attacks. This
DECODE scaleslinearlywiththebandwidthoftheattack
meansanadversarycannotcauseresourceexhaustionde-
and is independent of the attack traffic pattern. In Sec-
nialofserviceattacksagainstthereceivers.
tion4,weshowwhythispropertyofdistillationcodesis
useful for constructing DoS-resistant multicast authenti-
Computational DoS-resistance We first prove an cationprotocols.
upper bound on the extra computation an adversary To demonstrate what this upper bound means in con-
can cause with a pollution attack with attack factor f. crete terms, consider the case of a medium bandwidth
Consider the three expensive operations in distillation attack (f ≤ 10) where n = 128 and t = 64. Sup-
decoding: hashfunctionapplications,erasuredecodings, pose(TAG(·),VALIDATE(·))areRSA-1024signaturegen-
andVALIDATE(·)executions.
eration and verification, symbols are roughlythe size of
a network packet (1024 bytes), and one message is sent
Theorem2. In DISTILLATION DECODE, themostcom- per second. This corresponds to 128 encoding symbols
putation an adversary can cause with a pollution attack persecondofvalidtraffic, or1Mbpersecond. Foreach
withattackfactorf is(f+1)·n·(log(n)+1)hashfunc-
valid message sent by the encoder, the decoder will ex-
tion applications and
(cid:6)f·n(cid:7)+1
erasure decodings and ecute at most 11,264 hash function applications and 21
n−t
VALIDATE(·)executions.
erasuredecodingsandsignatureverifications.Thisisrela-
tivelyinsignificant:withtheseparameters,a2.4GHzPen-
Proof. To provethis upperbound, we calculate separate tium 4 machine running Linux can compute on average
upper bounds on the number of hash applications and 70,000 1024-byte SHA1 hashes per second, 1700 RSA-
the number of erasure decodings and VALIDATE(·) exe- 1024signatureverificationspersecond,and300(128,64)
cutions. Reed-Solomondecodingoperationspersecond. Wecon-
firm this analysis experientiallyin Section5 with anim-
plementationofdistillationcodes.
(1) Hash function applications: Every received sym-
bol triggers the execution of the accumulator operation
Recover(·,·). WithourMerklehashtreeimplementation Strongpollutionattacks Wenowdemonstrateapollu-
of one-way accumulators, this requires log(n)+1 hash tion attack which achieves this upper bound. To cause
functionapplicationspersymbol. Underattack factorf, PARTITION SYMBOLS to create a partition with n − t
thisresultsin(f+1)·n·(log(n)+1)totalhashfunction symbols,theadversarymustgenerateatleastn−tsym-
applications. bol/witness pairs that recover to the same accumulator
value. Todothis,anadversarygeneratesasetofrandom
symbols and runs Step 2 of DISTILLATION ENCODE to
(2) Erasure decodings and VALIDATE(·) executions: augmentthesymbolswithwitnessvalues. Theadversary
then injects the invalid symbol/witness pairs and repeats
I dn ect oh de inD gIS isTI eL xL eA cT uI tO edN iD
f
E aC nO dD oE nla ylgo ifrit Vhm AL, IDan ATe Er (a ·s )ur ie
s
thisprocessatotalof(cid:6) nf −·n t(cid:7)times.
executed. To trigger an additional erasure decoding
and VALIDATE(·) execution, the adversary must cause State-holding DoS-resistance We defer analysis of
DISTILLATION DECODE tocreateanadditionalpartition stateholdingattacksuntilSection4.5.3,whereweanalyze
containing at least n − t symbols. Since symbols are an applicationof distillation codes to multicast authenti-
only put into a single partition, creating an additional cation.
partitionwithatleastn−tsymbolsrequirestheadversary
to inject at least n − t symbols. This holds regardless
3.4.4 Messagereorderingandreplay
of the adversary’s attack method. Thus, with attack
factor f, an adversary can create at most (cid:6) f·n(cid:7) addi- Theauthenticityandcorrectnesspropertiesofdistillation
n−t
tionalpartitions,andDISTILLATIONDECODEexecutesat codesbythemselvesdonotpreventreplayandreorderingattacks.Thecorrectnesspropertyguaranteesthatifthele- fendagainstadversariallosspatterns,weneedasignature
gitimate encoder encodes and sends D over the channel amortizationschemethatcantoleratearbitrarypacketloss
and the decoder receives at least n−t valid symbols of within a block up to a predetermined number of pack-
D, then DISTILLATION DECODE will outputsomevalid ets. SAIDA uses erasure codes to achieve this. How-
reconstruction. D is not guaranteedto be the outputbe- ever, SAIDA is vulnerable to pollution attacks. PRABS
causean adversarycan replayvalidsymbolsfromprevi- combines distillation codes with the basic approach of
ousmessagesintothedecodingprocess. IntheStep4of SAIDAtoresistpollutionattacks,signatureflooding,and
DISTILLATION DECODE,V mightcontainmultiplevalid adversariallosspatterns. Beforewepresentthedetailsof
reconstructions,andonewillbeselectedrandomlyasthe PRABS, we first review SAIDA and discuss its vulnera-
output. bilitiestopollutionattacks.
Amoredesirablecorrectnesspropertyisthefollowing:
if T contains at least n − t valid symbols of D, then 4.1.SignatureAmortizationusingtheInformation
DISTILLATION DECODE willoutputD. Toachievethis, DispersalAlgorithm
we must add replayprotectionto (TAG(·),VALIDATE(·)).
InSAIDA,thesenderpartitionsthepacketstreaminto
Mostanyreplayprotectionmechanismisapplicable. For
blocks of n consecutive packets. Let h(·) be a crypto-
example, the TAG(·) algorithm can append a monoton-
graphic hash function, (PKSign(·,·),PKVerify(·,·,·))
ically increasing counter to D before authenticating it.
be a public key signature scheme, and (K ,K )
VALIDATE(D)firstverifiestheauthenticityofDandthen pub priv
be the public/private keypair of the sender. Then
v the ar tifi de es lat yhe mc eo su sn at ge er sv (a il .u ee .,i ds ef lr ives eh r. syT mo bh oa ln sd fl re oa mdv mer us la tir pie les for each block P j = pj 1,pj 2,...,pj n, the sender
f Tr Ie Osh Nv Da Eli Cd Om De Es )s ,a wge es ci an na exsi tn eng dle Dex ISe Tcu ILti Lo An To IOf NDI DST EI CL OL DA E-
c Ho jmput =es th he (pa
j
1u )t |h |hen (pti
j
2c )a |t |io ..n .||s htr (i pn
j
ng
)
H aj n| d|G H Gj, Hjwhe =re
tooutputmultiplevalidreconstructions. PKSign(K priv,h(H j)). GiventhehashstringH j andits
signatureG Hj,areceivercanauthenticateanypj
i
inblock
4. Pollution Resistant Authenticated Block j by verifying PKVerify(K pub,H j,G Hj) = true and
Streams thath(pj i)equalsthei-thentryinthehashstringH j.
Pollution Resistant Authenticated Block Streams
ThisprocessassumesthereceiverknowsH j andG Hj.
We would like to authenticateevery receivedpacket, re-
(PRABS)usedistillationcodestoconstructauthenticated
gardlessofthelosspatternofotherpacketsintheblock.A
multicast streams. PRABS builds on SAIDA (Signature naivesolutionistoincludeH jandG Hj witheverypacket,
AmortizationusingtheInformationDispersalAlgorithm)
butthisincurslargepacketoverhead.
[ P2 a2 r] k,
,
a Chm ou nl gtica as nt dau St ih ee gn et lica wti ho in chpr uo st eo sco el rap sr uo rp eos ce od deb sy
.
SAIDAconstructsan(n,t)erasurecodeoverH j||G
Hj
and includes one encoding symbol with each packet in
Pannetrat and Molva [21] present a protocol similar to
theblock.
Eachaugmentedpackettakestheformpj||sj
,
i i
SAIDA which has less overhead, but is slightly more wherepj isthei-thpacketintheoriginalblockandsj
is
i i
complex. Applying distillation codes to the Pannetrat- thei-thsymboloftheerasureencoding.Ifnomorethant
Molva construction results in a protocol with about 10
packetsarelostintransmission,thenthereceivercanre-
b siy mte ps licle its ys wo ef fo ov ce ur she oa nd SApe Ir Dp Aa .cket, but for the sake of constructH j||G Hj,verifyG Hj,andauthenticateeachof
thereceivedpackets.
SAIDA is a signatureamortizationscheme. Signature
amortizationschemes[11,18,21,22,26,33,35]amortize
4.2.PollutionvulnerabilitiesinSAIDA
thepacketoverheadandcostofgeneratingandverifying
a signature over many packets by dividing the multicast SAIDA is vulnerable to pollution attacks. If a single
streamintoblocks. Eachblockisthenauthenticatedwith invalid symbol is used in the decodingalgorithm, it will
asingledigitalsignature. failtoreconstructH j||G Hj.Park,Chong,andSiegelpro-
Signature amortization schemes differ mainly in their poseusingdistributedfingerprintstoremedythisproblem.
method for reliably transmitting the signature to the re- Distributedfingerprintscombineerasurecodeswitherror-
ceivers and individually authenticating each packet in correcting codes (ECC) to achieve robustness to sym-
the block. Previous approaches include hash graphs bolmodification[14]. InSAIDA,distributedfingerprints
[11,18,26,33],theWong-Lamscheme[35],anderasure augment each sj i with a symbol from an (n,t) ECC en-
codes[21,22]. coding of L j = h(sj 1)||h(sj 2)||...||h(sj n), where h(·)
AswediscussedinSection1,theseapproachestosig- is a collision-resistant cryptographic hash function and
nature amortization are vulnerable to pollution attacks,
{sj,sj,...,sj}
are the erasure encoding symbols of
1 2 n
signature flooding, and adversarial loss patterns. To de- H j||G Hj. The decoder reconstructs L j using ECC de-codingandverifies a candidatesymbols¯j bycomparing
i
h(s¯j i)tothei-thhashvalueinL j.
Park, Chong, and Siegel claim distributed fingerprints
preventDoSinSAIDA.3Althoughdistributedfingerprints
can handlesymbolmodification,they were notdesigned
to defend against pollution attacks where many invalid
symbols are injected. Since distributed fingerprints rely
onECC,theyarevulnerabletothepollutionattacks(Sec-
tion3.1).
4.3. Using distillation codes to prevent pollution
attacks
We now introduce Pollution Resistant Authenticated
Block Streams (PRABS). PRABS builds onSAIDA, but
uses distillation codes rather than erasure codes to resist
pollutionattacks.
InPRABS,thesenderpartitionsthepacketstreaminto
blocksofnconsecutivepackets,Forblockjcomposedof
packets P j = pj 1,pj 2,...,pj n the sender computes H j
(cid:0) j||h(pj )||h(pj )||...||h(pj). We assume each packetin- 1 2 n
cludesitsblocknumberandsequencenumberwithinthe
block. Now,ratherthanencodingH j||G Hj withan(n,t)
erasure code, we use an (n,t) distillation code. More
specifically, the sender applies DISTILLATION ENCODE
to inputD = H j. We define TAG(·), VALIDATE(·), and
STRIP(·)asfollows:
G
D (cid:0)
PKSign(K ,h(D))
priv
TAG(D)
(cid:0)
D||G
D
VALIDATE(D||G D)
(cid:0)
if(PKVerify(K pub,D,G D))
parseDas
j||h(p 1)||...||h(p n)
ifjisfreshreturntrue
returnfalse
STRIP(D||G D)
(cid:0)
tween the senderand the receiver, {rj,rj,...,rj } con-
1 2 m
tainssomesubsetoftheauthenticpacketsandsomenum-
ber of invalid packets injected by the adversary. Since
we are considering pollution attacks on receivers, we
are mostinterestedin the case when|invalidpackets| (cid:11)
|validpackets|.
Thereceiverparseseachaugmentedpacketrj aspj||tj
i i i
where pj represents an unaugmented packet of block j
i
and tj represents a symbol of the distillation encoded
i
authentication information H j. The receiver then ap-
plies DISTILLATION DECODE to the received symbols
{tj,tj,...,tj }. InStep4, thereceiverhasaset ofcan-
1 2 m
didatereconstructionsoftheformH j||G Hj andexecutes
VALIDATE(·)oneachonetoobtainV,thesetofvalidre-
constructions. To account for non-malicious delays and
reorderingsinthe network,wealter DISTILLATION DE-
CODEtooutputthecompletesetofvalidreconstructions
STRIP(V)
D
ApplyingDISTILLATIONENCODEtoH
j
resultsinndis-
tillation code symbols sj,sj,...,sj. The sender then
1 2 n augments each packet pj in the block with the corre-
i
spondingsymbolsj
andmulticaststheaugmentedpackets
i pj||sj
to thereceivers. This processis repeatedforeach
i i
block.
Let{rj,rj,...,rj }bethesetofreceivedpacketsfrom
1 2 m
blockj. Sinceweassumeapollutederasurechannelbe-
3For SAIDA, digital fingerprints are overkill. ECC is typically
moreexpensive thanerasurecodes,buttheadditional costisonlyno-
ticeable when the input is large. Digital fingerprints use ECC over
L = h(s 1)||h(s 2)||...||h(sn)wherethes iaretheerasureencoded
symbolsofsomedataD.|L|isrelativelysmallformodestvaluesofn,
andthusefficientforECC.However,when|D|isroughlyequalto|L|,
asitisinSAIDA(forn = 128,|D| = 1408vs. |L| = 1280),itis
moreefficienttosimplyuseECCdirectlyontheinputD.
(cid:0)
{STRIP(R):R∈V}
ratherthanasinglevalidreconstruction.
The authenticity propertyof distillation codes guaran-
teesallH j ∈STRIP(V)areauthentic,butthereceiverstill
needs to verify the authenticity of the underlyingpacket
stream. For eachH j ∈ STRIP(V), the receiverneeds to
verifytheauthenticityofallthepacketsclaimingtobein
blockj. Recallpj isannotatedwithitsspecificpositioni
i
inblockj,sothereceivercanauthenticatepj
byverifying
i
h(pj i)isequaltothei-thvalueinthehashstringH j.
The above description implicitly assumes the adver-
sarymountsthestrongpollutionattackdescribedinSec-
tion3.4.3(injectingaccumulatedrandomsymbol/witness
pairs).However,theadversarymayalsomountacut-and-
pasteattackwheresheinjectsinvalidpacketsaugmented
with symbol/witness pairs stripped from the valid pack-
ets. In the final step of verificationdescribedin the pre-
viousparagraph,thereceivermayhavemultiplepackets,
sayp(cid:1)j,p(cid:1)(cid:1)j,p(cid:1)(cid:1)(cid:1)j forapositionithatareaugmentedwith
i i i
thesamevalidsymbol.Inthiscase,thereceiverwillcom-
putethehashofeachofthesepacketsandcomparewith
thei-thpositioninthehashstringH j tofindtheauthentic
packet.
For each block, if no more than t out of n authentic
packetsarelostintransmission,PRABScanauthenticate
allreceivedpacketsintheblockregardlessofthepattern
of loss. Furthermore, in contrast to SAIDA, PRABS is
resistanttopollutionattacks. TheoperationofaPRABS
senderandreceiverisdetailedinFigure5.
4.4.Practicalconsiderations
EarlierinSection3,wepresentedDISTILLATION DE-
CODEasabatchalgorithm,wherewefirstcollectsymbols
andthenapplythedecodingalgorithmtoallthesymbols.r
1
r
2
r
3
r
4
rm
p
1
p
2
p
3
pn
j ||h(p 1) || h(p 2) || h(p 3) || || h(p n)
DISTILLATIONDECODE
PARTITIONSYMBOLS
Q Q Q
H 1 2 k
j
s1 s2 s3 sn ERASUREDECODE ERASUREDECODE ERASUREDECODE
DISTILLATIONENCODE
VALIDATE(·) VALIDATE(·) VALIDATE(·)
X X
p
1
p
2
p
3
pn
H j =j||h(p 1)||h(p 2)||···||h(p n)
(a)PRABSsender. Forblockj,thePRABSsender (b)PRABSreceiver. ThePRABSreceiver extracts
executes DISTILLATIONENCODEontheauthentica- thedistillationcodesymbolsfromthereceivedpack-
tion string H j = j||p 1||p 2||...||pn for the block ets and executes DISTILLATIONDECODE. Thede-
and augments each packet with a distillation code coder validates the resulting reconstructions, and if
symbol. sufficientlymanyvalidpacketswerereceived,outputs
thevalidauthentication stringH j fortheblock. Fi-
nally,thereceiverusesH jtoauthenticateeachofthe
receivedpackets.
Figure5.PollutionResistantAuthenticatedBlockStreams(PRABS)
In practice, andin particularforPRABS, it is moreeffi- Proof. WeassumeRSAsignaturegenerationandverifica-
cienttoimplementDISTILLATIONDECODEasanon-line tionguaranteesauthenticityofsignedmessages,andevery
algorithm,wherethepartitionsarecreateddynamicallyas receiverhas obtainedanauthenticcopyofthe legitimate
symbolsarriveoverthenetwork. Whenthesizeofapar- sender’s public key. We also assume h(·) is collision-
titionreachesn−t,itiserasuredecodedandvalidated. resistant hash function. Then by the authenticity prop-
The chief motivation for the on-line algorithm is to ertyofdistillationcodes(Section3.4.1andTheorem3in
avoid the tough decision of when to apply the batch de- AppendixA),everyoutputofDISTILLATIONDECODEis
codingalgorithm. Ideallyin the batch algorithm,the re- guaranteedtobeauthentic.
ceiver should not execute DISTILLATION DECODE until Therefore,if a receiverreceives anyn−t validpack-
itisconfidentithasfinishedreceivingallthepacketsina etsfromblockj,thenthemodifiedversionofDISTILLA-
particular block. The on-line decodingalgorithm avoids TION DECODEinSection4.3willoutputtheauthenticate
thisproblembytreatingeachpartitionindependentlyand hashstringH j =j||h(pj 1)||h(pj 2)||...||h(pj n)ofblockj.
decodingitonlywhenitbecomessufficientlylarge. The Givenanycandidatepacketp¯j fromblockj,areceivercan
i
onlyremainingproblemiswhentoreleasethememoryal- verifyitsauthenticitybycheckingwhetherh(p¯j )isequal
i
locatedforpartitionsthatneverreachn−tsymbols. We tothei-thhashentryinthehashstringH j. Anadversary
addressthisprobleminSection4.5.3. abletocauseareceivertoacceptaforgedpacketp¯j (cid:4)=pj
i i
impliessheisabletofindacollisiononh(·)atpj
.
4.5.Securityanalysis i
We analyze the security of PRABS in terms of packet
4.5.2 Messagereorderingandreplay
authenticity,replayprotection,andresistancetopollution
attacksusingourthreatmodelintroducedinSection2.5. Claim2. NovalidpacketinPRABSwillbeacceptedby
a receiver more than once, and for all authenticatedre-
4.5.1 Authenticity ceived packets, a receiver can reconstruct the order in
whichtheyweresent.
Claim1. IfareceiverinPRABSreceivesanyn−tvalid
packets from block j, it can verify the authenticity of all Proof. Letjdesignateapacket’sblockandidesignateits
packetsinblockj. positioninthatblock.Sincethereisaone-to-onemappingfrom(j,i) tothevalidpackets,afterH j is reconstructed second,and3700(128,64)Reed-Solomondecodingoper-
andpj is authenticatedandaccepted,allfuturecopiesof ationspersecond. Weverifythisanalysisexperimentally
i
pj canberejected. inSection5withanimplementationofPRABS.
i
(j,i) also determines a packet’s order in the stream. PRABS is resistant to signature flooding attacks be-
Althoughan adversarycan reorder the deliveryof pack- cause a signature is distributed among the all packets in
ets,afterareceiverauthenticatespj ,itcandeterminethe theblock. Tocauseasingleadditionalverificationoper-
i
properpositionofpj
inthestream.
ation, anadversarymustinjectat leastn−t packets. In
i
contrast to hash graphs and the Wong-Lam scheme, ad-
versariescancauseanadditionalverificationoperationby
4.5.3 DoS-resistance
injectingasinglepacket.
Computational DoS-resistance For computational
DoS-resistance, we consider the three expensive oper-
State-holding DoS-resistance In addition to computa-
ations in PRABS: hash function applications, erasure
tional DoS attacks, adversaries can launch state-holding
decodings,andsignatureverifications.
DoSattacksagainstreceivers,attemptingtoexhaustmem-
ory resources. For example, an adversary could accu-
Claim3. LetbbethebandwidthofPRABSinblocksper mulate and inject sets of less than n − t invalid pack-
second. Then the most computation an adversary can
ets (symbols) for block sequence numbers far into the
causeforreceiverswithapollutionattackwithattackfac-
future. A naive PRABS receiver will allocate space for
torf isb·(f +1)·(n·(log(n)+1)+n)hashfunction
thesepacketsandsymbolsandwaittoreceivesufficiently
applicationsand
b·((cid:6)f·n(cid:7)+1)
erasure decodingsand
n−t manysymbolsto reconstructthe authenticationinforma-
signatureverifications.
tion. For invalid block sequence numbers much greater
thanthecurrentvalidblocksequencenumber,thisattack
Proof. The denial-of-serviceresistance of PRABS relies
causesreceiverstoallocatelargeamountsofmemoryheld
ontheDoS-resistancepropertiesofdistillationcodes.For
until the valid sequence numbers catch up to the invalid
each packet a PRABS receiver receives, it extracts one
sequencenumbers.
distillation code symbol and uses it as input to DISTIL-
One solution to this attack is to limit the amount of
LATIONDECODE.ThenbyTheorem2,theadversarycan
causethereceivertoexecuteb·(f +1)·n·(log(n)+1) memoryallocatedtoPRABSreceiversandenforcesome
hashfunctionapplicationsandb·((cid:6) f·n(cid:7)+1)erasurede- reclamationpolicyonpacket(symbol)buffers. However,
n−t
choosinga reclamationpolicycanbe tricky. We needto
codingsandsignatureverifications.
be careful legitimate packets awaiting authenticationare
In addition, a receiver must check the authenticity of
eachreceivedpacketpj
. Thisrequirescheckingwhether
not freed prematurelyby some clever injection of attack
i
h(pj i)isequaltothei-thhashentryinH j,resultinginat traffic.
mostb·(f +1)·nhashfunctionapplications. To prove PRABS is resistant to these state-holding
Thus,withalegitimatetrafficrateofb blockspersec- attacks on memory resources, we show an upper bound
ond and attack factor f, the most computation an ad- on the memory requirements for PRABS receivers to
achieve the same authentication rate of valid packets
versarycan cause forreceiverswith a pollutionattack is
b·(f +1)·(n·(log(n)+1)+n)hashfunctionapplica- underattackaswhenthereisnoattack. Inourproof,we
tionsandb·((cid:6)f·n(cid:7)+1)erasuredecodingsandsignature assume an upper bound d on the maximum end-to-end
n−t
latency delay imposable by an adversary, and the same
verifications.
upperboundonnon-maliciousdelaysnormallyoccurring
Forexample,considerthescenarioofa1Mbpersecond within the network. We assume the sending rate of the
streamwithb=1,n=128,and1024bytepackets.With streamisr,andtheattackercaninjecttrafficatarateup
t = 64,hashoutputsof80bits,and1024bitRSAsigna- tof ·r.
tures, |(H j||G Hj)| ≈ 1408 bytes, and the resulting era-
surecodesymbolsareapproximately22bytes. For f = Claim 4. For arate r stream sendingn packetseachof
10, this requires receivers to execute to at most 11,264 size m, attack factor f, and maximum packet delay of d
22-byteSHA1hashespersecond,14081024-byteSHA1 seconds, if a PRABS receiver allocates at least r · (n ·
hashes per second, and 21 erasure decodings and signa- m/r+d)·(f+1)bytesofmemory,itwillnotdiscardany
ture verificationsper second. This is relatively insignifi- packetthatwouldhavebeenauthenticatedhadtherebeen
cant:withtheseparameters,a2.4GHzPentium4machine aninfiniteamountofmemoryavailable.
runningLinux can compute on average 540,00022-byte
SHA1hashespersecond,70,0001024-byteSHA1hashes Proof. SupposethePRABS receivermanagesits r·(n·
per second, 1700 RSA-1024 signature verifications per m/r + d) · (f + 1) byte packet cache with a FIFO re-placementpolicy.Wewillshowthatnopacketthatwould
havebeenacceptedhadtherebeenaninfinitesizedcache
willbediscarded.Thispropertywillallowustoconclude
thata boundedcachedoesnotaffectwhethera packetis
acceptedornot.
Supposethatthereisalegitimatepacketpthatisabout
to be evicted from the cache that would have been ac-
cepted with an infinitely sized cache. Since the receiver
hasnotauthenticatedp, p’s partitioncontainsfewerthan
n−t symbols. Forit to be acceptedat some later time,
thePRABSdecodermustreceiveatleastonemorepacket
fromitsblock,sinceallpacketsfromthesameblockshare
accumulatorvalues.But,weknowthatphasresidedinthe
cacheforatleast(n·m/r+d)seconds. Thisisbecause
thecacheusesaFIFOreplacementpolicy,itstotalcache
sizeisr·(n·m/r)·(f+1),andtrafficarrivesatarateless
than(f+1)·r.But,thelongesttransitdelayforapacketis
d,andtheencodersendsallpacketsfromthesameblock
withinn·m/rseconds.Thus,theencoderwillnotreceive
anyotherpacketfromp’sgroupaftern·m/r+dseconds.
Sincepwillneverbeacceptedaftern·m/r+dseconds,
ourassumptionthatpwouldhavebeenacceptedatsome
latertimeisfalse,anditissafetodiscardp.
4.6. Securely using smaller hash digests with
UOWHFs
Using a hash function with an 80 bit output to con-
structtheMerklehashtreeinourdistillationcoderesults
in10·log(n)bytesofoverheadpersymbol.Inthissection,
wedescribeanapplicationofUOWHFsthatleveragesthe
real-time nature of multicast to reduce this overhead by
close to a factor of two without affecting authentication
security. This optimization has no significant effect on
PRABS’sresistancetopollutionattacks.
Recall that with the target collision-resistance (TCR)
model for UOWHFs (Section 2.6), the sender chooses
a particular hash function from a family of TCR hash
functions and informs the receivers of the choice before
transmission begins. If we assume h(·) is a random or-
acle, we canconstructaTCR hashfunctionbychoosing
a randomsalt r and using the first k bits of output from
h r(x)
(cid:0)
tion for every block in PRABS. By revealing a new salt
value r at the start of eachblock’s transmission, thereis
asmallboundedamountoftimewherefindingacollision
on h r(·) is useful. After the receivers have successfully
receivedanddecodedthevalidauthenticationinformation
forablock,pollutionattacksagainstthatparticularblock
becomeimpossible.
Totakeadvantageofthisoptimization,theencoderand
decoderneedrelativelyfewchanges. Theencoderselects
a random salt r j for block j and uses h rj(·) in the con-
struction of the Merkle hash tree in Step 3 of DISTIL-
LATION ENCODE. To inform receivers of the salt value
r j,theencoderaugmentseachdistillationcodesymbolin
blockjwiththesaltvaluer j.
Todecode,inStep2aofPARTITIONSYMBOLS,thede-
coder parses each distillation code symbolas (r j,s(cid:1),w),
andrecoverstheaccumulatorvaluea = Recover(s(cid:1),w)
usingh rj(·) as theunderlyinghashfunction. Toprevent
adversariesfrombreakingtheaccumulatorbyfindingcol-
lisionsusingdifferentsaltvalues,Step2bof PARTITION
SYMBOLS(·)canpartitionbasedonboththeaccumulator
valueandtheadvertisedsaltvalue.
SecurityAnalysis Sinceweareshorteningonlytheout-
putofthehashfunctionusedintheMerkletree, andnot
theoutputofthehashfunctionusedintheauthentication
stringH j,thischangeonlyaffectsDoS-resistanceandnot
packetauthenticity.
Foranadversarytolaunchasuccessfulpollutionattack,
shemustfindacollisiononh rj(·)intheMerkletreeover
thesymbolsinblockj. Ifthelengthofsaltvaluesissuf-
ficiently long to preventlongrunningattacks that iterate
overallpossiblevaluesofr j,thentheadversarymustwait
untilthesenderdisclosesr j beforeshetriestofindacol-
lisionintheMerkletree.
Sincecollisionsareuselessafterthereceivershavere-
ceivedallthelegitimatepacketsinablock,ifweassume
adversaries can delay packets by at most d seconds and
each block requiresc seconds to send, then we must se-
lectk suchthatgivenr,adversarieshavelowprobability
infindingacollisiononh r(·)ind+cseconds.Afterthis
h(r||x||r). This is called the envelope method time,receivershavepresumablyreceivedandacceptedall
[13]. Assuming h(·) and k are agreed in advance, the thevalidpacketsfromtheblock,andfurtherpacketsfrom
sender only needs to informthe receivers of the random thatblockarerejected.
valuer. Forblocksizen,theadversarywinsifshefindsacol-
Toreducetheoverheadofdistillationcodesymbols,we lision on any of the n symbols in a block. If an adver-
would like to to use a hash function with a shorter out- saryhashes2k−log(n) randomvalues,thenshewillfinda
put, say 40 bits, for constructing the Merkle trees. Un- collisionononeofthesymbolswithnon-negligibleprob-
fortunately,shorteningthehashoutputreducescollision- ability. For block size n, we must choose k such that
resistance. A 40 bit output provides only about O(240) 2k−log(n) isanintractableamountofworkformassively
security, and an adversaryis likely to find a collision on parallelized adversaries to complete in d + c seconds.
h r(·)duringthelifetimeofalonglivedstream.However, Suppose n = 128, one block is transmitted per second,
thereisnoreasontonecessarilyusethesamehashfunc- andthemaximumadversarialdelayis10seconds. Giventhata2.4GHzPentiumIVmachinecancomputeroughly 140
540,000instancesof22-bytehashfunctionoperationsper
second,choosingk = 40bitsrequiresroughly1450ma- 130
chinestocompletethenecessaryworkbeforethereceivers 120
havefinishedreceivingtheblock.
Theremainingquestionisthevalueof|r|.If|r|issmall, 110
adversaries can launch long running attacks which iter- 100
ate over all values of r and hash 2k random values for
eachh r(·). We can boundthe effectivenessoflongrun- 90
ningattacksbyusingalongperstreamsaltdisseminated
80
toreceiversimmediatelybeforetransmission,butwestill
mustbeconcernedwithlongrunningattacksoverthelife- 70
timeofthestream. Iteratingoverallpossiblevaluesofr
requires about O(2|r|+k−log(n)) work to achieve a non- 60
4 8 16 32 64 128 256 512 1024
negligible success probability, but a birthday attack can Block size in packets
reduce this slightly. By the birthday paradox, if the ad-
versaryhashes2k−log(n) randomvaluesfor2|r 2| valuesof
r,thentheadversarywillseeacollisionafter2|r 2|
blocks
withnon-negligibleprobability.Forn=128andk =40,
choosing the |r| = 64 bits requires roughly 265 opera-
tionsforanadversarytobesuccessfulafter232legitimate
blockshavebeensent.
Westressagainthisoptimizationhasnoeffectonpacket
authenticity.Theauthenticationmechanismisunchanged;
hash outputs in the authentication string are 80 bits and
signedbyafullstrengthdigitalsignature. Ifanadversary
candelaypacketsmorethand secondsorapplymassive
computingpowertofindacollisionintheMerkletreein
less thand seconds,shecanonlycausedenialofservice
andcannotviolateauthenticity.
Overhead reduction The overhead savings of using a
saltedhashfunctionconstructionintheMerkletreeissub-
stantial. Using an unsalted hash function with an 80 bit
output results in Merkle hash tree verification sequence
lengthsof10·log(n)bytes.Usingthesaltedhashfunction
witha40bitoutputanda64bitsaltvalueyieldsverifica-
tionsequencesoflength5·log(n)bytesandanadditional
8bytesforthesalt.Thisprovidescomparablesecurityfor
precomputationattacks and saves (5·log(n)−8) bytes
persymbol.Weshowtheoverheadsavingsofsaltingwith
UOWHFsinFigure6.
5.Implementationand Measurements
We implemented PRABS and measured its perfor-
mance. Our goalwas to builda multicast authentication
protocolthatcouldefficientlyoperateevenwhenanadver-
sarysends10timesasmuchtrafficastheoriginalstream.
The protocol and test harness were implemented in
2,300linesofC++code. Thesendingandreceivingma-
chineseachhada2.4GHzPentium4processorand1GB
ofRAM.BothmachineswererunningLinux2.4kernels
setyb
ni
daehrevo
tekcaP
80 bit hash
40 bit hash
Figure6.PRABSpacketoverhead.
This graph shows the effect of block size on packet overhead
in PRABS using an (n,n) distillation code. The total packet 2
overheadis(10·n+|G|)· 2 +log(n)· k +|r|bytes,witha
n 8
k bithashoutputintheMerkletree,|r|bytesalt,and|G|byte
signature.Theplotislogscalewith|r|=8and|G|=128.We
showthesavingsofsaltingand40bithashoutputsintheMerkle
treevs.nosaltingand80bitoutputs.Forsmallerblocksizes,the
erasureencodingdominatestheoverhead,butbecomessmallas
ngrows. Forlargern,thewitnessinformationforeachsymbol
dominates.
andgcc 2.95. Theyareconnectedbya100Mb/slow-
latency switched network. We relied on the OpenSSL
library[1] for cryptographicfunctions and a Rizzo’s era-
surecodelibrary[31]. WeusedRSA-1024fortheTAG(·)
andVALIDATE(·)algorithms. WeusedtheSHA1crypto-
graphichashfunctionwith40bitoutputs(Section4.6)for
the Merkle tree and 80 bit outputs for the authentication
string.
Theserversentastreamofdatapacketsatavarietyof
rates and attack factors. We measured the receiver load
when receiving two streams: 1Mb per second and 4Mb
persecond. OurPRABS streamused128packetblocks,
where each packet had a 1024 byte data payload. For
each stream, we looked at attack factors between 0 and
10.Withattackfactor10againstthe4Mb/sstream,theat-
tackerinjects40Mb/sofattacktraffic. Recallthatthead-
versaryonlyneedstoinject64packetstoinduceadecode
operation;byinjecting72packets, theadversaryensures
that64packetswillarriveatthereceiverandcancausethe
receivertoprocess18timesasmanymaliciousblocksas
legitimateblocks.
Our tests measure the performanceof the client under
the worst case. For example, reconstruction data with a
systemicerasurecodeismuchslowerwhenusingthepar-
itypackets(packets64-127).Ouradversaryinducesaloss20
18
16
14
12
10
8
6
4
2
0
0 5 10 15 20 25
Time (s)
)%(
noitazilitU
rossecorP
revieceR
20
18
Attack Period
Attack Factor: 10x
16
14
12
10
8
6
4
2
0
0 1 2 3 4 5 6 7 8 9 10
Attack Factor
(a)Processor utilization measured once persecond to thenearest
percent at thereceiver while receiving a4Mbper second stream.
Duringthe attack phase, the adversary sendsa10timesasmuch
malicioustrafficaslegitimatetraffic. Thiscorrespondsto18times
asmanymaliciousblocksoftraffic.Thereceiver’sprocessorutiliza-
tionincreasesduringthisphase,butremainsbelow15%.Outsideof
theattackphase,authenticating thestreamconsumeslessthan2%
oftheCPU.
)%(
noitazilitU
rossecorP
revieceR
(b)Thisgraphillustratestherelationshipbetweenprocessoruti-
lization and the attack factor. Recall that the attack factor is
thebandwidthmultiplierofmaliciouspacketsthattheadversary
injects. Theprocessorutilization exhibitsalinearrelationship
withrespecttotheattackfactor. Eachdatapointisanaverage
from3separateruns.
Figure7.ProcessorutilizationwhilerunningPRABS.
of 48 legitimate non-parity packets to force the receiver 6 RelatedWork
reconstructitsdatausingmostlytheparitypackets. Like-
TESLAisabroadcastauthenticationschemewithmany
wise,theadversarychoosestoinjectparitypacketsaswell
attractiveguarantees: authenticity,lowoverhead,robust-
to increase the receiver’s load using the strong pollution
ness to loss, and DoS resistance [25, 27]. However,
attackdetailedinSection3.4.3.
TESLArequirestimesynchronizationbetweenthesender
Ourfirsttestmeasuredtheprocessorloadontheclient
andthereceiver.Foreachblock,thesenderpicksthenext
as it received a music file. The attacker then began an
key in a one-way key chain and appends a message au-
injectionattackonanexistingstreamwithanattackfac-
thentication code [5] to each packet in that block. The
torof10. We measuredthereceiver’sprocessutilization
senderlaterpublishesthekey. Receiversvalidatethekey
oncepersecondtothenearestpercent.Theresultsforthe
usingtheone-waychainandonlyacceptpacketsauthen-
4Mb/s stream are presented in Figure 7(a). With no at-
ticatedwiththatkeythatarrivebeforeitwasdisclosed.
tack, the receiveruses onlya small fractionof the CPU.
Previous work has addressed erasure symbol corrup-
Usually it was measured at 0%, and at all times it was
tioninthecontextofdistributedstorage. Krawczykpro-
under 2%. Under heavy attack, the receiver’s CPU load
poseddistributedfingerprints,anapplicationoferrorcor-
increasesto 10%, but alwaysremainsbelow15%. For a
rectioncodes(ECC)inconjunctionwitherasurecodesto
1Mb/s stream, the receiver’s CPU averaged3.6% during
detect altered symbols [14]. However, as discussed in
afactor10attack. Forbothstreams,thereceiversuccess-
Section 3.1, ECC is also vulnerableto pollutionattacks.
fullyauthenticatedallreceivedpackets.
Distributed fingerprintswork well when invalid symbols
Thesecondtestmeasuredtheprocessorutilizationasa
areguaranteedtoreplacethevalidsymbols,butnotwhen
functionoftheattackfactor.Wedisplaytheresultsforthe
thereispollution.
4Mb/sstreaminFigure7(b).Thegraphhighlightsthelin-
Weatherspoonetal. proposedaschemesimilartoours
earrelationshipbetweentheprocessorutilizationandthe
fordetectingcorruptedsymbolsinthedistributedarchival
attackfactor,confirmingouranalysisfromSection3.4.3.
system of Oceanstore [34]. However, similar to dis-
tributed fingerprints, they do not consider pollution at-
tacks where additional invalid symbols are injected into
thedecodingprocess.7.Conclusion policiesorendorsements,eitherexpressorimplied,ofthe
USGovernmentoranyofitsagencies.
Distillation codes enable systems to store or transmit
information that is robust against packet loss, pollution
References
attacks, and modification of transmitted packets. We
demonstratedthe potential of distillation codes by intro- [1] OpenSSL. http://www.openssl.org/.
ducingPRABS,annewDoS-resistantmulticastauthenti- [2] D. Adkins, K. Lakshminarayanan, A. Perrig, and I. Sto-
cationprotocol.PRABSissecureagainstawidevarietyof ica. TamingIPpacketfloodingattacks. InProceedingsof
Workshop on Hot Topics in Networks (HotNets-II), Nov.
pollution attacks without requiring significant overhead,
2003.
eitherinthespacerequiredtorepresentsymbolsorinthe
[3] T.Anderson,T.Roscoe,andD.Wetherall. PreventingIn-
computationaleffortrequiredtoencodeanddecodemes-
ternetdenial-of-service withcapabilities. InProceedings
sages. Distillationcodesarefast,general,andsecure,but
ofWorkshoponHotTopicsinNetworks(HotNets-II),Nov.
moreimportant,theyaredesignedtofacerealistic,hostile
2003.
threatmodels. [4] N. Baric and B. Pfitzmann. Collision-free accumulators
We hypothesize that distillation codes are applicable andfail-stopsignatureschemeswithouttrees.InAdvances
in a variety of contexts. Consider the example of a dis- in Cryptology – EUROCRYPT’97, volume 1233 ofLec-
tributedInternet-widefileservice. Auserwishestostore tureNotesinComputerScience,pages480–494,1997.
a file across multipleuntrustedrepositoriesand hopesto [5] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash
functions for message authentication. In Advances in
recoverhis file at a later date. Assume that the user can
Cryptology–CRYPTO’96,volume1109ofLectureNotes
nottrustanysinglemachinetopermanentlystoretheen-
inComputerScience,pages1–15,1996.
tire file or metadata about the file. One approach is to
[6] M. Bellare and C. Namprempre. Authenticated encryp-
dividetheoriginalfile intoshares, andthensigneachof
tion: Relationsamongnotionsandanalysisofthegeneric
thesharesastheyaredistributedtodifferentmachines.By compositionparadigm. InAdvancesinCryptology–ASI-
producingsharesthatstoreredundantinformation(along ACRYPT’00,volume1997ofLectureNotesinComputer
thelinesofsecretsharing,theinformationdispersalalgo- Science,pages531–545,2000.
rithm,orerasurecodes),wecanchecktoensurethatnone [7] M. Bellare and P. Rogaway. Collision-resistant hash-
oftheshareshavebeentamperedwith. However,ifshare ing: TowardsmakingUOWHFspractical. InAdvancesin
Cryptology–CRYPTO’97,volume1294ofLectureNotes
reconstructiontakesplaceonaheavilyloadedfile server
inComputerScience,pages470–484,1997.
thatissimultaneouslyreconstructingmanydifferentfiles,
[8] J. Benaloh and M. de Mare. One way accumulators: A
thismayyieldanunreasonableload. Incontrast,wecan
decentralizedalternativetodigitalsignatures.InAdvances
imagineasystemthatsignstheoriginalfile,andthenuses
inCryptology–EUROCRYPT’93,volume765ofLecture
distillationcodestorapidlyreconstructthefile.Whilefur-
NotesinComputerScience,pages274–285,1993.
therinvestigationisrequired,wehypothesizethatdistilla- [9] J. Camenisch and A. Lysyanskaya. Dynamic accumula-
tioncodes mayyieldgoodperformanceinthis situation. torsandapplicationtoefficientrevocationofanonymous
Similarly,othercaseswheredatamustbesegregatedand credentials. In Advances in Cryptology – CRYPTO’02,
thenreconstructedmayalsobefertilegroundforexplor- volume2442ofLectureNotesinComputerScience,pages
ingthepotentialofdistillationcodes. 61–76,2002.
[10] V.Gligor.Guaranteeingaccessinspiteofservice-flooding
attacks. In Proceedings of the Security Protocols Work-
Acknowledgements
shop,Apr.2003.
[11] P.GolleandN.Modadugu. Authenticatingstreameddata
Thisworkwassupportedinpartbyresearchgrantsand
inthepresenceofrandompacketloss. InProceedingsof
contractsfromtheNationalScienceFoundation,theDe-
the Symposium on Network and Distributed Systems Se-
fenseAdvancedResearchProjectsAgency,theUSPostal curity (NDSS 2001), pages 13–22. Internet Society, Feb.
Service, theArmyResearchOffice, theCenter forCom- 2001.
puterand CommunicationsSecurityat CarnegieMellon, [12] M.Goodrich,R.Tamassia,andJ.Hasic. Anefficientdy-
and gifts from Bosch, Intel, KDD, and Honda. Michael namicanddistributedcryptographicaccumulator. InPro-
Lubyhelpedmotivatethisworkandguidedusinitsearly ceedings ofInformationSecurityConference (ISC2002),
volume2433ofLectureNotesinComputerScience,pages
stages.DavidWagnerprovidedextensiveguidanceonour
372–388,2002.
proofs of security and Rob Johnson helped with our se-
[13] B.KaliskiandM.Robshaw. Messageauthenticationwith
curity analysis. We thank the anonymousreviewers and
MD5. RSACryptobytes,1(1):5–8,Spring1995.
DianaSmettersforhelpfulcommentswhichsignificantly
[14] H.Krawczyk.Distributedfingerprintsandsecureinforma-
improvedthequalityofourpaper. Theviewsandconclu- tionaldispersal. InProceedingsof13thACMSymposium
sions containedhere are those of the authors and should on Principles of Distributed Computing, pages 207–218.
not be interpretedas necessarilyrepresentingthe official ACM,1993.[15] M. Luby. LTcodes. In Proceedings of the 43rd Annual [31] L. Rizzo. Effective erasure codes for reliable computer
IEEE Symposium on Foundations of Computer Science communication protocols. ACM Computer Communica-
(FOCS’02),pages271–282,2002. tionReview,27(2):24–36,Apr.1997.
[16] M.Luby,M.Mitzenmacher,A.Shokrollahi,D.Spielman, [32] T. Sander. Efficient accumulators without trapdoor ex-
and V. Stemann. Practical loss-resilient codes. In Pro- tendedabstracts. InInformationandCommunicationSe-
ceedings of 29th Annual ACM Symposium on Theory of curity,SecondInternationalConference–ICICS’99,vol-
Computing(STOC’97),pages150–159,May1997. ume 1726 of Lecture Notes in Computer Science, pages
[17] R.Merkle.Protocolsforpublickeycryptosystems.InPro- 252–262,1999.
ceedingsoftheIEEESymposiumonResearchinSecurity [33] D.Song,D.Zuckerman,andJ.D.Tygar.Expandergraphs
andPrivacy,pages122–134,Apr.1980. for digital stream authentication and robust overlay net-
[18] S. Miner and J. Staddon. Graph-based authentication of
works. In Proceedings of the IEEE Symposium on Re-
digital streams. In Proceedings of the IEEE Symposium
searchinSecurityandPrivacy,pages258–270,May2002.
onResearchinSecurityandPrivacy,pages232–246,May
[34] H.Weatherspoon, C.Wells,P.R.Eaton, B.Y.Zhao, and
2001.
J. D. Kubiatowicz. Silverback: A global-scale archival
[19] M.NaorandM.Yung. Universalone-wayhashfunctions
system.TechnicalReportUCB//CSD-01-1139,University
and their cryptographic applications. In Proceedings of
ofCaliforniaatBerkeley,2000.
the21stAnnualACMSymposiumonTheoryofComputing
[35] C. Wong and S. Lam. Digital signatures for flows and
(STOC’89),pages33–43,May1989.
multicasts. InProceedingsonthe6thInternationalCon-
[20] K.Nyberg. Fastaccumulated hashing. In FastSoftware
ferenceonNetworkProtocols(ICNP‘98),pages198–209.
Encryption–ThirdInternationalWorkshop,volume1039
IEEE,October1998.
ofLectureNotesinComputerScience,pages83–87,1996.
[21] A.PannetratandR.Molva. Efficientmulticastpacketau-
thentication.InProceedingsoftheSymposiumonNetwork A. Security Analysis of Distillation Codes:
andDistributedSystemSecuritySymposium(NDSS2003). Authenticity
InternetSociety,Feb.2003.
[22] J. M. Park, E. Chong, and H. J. Siegel. Efficient mul- WewillshowthatiftheTAG(·)andVALIDATE(·)algo-
ticast packet authentication using erasure codes. ACM
rithmssatisfyintegrityofplaintext,thenadistillationcode
Transactions on Information and System Security (TIS-
usingthesealgorithmsalsosatisfiesintegrityofplaintext.
SEC),6(2):258–285,May2003.
We will adapt Bellare and Namprempre’s notion of in-
[23] J.M.Park,E.K.Chong,andH.J.Siegel. Efficientmulti-
castpacketauthenticationusingsignatureamortization.In
tegrity of plaintext(INT-PTXT) [6] to the public key set-
ProceedingsoftheIEEESymposiumonResearchinSecu- ting. Note that their definition was in the context of en-
rityandPrivacy,pages227–240,May2002. cryptionanddecryptionalgorithms,whileweframeours
[24] A.Perrig. TheBiBaone-timesignatureandbroadcastau- intermsofencodinganddecodingalgorithms.
thenticationprotocol. InProceedingsoftheEighthACM
Conference on Computer and Communications Security
Definitions & Notation We definea publickeyencod-
(CCS-8),pages28–37,PhiladelphiaPA,USA,Nov.2001.
[25] A.Perrig,R.Canetti,D.Song,andJ.D.Tygar. Efficient ing scheme PKE = (K,E,D) to consist of three al-
and secure source authentication for multicast. In Pro- gorithms. The randomized key generation algorithm K
ceedings of the Symposium on Network and Distributed takes a natural number k ∈
SystemsSecurity(NDSS2001),pages35–46.InternetSo-
ciety,Feb.2001.
[26] A. Perrig, R. Canetti, J. D. Tygar, and D. Song. Ef-
ficient authentication and signature of multicast streams
overlossychannels. InProceedingsoftheIEEESympo-
sium on Research in Security and Privacy, pages 56–73,
May2000.
[27] A.PerrigandJ.D.Tygar. SecureBroadcastCommunica-
tion inWired and Wireless Networks. KluwerAcademic
Publishers,2002.
[28] M.Rabin. Efficientdispersalofinformationforsecurity,
loadbalancing, andfaulttolerance. JournaloftheACM,
36(2):335–348,1989.
[29] I.Reed and G.Solomon. Polynomial codes over certain
finitefields. JournaloftheSocietyforIndustrialandAp-
pliedMathematics,8(2):300–304,1960.
[30] L. Reyzin and N. Reyzin. Better than BiBa: Short one-
timesignatureswithfastsigningandverifying. InSeventh
AustralasianConferenceonInformationSecurityandPri-
vacy(ACISP2002),July2002.
(cid:0)
as its security parame-
ter and outputs a public key K and private key K :
pub priv
(K ,K ) ←R− K(k). The encodingalgorithm E uses
pub priv
theprivatekeyK toencodeamessageM intoacode-
priv
text C, possibly using a randomization source: C ←R−
E K (M). The decoding algorithm D uses the public
priv key K to authenticate the codetext C. It returns a
pub
plaintext if it can authenticate the codetext, or ⊥ if it
cannot validate the codetext: P⊥ ← D K (C) where pub
P⊥ ∈ {⊥}∪{0,1}∗. Forall encodingschemes, we re-
quireM =D K (E K (M))
pub priv
We nowprovideanauthenticitydefinitionforapublic
keyencodingschemePKE(K,E,D). Averificationalgo-
rithmD∗ takes acodetextandreturnsabooleanvalue
K
pub
indicatingwhetherthedecodingwassuccessful:
ALGORITHM D K∗ :C ∈{0,1}∗ (cid:15)→{0,1}
pub
ifD
K
(C)(cid:4)=⊥return1
pub
return0WeallowanadversaryaccesstoK ,anencodingora-
pub
cle,aswellasaverificationoracleinordertotrytobreak
the encoding scheme. The adversary is able to violate
the integrity of the encoding scheme if it can produce a
codetextwhoseplaintextwas neverpassedto theencod-
ing algorithm E K (·). If it is computationally difficult
pub
foranadversarytoproducesuchaplaintext,theencoding
scheme is said to offerintegrityof plaintext, abbreviated
INT-PTXT.
Definition2. Integrityofapublickeyencodingscheme
Let PKE(K,E,D) be a public key encoding scheme.
Letk ∈
(cid:0)
andAbeanadversarythathasaccesstoanen-
codingoracleE(·)andaverificationoracleD∗(·). Then,
considerthefollowingexperiment:
EXPERIMENTExp
PKE,A
:k ∈
(cid:0)
(cid:15)→{0,1}
(K ,K )←R−K(k)
pub priv
ifA toE DKp ∗riv(·) (, ·D )K∗
sp uub
c( h·) t( hk a, tK
:
pub)makesaquery
K
D K∗ pp uu bb (C)=1andD K pub(C)was
neveraquerytoE
K
(·)
priv
thenreturn1
elsereturn0
Theadvantageoftheadversaryistheprobabilitythatthe
adversarycanproduceaquerytothedecoderthatreturns
successforwhichthecorrespondingplaincodewasnever
passedtotheencoder.Specifically:
AdvPKE,A(k) (cid:0)
(cid:1) (cid:2)
Pr Exp (k)=1 PKE,A
We definetheadvantagefunctionoftheschemeinterms
ofτ,therunningtimeoftheadversary,q e,thenumberof
queriestheadversarymakestotheencodingalgorithmE
withtotallengthµ e,andq d,thenumberofqueriesthead-
versarymakestotheverificationalgorithmD∗ withtotal
lengthµ d as:
Adv PKE(k,τ,q e,q d,µ e,µ d)
(cid:0)
bolsor⊥torepresentamissingsymbol:s⊥||s⊥||...||s⊥
1 2 n
wheres⊥
i
∈{⊥,s i}.
We set r to bethe inputmessagesize; (n,t) represent
theerasurecodingparameters: n thenumberofencoded
symbolspermessage,andtthemaximumnumberofsym-
bolsthatcanbelostforsuccessfulreconstruction;mtobe
thesizeoftheencodederasuresymbols;andf themaxi-
mumattackfactor,asdefinedinSection2.5.Weconsider
all oftheseas fixedparametersfora particularinstantia-
tionofPKEV
.
Weabstractdistillationcodekeygeneration,encoding,
anddecodingalgorithmsfromFigures2and3.Wedefine
the algorithm DE(·) to be steps 2-3 of DISTILLATION
ENCODE thaterasureencodestheauthenticateddataand
augments them with the accumulator values. We define
the algorithm DC(·) to be steps 1-3 of DISTILLATION
DECODE fromFigure3thatreturnsasetofcandidatere-
constructions.
ALGORITHMKDC :k ∈
max{AdvPKE,A(k)}
A
Thescheme PKE satisfies INT-PTXT if AdvPKE,A(k)
is negligible for any adversary A with time-complexity
polynomialink.
Distillation Codes We now briefly present distillation
codes in the public key encoding framework. Distilla-
tioncodesuseanunderlyingpublickeyencodingscheme
PKEV = (KV,EV,DV) that provides integrity protec-
tion.Torefertoaninstantiationofaparticulardistillation
code,wewritePKEDC =(KDC,EDC,DDC). Thisdis-
tillationcodeusestheunderlyingcodePKEV toprovide
integrityprotection. The key generationalgorithmKDC
returnsapublic-privatekeypair(KDC,KDC). Sincethe
pub priv distillation codecan decodedespitesymbolloss, the de-
codingalgorithmtakes astring composedofeithersym-
(cid:0)
(cid:15)→(KDC,KDC)
pub priv K ←KV(k)
returnK
ALGORITHME KD DC
C
:M ∈{0,1}r (cid:15)→{s}n
C
←DE(EVpriv
(M))
KV
priv
returnC
ALGORITHMD KDC
DC
:C ∈{⊥}∪{0,1}m (cid:15)→
pub {0,1}r∪{⊥}
R←DC(C)
for eachR∈R
if DV (R)(cid:4)=⊥returnDV (R)
KV KV
priv priv
return⊥
Theorem 3. If PKEV = (KV,EV,DV) is INT-
PTXT secure, then the distillation code PKEDC =
(KDC,EDC,DDC)isalsoINT-PTXTsecure.
Proof. Assume that there exists an adversary
A EDC(·),D∗DC(·) that can violate the INT-PTXT property
of a distillation code
PKEDC
. Then, we will provide a
constructionforanadversaryB EV(·),D∗V(·)thatcanbreak
any INT-PTXT secureencodingschemePKEV . Inother
words,wewillcreateanadversaryB thatmakesaquery
CV toD∗V(·)suchthatDV(CV) (cid:4)=⊥andDV(CV)was
neveraquerytoEV(·). Wewillprovethattheadvantage
for adversary B will be at least as large as that held by
adversaryA.
Adv PKEDC,A(k)≤Adv PKEV,B(k) (1)
Furthermore, if A runs in time t using q e encoding
queries of total length µ e and q d verification queries
of total length µ d, then B will run in the same query
s(cid:3)ize parame(cid:4)ters µ e and µ d making q e encoding and ≤
(cid:6) nf −n t(cid:7)+1 q d verificationqueries.The adversary B will use the adversary A to break
PKEV
. It will emulate the distillation code encoding
and verification process fully so that A will believe that
it is interacting with a true distillation encoderand veri-
fier. Thus, B will take in the security parameterk and a
publickeyandwilloutputacodetextC. Specifically:
ADVERSARY B EV(·),D∗V :K pub×k∈
(cid:0)
(cid:15)→{0,1}
fori=1...(q d+q e)do
whenAmakesaqueryM toitsencoding
oracleEDC(·),
doA⇐DE(EV(M))
whenAmakesaqueryT toitsverification
oracleD∗DC(·),
do{R 1,...,R l}←DC(T)
forj =1,...,l
if D K∗V
V
(R j)=1
pub
A⇐1;return
A⇐0
Suppose, in the courseof its run, adversaryA has ad-
vantageα = Adv PKEDC,A. In other words, it succeeds
in breaking the distillation code in an α fraction of its
executions. Consider such an execution. In this execu-
tion,letC denotethefirstquerythatAmakestothever-
ification oracle D∗DC(C) for which it has never made
the query EDC(DDC(C)) with DDC(C) (cid:4)=⊥. By con-
struction of DDC, this means that there exists some R i
and for which DV(R i) (cid:4)=⊥. Now, to show this violates
the INT-PTXT propertyof
PKEV
, weneedtoverifythat
DV(R i) was never a query to to EV(·). We know that
DV(R i) = DDC(C) and DDC(C) was never a query
to EDC(·). This means that DV(R i) was never a query
to EV(·). Thus, the advantage that adversary B has in
breakingPKEV is at leastas largeas A has inbreaking
PKE. Thus we have a contradiction since we assumed
that
PKEV
is INT-PTXT, implying that there can be no
adversarythatbreaksPKE withnon-negligibleprobabil-
ity.
WenotethatBwillmakemorequeriestothedecoding
oraclethanA. Sinceagivencodetextcanproducemany
candidatereconstructions,eachofwhichneedstobeval-
idated,B willmakemorequeriestoitsvalidationoracle.
In fact, as argued in Section 3.4.3, there will be at most
(cid:6) fn (cid:7)+1 candidate reconstructions. Thus, if A makes
n−t (cid:3) (cid:4)
q dvalidationoraclecalls,Bwillmake≤ (cid:6) nf −n t(cid:7)+1 q
d
validationoraclecalls.