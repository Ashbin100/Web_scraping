Constant Round Maliciously Secure 2PC with
Function-independent Preprocessing using LEGO
Jesper Buus Nielsen Thomas Schneider Roberto Trifiletti
Aarhus University Technische Universita¨t Darmstadt Aarhus University
jbn@cs.au.dk thomas.schneider@crisp-da.de roberto@cs.au.dk
Abstract—Secure two-party computation (S2PC) allows two input x and B has input y. The guarantee offered from
parties to compute a function on their joint inputs while leaking securely computing f is that the only thing learned from
onlytheoutputofthefunction.AtTCC2009OrlandiandNielsen the computation is the output z = f(x,y), in particular
proposed the LEGO protocol for maliciously secure 2PC based nothingisrevealedabouttheotherparty’sinputthatcannotbe
on cut-and-choose of Yao’s garbled circuits at the gate level and
inferred from the output z. This seemingly simple guarantee
showed that this is asymptotically more efficient than on the
turns out to be extremely powerful and several real-world
circuit level. Since then the LEGO approach has been improved
applications and companies using secure computation have
upon in several theoretical works, but never implemented. In
arisen in recent years [1]–[3], [15], [16]. The idea of secure
this paper we describe further concrete improvements and
provide the first implementation of a protocol from the LEGO computation was initially conceived in 1982 by Andrew Yao
family. Our protocol has a constant number of rounds and is [70], [71], particularly for the semi-honest setting, in which
optimizedfortheoffline/onlinesettingwithfunction-independent all parties are assumed to follow the protocol specification but
preprocessing. We have benchmarked our prototype and find can try to extract as much information as possible from the
that our protocol can compete with all existing implementations protocol execution. Yao gave an approach for preventing any
and that it is often more efficient. As an example, in a LAN such extraction using a technique referred to as the garbled
setting we can evaluate an AES-128 circuit with online latency
circuit technique. At a very high level, using the abstraction
down to 1.13ms, while if evaluating 128 AES-128 circuits in
of[12],Astartsbygarblingor“encrypting”thecircuitf using
parallel the amortized cost is 0.09ms per AES-128. This online
the garbling algorithm (F,e,d) = Gb(f) obtaining a garbled
performance does not come at the price of offline inefficiency
circuitF,aninputencodingfunctioneandanoutputdecoding
as we achieve comparable performance to previous, less general
protocols, and significantly better if we ignore the cost of the functiond.ItthenencodesitsinputasX =En(x,e)andsends
function-independentpreprocessing.Also,asourprotocolhasan (F,X,d) to B. Then, using oblivious transfer (OT), A blindly
optimal2-roundonlinephaseitissignificantlymoreefficientthan transfers a garbled version Y of B’s input which enables B to
previous protocols when considering a high latency network. compute a garbled output Z =Ev(F,X(cid:107)Y) which it can then
decode to obtain z =De(Z,d). Finally B returns z to A.
Keywords—Secure Two-party Computation, Implementation,
LEGO, XOR-Homomorphic Commitments, Selective OT-Attack
Asalreadymentioned,theabovesketchedapproachcanbe
proven secure in the semi-honest setting [52]. In the stronger
I. INTRODUCTION malicious setting however it completely breaks down as in
this model the parties are allowed to deviate arbitrarily from
Secure two-party computation is the area of cryptology the protocol specification. One of the most obvious attacks
dealing with two mutually distrusting parties wishing to com- is for A to garble a different function f(cid:48) =(cid:54) f which could
pute an arbitrary function f on private inputs. Say A has enableAtolearny fromtheresultingvaluez(cid:48) withoutBeven
noticingthis.Tocombatthistypeofattackthecut-and-choose
We acknowledge support from the Danish National Research Foundation techniquecanbeapplied:insteadofgarblingasinglecircuit,A
and The National Science Foundation of China (under grant 61361136003)
garbles several copies and sends these to B. A random subset
for the Sino-Danish Center for the Theory of Interactive Computation and
fromtheCenterforResearchinFoundationsofElectronicMarkets(CFEM), ofthemisnowselectedforcheckingbyBandifeverythingis
supportedbytheDanishStrategicResearchCouncil.Alsopartiallysupported correct,somefractionoftheremainingcircuitsmustbecorrect
bytheEuropeanResearchCommissionStartingGrant279447. withoverwhelmingprobability.Leavingoutmanydetailsthese
ThisworkwaspartiallyfundedbytheGermanFederalMinistryofEduca-
cannowbeevaluatedtoobtainasinglefinaloutput.Whilethis
tionandResearch(BMBF)withinCRISP,bytheDFGaspartofprojectE3
approachthwartstheaboveattackitunfortunatelyopensupfor
withinCRC1119CROSSING,andbytheEuropeanUnion’s7thFramework
Program(FP7/2007-2013)undergrantagreementn.609611(PRACTICE). several new ones that also need to be dealt with, for instance
ensuring input consistency for all the remaining evaluation
garbled circuits. Another more subtle issue in the malicious
Permission to freely reproduce all or part of this paper for noncommercial settingistheSelective-OTAttack (alsocalledSelectiveFailure
purposes is granted provided that copies bear this notice and the full citation
Attack) as pointed out in [46], [57]. A corrupt A can cheat
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author when offering B the garbled inputs in the OT step by using
(for reproduction of an entire paper only), and the author’s employer if the a bogus value for either the 0 or the 1 input. This will either
paper was prepared within the scope of employment. result in B aborting as it cannot evaluate the garbled circuit
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
or it will go through undetected and B will return the output
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23075 to A. Either way the input bit of B is revealed to A which is aSecretSharing-based GarbledCircuit-based
Protocol [45]∗ [28]∗ [26]∗ [69] [56] [65] ThisWork
Constantround (cid:55) (cid:55) (cid:55) (cid:88) (cid:88) (cid:88) (cid:88)
Independentpreprocessing N/A (cid:55) (cid:55) (cid:55) (cid:55) (cid:55) 13.84ms
Dependentpreprocessing (cid:55) N/A N/A 62ms 74ms 5.1ms 0.74ms
Bestonlinelatency 12ms 6ms 1.05ms 21ms 7ms 1.3ms 1.13ms
Bestonlinethroughput ∼1ms 0.4ms 0.45µs N/A N/A 0.26ms 0.08ms
∗UsesdedicatedtechniquesforevaluatingAES.
TABLEI. OVERVIEWOFSTATE-OF-THE-ARTPROTOCOLSANDTHEBESTREPORTEDTIMINGSFORSECURELYEVALUATINGAES-128WITHMALICIOUS
SECURITYONALANINTHEOFFLINE/ONLINESETTING.ALLTIMINGSAREPERAES-128.N/ASTANDSFORNOTAVAILABLE.
directbreachofsecurity.Itiseasytoseethatusingthisattack Another direction in secure computation is the secret
A can learn any l bits of B’s input with probability 2−l if not sharing approach where the parties initially secret share their
properly dealt with. inputs and then interactively compute the function f in a
secure manner. A particularly nice property of these protocols
Over the last decade several solutions to the above issues
is that when considering the offline/online setting the offline
have been proposed, along with dramatic efficiency improve-
phase can usually be done independently of the circuit f
ments for secure 2PC protocols based on the cut-and-choose
which we call independent preprocessing. This allows for
approach of garbled circuits [4], [18], [32], [36], [39], [40],
naively utilizing parallelism in the preprocessing phase and
[42], [48], [50], [51], [53], [58], [64], [66], [67], [69]. Finally
also adds more flexibility as the offline material produced
we note for completeness that secure computation has also
is universal. Another benefit is that in general this secret-
been studied in great detail for many other settings, including
sharing technique works for any number of parties and over
the more general multi-party case (MPC). Several different
any field, which depending on the desired functionality f can
adversarial models such as honest majority [14], [22], [37],
significantlyincreaseperformance.Wenotehoweverthatthese
dishonest majority [27] and covert security [7] have also been
protocols usually employ expensive public-key cryptography
proposed in the literature. In this work we focus solely on
in the preprocessing phase and are therefore much slower
the special case of two parties with malicious security and in
than the offline phases of e.g. [56], [65]. Finally the inherent
the next section we discuss the reported concrete efficiency of
interactiveness of the online phase, which has O(depth(f))
state-of-the-art protocols in this setting.
roundsofinteraction,makestheseprotocolsill-suitedforhigh
latencynetworkssuchasWANs.Therearemanyvariationsof
A. Related Work the secret sharing approach but they typically enjoy the same
overall pros and cons in terms of independent preprocessing
Inthelessthan10yearssincethefirstreportedimplemen-
and required interactivity. Examples of recent protocols fol-
tationofmaliciouslysecure2PCbasedongarbledcircuits[54],
lowingthisparadigmare:TinyOT[19],[49],[60],SPDZ[24],
the performance advancements have been enormous [4], [32],
[27],[44],[45],MiniMac[25],[28],[29],andTinyTables[26].
[36],[48],[56],[64]–[67],[69].Furthermoredifferentsettings
The fastest reported online time for computing an AES-128
andhardwareconfigurationshavebeenexplored,notablyusing
circuit in this setting is 1.05ms by [26] using dependent
commodity grade GPUs in [32], [36] and large-scale CPU
preprocessing. The work of [45] reports 12ms online time
clusters [67] to parallelize the bulk of the computation. In
using independent preprocessing, but the evaluation exploits
thesingle-executionsettingbasedsolelyonstandardhardware
the algebraic structure of AES-128. Furthermore [26] has an
the best reported performance time is that of [69] which
impressive throughput of 0.45µs per AES-128 while [45] and
evaluates an AES-128 circuit in total time 65ms. In addition,
[28] have throughput ∼1ms and 0.4ms, respectively.
the works of [56] and [65] explore the more restricted setting
of amortizing secure 2PC based on the cut-and-choose and
the dual execution approach, respectively. By amortizing we In Table I we give an overview of the properties of the
mean that the protocols exploit constructing multiple secure mentioned protocols and the reported timings for securely
evaluations of the same function f yielding impressive perfor- evaluating AES-128 on LAN in the offline/online setting. As
mance benefits over the more general single execution setting. thesecretsharing-based,non-constantround,protocolsareill-
Furthermore these protocols are in the offline/online setting suited for high latency networks we omit this from Table I
where the bulk of the computation and communication can since no AES-128 timings are published for these schemes
be done before the inputs are determined. We highlight that in a WAN setting (however see Section VI-B for a WAN
for both protocols, the offline computation depends on the comparison of the garbled circuit protocols). The timings
functiontobecomputedandwewillrefertothisasdependent reported for [26], [56], [65] and This Work are all measured
preprocessing. However both protocols allow for the inputs to on the same hardware (Amazon Web Services, c4.8xlarge
bechosensequentiallywhensecurelyevaluatingf.Thisallows instances on 10 Gbit LAN), while the timings for [69] are on
for a low latency online phase which is desirable for many a less powerful instance (Amazon Web Services, c4.2xlarge
applications. For securely computing 1024 AES-128 circuits, instances on 2.5 Gbit LAN). Finally the results of [28], [45]
[56]reports74msofflineand7msonlineperevaluation,while havebeenobtainedonhigh-endDesktopmachineswith1Gbit
the more recent [65] reports 5.1ms offline and 1.3ms online LAN.Thetimingsof[56],[65]andThisWorkareallfor1024
for the same setting. Furthermore [65] achieves a 0.26ms AES-128 evaluations, while those of [69] are for a single-
online phase when considering throughput alone, i.e. batched execution. We believe the difference in performance between
evaluation. the offline/online (62ms + 21ms) and total latency (65ms)
2settingsfor[69]canbeexplainedbytheinabilitytointerleave Ind. Dep. Online Online
the sending/checking and evaluation of garbled circuits in the Setting Preprocessing∗ Preprocessing Latency Throughput
offline/online setting. In summary, as can be seen in the table SingleExecution
1xAES-128 89.61ms 13.23ms 1.46ms 1.46ms
our work is the first implementation of a protocol combining
1xSHA-256 478.54ms 164.40ms 11.19ms 11.19ms
the advantages of independent (and dependent) preprocessing
Amortized
using only a constant number of rounds.
128xAES-128 14.85ms 0.68ms 1.15ms 0.09ms
128xSHA-256 173.05ms 12.13ms 9.35ms 1.09ms
B. LEGO ∗NotincludingthetimetocomputetheinitialBaseOTs.
The Large Efficient Garbled-circuit Optimization (LEGO) TABLEII. PERFORMANCESUMMARYOFOURPROTOCOLONAHIGH
was first introduced by Nielsen and Orlandi in [61] which BANDWIDTH(10GBIT)LANNETWORK.
showed a new approach for maliciously secure 2PC based
on cut-and-choose of garbled gates. This gave an asymp-
totic complexity improvement to O(s/log(|f|)) as opposed to
time if additional garbling material is necessary. As part
O(s) for the standard circuit cut-and-choose approach for
of our prototype we also implement the XOR-homomorphic
statistical security s. However the construction of [61] was
commitment scheme of [34] and report on its efficiency
heavily based on expensive public-key cryptography and was
separately as we believe our findings can be of independent
mainly considered an asymptotic advancement. This was later
interest. This is to our knowledge the first implementation of
improved in the two follow-up works of MiniLEGO [35]
a protocol based directly on the LEGO paradigm and of the
and TinyLEGO [33] yielding incrementing asymptotic and
mentioned commitment scheme. The support for independent
concrete efficiency improvements. In a nutshell, the LEGO
preprocessing is achieved from the fact that the bulk of the
technique works by the generator A first garbling multiple
computation using the LEGO approach is based on cut-and-
individual AND gates (as opposed to garbling entire circuits)
chooseofindependentlygarbledgatesandhenceonlydepends
and sending these to the evaluator B. Then a cut-and-choose
on the security parameter and the number of AND gates one
steponarandomsubsetofthesegatesiscarriedoutandfinally
wishestopreprocess.Thesubsequentsolderingphasecanthen
theremaininguncheckedgatesarecombined(orsoldered)into
be seen as a dependent preprocessing phase where knowledge
a garbled fault tolerant circuit computing f. A crucial ingre-
of the circuit f is required. This multi-level preprocessing is
dient for securely soldering the garbled gates into circuits are
incontrasttopreviousnon-LEGOprotocolsbasedoncut-and-
XOR-homomorphic commitmentswhich in[61] wererealized
choose of garbled circuits in the offline/online setting where
using expensive Pedersen commitments [62]. In the follow-up
the entire offline phase depends on the circuit to be evaluated.
construction of [35] these were replaced by an asymptotically
In more detail our main contributions are as follows:
more efficient construction, however the concrete communi-
cation overhead of the proposed commitment scheme was
1) We propose a new technique for dealing with the
inadequate for the protocol to be competitive for realistic
selective-OT attack on 2PC protocols based on garbled
circuit sizes and parameters. In the recent works of [21], [34]
circuits. Our technique makes use of a globally corre-
this overhead has been improved to an optimal rate-1 and the lated OT functionality (F ) combined with XOR-
∆-ROT
resulting UC-secure XOR-homomorphic commitment scheme
homomorphic commitments and a Free-XOR garbling
is both asymptotically and concretely very efficient. Finally
scheme[47].Usingthewell-knownfactofBeaver[8]that
the work of [41] introduced a different primitive for LEGO
OTs can be precomputed, we can mitigate the selective-
soldering called XOR-Homomorphic Interactive Hash, which
OT attack by having the circuit constructor decommit to
hassomeadvantagesoverthecommitmentapproach.However,
a single value per input bit of the evaluator in the online
the best instantiation of XOR-Homomorphic Interactive Hash
phase. This ensures that if the constructor tries to cheat,
still induces higher overall overhead than the commitment
the evaluator aborts regardless of the value of his input.
approach when using the schemes of [21], [34].
Thetechniqueisgeneralandwebelievethatitcanbeused
in other 2PC protocols based on garbled circuits as well.
Although the original LEGO protocol, and the above-
We also provide a more efficient instantiation of F
mentioned follow-up works, asymptotically are very efficient, ∆-ROT
than previously appearing in the literature by tightening
the overall consensus in the secure computation community
the analysis of the construction presented in [19].
hasbeenthattherelianceofXOR-homomorphiccommitments
2) As part of our 2PC prototype we also implement the
for all circuit wires hinders actual practical efficiency. In
XOR-homomorphic commitment scheme of [34]. It is
this work we thoroughly investigate the practical efficiency
alreadyknownthatthisschemeisasymptoticallyveryef-
of the LEGO approach and, in contrast to earlier beliefs,
ficient,butthisistoourknowledgethefirsttimeitspracti-
we demonstrate that it is indeed among the most practical
calefficiencyhasbeenthoroughlyinvestigated.Theresult
protocolstodateforgeneralsecure2PCusinggarbledcircuits.
is a very efficient scheme achieving an amortized cost of
less than a microsecond for both committing and decom-
C. Our Contributions
mitting to a random value. To maximize performance we
WeimplementtheTinyLEGOprotocolwithaddedsupport utilizecacheefficientmatrix-transpositionandinspiredby
for both independent and dependent preprocessing. Further- theconstructionof[21]weusetheIntelStreamingSIMD
more, our protocol supports fully reactive computation, mean- Extension (SSE) instruction PCLMULQDQ to efficiently
ing that when a function result has been obtained, another compute the required linear combinations.
function depending on this result can be evaluated. Also, 3) We build our LEGO prototype on top of the above-
the independent preprocessing phase can be rerun at any mentioned implementation which results in a very effi-
3cientandflexibleprotocolformaliciouslysecurereactive C. Free-XOR and Soldering
2PC. As our online phase consists of an optimal two
rounds,wecansecurelyevaluateanAES-128withlatency The LEGO protocols [35], [61] and [33] all assume that
down to 1.13ms. When considering throughput we can the underlying garbling scheme supports the notion of Free-
doeachAES-128blockinamortizedonlinetime0.08ms XOR [47], meaning that the XOR of the 0- and 1-key on
(considering 1024 blocks). In applications where inde- any wire of any garbled gate yields the same value, ∆, which
pendent preprocessing can be utilized our offline phase we call the global difference. In addition to making garbling
is superior to all previous 2PC protocols, in particular and evaluating XOR gates virtually free, this optimization
based on our experiments we see a 6-54x gain over [65] also allows for easily soldering wires together. A soldering
dependingonnetworkandnumberofcircuitsconsidered. of two wires is a way of transforming a key representing
If preprocessing is not applicable, for most settings we bit b on one wire into a key representing bit b on the other
cannot compete with the offline phase of [65], but note wire. As we will see in more detail below, with Free-XOR, a
that the difference is within a factor 1.2-3x. See Table II soldering is simply the XOR of the 0-keys on the two wires.
for an overview of our performance in different settings Furthermore, in order to avoid any cheating all wires of all
and Section VI for a more detailed presentation and garbled gates are committed to using a XOR-homomorphic
comparison of our results. commitment functionality F and the solderings are then
HCOM
always decomitted when needed.
II. PRELIMINARIES
As an example, assume we wish to solder the output wire
In this section we give some of the technical background
of gate g onto the left input wire of gate g+1. In doing so
for LEGO garbling, adopting the notation and conventions of we decommit the value SL = O0 ⊕ L0 using F .
the original TinyLEGO protocol [33] for ease of exposition. g+1 g g+1 HCOM
When gate g outputs the key representing the bit b one can
now learn the left b-key for gate g+1. Specifically it can be
A. Notation computed as Ob ⊕SL = (cid:0) O0⊕(b·∆)(cid:1) ⊕O0 ⊕L0 =
g g+1 g g g+1
We will use as shorthand [n] = {1,2,...,n} and [i;j] = L0 ⊕(b·∆)=Lb . This obviously generalizes when one
g+1 g+1
{i,i + 1,i + 2,...,j}. We write e ∈ S to mean: sample wishestosoldertogetherseveralwires,e.g.ifwewishtosolder
R
an element e uniformly at random from the finite set S. the output wire of gate g to the left input wire of gate g+1,
We sometimes (when the semantic meaning is clear) use g +2 and g +3, then it is enough to decommit the values
subscript to denote an index of a vector, i.e., x denotes the SL =O0⊕L0 ,SL =O0⊕L0 ,SL =O0⊕L0 .
i g+1 g g+1 g+2 g g+2 g+3 g g+3
i’th bit of a vector x. We use k to denote the computational
security parameter and s to represent the statistical security It is also straightforward to evaluate XOR gates as part of
parameter. Technically, this means that for any fixed s and the soldering: To compute the XOR of g and g+1 and then
any polynomial time bounded adversary, the advantage of the use this result as the left input to gate g +2 we decommit
adversary is 2−s+negl(k) for a negligible function negl. i.e., the value SL = (cid:0) O0⊕O0 (cid:1) ⊕ L0 . We see now that
g+2 g g+1 g+2
the advantage of any adversary goes to 2−s faster than any Oa⊕Ob ⊕SL =a·∆⊕b·∆⊕L0 =La⊕b as desired.
g g+1 g+2 g+2 g+2
inverse polynomial in the computational security parameter. If In conclusion a soldering is therefore always the XOR of the
s=Ω(k) then the advantage is negligible. In our experiments 0-keys of the wires going into an XOR gate and the 0-key of
we set k =128 and s=40. the wire we wish to solder the result onto.
B. Circuit Conventions
We assume A is the party constructing the garbled gates
III. ANEWAPPROACHTOELIMINATETHE
andcallittheconstructor.Likewise,weassumeBistheparty
SELECTIVE-OTATTACK
evaluating the garbled gates and call it the evaluator. Further-
more, we say that the functionality they wish to compute is
As already mentioned in Section I the selective-OT at-
z = f(x,y), where A gives input x and B gives input y. We
tack enables a corrupt A to learn any input bit of B with
assume that f is described using only NOT, XOR and AND
success probability 1/2 for each bit. Prior work has dealt
gates. The XOR gates are allowed to have unlimited fan-in,
with this attack in different ways, but the off-the-shelf black-
whiletheANDgatesarerestrictedtofan-in2,andNOTgates
box solution has typically been the s-probe resistant matrix
have fan-in 1. All gates are allowed to have unlimited fan-out.
approach of [51], [56], [67]. These approaches augment the
We denote the bit-length of x by |x| = n , the bit-length of
A evaluation circuit f → f(cid:48) so that learning any s − 1 input
y by |y| = n and let n = n +n . We will denote the bit-
B A B bits of B in f(cid:48) leaks nothing about the actual input used
length of the output z by |z| = m. Furthermore, we assume
in the original f. The downside of this approach is that
thatthefirstn inputwiresareforA’sinputandthefollowing
A the input length of B needs to be increased to n(cid:48) > n ,
n input wires are for B’s input. B B
B which in turn results in more communication, computation
We define the semantic value of a wire-key of a garbled and OTs. For the approach of [51] and [56] the increase is to
gate to be the bit it represents. We will use K jb to denote n(cid:48)
B
=n B+max(4n B,20s/3) while for the approach of [67] we
the j’th wire key representing bit b. Sometimes, when the have n(cid:48) ≤n +lg(n )+n +s+s·max(lg(4n ),lg(4s)).
B B B B B
contextallowsit,wewillletLbl,Rbr,andObo denotetheleft In addition to extending the input size, experiments of [56]
g g g
input, right input, and output key respectively for garbled gate show that producing the s-probe resistant version of f can be
g representing the bits b , b and b . When the bit represented a computationally expensive task (up to several seconds for
l r o
by a key is unknown we simply omit the superscript, e.g. K . 1000-bit input).
j
4A. Our New Approach indeed carries the correct value y , by verifying that
i
We propose a new approach that combines the use of 1- y i = lsb(K i)⊕lsb(D i)⊕lsb(r i0)⊕e i
out-of-2 ∆-ROTs (also called globally correlated OTs), XOR- = lsb(K )⊕lsb(K0)⊕lsb(rei)⊕lsb(r0)⊕e
i i i i i
homomorphic commitments and the Free-XOR technique that = lsb(K )⊕lsb(K0) .
sidestepstheneedofexpandingtheinputsizeofBasdescribed i i
above. We recall that ∆-ROTs are similar to Random OTs This secure leaking is described in the VerLeak step of Fig. 1
(ROT), except that all OTs produced are correlated with a and the check is carried out as part of the Eval step of Fig. 2,
global difference ∆. In other words, for each ∆-ROT i pro- both of which are presented in Section IV.
duced,thefollowingrelationholdsforafixed∆:r1 =r0⊕∆
i i
wherer i0,∆∈{0,1}k areuniformlyrandomstringsknownto B. On Constructing ∆-ROTs
the sender and b ∈{0,1} is the uniformly random choice-bit
i
of the receiver who learns rbi as part of the OT protocol. Our The above technique requires (n B+s) ∆-ROTs to obliv-
i iously transfer the input keys of B. However, current state-
approachisdescribedbelowandisinspiredbytheprotocolof
of-the-art protocols for OT extension [6], [19], [43], [60] all
Beaver [8] for precomputing OT.
produce ROTs. It can be seen by inspecting the above OT
extension protocols that they all produce a weaker variant
1) The parties precompute (n +s) ∆-ROTs such that the
B of ∆-ROT called leaky ∆-ROT as an intermediate step. The
sender learns (∆, r0) and the receiver learns (rbi,b ) for
i i i leaky ∆-ROT is identical to ∆-ROT in that all OT pairs are
i∈[n +s].Thesenderwillnowcommit,usingtheXOR-
B correlated with a global ∆, however a corrupt receiver can
homomorphic commitment scheme, to ∆ and each r0. In
i cheatandlearnsomebitsof∆withnon-negligibleprobability.
order to verify that the sender indeed committed to the
In fact, for each bit learned of ∆, the receiver gets caught
∆ used in the OTs, the parties run a simple check in the
followingway:Bsends{(rbj,b )} toAwhich
with probability 1/2, which means it can learn up to s−1 bits
j j j∈[nB;nB+s] of∆,whiletheotherbitsremainuniformlyrandominitsview.
in turn needs to successfully decommit to the received
The work of [19] gives a construction for ∆-ROTs of string
values. The s OTs used for the check are hereafter
length v from leaky ∆-ROTs of string length 22v/3 ∼ 7.33v
discarded. The reason why B needs to send the values to
using linear randomness extraction. Concretely, they propose
A in the first place is that it needs to prove knowledge of
multiplying all the strings learned from the leaky ∆-ROT
thevaluer jbj beforeitissafeforAtoopenit.Foreachof protocolwitharandommatrixA∈{0,1}22v/3×v.Inthiswork
thestests,ifAdidnotcommittothe∆usedintheOTs, we observe that the factor 22/3 is not tight and by applying
then it can only pass the test with probability at most 1/2 Theorem 1 below we can reduce the number of rows in A
as the choice-bits of B are uniformly random. Because downtov+s,goingfromamultiplicativetoanadditivefactor.
these are also chosen independently we see that the
check therefore catches a cheating A with overwhelming Theorem 1 ([73], Theorem 7). Let X = x 1,x 2,...,x u be a
probability 1−2−s. binary sequence generated from a bit fixing source in which
2) Ifthechecksucceeds,Ausesthe∆learnedfromtheOTs l bits are unbiased and independent, the other u−l bits are
fixed or copies of the l independent random bits. Let A be a
above as the global difference in the Free-XOR garbling
u×v random matrix such that each entry of A is 0 or 1 with
scheme. Recall that this means that all garbling keys will
be correlated in the same way as the ∆-ROTs, i.e. K1 = probability 1/2. Given Y =XA, then we have that
l
K l0⊕∆foralll.Inparticularthisisthecaseforthekeys Pr[ρ(Y)(cid:54)=0]≤2v−l
associated to the input of B which need to be obliviously A
transferred in the online phase. In addition, in our 2PC
whereρ(Y)isdefinedasthestatisticaldistancetotheuniform
protocol all 0-keys K l0 have been committed to using the distribution over {0,1}v, i.e. ρ(Y) = 1(cid:80) |Pr[Y =
same XOR-homomorphic commitment scheme as used 2 y∈{0,1}v
y]−2−v|.
for the OT strings r0 and ∆.
i
3) Finally when B learns its real input y, it computes
Now let u = v+s and let ∆ have length u and let ∆A
e = y ⊕b and sends this to A where b are the choice-
have length v. Consider an adversary B who is allowed to try
bitsusedintheprecomputed∆-ROTs.Awillrespondby
decommitting the values {D = K0 ⊕rei} . B can to learn some of the bits of ∆ to make ∆A non-uniform. In
i i i i∈[nB] our setting, if an adversary B tries to learn λ bits of ∆ it is
now compute its actual input keys Kyi = D ⊕rbi =
i i i caught except with probability 2−λ. If B is not caught then it
K0⊕rei ⊕rbi =K0⊕y ·∆.
i i i i i learns λ bit positions and the remaining bits are independent
and uniform. Since we have u = v +s, the l in the above
The above approach eliminates the selective-OT attack as the theorem equals u−λ = v+(s−λ) when B learns λ bits,
only way a corrupt A can cheat is by committing to different i.e., 2v−l =2λ−s. This implies that for all 0≤λ<s it holds
values r(cid:48)0 i (cid:54)=r i0 where r i0 is the value sent using the ∆-ROTs. that the probability that B is not caught and at the same time
However if this is the case then D(cid:48)⊕rbi (cid:54)∈{K0,K1} and B ∆A is not uniform is at most 2−λ2λ−s = 2−s. Clearly, for
i i i i
will abort regardless of the value of his input y i. One caveat all λ ≥ s, then the probability that B is not caught and at
of the above approach is that it allows a corrupt A to flip an the same time ∆A is not uniform is at most the probability
inputbitiofBwithoutgettingcaughtbycommittingtor0⊕∆ B is not caught, which is at most 2−s. This shows that when
i
instead of r0. In our 2PC protocol we eliminate this issue by u=v+s then for all B, the probability that B is not caught
i
ensuringthatlsb(∆)=1andbysecurelyleakinglsb(r0)toB. andatthesametime∆Aisnotuniformisatmost2−s,which
i
This allows B to check that the resulting key K = D ⊕rbi is negligible.
i i i
5Theconsequenceofournewanalysisisthatwecanchoose The Setup step is only required to be run once, regardless of the
therandommatrixasA∈{0,1}(v+s)×v andthusweonlyhave number of future calls to Generate.
to produce leaky ∆-ROTs of length v +s instead of length Setup(pp):
22v/3, a substantial optimization. As we ultimately require 1) On input (k,s,p g,p a,β,α,β˜,α˜) ← pp, A and B initialize
(non-leaky) ∆-ROTs of length k, we can utilize any of the the functionality F HCOM by sending (init,sid,A,B,κ) to it,
mentioned OT extension protocols to produce leaky ∆-ROTs where κ is the key-length of the garbling scheme.
oflengthk+sandthenapplythelinearrandomnessextraction The Generate step produces q garbled AND gates which can be
on the resulting OT-strings. For the parameters s = 40 and solderedintocircuitsthatintotalcanhaveninputsandmoutputs.
k =128consideredinthisworkourrefinedanalysisultimately ItispossibletodomultiplecallstoGenerateatanypointintime
yields an improvement of around a factor 5.6x compared to in order to produce more garbling material.
the previous best known result of [19]. Generate(q,n,m):
1) LetQandAbechosensuchthatafterrunningthebelowcut-
IV. THEPROTOCOL and-choose step, with overwhelming probability (qβ+nβ˜)
garbled gates and (qα+nα˜) wire authenticators survive.
As already mentioned in Section I, our protocol is based 2) AandBinvokeF (n+s)timesfromwhichAlearns∆
∆-ROT
on TinyLEGO [33], but modified to support preprocessing andrandomstringsr0andBlearnsthechoice-bitsb andrbi
i i i
of all garbled components along with our new approach for for i ∈ [n+s]. Furthermore, A instructs F to ensure
∆-ROT
dealing with the selective-OT attack of Section III-A. This that lsb(∆)=1.
includes removing the restriction of B choosing input and 3) Next, A garbles Q AND gates and constructs A wire
committing to the cut-and-choose challenges before obtaining authenticators using ∆ and sends these to B.
4) AthencommitstoeachwireofthegarbledANDgates,each
the garbling material and solderings. As a consequence, our
authenticatedwireproduced,∆,the0-stringsreceivedfrom
modificationsallowformulti-leveledpreprocessingandavery
F ,andm+srandomvalues{v } .Thusitsends
efficient online phase. We give a description of our resulting ∆-ROT j [m+s]
3Q+A+1+n+s+m+s values to F .
HCOM
protocol in Fig. 1 and Fig. 2. See [33] for a more detailed
VerLeak:
specification of the original TinyLEGO protocol. At a high
5) For i ∈ [n] and j ∈ [m+s], A sends lsb(r0) and lsb(v )
level our protocol can be broken down into four main steps. i j
to B.
6) B challenges A to send, using F , s random linear
1) The Setup phase initializes the commitment scheme. All HCOM
combinationsofr0,v and∆fori∈[n]andj ∈[m].Also,
public-key operations of our protocol can be carried out i j
the l’th combination is set to include a one-time blinding
in this initial step, including the BaseOTs required for
value v for l∈[s].
bootstrapping OT extension. m+l
7) Bverifiesthatlsbofthereceivedsvaluescorrespondtothe
2) The Generate step takes as input the number of gates q, samelinearcombinationsoftheinitiallsbvaluessentbyA
number of inputs n and number of outputs m the par- instep5.Inaddition,if∆isincludedinalinearcombination
ties wish to preprocess. After sending the garbled gates B flips the value. This ensures that indeed lsb(∆)=1.
and wire authenticators and committing to all associated Cut-and-Choose:
wires, a cut-and-choose step is run between the parties. 8) After receiving the garbled gates (wire authenticators), B
The wire authenticators is a gadget that either accepts or chooses to check any gate (wire authenticator) with proba-
rejectsagivenkey(withoutrevealingthevalueofthekey) bility p (p ). B then challenges A to send, using F ,
g a HCOM
and it was shown in [33] that constructing AND buckets two random inputs and the corresponding AND output of
from both garbled gates and wire authenticators can sig- theselectedgarbledgatesandarandominputoftheselected
nificantly reduce the overall communication compared to wire authenticators.
9) B evaluates the selected garbled gates and wire authen-
using garbled gates alone. After the cut-and-choose step,
ticators and checks that they output the received output
using the XOR-homomorphic commitments, the parties
key and that they verify the values received from F ,
soldertheremaininggarbledgatesandwireauthenticators HCOM
respectively.
randomly into independent fault tolerant AND buckets. 10) In addition, for i∈[n;n+s] B sends rbi =r0⊕(b ·∆)
3) TheBuildsteptakesasinputthecircuitdescriptionf and to A which in turn instructs F to sei nd bai ck thei same
HCOM
through the XOR-homomorphic commitments, A sends value.Thisistoensurethatthecommitted∆istheoneused
the required solderings to glue together a subset of pre- in F .
∆-ROT
viously produced AND buckets so that they compute f. Bucketing:
4) Finally,theEvalstepdependsontheparties’inputstof.
11) For the remaining garbled gates (wire authenticators), B
Itconsistsoftworounds,firstBsendsacorrectionvaluee samplesandsendsarandompermutationthatfullydescribes
which depends on his input y, and as a response A de- how these are to be combined into q AND buckets of size
commits to B’s masked input keys as well as sending it’s β+α,ninputbucketsofsizeβ˜andninputauthenticators
own input keys directly. Finally A also decommitments of size α˜.
to the lsb of all output 0-keys. This allows B to evaluate 12) Athensends,usingF HCOM,alltherequiredsolderingssuch
the garbled circuit and decode the final output. that for all the specified bucket gadgets, each component is
defined with the same input/output keys.
We highlight that our modified protocol also naturally
supportsthenotionofstreamingorpipeliningofgarbledcircuit
Fig.1. ThemodifiedTinyLEGOprotocolwithsupportforpreprocessingin
evaluation [39] which was not the case in [33]. This can be the(F ,F )-hybridmodel(Part1).
HCOM ∆-ROT
seenbythefactthatonecanevaluatethecircuitf inalayered
approach and using the XOR-homomorphic commitments to
glue the output of one layer onto the input of the next layer.
6The Build step uses the garbling material created in Generate to respectively. These are attached to the input wires of the final
construct a fault tolerant garbled circuit computing f. garbled circuit and serve to guarantee validity of the input
Build(f): keys, along with guaranteeing that B can always learn the
1) AinstructsF HCOM tosendtherequiredsolderingssuchthat final output f(x,y), even if A is cheating. This is so since
thefirst|f|unusedANDbucketscorrectlycomputef.This the input buckets can be seen as a trapdoor that together with
includes the solderings to attach n input buckets and n
A theglobaldifference∆allowsBtoextracttheinputxofA.It
input authenticators onto the final garbled circuit.
isthenclearthatitcancomputef(x,y)directly.Thesespecial
In the Eval step the parties transfer to B all input keys in an buckets are necessary as our regular AND buckets do not rule
obliviousmannerwhichthenallowsBtoevaluateanddecodethe out outputting both the 0 and 1-key (say if one of the garbled
garbled circuit previously constructed using the Build step. gates in the bucket is in fact a NAND gate). However, if a
Eval(x,y): bucket outputs two distinct keys it is guaranteed that they are
1) Forinputy∈{0,1}nB,Bsendse=b⊕y toA,wherebis both valid and hence their XOR is ∆ and B can extract x.
the first n B unused choice-bits of F ∆-ROT. If no cheating is detected then the input buckets are simply
2) A then instructs F HCOM to send to the values {D i = r i0⊕ ignored by B.
K0⊕e ·∆} whereK0 isthe0-keyonthei’thinput
wii
re
ofi
B
ani d∈[ rn 0B]
is the
firsi
t unused ∆-ROT string. Also, As already established in the original LEGO paper [61],
i
fortheinputx∈{0,1}nA,itsendsthecorrespondinginput the number of AND gates q directly affects the required size
keys {K ixi} i∈[nA] directly to B. of the buckets, meaning that as q grows the required bucket
3) Finally, A instructs F HCOM to send the output decoding size can be decreased while still retaining the same level of
values {D = v0⊕K0} to B where K0 is the j’th
j j j j∈[m] j security. Theorem 2 below gives a direct way of computing
output 0-key of the garbled circuit and {v } are the
j j∈[m] the success probability of a corrupt A given the parameters
first m unused blinding values setup in the VerLeak step. q,n,β,α,β˜,α˜.
4) Uponreceivingtheabove,fori∈[n ]BcomputesK =
B nA+i
r ibi⊕D i andlsb(K i0)=lsb(D i)⊕lsb(r i0)⊕e i andverifies Theorem 2 ([33], Lemma 9). Given the bucketing parameters
that lsb(K nA+i) ⊕ lsb(K i0) = y i. Then using the input q,n,β,α,β˜,α˜ for the case where α = β −1 we can bound
authenticators,Balsoverifiesthatthekeys{K i} i∈[nA] ofA the probability of the bad bucketing events occurring as:
are valid input keys to the garbled circuit.
5) If everything checks out, B evaluates the previously con- Pr[Any bad bucket]≤
structedgarbledcircuitontheinputkeys(K 1,K 2,...,K n) (cid:32) 1
to obtain the output keys (Z 1,Z 2,...,Z m). For j ∈ [m]
q·
(cid:89) (cid:16) (1−p g)4i (cid:17)
+
i zt t =he ln sbc (o Zm )pu ⊕te ds .d Fj in= allyl ,s Bb( ov uj t) pu⊕ tsl zsb =(D (j z) ,a znd ,..d .e ,c zode )s
. i=β
p g(qβ+nβ˜)+(1−p g)4i
j j j 1 2 m
β l
(cid:88) (cid:89)(cid:16) (1−p g)4i (cid:17)
·
Fig.2. ThemodifiedTinyLEGOprotocolwithsupportforpreprocessingin p (qβ+nβ˜)+(1−p )4i
the(F HCOM,F ∆-ROT)-hybridmodel(Part2). l=2 i=β g g
α+2−l (cid:33)
(cid:89) (cid:16) (1−p a)2j (cid:17)
p (qα+nα˜)+(1−p )2j
a a
Each of these layers can be processed on the fly with our j=α
protocol and in this way the circuit never needs to be stored
entirely at any given time. This approach is similar to that
proposed in [59] for reusing garbled values, however in this Pr[Any bad input authenticator]≤
s he ot mtin og rme ov pe hr iy cth ci on mg mw ito mrk es ntsou ot n-o af l- lth ce i- rb cuo ix
t
wd iu re es.to the XOR- n·(cid:88)(cid:100)α 2˜(cid:101) (cid:89)v
(cid:16) (1−p a)2l (cid:17)
p (qα+nα˜)+(1−p )2l
a a
The LEGO approach also has the advantage compared to v=1l=α˜
traditionalcut-and-chooseprotocolsthatonlyasinglefaulttol-
erant garbled circuit is produced and evaluated. This removes
the necessity of ensuring input consistency for all the eval- Pr[Any bad input bucket]≤
u ma uti lo tin plecir sc eu tsits o. fIt ina pls uo
t
ksi ed ye sst ie nps tht ehe ono lv iner ehe pa hd aso ef
,
t or na ens sfe er tri fn og
r
n·(cid:88)(cid:100)β 2˜(cid:101)
(cid:89)l
(cid:16) (1−p g)4i (cid:17)
each evaluation circuit. p (qβ+nβ˜)+(1−p )4i
l=1i=β˜ g g
A. Bucketing
Based on Theorem 2, given the number of AND gates q
With the bucketing approach of [33] each AND bucket and the number of inputs n we directly compute the optimal
consists of β garbled gates and α wire authenticators. For choicesofβ,α,β˜,α˜forminimizingtheoverallcommunication
any garbled gate (wire authenticator) the probability p (p ) of the protocol while still guaranteeing a negligible upper
g a
is used to determine if it is checked in the cut-and-choose bound on the success probability of a corrupt A. This is a
or not. The value of p and p therefore induces a certain once and for all computation so for our implementation we
g a
sense of “quality” level of the remaining non-checked garbled have precomputed a table of secure choices using a simple
components which affects the required bucketing size. In script which is looked up on runtime when q and n have been
addition there are also the special cases of input buckets and decided.Wenotethatitisalsopossibletominimizeforlowest
input authenticators, which are buckets that consist of garbled possible bucket size if desired. This has the effect of reducing
gates only (size β˜) and wire authenticators only (size α˜), the computational overhead in the online phase at the price of
7increasing both communication and computational overhead on communication. In [33] they use an interactive
in the independent preprocessing phase. In our experiments in protocol with less communication.
Section VI we solely minimize for overall communication. Change 2 In [33] they let B commit to the cut-and-choose
challenges and choose his input via OT before
obtainingthegarbledgates,wireauthenticatorsand
B. Security
solderings.Wehaveremovedthisstep.NowBpicks
Our protocol is similar to the TinyLEGO protocol in [33] hisinputafterthecircuitisconstructedanddoesnot
and the proof follows the same general outline. We will commit to his challenges.
therefore only give a very brief sketch of the overall proof Change 3 In our protocol we take the global ∆-value output
strategy and then describe how to deal with the changes we by the OT extension and reuse it as the global ∆
made relative to TinyLEGO. in the Free-XOR garbling scheme. In [33] they use
two independent values.
ConsiderfirstthecasewherethegarblerAiscorrupted.As Change 4 We protect against selective error on the input of B
is typically the case it is easy to see that the communication by using the same ∆ in OT extension and garbling
of the protocol does not leak any information on the input of and using a ∆-ROT to offer the input keys to B.
B as long as the protocol does not abort. The garbler A might Wealsoleaktheleastsignificantbitofthe∆-OT0-
however give wrong input to some of the OTs used by B to stringstoBforallhisinputwires.In[33]adifferent
choose its input keys, giving rise to selective errors where technique was used.
theabortprobabilitydependsontheinputofB.ThegarblerA
mightalsocreatesomebadgarbledgateswhichcouldapriori Change1doesnotaffectsecurity.Itwasintroducedtogive
result in an abort or a wrong output, which might both leak better execution time for typical circuits.
information on the input of B. The problem with bad gates
We now address Change 2. The reason why B commits to
is handled exactly as in [33], by setting the cut-and-choose
the cut-and-choose challenges and chooses his input via OT
parametersandbucketsizesappropriately.Wehoweverhandle
before obtaining the garbled material in [33] is that security is
the case with bad inputs to the OTs differently, as described
proven via a reduction to a standard (non-adaptive) selective
below. In the universal composability (UC) framework [20],
garblingscheme(e.g.[12]),wheretheadversaryinthesecurity
when A is corrupt, we also need to be able to extract the
game must supply its input before it gets the garbled circuit.
input of the corrupted A from its communication and input
Thereforetheyneedtobeabletoextracttheinputandcut-and-
to ideal functionalities (OT and commitment). We handle this
choosechallengesofBbeforeassemblingthegarbledcircuitin
exactly as [33]: the cut-and-choose ensures that most key
the simulation. We have skipped this step as it would prevent
authenticators only accept their two corresponding committed
independent preprocessing. Now that we assemble the circuit
keys. For a good key authenticator the accepted key can then
before B picks its input, the hope would be that we could
be compared to the committed values to compute its semantic
do a reduction to an adaptive garbling scheme. However, due
value.Thebucketsizehasbeensetsuchthatthereisamajority
to the soldering approach of LEGO where the XOR of 0-
of good key authenticators on all input wires. This allows to
keys are sent to the evaluator before the input is determined,
compute the semantic of any accepted key by taking majority.
it is unclear how to reduce security to the standard notion of
Consider then the case where the evaluator B is corrupted. adaptivegarbling,assomeofthese0-keysarenotknowntothe
As is typically the case, the communication clearly does not simulator. To overcome this we instead identify the defining
leak information to B about the input of A. All that is left is propertyweneedfromtheunderlyinggarblingfunctionwhich
thereforetodescribehowtohandletwotechnicalrequirements isthattheoutputsofthehashfunctionappearrandomaslong
imposedbytheUCframework.First,wehavetodescribehow astheinputsareallunknownandhavesufficiententropy,even
toextracttheinputyofacorruptedB.Second,afterlearningy iftheinputsarerelated.Anon-extractable,non-programmable
and z = f(x,y) we must enforce that the simulated protocol random oracle clearly satisfies this property [13]. The type of
constructs a circuit that evaluates to z. This must be done garblingschemeconsideredinthiswork[72]couldinprinciple
without knowing x. Extracting y is handled exactly as in [33]. be made adaptively secure by using a programmable random
We simply inspect which choice bits B uses in the OTs for oracle using techniques described in [11], [55].1 We avoid
selecting its input. Hitting z in the simulation is also handled using the programability of the random oracle by changing
exactlyasin[33].Wesimplyconstructthecircuitcorrectlyand the usual approach a little. Normally security proofs need
run with input 0 for A. This gives a potentially wrong output to program the circuit to hit the right output. We instead
z(cid:48) = f(0,y). We patch this by giving appropriately chosen garblethecircuitscorrectlyandthenprogramorequivocatethe
wrong output decoding information by opening a wrong least outputdecodinginformationtodecodetothevalueweneedto
significant bit of the output key for the output wires i where hit. Specifically we use equivocation of the UC commitment
z(cid:48) (cid:54)= z . This is possible as the simulator controls the ideal schemetoincorrectlyopentheleastsignificantbitoftheoutput
i i
functionality for commitment in the simulation. keys when we need to hit a different value. Returning to the
simulation, we therefore garble all gates and answer all cut-
We now focus on the changes we made to [33].
and-choose challenges honestly. As we now know all garbling
keys we can also open consistently to differences between 0-
Change 1 In both protocols the output decoding information
keys for the remaining evaluation gates. Finally, in order to
consists of the least significant bit of the output
keys, securely leaked via the commitment scheme.
1Itisalsopossibletobuildanadaptivelysecuregarblingscheme(withshort
However,theimplementationdiffers.Weuseanon-
inputkeys)usinganon-programmablerandomoracle[9],butthisparticular
interactiveimplementationwhichisslightlyheavier schemeisnotasefficientastheoneof[72].
8make the complete soldered garbled circuit “hit” the output z following this OT + PRG blueprint has been implemented
we equivocate the openings of the least significant bits of the and we believe our experimental findings are of independent
output keys such that this becomes the decoded value. This is interest. At a high level, the scheme works by the parties
possible as the decoding information is only opened after we initially doing n˜ BaseOTs of security parameter k-bit strings,
extracttheinputofthecorruptreceiver.Ifthegarblingisdone where n˜ is the code-length for some linear error correcting
using a random oracle this will have the same distribution as code C with parameters [n˜,κ,s]F with κ being the bit-
2
in the protocol. lengthofthecommittedmessages.Thepartiesthenexpandthe
received k-bit strings into bit-strings of length γ using a PRG
For Change 3 we again use that we are in the random
which then define the γ random commitments the sender is
oracle model. The first step in the proof will be to go from
committing to. Next, the sender sends a correctional value for
the case where ∆ is reused in the garbling scheme to the case
each produced commitment to turn these into codewords of C.
whereanindependent∆(cid:48) isusedforgarblingasin[33].Inthis
Finally, to ensure that the sender sent valid corrections, the
hybrid we also let A commit to ∆(cid:48). We then use equivocation
receiverchallengesthesendertodecommitto2srandomlinear
of the commitment scheme to make the cut-and-choose proof
combinations of all produced commitments. This is done in a
that ∆(cid:48) =∆ go through. Since B only sees one key for each
way such that no information is leaked about the γ committed
wire and has high entropy on ∆ and ∆(cid:48), this change will
values. Additively homomorphism then follows from the fact
be indistinguishable to B if the output of the hash function
that the code C is linear and all operations on the expanded
appearsrandomaslongastheinputsareallunknownandhave
PRG strings are linear as well. We highlight the fact that any
sufficient entropy, even if inputs are related. As above, a non-
XOR homomorphic commitment scheme supports the notion
extractable, non-programmable random oracle clearly satisfies
of batch opening/decommitment which is similar in nature
this property.
to the above consistency check. The idea is that the sender
We finally address Change 4. Using a ∆-ROT to offer initially sends the decommited values directly to the receiver,
the input keys to B ensures that when A inputs the keys who hereafter challenges the sender to decommit to s linear
to the OT, either both are correct or both are incorrect. If combinationsofthepostulatedvalueswheresisthestatistical
both are incorrect, it will be detected by a key authenticator security parameter. Notice that it is only in the initial commit
independently of the input of B. This means that the only step that 2s combinations are necessary. If the decommitted
remaining attack vector is for A to swap the two correct keys. values match the linear combinations of the postulated values,
ThisisdetectedbyBasBknowstheleastsignificantbitofthe the receiver accepts. As now only s values are decommitted
∆-ROT 0-strings and the two correct keys have different least this approach has the benefit of making the communication
significantbits.Againthedetectionisindependentoftheinput overhead independent of the number of values decommitted
of B. Notice that the output decoding information is sent to B to. For the full details we refer to [34].
usingF afterhesendshisinputcorrectionvaluee,sowe
HCOM We implement the above scheme in C++14 taking advan-
canequivocateittohitthecorrectoutputz.This,togetherwith
tage of multi-core capabilities and Intel SSE instructions. We
the fact that the outputs of the hash function appear random,
can therefore base the PRG on AES-NI in counter mode and
iswhyitissecuretoperformtheVerLeak stepbeforelearning
for the error correcting code we use a modified version of
the input of B.
the linux kernel implementation of the BCH code family [17],
As argued above, our modified protocol can be proven [38].Aspartofthecommitmentstepthepartiesarerequiredto
secure in the non-extractable, non-programmable random ora- transposeabinarymatrixS ∈{0,1}n˜×γ inordertoefficiently
cle model following the proof of [33]. As we do not require address the committed values in column-major order. As γ in
programmability of the random oracle we conjecture that our our case can be huge (> 220 Mio. for 2000 AES-128 com-
protocol can be proven secure in the standard (OT hybrid) putations) we use the efficient implementation of Ekhlund’s
model using the recently proposed ICE framework of [31], an cache-efficient algorithm for binary matrix transposition [30]
extension of the UCE framework of [9]. However, we note presented in [5], [6].2 As a side note we also augment
that it does not seem like our scheme can be proven secure the OT extension code to support the randomness extraction
using the UCE framework as in our setting all the garbled techniquedescribedinSectionIII-AtoimplementtheF
∆-ROT
gates are related (all garbled with the same ∆) and therefore functionality needed in our 2PC protocol.
a single leakage phase as prescribed in the UCE framework
During the development of our implementation we iden-
seems insufficient.
tified the main computational bottleneck of the scheme to be
the computation of the random linear combinations. Even if
V. IMPLEMENTATION
these operations are based on mere XORs, when implemented
In this section we highlight some of the more technical naively, the number of required instructions is still γs in
details of our implementations of the XOR-homomorphic expectation. Therefore, inspired by [21], we use a different
commitment scheme and our final 2PC protocol supporting approach for computing the consistency checks using Galois
independentpreprocessing.Thesourcecodeoftheprojectcan field multiplication. Combined with efficient matrix transposi-
be found at https://github.com/AarhusCrypto/TinyLEGO. tion the effect of using GF(2l) multiplication can be seen as
computing l linear combinations in parallel. For our particular
setting we set l = 128 as this is the smallest power of 2
A. UC-Secure XOR-Homomorphic Commitments
greater than the required 2s for s = 40. We can then use
As part of our full 2PC prototype we implement the the Intel SSE instruction PCLMULQDQ to very efficiently
XOR-homomorphic commitment scheme of [34] as a separate
subprotocol. This is to our knowledge the first time a scheme 2Availableathttps://github.com/encryptogroup/OTExtension
9γ #Threads Commit[µs] Decommit[µs] wespawn.Furthermore,theseexperimentswereperformedon
the local LAN setup described in Section VI and not on the
500 1 7.21 (2815.28) 2.20
Amazon Web Services (AWS) architecture.
1000 2 3.85 (1401.83) 1.40
15000 4 0.64 (93.99) 0.34
50000 8 0.57 (28.49) 0.22
B. 2PC with preprocessing using LEGO
500000 20 0.45 (3.25) 0.17
10000000 200 0.21 (0.35) 0.14 We implement the TinyLEGO protocol with our modifica-
200000000 400 0.20 (0.21) 0.14
tions on top of the previously described commitment scheme.
The code is also written in C++14 and makes heavy use
TABLEIII. TIMINGSFORCOMMITTINGTOγSTRINGSOFLENGTH128
BITWITHs=40.ALLTIMINGSAREµsPERCOMMITMENT.THECOMMIT of parallelism and Intel SSE instructions for garbling and
TIMEINPARENTHESESINCLUDESTHECOSTOFTHEINITIALBASEOTS. evaluation of the garbled gates. At a high level, the Generate
step is implemented by first partitioning the inputs (q,n,m)
into t equally sized subsets for some parameter t. The main
compute the GF(2128) multiplications. In detail, our approach threadthenstartstparallelexecutionsofthegeneratestepwith
twosynchronizationpoints,onewherethecommitmentto∆is
to compute the checks is as follows:
sent(whichonlyoneexecutionischargedwith),andoneafter
1) Given a random challenge element α ∈ GF(2l) the the cut-and-choose step. The latter is necessary as the random
R
matrix S of committed values in column-major order is permutation that describes the initial bucketing must only be
split into u=(cid:100)S/l(cid:101) blocks B
i
∈{0,1}n˜×l. Each block is revealedafterallgarbledcomponentshavebeensenttoB.We
then transposed into row-major order. emphasizethatitisduetoourpreprocessingbeingindependent
2) For i ∈ [u] and j ∈ [n˜], the new matrix B(cid:48) = Bj ·αi of the structure of f that we can trivially parallelize the above
i i
is computed where Bj ∈ {0,1}l is the j’th row of B step using any number of threads t. Due to the above design
i i
interpreted as an element of GF(2l). we also run t executions of the commitment scheme, however
3) Finally, the combined matrix B(cid:48) =(cid:80)u B(cid:48) is produced for the PRG expansion we use the same seed OT values in all
i=1 i
and transposed back into column-major order. executions. As the PRG is based on a block cipher in counter
mode this is not an issue as execution i+1 sets it’s counter
Each column of B(cid:48) can now be seen as a random linear sufficiently high compared to the i’th execution so there is no
combination of all values of S. As a further optimization we overlap. Since they all use the same seed OTs the choice-bits
see that most GF elements are only multiplied a single time are also the same across all executions and they can therefore
in the above and we can therefore postpone the expensive be combined in the same way as for a single execution.
degree reduction step of the multiplication until B(cid:48) has been
fully computed. This is different for computing αi which we TheBuildandEvalphasesfollowroughlythesamedesign
thereforereduceateachiteration.Intotaltherequirednumber pattern as above. We note however that in these phases each
ofdegreereductionsbecomesn+uasopposedto(n+1)u.Our thread is responsible for soldering and evaluating an entire
experiments show that using the above method of computing circuit. The garbling and evaluation of garbled gates and wire
128 linear combinations compared to the naive approach is authenticators are implemented purely as 128-bit SSE instruc-
between10-13xfasterstartingatamoderatenumberofrandom tionstomaximizeperformance.Webasethehashfunctionfor
commitments γ >8000. garblinggatesandproducingwireauthenticatorsonFixed-Key
AES-NIasadvocatedin[10].Thischoiceismainlymotivated
As our implementation of the XOR-homomorphic com-
by producing as comparable results as possible to previous
mitment scheme might be of independent interest we here
works that are also based on Fixed-Key AES-NI.
presentourobservedtimingsforcommittinganddecommitting
to γ random bit-strings of length 128 with k = 128 and The Eval phase consists of two rounds, one where B
s =40. We instantiate the binary BCH code with parameters specifies the input mask and one where A replies with its
[312,128,41] and for convenience we use the implementation keys and decommitments. A’s reply has communication com-
of [6] augmented with our randomness extraction technique plexity kn for A’s input keys and (n˜+k)(n +m) for the
A B
to compute the required 312 Random OTs. In total this takes decommitments of B’s input keys and the lsb masks of the
about 1400ms with our implementation, where 1392ms are output keys, where n˜ is the code-length of the BCH code.
due to the BaseOTs (using PVW [63]). From the timings re- We note that the communication cost of the decommitments
portedin[23]wepredictthatthisinitialsetupstepcanbedone can be reduced to (n˜ + k)s + k(n + m) using the batch
B
much faster (around 20ms) using their implementation, but decommit approach mentioned in Section V-A, but at the
since this requires a programmable random oracle assumption cost of adding an additional round. For the circuits used in
and this cost amortizes away as γ grows we did not pursue our experiments (AES-128, SHA-256) we observed a loss of
this.Also,ifthecommitmentschemeisusedinanapplication around a factor 1.25 in the LAN setting and much more in
that already relies on oblivious transfer, OT extension can be the WAN setting with this approach. Still, for other circuits
used to produce the starting BaseOTs at very low cost. We where the ratio (nB+m)/|f| is substantial and both network
report our findings in Table III. As the scheme requires n˜ latency and bandwidth are low we suspect that adding this
BaseOTstosetupweincludethiscostinthecommittimingsin extra round can pay off. Finally if one is willing to assume a
parentheses.Itcanthusbeseenbycomparingthecommitment programmablerandomoracletheonlinecostfortheoutputbits
numbershowtheinitialOTcostamortizesawayasγincreases. can be eliminated entirely as the simulator then can program
Asthereisnoinitialcostassociatedwithdecommitmentthese the oracle to output matching output keys for a preprocessed
timings are only affected by the number of worker-threads decommitment lsb-bit once it learns the final output.
10VI. PERFORMANCE externalmemorysourceswithsupportforpipelinedevaluation
as described in Section IV.
To give a broad view of the performance of our prototype
werunexperimentsinalocalLANsettingandonbothaLAN FortheAWSWANsettingweseethatasingleexecutionof
andWANontheAmazonWebServices(AWS).Inmoredetail: AES-128 takes around 83ms online time where almost all of
the runtime is spent waiting due to a latency of ∼81ms. The
Local LAN with two machines, one acting as A and the latency also severely impacts the two preprocessing phases
other acting as B. We measured a total bandwidth of where the independent preprocessing takes around 1882ms
942 Mbits/sec with round trip time (rtt) 0.12ms. Both (20x compared to AWS LAN) and the dependent offline
machines run Ubuntu 16.04 with an Intel Ivy Bridge i7 phase takes 96ms (7x compared to AWS LAN). However
3.5 GHz quad-core processor and 32 GB DDR3 RAM. this overhead can be somewhat mitigated when considering
AWS LAN with two c4.8xlarge instances located in the Vir- several circuits, down to a factor 2-4x compared to AWS
ginia region connected via a high performance LAN. We LAN due to the computation and communication being more
measured abandwidth of9.52 Gbits/sec withrtt 0.16ms. interleavedandbetterutilizationofthebandwidthwithseveral
Both machines run Amazon Linux AMI 2016.03.2 with TCP connections.
an Intel Xeon E5-2666 v3 (Haswell) processor with 36
Finally in Table V on the next page we report on the
vCPUs and 60 GB RAM.
amount of data our prototype transfers from the circuit
AWS WAN with two c4.8xlarge instances, one in Virginia
constructor to the circuit evaluator for both AES-128 and
and one in Ireland. We measured a bandwidth of 214
SHA-256. For clarity we have not included the communi-
Mbits/seconaverageforasingleTCPconnectionandup
cation from evaluator to constructor, but note that for 1024
to3.17Gbit/secwhenrunningmanyparallelconnections.
AES-128 and 256 SHA-256 a total of 8.12MB and 4.09MB
Therttmeasuredwas81.32ms.BothmachinesrunAma-
are transferred, respectively, and for both cases around 99%
zon Linux AMI 2016.03.2 with an Intel Xeon E5-2666
of the communication stems from the initial BaseOTs. The
v3(Haswell)processorwith36vCPUsand60GBRAM.
table also summarizes the bucketing parameters used in our
ForallsettingsthecodewascompiledusingGCC-5.4with experiments, which have been chosen so that the probability
the -O3 optimization flag set. As mentioned in Section V-A bound given by Theorem 2 in Section IV-A is negligible.
the implementation used for the BaseOTs are based on [6] Also we set the two input bucket parameters β˜ = 2β + 1
using PVW [63]. If one is willing to assume a programmable and α˜ = 2α + 1 which ensures a correct majority for all
random oracle, these can be replaced with the fast protocol the input buckets and authenticators except with negligible
and implementation of [23] and we would expect a total cost probability. For the data numbers in Table V it can be seen
around 20ms as opposed to 850ms (AWS LAN) with the in parentheses how the relative preprocessing cost of a circuit
current implementation. decreases as more evaluations are considered. We highlight
thatinthiswork(andpreviousLEGOprotocols)thisisdueto
the increasing number of gates produced, not by the number
A. Our Performance Results
of circuits. As an example of this effect, going from a single
AES-128 with 6928 gates3 to 1024 AES-128 with 7094272
We summarize our measured results in Table IV on the
gates decreases the cost of the independent preprocessing by
following page for the three above-mentioned settings. All
a factor 2.3x per AES-128, from 14.94MB to 6.42MB. It
numbers reported are averages of 10 executions. Not surpris-
is worth noting that the “LEGO effect” only applies to the
inglyweseethebestperformanceontheAWSmachinesinthe
independent preprocessing. This is because in the subsequent
LAN setting where we can evaluate an AES-128 circuit with
dependent preprocessing step two solderings (k bits each) are
latency 1.13ms or 0.08ms throughput per AES-128 in the
sent per gate of the circuit f and not for each garbled gate
online phase. We also see that when considering 1024 AES-
produced. In addition a small constant 2.2kB of decommit-
128evaluationsthedependentpreprocessing+theonlinephase
mentdataistransferredinthisphasefortheschallengelinear
is below 2ms. When including the cost of the independent
combinations. For the online step the communication consists
preprocessingeachAES-128canbedoneintotaltimelessthan
of n k bits for the constructors input + (n˜+k)(n +m) bits
16ms. Similarly when considering 256 SHA-256 evaluations A B
for the decommitments to the evaluators input and the output
the online phase can be done with latency 9.14ms or 1.05ms
decoding bits where n˜ is the code-length of the ECC C used
ofthroughputperSHA-256.Alsothedependentpreprocessing
in the commitment scheme. In Section V-B we discussed how
+ online phase and total cost is below 22ms and 205ms,
this could further be reduced to (n˜+k)s+k(n +m) at the
respectively (when preprocessing material enough for 256 B
price of adding an extra round to the online phase.
SHA-256 evaluations).
For the single execution setting we see a significant B. Comparison with Related Work
increase in execution time for the dependent preprocessing
We compare our measured timings to those reported in
compared to above. This is due to the design of our prototype
the recent works of [56] and [65], both of which are solely
which only uses multiple execution threads in the dependent
applicable in the amortized setting. In contrast our protocol
preprocessing and online phases if several, possibly different,
can naturally handle the single execution setting, along with a
circuits are processed at the same time. We also note that our
moregeneralamortizedsettingwhereseveraldistinctfunctions
prototype requires a large amount of RAM as we store all
garbling material and commitments in-memory. This design
3WeusetheAESnon-expandedcircuitof[68]whichhas6800ANDgates.
choice is due to convenience, but for a deployed system
Howeverweaugmentthecircuitwithidentitygatesonthe128outputwires
based on the LEGO approach this should be addressed using inordertosimplifyoutputdecodingusingVerLeak.
11Setting Circuit Number BaseOTs Ind.Preprocessing Dep.Preprocessing Online(latency) Online(throughput)
1 1400.89 220.44 15.12 2.52 2.52
32 44.90 87.63 3.35 2.25 0.35
AES-128
128 11.23 70.89 2.95 1.86 0.26
LocalLAN 1024 1.40 61.33 2.85 1.60 0.25
1 1400.39 1381.05 208.00 22.65 22.65
SHA-256 32 44.94 812.12 44.59 11.77 3.12
128 11.22 771.27 37.72 10.43 3.02
1 850.42 89.61 13.23 1.46 1.46
32 26.61 27.91 0.85 1.23 0.18
AES-128
128 6.65 14.85 0.68 1.15 0.09
1024 0.84 13.84 0.74 1.13 0.08
AWSLAN
1 852.90 478.54 164.40 11.19 11.19
32 26.82 165.26 14.87 9.14 1.42
SHA-256
128 6.67 173.05 12.13 9.35 1.09
256 3.34 183.51 11.70 9.56 1.05
1 2980.25 1881.63 96.66 83.17 83.17
32 93.75 142.00 5.19 83.21 2.71
AES-128
128 23.44 72.31 3.96 83.65 0.73
1024 2.96 39.18 2.12 83.15 0.62
AWSWAN
1 3043.64 2738.62 350.01 93.94 93.94
32 92.98 670.98 42.01 92.42 4.04
SHA-256
128 23.66 431.71 25.44 92.38 1.70
256 11.75 356.48 27.97 92.74 1.87
TABLEIV. EVALUATORTIMINGSMEASUREDINTHELOCALLAN,AWSLANANDAWSWANSETTINGFORAES-128ANDSHA-256WITHk=128
ANDs=40.ALLTIMINGSAREmsPERCIRCUIT.
Circuit Number β pg α pa BaseOTs Ind.Preprocessing Dep.Preprocessing Online
1 7 2−4 6 2−3 19.52kB 14.94MB 226.86kB 16.13kB
32 4 2−2 3 2−2 19.52kB (610B) 279.78MB (8.74MB) 7.26MB (226.86kB) 516.10kB (16.13kB)
AES-128
128 4 2−3 3 2−3 19.52kB (153B) 924.68MB (7.22MB) 29.04MB (226.86kB) 2.06MB (16.13kB)
1024 4 2−5 3 2−6 19.52kB (19B) 6.57GB (6.42MB) 232.31MB (226.86kB) 16.52MB (16.13kB)
1 5 2−3 4 2−4 19.52kB 120.34MB 2.93MB 22.23kB
32 4 2−4 3 2−5 19.52kB (610B) 2.73GB (85.19MB) 93.63MB (2.93MB) 712.70kB (22.23kB)
SHA-256
128 4 2−6 3 2−5 19.52kB (153B) 10.31GB (80.54MB) 374.52MB (2.93MB) 2.85MB (22.23kB)
256 4 2−7 3 2−5 19.52kB (76B) 20.28GB (79.20MB) 749.03MB (2.93MB) 5.70MB (22.23kB)
TABLEV. BUCKETINGPARAMETERSANDDATARECEIVEDBYTHEEVALUATORINTHEDIFFERENTPHASESOFOURPROTOCOLFORAES-128AND
SHA-256WITHk=128ANDs=40.NUMBERSINPARENTHESESAREDATAPERCIRCUITPRODUCED.
can be preprocessed in the same batch. However to make a
Protocol Setting Number Ind.Preprocessing Offline Online
meaningful comparison we focus on the “traditional” amor-
32 (cid:55) 197 12
AWSLAN 128 (cid:55) 114 10 tized setting considering 32, 128, and 1024 AES-128 compu-
1024 (cid:55) 74 7 tations and we summarize the comparison in Table VI. The
[56]
32 (cid:55) 1126 163 independent preprocessing timings for our protocol consists
AWSWAN 128 (cid:55) 919 164 of the BaseOTs + the independent preprocessing. The first
1024 (cid:55) 759 160
thing to notice is that for applications where independent
32 (cid:55) 45 1.7 preprocessing is applicable, and can therefore be disregarded,
AWSLAN 128 (cid:55) 16 1.5 our dependent offline performance is superior to both prior
1024 (cid:55) 5.1 1.3
[65] works for any number of AES-128 computations by a large
32 (cid:55) 282 190
margin. Compared to [56] our reported timings are better by
AWSWAN 128 (cid:55) 71 191
1024 (cid:55) 34 189 100-358xdependingonthesettingandnumberofcircuits.For
[65] the gap is smaller, but still substantial, namely by 6-54x.
32 54.52 0.85 1.23
For applications where independent preprocessing can not be
AWSLAN 128 21.5 0.68 1.15
1024 14.68 0.74 1.13 utilized we are still superior to the work of [56], but for most
ThisWork
32 235.75 5.19 83.21 settings and number of circuits we cannot compete with the
AWSWAN 128 95.75 3.96 83.65 offline phase of [65]. However the differences are typically
1024 42.14 2.12 83.15
within a factor 1.2-3x.
TABLEVI. COMPARISONOFTHEREPORTEDTIMINGSFORAES-128 For the online timings in the AWS LAN setting for
INTHEAWSLANANDAWSWANSETTINGWITHk=128ANDs=40.
AES-128 we measure faster overall timings than [65] for all
THEPREPROCESSINGCOLUMNINCLUDESTHECOSTOFTHEBASEOTS
FORTHISWORK.ALLTIMINGSAREmsPERAES-128.BESTRESULTS numberofcircuitsbyatinymargin.Asthedifferencesareless
MARKEDINBOLD. than half a millisecond we believe the only reasonable thing
to conclude is that the online times are comparable. Though
12Protocol Number Ind.Preprocessing Offline Online of data, the above comparison is only meaningful assuming
32 (cid:55) 8.13MB 312kB a full-duplex channel which might not always be available.
[56] 128 (cid:55) 5.45MB 238kB Finally, even if the amount of data received by the evaluator
1024 (cid:55) 3.76MB 170kB in our protocol is up to ∼4x that of [65] in Table VII,
32 (cid:55) 3.75MB 25.76kB due to the highly parallelizable nature of our independent
[65]∗ 128 (cid:55) 2.5MB 21.31kB
1024 (cid:55) 1.56MB 16.95kB preprocessing phase, this does not translate into equivalently
lower performance as can be seen in Table VI.
32 8.74MB 226.86kB 16.13kB
ThisWork 128 7.22MB 226.86kB 16.13kB For the online phase, our protocol is more data-efficient
1024 6.42MB 226.86kB 16.13kB
than the previous works for any of the considered settings.
∗Dual-execution,sototalofflinecommunicationisdoublethereportednumbers.
In particular, we require sending 16.13kB per AES which
TABLEVII. COMPARISONOFTHEDATARECEIVEDBYTHE is around 1.05-1.6x less data than [65] and 10.5-19x less
EVALUATORFORDIFFERENTNUMBEROFEXECUTIONSOFAES-128WITH than [56], depending on the number of executions considered.
k=128ANDs=40.ALLNUMBERSAREDATAPERAES-128.BEST
Furthermore if one is willing to assume a programmable
RESULTSMARKEDINBOLD.
randomoracle,asisalreadythecaseofboth[65]and[56],our
online phase can easily be modified to only sending 6.30kB
(using 3 rounds) or 9.09kB (using 2 rounds) as explained in
when looking at raw throughput we outperform [65] by more Section V-B.
thanafactor3x(0.08msvs.0.26ms).GoingbeyondTableVI
Finally as mentioned in Section I and summarized in Ta-
and considering the larger SHA-256 circuit we note that our
bleIthebestreportedtimingsforevaluatingasingleAES-128
online phase is not faster than [65] (9.35ms vs. 8.8ms for
is65msin[69].Basedonthereportednumbersintheirpaper
128 circuits). This is again due to the design of our prototype
we estimate that ∼20ms of the execution time consists of
that uses a single execution thread in the online phase per
the initial BaseOTs. We therefore consider the actual cost
circuit, while [65] uses several threads. We therefore see it as
of their protocol to be around 45ms and motivate this by
an interesting problem for future research to tailor the LEGO
observingthatasinglecomputationofBaseOTscanbereused
online phase to better exploit parallelism for a single circuit.
for any number of future executions using OT extension. To
With regards to online latency in the AWS WAN setting give as meaningful a comparison as possible we also ran
there is however no doubt that our two round online phase our implementation on the same AWS setup (c4.2x instance)
outperforms both [56] and [65]. This is directly related to the for the single execution AES-128 case measuring 105.7ms
previousprotocolshavingmoreroundswhichinahighlatency of ind. preprocessing time, 12.07ms dep. preprocessing time
network significantly decreases performance. For comparison and 1.41ms online time on a LAN. Therefore our protocol
[56] has a 4 round online phase and [65] has 5. One thing performs around 2.5x times slower than theirs in total time
to note however is that [65] delivers output to both parties (whenalsoignoringthecostofourinitialBaseOTs).However
in 5 rounds, whereas both our work and [56] would need an if ind. preprocessing can be applied, then from the time the
extraroundtosupportthis.Alsotheimplementationof[56]is circuit is input by the parties, our protocol takes around
written in a mix of Java and C++ using JNI which definitely 13.48ms to evaluate, which is around 3.5x faster than [69].
adds overhead to the running time. It is however unclear how We ran the same experiment in the WAN setting where we
much of a speedup a native implementation would achieve, evaluate an AES-128 in 1837ms of ind. preprocessing time,
but we suspect it would be substantial. The implementation of 82.51msdep.preprocessingtimeand72.63msonlinetime.As
[65] is written solely in C++ and according to the paper also [69] takes 1513ms in total, when adjusting for initial BaseOT
takes full advantage of parallelization. cost the difference is about a factor 1.5x in favor of the latter.
However, when ignoring time for independent preprocessing
InTableVIIwesummarizetherequiredcommunicationfor our protocol can perform around an order of magnitude faster.
thepreviouslyconsideredprotocolsandourworkforthesame We believe this difference in factors between LAN and WAN
settingasTableVI.Aswasthecaseforthemeasuredtimings, is due to our protocol having fewer rounds (when ignoring
when disregarding the cost of the independent preprocessing, ourpreprocessing)andourimplementationfullysaturatingthe
our protocol requires significantly less communication in both network as it sets up multiple parallel TCP connections for
the offline and online phase compared to the previous works. maximal bandwidth utilization.
Fortheofflinephasethecommunicationis5-12xlessthan[65]
and 16-358x less than [56]. If the independent preprocessing ACKNOWLEDGMENTS
is included as part of the offline phase our protocol however
requires transferring more raw data than the previous two The authors would like to thank Michael Zohner for
works for any of the considered number of circuits. However his assistance in augmenting the code of [6] to support the
this is only so because we are considering multiple copies randomnessextractiontechniqueusedtoproduce∆-ROTs.We
(32, 128, and 1024) of the same function AES-128. If we also thank Tore Kasper Frederiksen and Thomas P. Jakobsen
insteadconsidersettingswithfewcopies(thelargerthebetter), for sharing their initial unpublished work on implementing
a single copy, or several different circuits, the amount of data TinyLEGO which was used as inspiration for part of our
received in the independent + dependent preprocessing phase codebase. Finally, we thank the anonymous reviewers from
of our protocol can match or be lower than the dependent NDSS 2017 for their valuable feedback on our paper.
offlinephaseof[65],dependingonthecircuitsizesandnumber
of circuits considered. Also, as [65] uses the dual-execution
paradigmwherebothpartiessendandreceivethesameamount
13REFERENCES [22] D. Chaum, C. Cre´peau, and I. Damga˚rd, “Multiparty unconditionally
secureprotocols(extendedabstract),”inSTOC1988. ACMPress,May
[1] DyadicSecurity.https://www.dyadicsec.com. 1988,pp.11–19.
[2] Partisia.http://www.partisia.dk. [23] T.ChouandC.Orlandi,“Thesimplestprotocolforoblivioustransfer,”
[3] Sepior.https://www.sepior.com. in LATINCRYPT 2015, ser. LNCS, K. E. Lauter and F. Rodr´ıguez-
[4] A.Afshar,P.Mohassel,B.Pinkas,andB.Riva,“Non-interactivesecure Henr´ıquez,Eds.,vol.9230. Springer,Aug.2015,pp.40–58.
computation based on cut-and-choose,” in EUROCRYPT 2014, ser. [24] I.Damga˚rd,M.Keller,E.Larraia,V.Pastro,P.Scholl,andN.P.Smart,
LNCS,P.Q.NguyenandE.Oswald,Eds.,vol.8441. Springer,May “PracticalcovertlysecureMPCfordishonestmajority-or:Breakingthe
2014,pp.387–404. SPDZlimits,”inESORICS2013,ser.LNCS,J.Crampton,S.Jajodia,
[5] G. Asharov, Y. Lindell, T. Schneider, and M. Zohner, “More efficient andK.Mayes,Eds.,vol.8134. Springer,Sep.2013,pp.1–18.
oblivioustransferandextensionsforfastersecurecomputation,”inACM [25] I. Damga˚rd, R. Lauritsen, and T. Toft, “An empirical study and some
CCS2013,A.-R.Sadeghi,V.D.Gligor,andM.Yung,Eds. ACMPress, improvements of the MiniMac protocol for secure computation,” in
Nov.2013,pp.535–548. SCN 2014, ser. LNCS, M. Abdalla and R. D. Prisco, Eds., vol. 8642.
Springer,Sep.2014,pp.398–415.
[6] ——, “More efficient oblivious transfer extensions with security for
malicious adversaries,” in EUROCRYPT 2015, Part I, ser. LNCS, [26] I. Damga˚rd, J. B. Nielsen, M. Nielsen, and S. Ranellucci, “Gate-
E. Oswald and M. Fischlin, Eds., vol. 9056. Springer, Apr. 2015, scrambling revisited - or: The TinyTable protocol for 2-party secure
pp.673–701. computation,” IACR Cryptology ePrint Archive, vol. 2016, p. 695,
2016.[Online].Available:http://eprint.iacr.org/2016/695
[7] Y. Aumann and Y. Lindell, “Security against covert adversaries: Effi-
cientprotocolsforrealisticadversaries,”inTCC2007,ser.LNCS,S.P. [27] I.Damga˚rd,V.Pastro,N.P.Smart,andS.Zakarias,“Multipartycom-
Vadhan,Ed.,vol.4392. Springer,Feb.2007,pp.137–156. putationfromsomewhathomomorphicencryption,”inCRYPTO2012,
ser.LNCS,R.Safavi-NainiandR.Canetti,Eds.,vol.7417. Springer,
[8] D. Beaver, “Precomputing oblivious transfer,” in CRYPTO 1995, ser.
Aug.2012,pp.643–662.
LNCS,D.Coppersmith,Ed.,vol.963. Springer,Aug.1995,pp.97–
109. [28] I. Damga˚rd and R. W. Zakarias, “Fast oblivious AES A dedicated
application of the MiniMac protocol,” in AFRICACRYPT 2016, ser.
[9] M. Bellare, V. T. Hoang, and S. Keelveedhi, “Instantiating random
LNCS,vol.9646. Springer,2016,pp.245–264.
oracles via UCEs,” in CRYPTO 2013, Part II, ser. LNCS, R. Canetti
andJ.A.Garay,Eds.,vol.8043. Springer,Aug.2013,pp.398–415. [29] I. Damga˚rd and S. Zakarias, “Constant-overhead secure computation
of boolean circuits using preprocessing,” in TCC 2013, ser. LNCS,
[10] M. Bellare, V. T. Hoang, S. Keelveedhi, and P. Rogaway, “Efficient
A.Sahai,Ed.,vol.7785. Springer,Mar.2013,pp.621–641.
garbling from a fixed-key blockcipher,” in IEEE S&P 2013. IEEE
ComputerSocietyPress,May2013,pp.478–492. [30] J.O.Eklundh,“Afastcomputermethodformatrixtransposing,”IEEE
Trans.Computers,vol.21,no.7,pp.801–803,1972.
[11] M.Bellare,V.T.Hoang,andP.Rogaway,“Adaptivelysecuregarbling
with applications to one-time programs and secure outsourcing,” in [31] P.FarshimandA.Mittelbach,“Modelingrandomoraclesunderunpre-
ASIACRYPT2012,ser.LNCS,X.WangandK.Sako,Eds.,vol.7658. dictable queries,” in FSE 2016, ser. LNCS, T. Peyrin, Ed., vol. 9783.
Springer,Dec.2012,pp.134–153. Springer,March,2016,pp.453–473.
[12] ——, “Foundations of garbled circuits,” in ACM CCS 2012, T. Yu, [32] T.K.Frederiksen,T.P.Jakobsen,andJ.B.Nielsen,“Fastermaliciously
G.Danezis,andV.D.Gligor,Eds. ACMPress,Oct.2012,pp.784– securetwo-partycomputationusingtheGPU,”inSCN2014,ser.LNCS,
796. M. Abdalla and R. D. Prisco, Eds., vol. 8642. Springer, Sep. 2014,
pp.358–379.
[13] M.BellareandP.Rogaway,“Randomoraclesarepractical:Aparadigm
for designing efficient protocols,” in ACM CCS 1993, V. Ashby, Ed. [33] T. K. Frederiksen, T. P. Jakobsen, J. B. Nielsen, and R. Trifiletti,
ACMPress,Nov.1993,pp.62–73. “TinyLEGO: An interactive garbling scheme for maliciously secure
two-party computation,” IACR Cryptology ePrint Archive, vol. 2015,
[14] M.Ben-Or,S.Goldwasser,andA.Wigderson,“Completenesstheorems
p.309,2015.[Online].Available:http://eprint.iacr.org/2015/309
for non-cryptographic fault-tolerant distributed computation (extended
abstract),”inSTOC1988. ACMPress,May1988,pp.1–10. [34] ——, “On the complexity of additively homomorphic UC commit-
ments,”inTCC2016-A,PartI,ser.LNCS,E.KushilevitzandT.Malkin,
[15] D.Bogdanov,S.Laur,andJ.Willemson,“Sharemind:Aframeworkfor
Eds.,vol.9562. Springer,Jan.2016,pp.542–565.
fast privacy-preserving computations,” in ESORICS 2008, ser. LNCS,
S. Jajodia and J. Lo´pez, Eds., vol. 5283. Springer, Oct. 2008, pp. [35] T. K. Frederiksen, T. P. Jakobsen, J. B. Nielsen, P. S. Nordholt, and
192–206. C.Orlandi,“MiniLEGO:Efficientsecuretwo-partycomputationfrom
generalassumptions,”inEUROCRYPT2013,ser.LNCS,T.Johansson
[16] P. Bogetoft, D. L. Christensen, I. Damga˚rd, M. Geisler, T. Jakobsen,
andP.Q.Nguyen,Eds.,vol.7881. Springer,May2013,pp.537–556.
M.Krøigaard,J.D.Nielsen,J.B.Nielsen,K.Nielsen,J.Pagter,M.I.
Schwartzbach,andT.Toft,“Securemultipartycomputationgoeslive,” [36] T.K.FrederiksenandJ.B.Nielsen,“Fastandmaliciouslysecuretwo-
in FC 2009, ser. LNCS, R. Dingledine and P. Golle, Eds., vol. 5628. party computation using the GPU,” in ACNS 2013, ser. LNCS, M. J.
Springer,Feb.2009,pp.325–343. Jacobson Jr., M. E. Locasto, P. Mohassel, and R. Safavi-Naini, Eds.,
vol.7954. Springer,Jun.2013,pp.339–356.
[17] R.C.BoseandD.K.Ray-Chaudhuri,“Onaclassoferrorcorrecting
binarygroupcodes,”Informationandcontrol,vol.3,no.1,pp.68–79, [37] O.Goldreich,S.Micali,andA.Wigderson,“Howtoplayanymental
1960. gameorAcompletenesstheoremforprotocolswithhonestmajority,”
inSTOC1987,A.Aho,Ed. ACMPress,May1987,pp.218–229.
[18] L. T. A. N. Branda˜o, “Secure two-party computation with reusable
bit-commitments,viaacut-and-choosewithforge-and-losetechnique- [38] A. Hocquenghem, “Codes correcteurs d’erreurs,” Chiffres, vol. 2, no.
(extendedabstract),”inASIACRYPT2013,PartII,ser.LNCS,K.Sako 147-156,pp.8–5,1959.
andP.Sarkar,Eds.,vol.8270. Springer,Dec.2013,pp.441–463. [39] Y. Huang, D. Evans, J. Katz, and L. Malka, “Faster secure two-
[19] S. S. Burra, E. Larraia, J. B. Nielsen, P. S. Nordholt, C. Orlandi, party computation using garbled circuits,” in USENIX Security 2011.
E. Orsini, P. Scholl, and N. P. Smart, “High performance multi-party USENIXAssociation,2011.
computation for binary circuits based on oblivious transfer,” IACR [40] Y. Huang, J. Katz, and D. Evans, “Efficient secure two-party compu-
CryptologyePrintArchive,vol.2015,p.472,2015.[Online].Available: tationusingsymmetriccut-and-choose,”inCRYPTO2013,PartII,ser.
http://eprint.iacr.org/2015/472 LNCS, R. Canetti and J. A. Garay, Eds., vol. 8043. Springer, Aug.
[20] R. Canetti, “Universally composable security: A new paradigm for 2013,pp.18–35.
cryptographic protocols,” in FOCS 2001. IEEE Computer Society [41] Y. Huang and R. Zhu, “Revisiting LEGOs: Optimizations, analysis,
Press,Oct.2001,pp.136–145. and their limit,” IACR Cryptology ePrint Archive, vol. 2015, p. 1038,
[21] I. Cascudo, I. Damga˚rd, B. David, N. Do¨ttling, and J. B. Nielsen, 2015.[Online].Available:http://eprint.iacr.org/2015/1038
“Rate-1, linear time and additively homomorphic UC commitments,” [42] N. Husted, S. Myers, a. shelat, and P. Grubbs, “GPU and CPU
inCRYPTO2016,PartIII,ser.LNCS,M.RobshawandJ.Katz,Eds., parallelizationofhonest-but-curioussecuretwo-partycomputation,”in
vol.9816. Springer,2016,pp.179–207. ACSAC2013,C.N.P.Jr.,Ed. ACM,2013,pp.169–178.
14[43] M.Keller,E.Orsini,andP.Scholl,“ActivelysecureOTextensionwith ifiable secret sharing,” in CRYPTO 1991, ser. LNCS, J. Feigenbaum,
optimal overhead,” in CRYPTO 2015, Part I, ser. LNCS, R. Gennaro Ed.,vol.576. Springer,Aug.1992,pp.129–140.
and M. J. B. Robshaw, Eds., vol. 9215. Springer, Aug. 2015, pp. [63] C.Peikert,V.Vaikuntanathan,andB.Waters,“Aframeworkforefficient
724–741. and composable oblivious transfer,” in CRYPTO 2008, ser. LNCS,
[44] ——,“MASCOT:fastermaliciousarithmeticsecurecomputationwith D.Wagner,Ed.,vol.5157. Springer,Aug.2008,pp.554–571.
oblivioustransfer,”inACMCCS2016,E.R.Weippl,S.Katzenbeisser, [64] B. Pinkas, T. Schneider, N. P. Smart, and S. C. Williams, “Secure
C.Kruegel,A.C.Myers,andS.Halevi,Eds. ACMPress,Oct.2016, two-party computation is practical,” in ASIACRYPT 2009, ser. LNCS,
pp.830–842. M.Matsui,Ed.,vol.5912. Springer,Dec.2009,pp.250–267.
[45] M. Keller, P. Scholl, and N. P. Smart, “An architecture for practical [65] P. Rindal and M. Rosulek, “Faster malicious 2-party secure compu-
activelysecureMPCwithdishonestmajority,”inACMCCS2013,A.- tation with online/offline dual execution,” in USENIX Security 2016.
R.Sadeghi,V.D.Gligor,andM.Yung,Eds. ACMPress,Nov.2013, USENIXAssociation,2016,pp.297–314.
pp.549–560.
[66] a. shelat and C.-H. Shen, “Two-output secure computation with mali-
[46] M.S.KirazandB.Schoenmakers,“Aprotocolissueforthemalicious ciousadversaries,”inEUROCRYPT2011,ser.LNCS,K.G.Paterson,
case of Yao’s garbled circuit construction,” in 27th Symposium on Ed.,vol.6632. Springer,May2011,pp.386–405.
InformationTheoryintheBenelux,2006,pp.283–290.
[67] ——,“Fasttwo-partysecurecomputationwithminimalassumptions,”
[47] V.KolesnikovandT.Schneider,“Improvedgarbledcircuit:FreeXOR in ACM CCS 2013, A.-R. Sadeghi, V. D. Gligor, and M. Yung, Eds.
gatesandapplications,”inICALP2008,PartII,ser.LNCS,L.Aceto, ACMPress,Nov.2013,pp.523–534.
I.Damga˚rd,L.A.Goldberg,M.M.Halldo´rsson,A.Ingo´lfsdo´ttir,and [68] N. Smart and S. Tillich. Circuits of Basic Functions Suitable For
I.Walukiewicz,Eds.,vol.5126. Springer,Jul.2008,pp.486–498. MPCandFHE.[Online].Available:http://www.cs.bris.ac.uk/Research/
[48] B. Kreuter, a. shelat, and C. Shen, “Billion-gate secure computation CryptographySecurity/MPC/
with malicious adversaries,” in USENIX Security 2012. USENIX [69] X.Wang,A.J.Malozemoff,andJ.Katz,“Fastertwo-partycomputation
Association,2012,pp.285–300. secure against malicious adversaries in the single-execution setting,”
[49] E.Larraia,E.Orsini,andN.P.Smart,“Dishonestmajoritymulti-party Cryptology ePrint Archive, Report 2016/762, 2016, http://eprint.iacr.
computationforbinarycircuits,”inCRYPTO2014,PartII,ser.LNCS, org/2016/762.
J. A. Garay and R. Gennaro, Eds., vol. 8617. Springer, Aug. 2014, [70] A.C.-C.Yao,“Protocolsforsecurecomputations(extendedabstract),”
pp.495–512. in FOCS 1982. IEEE Computer Society Press, Nov. 1982, pp. 160–
[50] Y. Lindell, “Fast cut-and-choose based protocols for malicious and 164.
covert adversaries,” in CRYPTO 2013, Part II, ser. LNCS, R. Canetti [71] ——, “How to generate and exchange secrets (extended abstract),” in
andJ.A.Garay,Eds.,vol.8043. Springer,Aug.2013,pp.1–17. FOCS1986. IEEEComputerSocietyPress,Oct.1986,pp.162–167.
[51] Y. Lindell and B. Pinkas, “An efficient protocol for secure two-party [72] S. Zahur, M. Rosulek, and D. Evans, “Two halves make a whole -
computation in the presence of malicious adversaries,” in EURO- reducing data transfer in garbled circuits using half gates,” in EURO-
CRYPT 2007, ser. LNCS, M. Naor, Ed., vol. 4515. Springer, May CRYPT2015,PartII,ser.LNCS,E.OswaldandM.Fischlin,Eds.,vol.
2007,pp.52–78. 9057. Springer,Apr.2015,pp.220–250.
[52] ——,“AproofofsecurityofYao’sprotocolfortwo-partycomputation,” [73] H. Zhou and J. Bruck, “Linear extractors for extracting randomness
JournalofCryptology,vol.22,no.2,pp.161–188,Apr.2009. from noisy sources,” in ISIT 2011, A. Kuleshov, V. Blinovsky, and
A.Ephremides,Eds. IEEE,2011,pp.1738–1742.
[53] ——, “Secure two-party computation via cut-and-choose oblivious
transfer,”inTCC2011,ser.LNCS,Y.Ishai,Ed.,vol.6597. Springer,
Mar.2011,pp.329–346.
[54] Y. Lindell, B. Pinkas, and N. P. Smart, “Implementing two-party
computationefficientlywithsecurityagainstmaliciousadversaries,”in
SCN2008,ser.LNCS,R.Ostrovsky,R.D.Prisco,andI.Visconti,Eds.,
vol.5229. Springer,Sep.2008,pp.2–20.
[55] Y.LindellandB.Riva,“Cut-and-chooseYao-basedsecurecomputation
intheonline/offlineandbatchsettings,”inCRYPTO2014,PartII,ser.
LNCS,J.A.GarayandR.Gennaro,Eds.,vol.8617. Springer,Aug.
2014,pp.476–494.
[56] ——, “Blazing fast 2PC in the offline/online setting with security
for malicious adversaries,” in ACM CCS 2015, I. Ray, N. Li, and
C.Kruegel:,Eds. ACMPress,Oct.2015,pp.579–590.
[57] P.MohasselandM.Franklin,“Efficiencytradeoffsformalicioustwo-
party computation,” in PKC 2006, ser. LNCS, M. Yung, Y. Dodis,
A. Kiayias, and T. Malkin, Eds., vol. 3958. Springer, Apr. 2006,
pp.458–473.
[58] P. Mohassel and B. Riva, “Garbled circuits checking garbled circuits:
More efficient and secure two-party computation,” in CRYPTO 2013,
Part II, ser. LNCS, R. Canetti and J. A. Garay, Eds., vol. 8043.
Springer,Aug.2013,pp.36–53.
[59] B.Mood,D.Gupta,K.R.B.Butler,andJ.Feigenbaum,“Reuseitor
lose it: More efficient secure computation through reuse of encrypted
values,”inACMCCS2014,G.-J.Ahn,M.Yung,andN.Li,Eds. ACM
Press,Nov.2014,pp.582–596.
[60] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra, “A
new approach to practical active-secure two-party computation,” in
CRYPTO 2012, ser. LNCS, R. Safavi-Naini and R. Canetti, Eds., vol.
7417. Springer,Aug.2012,pp.681–700.
[61] J.B.NielsenandC.Orlandi,“LEGOfortwo-partysecurecomputation,”
inTCC2009,ser.LNCS,O.Reingold,Ed.,vol.5444. Springer,Mar.
2009,pp.368–386.
[62] T. P. Pedersen, “Non-interactive and information-theoretic secure ver-
15