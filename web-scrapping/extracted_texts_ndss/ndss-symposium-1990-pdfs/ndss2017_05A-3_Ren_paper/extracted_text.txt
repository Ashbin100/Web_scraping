WindowGuard: Systematic Protection of GUI
Security in Android
Chuangang Ren Peng Liu Sencun Zhu
The Pennsylvania State University The Pennsylvania State University The Pennsylvania State University
cyr5126@cse.psu.com pliu@ist.psu.com szhu@cse.psu.com
Abstract—Android graphic user interface (GUI) system plays Android GUI attack refers to any harmful behavior that
an important role in rendering app GUIs on display and attempts to adversely affect the integrity and availability of
interacting with users. However, the security of this critical sub- GUIs belonging to other apps in order to achieve malicious
systemremainsunder-investigated.Infact,AndroidGUIhasbeen purposes, such as launching a phishing or spoofing window
plagued by a variety of GUI attacks in recent years. GUI attack
to lure the user into taking undesirable actions, or forcefully
refers to any harmful behavior that attempts to adversely affect
pushingunwantedGUIcontenttothescreen.Therehavebeen
the integrity or availability of the GUIs belonging to other apps.
extensive recent studies on Android GUI attacks. In an attack
Theseattacksarerealthreatsandcancausesevereconsequences,
demonstrated in [7], an attacker launches a phishing GUI
such as sensitive user information leakage, user device denial
of service, etc. Given the seriousness and rapid growth of GUI immediately after an interesting event in a banking app is
attacks, we are in a pressing need for a comprehensive defense detected, resulting in bank account information stolen. In [2],
solution. Nevertheless, existing defense methods fall short in [19],[25],theauthorsshowthatappswithcertainpermissions
defense coverage, effectiveness and practicality. can launch different types of powerful phishing or tapjacking
attacks. Notably, a more dreadful attack method, called task
Toovercomethesechallenges,wesystematicallyscrutinizethe
hijacking [28], can be done even without any permission.
securityimplicationsofAndroidGUIsystemdesignandpropose
Specifically, by manipulating the activity browsing history
anewsecuritymodel,AndroidWindowIntegrity(AWI),tocom-
saved in Android tasks, an attacker can launch a broad range
prehensively protect the system against GUI attacks. The AWI
modeldefinestheusersessiontobeprotectedandthelegitimacy of attacks, including GUI confusion, denial-of-service, and
of GUI system states in the unique mobile GUI environment. By user activity monitoring attacks. Surprisingly, these attacks
doing so, it can protect a normal user session against arbitrary can affect all Android versions and all apps installed on the
manipulation by attackers, and still preserve the original user vulnerable devices, including the most privileged system apps
experience. Our implementation, WindowGuard, enforces the and system UI.
AWImodelandrespondstoasuspiciousbehaviorbybriefingthe
useraboutasecurityeventandaskingforthefinaldecisionfrom Moreconcerningly,theGUIattackvectorsareincreasingly
the user. This design not only improves the detection accuracy, employed by real-world malware at an alarming rate. For
butalsomakesWindowGuardmoreusableandpracticaltomeet instance, several malware families use GUI confusion attacks
diverse user needs. WindowGuard is implemented as an Xposed to steal credit card information [35]. Ransomware, a type
module, making it practical to be quickly deployed on a large
of malware that renders a user device useless by forcefully
numberofuserdevices.OurevaluationshowsthatWindowGuard
locking the screen until a certain amount of ransom money is
can successfully detect all known GUI attacks, while yielding
paid, has migrated from PC to the Android world [4], [26],
small impacts on user experience and system performance.
infecting more than 900 thousand Android devices within two
years [9]. In addition, adware, which repeatedly presents un-
wanted (and sometimes “unclosable”) advertisement windows
I. INTRODUCTION
totheuser,isnotonlyirritating,butalsomakestheuserprone
Mobile graphic user interface (GUI) system plays an im- to further malware infection [27], [33]. Given the severity and
portant role in rendering app GUIs on display and interacting rapid growth of GUI attacks, we have a pressing need for
withtheuser,whichhasmajorimpactsontheuserexperience a comprehensive defense solution to effectively mitigate the
of a mobile device. In particular, Android’s GUI has greatly emerging threat.
promoteduserexperienceandgainedmassivepopularitytothe
Androidsystem.Despitethemerits,Androidhasbeenplagued Challenges: A recent defense solution has been proposed
by a variety of GUI attacks in recent years. in [2], which involves a two-layer defense: an app vetting
process based on static analysis, and an on-device defense
mechanism. The static analysis scans for the suspicious use
Permission to freely reproduce all or part of this paper for noncommercial of GUI-related APIs/permissions and flags the apps who use
purposes is granted provided that copies bear this notice and the full citation
them as malicious. A fundamental challenge (also mentioned
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author by the authors) is that it is difficult for code analysis to
(for reproduction of an entire paper only), and the author’s employer if the determine the real purpose of using these APIs/permissions.
paper was prepared within the scope of employment. For instance, although a legitimate screen locker app may use
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
the same set of APIs and exhibits similar behavior (launching
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23529 a lock screen) as a malicious ransomware, the purposes ofthe two apps are totally different. In this case, it is up to briefs the user about the security event and asks for the final
the user to decide if a screen lock is desirable or not based decision from user, who is inherently more capable of making
on the runtime context. User involvement is adopted by the the best decision for him/herself based on the context. More
second on-device defense in [2], which inherits the idea of importantly,thisdesignmakesWindowGuardmoreusableand
Extended Validation Certificate (EV) green address bar in practical to meet diverse needs from users and app developers
browsers. By putting a reliable app origin indicator in the in the current Android ecosystem. Our evaluation shows that
navigation bar, an app can constantly inform the user of its WindowGuard can immediately detect all known GUI attacks
identity as long as the origin indicator is visible. By this with minimal performance overhead. We also evaluate the
means, it prevents user from providing sensitive information usability of WindowGuard over 12,060 most popular Google
to the wrong entity in a GUI confusion attack. Despite the Play apps. We find that the WindowGuard has no usability
novelty of this solution, the passive defense solely relies on impact on most apps. Among the 1.03% of apps that trigger
the correct judgment of savvy users and thus requires users’ the security alert, most of them are only involved in one type
continuousattentiontotheindicatoronthenavigationbar.This of security enforcement, which can be promptly turned off
not only largely affects user experience, but also undermines for that app based on user decision and will not distract the
its effectiveness, e.g., reportedly only 76% detection rate at useranylongerafterthat.Insummary,wemakethefollowing
best in a user study. Moreover, this defense strategy is only contributions:
helpfulinGUIconfusionattacks,butcannotdefeatothertypes
• New understanding of the Android GUI security. To
of GUI attacks, e.g., denial-of-service attack. In addition, the
the best of our knowledge, we are the first to sys-
requirements of modifying both existing apps (implementing
tematically overhaul the security implications of the
HTTPS EV certification) and the system make it impractical
Android GUI system design, a complex subsystem
to be adopted by any significant portion of apps or systems in
that is composed of a variety of system services
the Android ecosystem.
and components. This new understanding can further
inspire follow-up research on mobile GUI system
Our approach: It is exactly these challenges that this paper
security.
seeks to address by proposing a viable new solution. We take
the first steps to systematically scrutinize the security impli- • Novel GUI security model in mobile environment. We
cations of Android GUI system, one of the most sophisticated propose a novel security model - Android window
subsystem in Android. At the heart of the problem, a GUI integrity - for the GUI subsystem in a unique mobile
attack occurs when an attacker interferes with the normal user environment like Android. By clearly specifying the
session such that the attacker’s GUI finally takes over part or capabilities of various principals in a user session and
all of the device’s display (regardless of if the user realizes it defining the legitimacy of GUI system states, AWI is
ornot).AlthoughtheAndroidsecuritymodelrendersdifferent able to comprehensively and automatically protect a
appssandboxedandisolatedfromoneanother,theusersession normal user session against a wide spectrum of GUI
- a series of GUIs that a user has visited when doing a attacks.Moreimportantly,thenewsecuritymodelalso
particular job - is typically a joint “effort” from different considerably raises the bar for future attacks. New
apps, and is beyond the protection scope of the existing attacks can now be put under the test of our defense
security mechanisms. The problem is further exaggerated by before they cause real threats.
the uniqueness of mobile GUI environment. That is, given
• Implementation and evaluation. WindowGuard is de-
the lack of app identifier and user control on the screen,
veloped as an Xposed module that can be quickly
plus a plethora of APIs that can be abused to affect the GUI
deployed and protect a large number of user devices.
system states, the normal user session is extremely vulnerable
WindowGuard implements the AWI model and en-
to arbitrary interruption or manipulation by the attacker, e.g.,
gages the user when suspicious behaviors are de-
popping up a phishing window on top of the current app,
tected. This design involves user input in context-
modifying an app’s window history, etc.
aware “block it or not” decision-making and also
Tofillthisimportantsecuritygap,weproposeanewsecu- preserves desired user experience based on user’s
rity model - Android window integrity(AWI) - to comprehen- choices.OurevaluationshowsthatWindowGuardcan
sivelyprotectthesystemagainstGUIattacks.AWIisageneric detect all known GUI attacks while yielding small
security model that clearly designates a user session, specifies impact on device usability and system performance.
the capabilities of various other principals in the system, and
defines the legitimacy that the GUI system should keep from II. ANDROIDGUISYSTEM
one state to another. AWI is carefully designed to conform to
Android GUI subsystem is composed of various system
the Android app model and the norm of app navigation. By
services and components and requires a close collaboration of
doing so, it protects the normal user session against abrupt
them. Activity Manager Service (AMS) and Window Manager
interference by other apps while still preserving the original
Service (WMS) are among the most important ones. In this
user experience. Our implementation of the model, namely
section, we introduce how Android GUI system works and
WindowGuard,cansystematicallyprotecttheGUIsystemand
identify the security risks of this complex system.
aimstodefeatallGUIattacks,amuchbroaderrangeofattacks
than previous work. When WindowGuard is deployed on user
A. Activity and Window
devices, the user is not bothered at all until a suspicious
behavior is detected, caused by the violation of a set of Activity: Activity is a type of app component that provides
integritycriteriadefinedintheAWImodel.WindowGuardthen one or more windows to the user. Activity and window are
2Activity Manager frame.(4)Oncetheappreceivesthesharedsurface,itcanstart
1 Service drawing the window’s entire view hierarchy on the surface
Tasks and signals SurfaceFlinger when the drawing is completed.
App
Activity 2 This drawingprocess is synchronized withSurfaceFlinger and
Windows Manager
Phone Service can happen as fast as 60 frames/second. (5) SurfaceFlinger
Window Window keeps multiple layers of different windows in a layer stack.
Stack
Whenallthevisiblelayersareready,SurfaceFlingercomposes
3
View Hierarchy 5 them and displays the final frame on the screen, with the help
DecorView 4 SurfaceFlinger
TextView Image L Sa tay ce kr ComH/ pW oser Afro bm strH aca tr Ldw aya er re (C Ho Am Lp )os lie br ra(H ryW . C),adevice-specificHardware
Application System Services Mobile Display User
In this architecture, although SurfaceFlinger has direct
control to the display hardware, it strictly carries out the
Fig.1. OverviewofAndroidGUISystemArchitecture
commandsfromits“supervisors”.The“supervisors”,i.e.AMS
and WMS, not only control how the windows should be
closely related: each activity must have a window instance, displayed, e.g. window size, location, transparency, z-order,
which contains the GUI contents to be displayed. The GUI but also determine what windows should be made visible. In
contents are specified by the app developer. If not explicitly otherwords,thesetwosystemservicesaretheheartofAndroid
specified, a default GUI will be populated to the activity’s GUIsystem.Wenowintroducethembylookingatanexample
window. In Android, activity is designed to be the building shown in Figure 2.
block of app navigation. For example, when an user opens an
1)Activity Management: Activity management is per-
emailapp,thefirstactivitymayshowaloginscreen;afterthat
formed by AMS. Activities are started by AMS upon client
thesecondactivitydisplaystheinbox;andthentheuseropens
requests through intents, an abstract description of the activity
the third one to compose a new message.
to be started. As shown in the left part of Figure 2, every
Window: Conceptually, window is a visual area on screen app activity has one-to-one mapping to its corresponding
that shows the GUI of the program it belongs to. In an app ActivityRecord instance in AMS. For convenience, we refer
activity, a window instance is a container that holds hierarchi- to an ActivityRecord instance in AMS simply as activity for
cal GUI elements (view hierarchy) to be displayed on screen. the rest of this paper.
InWindowManagerService,eachwindowisrepresentedbya
AMSorganizesallactivitiesintasks[1].Eachtaskincludes
WindowStateinstance,whichcontainsalltheparametersabout
a stack of activities, namely back stack. Activities in a back
the window such as size, location, transparency, and z-order
stack are ordered by the time that they are visited, such that
etc. There are usually multiple windows at the same time and
the user can go back to the most recent activity. There is only
the system composes them into one frame to be displayed on
one activity running in the system at a time, called focused
screen. Android system defines three classes of windows: (1)
activity. The task that contains the focused activity is focused
App window: the top-level window that is associated with an
task; all other tasks are in the background. Figure 2 (in AMS)
activity;(2)Systemwindow:asetofwindowsthatareusedfor
shows multiple tasks: two for app A and B, respectively, and
specialpurposes,e.g.,statusbar,navigationbar,andkeyguard
another task for the launcher. When the user clicks an app
etc. (3) Sub-window: the window that is attached to the other
icon in the launcher, a new task is typically created and the
two classes of windows. It is noteworthy that although system
main activity of the app becomes the root activity in the task.
windows are mainly used by the system, third-party app can
When another activity is later started, it is by default pushed
also launch system windows as long as it is granted certain
on top of the task that launched it. For instance, activity A2
permission (as we will see in Section II-B). For example,
is started by A1 and is thus put on top of task A. Activity A1
method input or wall paper windows could come from third-
is stopped but remains in the task, whereas A2 gets the focus
party packages.
and is shown on display. When the user later presses the back
button, the top activity is popped from the task and destroyed,
B. GUI Architecture Overview
and the next activity A1 on stack is then resumed and become
Figure1showsthearchitectureofAndroidGUIsystemand the focused activity again. Since activity is the building block
illustrateshowanapp’sactivitymanagestodisplayitswindow oftheapplicationmodelinAndroid,AMSessentiallycontrols
onscreen.Theprocessinvolvesthefollowingstepsfromahigh theappnavigation,andtheoveralluserexperienceinAndroid.
level:(1)AMSlaunchesanewactivityofanapp.(2)Thenew
2)WindowManagement: WMSisresponsibleforavariety
activity then creates a window for itself during initialization
of jobs. One of the most important one is to manage all
and registers the window to the WMS. WMS creates a new
windowsinthesystem,updatetheirparametersandpassthem
WindowStateinstancethatrepresentsthenewwindowandadd
to SurfaceFlinger when needed. Specifically, each window is
ittoawindowstack,whichcontainsallavailableWindowState
represented as a WindowState instance in WMS. For conve-
instances in the system. (3) On behalf of the app, WMS then
nience,werefertoaWindowStateinstancesimplyasawindow
asks the SurfaceFlinger to create a drawing surface for the
for the rest of this paper.
window, i.e. a buffer containing graphical data. The drawing
surface, also known as layer, is in turn shared with the app All windows in a display (usually only one for mobile
by passing a handler back to the app. Meanwhile, WMS also device) are kept in one stack, namely window stack. Once
provides the window parameters to SurfaceFlinger such that changes happen to any window or the window stack, e.g.,
the latter can later use this information to compose the final window re-sizing, activity launch, etc., WMS would walk
3AMS WMS
Sys
Task A Status Bar Win
A2 Keyguard Win
Toast Win
A1
A2 Sub Win
Task B Input A2 Win
A1 Win
B1 Input Win
B1 Win Task L Launch Launcher Win
Wallpaper Win
Window stack
redro-Z
App A
addView()
R S NavigaBon Bar Win
Ac0vity
A2 A2 A pp Service
A1 A1 Broadcast Receiver
Back Ac0vity Record App B Stacks
Focused Ac0vity Record
B1 B1
WindowToken
AppWindowToken Launcher
Launcher Wall Visible Window
L paper
Invisible Window
Apps System Services Mobile Display
Fig.2. AsnapshotofsystemstatesinAMSandWMS
through the window stack, calculate the new parameters for classify all windows in the system into two categories. As we
all windows, and pass the new information to SurfaceFlinger, willsee,itisimportanttomakesuchdistinctionforthedesign
whichwouldcomposeallupdatedlayersandfinallyreflectthe of GUI security scheme.
changes on screen.
1) Activity window: the window that is associated with
As shown in Figure 2, the window stack ranks windows anactivity.Itmaybeatoplevelappwindoworasub
by a numeric value called z-order. A window with higher z- windowattachedtotheappwindow.Anactivitymay
orderresideshigherinthestack,whichmeansthatthewindow have multiple windows. These windows are grouped
will appear on top of others if window overlap occurs. A into a list under the corresponding AppWindowTo-
preliminary z-order is first assigned to a window based on ken, which uniquely identify the activity in AMS.
its type. For example, app windows have lower z-order values 2) Free window: a window that is not associated with
whilesystemwindows(suchasstatusandnavigationbar)have anyactivity.Afreewindowiseitherasystemwindow
higher values and hence are shown on top of screen. The final or a sub-window attached to the system window.
z-order is further determined based on a variety of factors,
such as window function, order of creation, etc. For instance, Figure 2 shows all available WindowTokens, and App-
the z-order of an input method window is always set to be WindowTokens including their one-to-one mappings to Activ-
a bit higher than the app window (B1 window) that requests ityRecord instances in AMS. Notably, two activity windows
the input keyboard, but not higher than the window that is are visible and both belong to token A2: one sub window in
originally above the app window. the foreground (a progress dialog “A2 Sub”), and another app
window (”A2 Win”) beneath it. They are emplaced above all
A window can either be visible or hidden, and there are
other activity windows by WMS when activity A2 becomes
usually multiple visible windows simultaneously. Figure 2 ex-
the focused activity. In addition, an activity window is always
hibitsthevisiblewindowsinWMSandtheirwindowareason
started by an activity. On the other hand, both the system and
screen. Here, visibility does not refer to whether being visible
third-party apps can directly launch free windows by making
bynakedeye.Instead,visibilityisawindowstate.if“visible”,
an addView() API call to WMS, e.g., app A is free to start
it indicates that the window is ready for display. Nevertheless,
a toast window (one type of system window) on top of other
whether the window will finally be shown on screen depends
windows in Figure 2.
on the location, transparency and z-order of other “visible”
windows. That is, if the window area is completely overlaid
by other windows higher in the window stack, the window is C. Security Mechanisms
in fact hidden “behind” the foreground windows even if the
Therearethreesecuritymechanismsthatplaycriticalroles
state is “visible”. For example, although the visibility of the
for GUI security in Android: app sandboxing, binder token,
launcher’s wallpaper window in Figure 2 is always set to be
and permission scheme.
“visible”, it is completely overlayed by other visible windows
(because it resides at the bottom of the window stack) and is In Android, every app is given a unique Linux UID and
in fact invisible on display. On the other hand, if visibility is runsinaseparateprocessbydefault,whicheffectivelyisolates
set to “hidden”, a window will not be displayed at all. one app from the others. From GUI’s perspective, sandboxing
guaranteestheisolationofthegraphicinformationineachapp
Given the windows in window stack, WMS is able to
window, e.g., preventing an app from modifying the drawing
quickly and reliably identify the owner of each window
surface of another app, given that the system itself is not
by using WindowToken and AppWindowToken. As its name
compromised.
implies, a WindowToken is a type of binder token (will be
discussed in Section II-C) that is used to uniquely identify a Inreality,anappcrossesprocessboundariesandcommuni-
group of related windows in the system. AppWindowToken cate with system services to enable its proper functionality by
is similar to WindowToken, except that all windows in the usinganimportantIPCmechanismcalledbinder.Inthisclient-
group are associated with the same activity. In other words, service communication, it is crucial for the system services
an AppWindowToken is a representation of its corresponding to securely identify who the client is. It turns out that a
activityinstanceinAMS.Giventhesetwotypesoftokens,we binder object has a unique property that is supported by
4the binder driver: each binder object maintains a globally Category AttackVector Conseq-
uences
unique identifier across all processes. This property makes
UIinterceptionattack[13] A
a binder object ideal for app authentication purpose, i.e., a Tapjackingattack[19],[25],[29] B
binder object is used as a security token shared between Window Toastmessage[19],[25] A,B
Overlay Phishingattack[2],[7],[13],[29] A,C
client and system service. Specifically, AMS and WMS create
Immersivefullscreenattack[2] A,C
app/window tokens (e.g. AppWindowToken and WindowTo- DenialofService D
ken) and share them with a client app. When a client app Adware D,E
(or its enclosed activity) asks for service, the system services Backbuttonhijacking[2],[28] A,C
Task Applaunchspoofing[28] A,C
requiretheclienttoidentifyitselfbyincludingthegiventoken Hijacking DenialofService[28] D
in its request. This authentication scheme is a cornerstone of Usermonitoringattack[28] F
moveTaskToAPIs[2] A,C
Androidsecurityarchitecture.Itpreventssystemservicesfrom
being spoofed by the attacker, e.g., mistakenly modifying the TABLEI. EXISTINGKNOWNGUIATTACKVECTORSINPRIORWORK.
window states of another app, or delivering user inputs given THECONSEQUENCESARE:A-SENSITIVEDATASTOLEN;B-USERINPUT
on a window to the wrong app.
EAVESDROPPING;C-USERSPOOFING;D-LOSSOFAVAILABILITY;E-
MALWAREINFECTION;F-USERPRIVACYINFRINGEMENT
Moreover,Androidprovidesfiner-grainedsecurityenforce-
mentbasedonitspermissionmechanism.Appsmustexplicitly
a normal app can freely launch new activities, add high z-
declarethepermissiontheyneedforadditionalcapabilities.For
order system windows on screen, or modify other apps’ back
example, an app can launch certain system windows only if it
stacks. Originally intending to promote the platform features
has obtained the SYSTEM_ALERT_WINDOW permission. Per-
forappdevelopers,thesefeaturesinadvertentlyenrichtheGUI
missioncanalsobedeclaredtoprotectactivity.Duringactivity
attack vectors and facilitate the mal-behaviors. In fact, Google
launch, AMS enforces access control by consulting Package
has long realized the security issues of the over-flexible GUI
ManagerService,whichchecksthepermissionrequirementof
features, and has taken steps to remedy the problems in newer
the callee activity (if there is any) and returns the check result
Android releases, e.g. adding security attributes to GUI com-
to AMS.
ponents,requiringexplicituserconsenttocertainpermissions,
enforcing runtime permission, etc. However, many security
featuresarebarelyusedbyunwittingdevelopers(evenGoogle
D. Security Risks
apps themselves). Even if they are fully employed, the ad-
Although the current security model works especially well hoc protection cannot systematically mitigate all attacks. On
in many aspects, it performs poorly in protecting the GUI the other hand, removing or modifying the longstanding GUI
system against existing attacks. The fundamental problem is, features will break a bulk of existing apps.
in the GUI context, it is the user session - a list of GUIs that
As a result, the Android GUI system becomes particularly
an user has visited in a time series when doing a particular
vulnerable to a variety of GUI attacks that can be easily
job - that requires security guarantees and protection. The
launchedwithoutconfinement.Thisisprovenbyboththeprior
security of app sandboxing is only enforced on process/app
research findings and the rapidly growing real-world threats.
boundaries, leaving the user sessions vulnerable to being
To the best of our knowledge, Table I shows a full list of
arbitrarilyinterruptedormanipulatedbyattacker,e.g.popping
known GUI attacks. Depending on attack vectors, all attacks
up a phishing window, or redirecting the user to a different
are classified into two categories:
task during app navigation.
• Window overlay attack: attacks that render a window
Unfortunately, this problem is further exaggerated by the
on top of screen, partially or completely overlaying
uniqueness of GUI in mobile environment. First, unlike the
other windows.
desktop machines, the screen of a mobile device is relatively
smallandusuallyonlyshowsoneappatatime.Tosavespace, • Task hijacking attack: a class of malicious behaviors
there is generally no app identifier on screen, e.g. a task bar that trick the system to modify the app navigation
or a window title bar like in desktop OSes. Because of this behavior or the tasks (back stacks) in the system.
limitation, it is cumbersome for a user to constantly verify
the real identity of the current GUI. Although a user can Both categories of attacks can cause serious consequences
resort to the recent button for the name of the current task, as shown in the last column of Table I. In summary, we
the displayed information is untrustworthy as the recent task consider a threat model as follows:
listissubjecttomanipulationbyattackers[28].Therefore,for
a normal user reliably identifying the current GUI becomes Threat Model: We consider a harmful app has been installed
infeasible. Secondly, the GUI design and the norm of app on the user’s Android device. Like most real-world malware,
navigation makes GUI attacks more likely to succeed. For the harmful app does not have system privilege, e.g., running
example, because the user has been accustomed to the default withasystemUID.Instead,itmayseemharmless,requiringa
appnavigationbehaviors,onemightbeeasilyspoofedifthese minimal set of permissions needed for the malicious purpose.
default behaviors are maliciously tampered. Due to the lack We assume that the system itself is un-compromised and
of user control to the screen, it is troublesome for the user to trustworthy. We also assume that one window involves one
escape a lock screen (e.g., a non-escapable system window) principal.Inthecaseswhenawindowiscomposedofelements
in a denial-of-service attack. Thirdly, Android provides app from different principals, e.g., the app itself and an embedded
developers with great flexibility to control the window states third-partyadlibrary,weconsidertheprincipaltobetheowner
in the system without being strictly disciplined. For example, of the window. In order to achieve its malicious purpose,
5A1 A2 2
AMS
B2
AMS
B2
Launch
er Recent L A1 A2 B1 L A1 A2 B1
Tasks
1 3
2
A1 A2 A1
B1 B2 A c4vity L L A2
Focused Ac4vity
1 Focused Ac4vity
Transi4on B1 B2 B1 B2
Fig.3. Multipleactivitysessionsinthesystem. (a) (b)
the attacker’s goal is clear: affect a normal user session to Fig.4. Anactivitysessiontransitionexample.
the attacker’s advantage using windows or activities under
attacker’s control. of activities that guide the user from the launcher activity to
the currently focused activity. It intends to capture the user’s
III. ANDROIDWINDOWINTEGRITY visual experience of previous activities, the basic building
blocks of an app, when doing a particular job. Specifically,
As discussed, the existing security model is not designed
as shown in Figure 3, each node indicates an activity. An
to cope with GUI attacks. The fundamental limitation is, GUI
activity session always starts from the launcher activity. When
attack targets a normal user session, a series of windows that
a new activity is displayed on screen, it is chained to the end
userhasvisited,whichisbeyondthescopeofappsandboxing
of the current activity session. There can be multiple activity
protection. Motivated by the challenges and serious threats,
sessions at the same time. All the activity sessions form a
we propose a new security model - Android Window Integrity
tree: the launcher activity is the root and the only joining
(AWI)-tofillinthisimportantsecuritygap.AWIisageneric
point of all activity session branches. The focused activity
model for Android GUI security. It redefines a user session as
(belonging to the display owner) is always at the tail of an
a chain of activities starting from the launcher, specifies the
activity session, which is called focused activity session (e.g.
capabilities of various principals in the system, and describes
launcher →B1→B2 in Figure 3).
the criteria of how the GUI system should be kept valid from
one state to the next. The user can switch to another activity session anytime,
called activity session transition. For instance, as illustrated in
A. Display Owner and Activity Session thediagramofFigure3,focusedactivityB2maytransittoA2
following three routes (the dashed line). In 1 and 2, the user
ThekeyprincipleofAWIisthat,noapplication,bydefault,
can either go to the launcher or the recent task activity, and
haspermissiontoperformanyoperationsthatwouldadversely
thenresumesA2.Inparticular,therecenttaskactivitybelongs
affect the user session of other apps or the system UI. At the
to system UI and is only started upon user pressing the recent
center of the model are display owner and activity session,
button. Since its function is to be a “hub” that facilities task
which are the basic entities to be protected in AWI, just like
switchinthesystem,weregardtherecenttaskactivityitselfas
an app process in the app sandboxing.
aseparateactivitysessionthatdoesnotoverlapwithanyother
As discussed in Section II-D, mobile display is an unique activity sessions. In this sense, the transition from B2 to the
time sharing resource that is shared by different apps at recent task activity is an activity session transition by itself.
different time. We introduce display owner, the one and only In route 3, a focused activity transition can also occur directly
one principal that is more privileged than other apps and from B2 to A2. This can happen in many circumstances, e.g.,
“owns” the mobile display at a time. In AWI, we specify the launching an existing activity with special intent flag, etc.
display owner to be the app of the currently focused activity.
AlthoughanactivitysessionlookssimilartoataskinAMS,
Itmeansthattheappofthefocusedactivityismoreprivileged
the two are independent and have major differences as we
thanothersintermsofGUI-relatedoperations,anditswindows
will see in Section III-C. Note that the sequence of activities
and user session is protected under the AWI model (although
retained in an activity session may be saved in multiple
the display owner is still disciplined by the existing security
tasks/backstacksbyAMS.Figure4(a)showssuchanexample,
mechanism).
in which both the activity session and corresponding system
InAndroid,appnavigationalwaysstartsfromthelauncher statearedepicted.ActivityA2waslaunchedbyA1butplaced
activity, the first focused activity after system boot-up and the intoanewtaskinAMS(e.g.byspecifyingsingleTaskactivity
primary app navigation “hub”. A user starts a job by opening attribute). Since A1 and A2 are displayed in a sequence, they
an app activity from the launcher and later proceeds to other are regarded to be in the same activity session. If the focused
activities as the job goes on. The states of previous activities activity then transits from activity B2 to A1 as a result of
in a job are saved and can later be resumed by tapping the any of the above reasons, the original activity session will be
back button. Once the current job is finished, one can go back dividedintotwosessions(stillrootedatthelauncheractivity),
to the launcher via the home button, or switch to another job as shown in Figure 4(b).
by going to the recent task list (pressing the recent button),
Given these two important notions, we next introduce the
another navigation “hub”.
three aspects of legitimacy that AWI attempts enforce on the
AWI complies with this norm of app navigation by in- system states. But before we proceed, to better understand
troducing activity session. An activity session is a sequence these principles, we first simplify the complex GUI system
6and formalize it in a state transition model. the difference between the two. Any disparity between the
two indicates a mismatch of user’s visual experience and
B. System State Transition system state, and is considered suspicious. More specifically,
themodelconsidersthefollowingstatementasapropersystem
The state transition of the GUI system is described by
state:
(S,Λ,→), where S = {S ,WS}. S denotes the set
AMS
of system states; S AMS indicates the set of system states ∃{bs∗ 1,bs∗ 2,...,bs∗ n}⊆β :s fg =(bs∗ 1 (cid:107)bs∗ 2 (cid:107),...,(cid:107)bs∗ n)
in AMS; WS stands for the set of window stack states in
WMS. Λ indicates a set of events and conditions that invoke where β indicates the set of all back stacks, in which bs∗
i
a set of viable transition →. Specifically, given a system state is one of them. s denotes the foreground activity session,
fg
s∈S and a window stack state ws∈WS, they have the composed of an ordered list of activities. In other words, it
AMS
following states: checks if there exists a subset of back stacks, such that the
concatenation of their ordered activity lists is the same as the
• s = {a ,β}, where β = {bs ,bs ,...,bs },
focus 1 2 n ordered activities in the foreground activity session.
and bs = (a ,a ,...,a ). a denotes the current
1 2 m focus
focused activity. β is a set of all n back stacks in The failure ofactivity session integrity checkmay indicate
the system. bs denotes a back stack, each in turn possible attack, but it may also come from the use of task
includes an ordered list of activities, indicated by features for legitimate purposes. The distinction lies in an
(a ,a ,...,a ). important premise of task hijacking: a task hijacking attack
1 2 m
happens only if the malicious activities manage to reside in
• ws = (w 1,w 2,...,w n). ws represents the window the same task together with the legitimate activities. Given
stack containing a total of n windows. w 1 and w n this premise, AWI iterates the back stacks that are part of the
representthebottomandthetopwindowsinthestack focused activity session. If the activities in the back stacks are
respectively. Each window w i (1 ≤ i ≤ n), includes all from the same app, AWI regards it to be valid. Otherwise,
a few parameters such as visibility, size, transparency, a notification is created to alert the user about the event and
etc. possible security hazard.
C. System State Legitimacy Legitimacy of current visible windows After an activity
gets focus and becomes the display owner, other than its own
Android window integrity is composed of three types of
activity window(s), there are usually other visible windows
legitimacy: the legitimacy of the past activity session, the
in the window stack. To prevent the display owner’s activity
legitimacy of the current visible windows, and the legitimacy
window from being disturbed by unauthorized windows from
ofthefuturewindowstobedisplayed.Insteadofbeingarigid
other apps, an overhaul of the window stack is necessary.
security model, AWI adapts to the diversity of user needs by
Specifically,themodelspecifiesthatnoothervisiblewindows,
incorporating user’s choice in the model. Once an integrity
except the windows belonging to the display owner app and
violation is detected, it is up to the user to make the final
a set of white-listed windows, should overlay on top of
decision. This makes AWI both usable and practical to be
the focused activity window in the window stack. To put it
employed in reality.
formally, the model have the following guarantees:
Legitimacy of activity session. An activity session looks ¬∃w ∈ws:w .visible=true,i>k,
i i
similarlytoatask’sbackstackatthefirstglance,e.g.bothkeep w ∈/ FocusedApp,w ∈/ L
i i
arecordofpreviousactivities.However,activitysessionisnot
a simple duplication of task. A task is a container that keeps wherew istheith windowfromthebottomofwindowstack;
i
existing activity instances. Although the order of activities in k represents the index of the top focused activity window in
a back stack is typically reserved and follows the order of the window stack; and L denotes a white list of windows.
activity launch most of the time, it is not always true. In fact, The white list typically includes system windows and other
Ren et. al. [28] demonstrated that the back stacks could be windows explicitly specified by the user, as we will discuss in
manipulated outrageously by abusing the task features, e.g., the implementation in Section IV.
an activity could be relocated to other tasks; app navigation
behaviorcouldbechanged;afullbackstackofactivitiescould Legitimacy of future windows. There is a plethora of ap-
be created without user’s awareness. This flexibility however proaches to launch a window in Android, but all windows
contradicts with user’s common sense, e.g., it is commonly are in two categories: free window and activity window. The
believed that back button pressing should resume activities legitimacy of future window is defined as: given the current
that the user has previously seen; clicking an app icon from display owner, the principal (identified by UID) that initiates
the launcher ought to start the app window (which may not the launch of a new window must be either the display owner
be the case), and so on. By taking advantage of these pitfalls, appitselforfromawhitelistspecifiedbytheuser.Thiscriteria
the most dreadful task hijacking attacks could be launched, as holds for both free window and activity window. We now
listed in Table I. explain the two cases respectively.
On the other hand, activity session is designed to simulate Although third-party app or package can launch free win-
and preserve user’s visual experience by saving the sequence dows, such as toast window (without any permission), or
of visible activities when the user is doing a job. Every time other system windows (requires SYSTEM_ALERT_WINDOW
thefocusedactivitychanges,theforegroundactivitysessionis permission), many free windows are typically launched by
used to check the integrity of the back stacks by comparing the system or system apps. The model considers a white list
7of UIDs of the system processes (e.g. system server) and ThesefeaturesmakesWindowGuardpracticaltobedistributed
system packages (e.g. system UI) trustworthy, and allow their to a large number of Android devices and provide immediate
windowsbeingdisplayedfreely.Moreover,therearetwotypes protection.
of windows that the system treats differently: input window
(including input method or dialog windows), and wallpaper A. AWI Model Implementation
window. An input window is registered in the Input Manager
WindowGuard implements AWI by hooking 26 functions
Service. When a window requests input method, the Input
of AMS, WMS, Package Manger Service (WMS), and system
Manager Service launches the input window on top of the
UI in a total of 2300 lines of code.
client window in the window stack. Wallpaper window is
similar, except that it is started by a wallpaper service and
is placed under the client window. Since the type and the Activitysessionintegrity.AspreviouslydepictedinFigure3,
client window of an input or wallpaper window are securely activity sessions are implemented as a tree data structure
specified by the system, they are considered trustworthy (as maintained in the system server process (a privileged process
long as the input method or wallpaper packages themselves hosting all system services implemented in Java). Each node
are legitimate). The model allows input or wallpaper windows represents an activity, which links to its predecessor and
being started as long as their client window is one of the successor activities. Activity sessions share the same root, the
currently visible windows. launcher activity. A new activity node will be added to the
current foreground activity session only if a new activity ob-
When an activity window is started, either (1) the focused tains the focus (its windows become visible), and is destroyed
activity remains the same (e.g. launching another top-level together with its corresponding activity. WindowGuard hooks
app window or a sub-window) or (2) the focused activity functions in AMS to perform back stack integrity check upon
changes,andtheactivitywindowbelongstothenewlyfocused the change of focused activity, as discussed in Section III-C.
activity. The first case is always valid because the display
owner is unchanged and the activity window must be started AccesscontroloffreewindowsGivenadisplayowner,access
by the display owner app (assured by the security guarantee control is enforced on the free windows that are about to be
of app window tokens). In the second case, the change of displayedorresumedbasedonthediscussioninthelegitimacy
focused activity implies a possible change of display owner. of future windows. For those existing visible windows that
Given the flexibility of Android APIs and task features, there violatethewindowlegitimacycriteria,freewindowsaremade
are numerous possibilities that would result in the change of invisible, and activity windows (if there is any) are reordered
display owner, which we will characterize in Section IV-A. under the focused activity windows in the window stack.
Despite the complexity, the same principle still holds, i.e., the To achieve this, WindowGuard hooks a handful of WMS
change of focused app must be initiated by the display owner functionsperformingfunctionssuchasaddingwindowstothe
app or white-listed principals. windowstack,windowstackreordering,andwindowvisibility
control. Access control of free window helps prevent window
Among the many possibilities of focused activity change,
overlay attacks such as user spoofing or a ransomware denial-
backbuttonpressingisspecial.Backbuttonisoneofthemost
of-service attack. In a denial-of-service attack, even if the
popularusernavigationcontrolalwaysavailableonscreen.By
ransomwaremanagesto“lock”thescreenusingafreewindow,
default, one can navigate backward to the previous screens by
the use can always click home or recent activity button to
pressing the back button. In this case, the system destroys
escape the lockscreen.
the current focused activity and resumes the next activity
on back stack. However, the back button behavior can be
Safeguarding focused activity transition Focused activity
changed by overriding the onBackPressed callback function
transition happens frequently during the use of device in
of the focused activity. Although this flexibility is useful in
practice.Ithappenseitherduringactivitylaunchorresumption
many cases, e.g., fragment or webview navigation within the
and may result in a new display owner. In principle, the
same activity, it is sometimes confusing to the user if being
focused activity transition must be initiated by the display
mis-used,e.g.,insteadof“goingback”,itre-directstheuserto
owner app in either cases, as previously discussed. Due to
someotheractivity.Themodeldoesnotregardthecustomized
the complex app navigation behaviors, the focused activity
back behavior malicious as it is defined and initiated by the
transition requires close monitoring of a variety of system
focused activity. That being said, the model keeps an eye on
functions or APIs.
the program behaviors after a back button pressing, and raises
a toast message when user confusion is possible. A new activity gets focus when it is launched by one of
the startActivity function calls from an app. The origin of
the caller app is examined. If the caller app UID is not the
IV. WINDOWGUARD
current display owner or one of the white-listed principals,
We implement the AWI as a module for the Xposed an alert notification with detailed information is prompted to
framework, a popular code-injection framework for rooted the user for confirmation to proceed. This effectively prevents
Android devices. The implementation, namely WindowGuard, attacker from overlaying an malicious activity window on top
istestedonGoogleNexus5phoneandcanbeusedinAndroid of a victim app. Similarly, resumption of existing activity can
4.4, Android 5.x and Android 6.0 with minor changes. An also trigger focused activity transition. Activity resumption
Xposed module can hook arbitrary functions of the system or could occur either passively or actively. For example, the
apps at runtime and change their behaviors without modifying next activity on the back stack is passively resumed when
the system or apps themselves. WindowGuard can be used on the current focused activity quits and is destroyed by the
allAndroiddevicebrandsthattheXposedframeworksupports. system. It is perfectly valid in this case for the display owner
8to yield its own privilege. Activity resumption can also be Recent Task List: The recent tasks screen contains a list of
actively initiated by invoking a set of APIs such as startAc- all recently accessed tasks, and for each task it shows the task
tivity,moveTaskToFront/Back,ormoveTaskForward/Backward. owner’sname/iconandthetask’slastscreenshot.Theusercan
Specifically,startActivitycanresumeanexistingactivityunder browsethroughthelistandchooseatasktoresume.However,
certain conditions, e.g., the activity’s launch mode is singleIn- the recent task list suffers from the similar problem of task
stance. The latter two APIs can move a task to the foreground ownershipconfusion,becauseitregardstheownerofataskto
orbackground,whichessentiallychangesthedisplayownerat be the app described in the taskAffinity attribute of the task’s
will by any app as long as REORDER TASKS permission is root activity. As a result, the user could be easily spoofed by
granted. WindowGuard hooks the internal functions in AMS a malicious task which camouflages as the victim app in the
for each of these app APIs to check the caller origin. A user recent task list. To impede such an attack, the system UI is
confirmationisfurtherrequestedifthecalleroriginisnotfrom hooked such that it shows the name/icon of the root activity
the display owner. app of a task, instead of what is described in the taskAffinity
attribute. By this means, it faithfully reflects the real identities
of tasks in the system.
B. Security of App Navigation “Hubs”
The launcher and recent task list play crucial roles and act C. Preserving User Experience
as app navigation “hubs”. Due to the vendor customization or
WindowGuard implements the AWI model, which is de-
availability of third-party alternatives, the security implication
signed to adapt to the Android use and navigation pattern,
of these components is unknown. In addition to the security
such that the user experience is not affected at all in normal
provided by the generic AWI model, WindowGuard provides
useuntilasecurityviolationisdetected.Thesecurityviolation
extra protection on these critical components.
mayindicateapotentialGUIattackoralegitimateuseofGUI
features that do not strictly follow the norm of Android app
Launcher: Launcher is the first app activity to be started.
model.WindowGuardtakesalight-weightresponsebybriefing
Other than the default launcher that comes with the stock
theuserandaskingfortheuser’sfinaldecisionuponasecurity
system, third-party launchers are also available. Our first goal
event, such as block, allow for once, or add to white list, etc.
is to securely start the launcher activity of user’s choice. After
The alert messages, depending on the emergency and severity
system boot-up, AMS queries PMS about the information of
of attacks, are delivered via a confirmation dialog, a system
packages that can serve as the launcher. If multiple launcher
notification or a toast message right after the violation occurs.
activities are returned, a dialog is prompted for user to make
WindowGuard maintains a handful of white lists; one for
a choice. At this stage, WindowGuard is able to prevent an
each security feature. Those on a particular white list are not
attackerfromaffectinguser’schoicebymanipulatingwindows
confined by the corresponding security feature. WindowGuard
on screen, as the display owner is system UI (who owns the
always respects the user’s decision and the diversity of user
dialog activity). WindowGuard trusts the user’s choice and
needs;thewhitelistsarepromptlyupdatedbasedonuserinput.
regards the chosen launcher activity as the only root of all
Moreover,allGUIsecurityprotectionfeaturescanbeliftedand
activity sessions in this system launch.
re-enforcedinacentralizedcontrolpanel,makingitconvenient
for the user to tune the security features based on preference.
The second goal is to assure that an app is reliably started
whentheuserclicksitsiconinthelauncher.Herewediscover
a security issue in the app launch process, which affects V. EVALUATION
all Android and launcher versions. When an app icon is
We now proceed to the empirical evaluation of the effi-
clickedinthelauncher,anintentwithNEW TASKandACTIV-
cacy of WindowGuard in the following facets: effectiveness,
ITY BROUGHT TO FRONTissenttostartthecorresponding
usability and performance impact.
app.Thecombineduseoftheseintentflagscreatesanewtask
to host the app’s new activity. If the app’s task already exists,
A. Effectiveness
thetaskwillsimplybebroughttotheforeground.However,in
thisoperation,AMSconsidersthetaskownertobethepackage To evaluate the effectiveness of our solution, we install
name described in the taskAffinity attribute of the root activity the WindowGuard prototype on a Google Nexus 5 phone and
(thebottomactivityinthebackstack),insteadoftheappofthe experiment with 15 attack samples from all 12 attack vectors
root activity itself. Although the two are by default the same, listed in Table I. The attack samples are either real-world
the taskAffinity attribute can be configured arbitrarily to some malware/adware, or are proof-of-concept apps we developed
other app’s package names without restriction. Therefore, a based on previous research [2], [7], [13], [19], [25], [28].
maliciousactivitycanspoofthesystembyspecifyingavictim The evaluation shows that WindowGuard is able to effectively
app’s package name as its taskAffinity, and start the activity detect and defeat all attacks. We now show a few case studies
in a new task. The task is then believed by the system to be todemonstratehowtheattackbehaviorsviolateAWIandhow
the victim app, but in fact, is controlled by the attacker. The WindowGuard delivers the potential attack alert to the user.
problem occurs when the user clicks on the victim app, yet
the malware task is started instead of the victim app itself. Back button hijacking: Back button hijacking [28] is one
To remedy this problem, WindowGuard monitors the requests type of task hijacking attacks. The attack misleads the user to
of activity launch in AMS. If it comes from the launcher, aphishingactivityaftertheuserclicksthebackbutton,instead
WindowGuard saves the app to be started, and later verifies oftheoriginalactivitytheuserjustvisited.Figure5showsthe
that if the focused task indeed belongs to the app by checking task states in AMS. In Figure 5(a), victim activity A2 intends
the origin of the task’s root activity. tostartalegitimateutilityactivityUtoservetheuser’srequest
9U
AMS AMS ? AMS
U
A2 M2 A2 M2 A2 M2
L A1 M1 L A1 M1 L A1 M1
M1 M2 M1 M2
L L Focused Ac*vity
A1 A2 A1 A2 U
Ac/vity A2 intends to launch However, ac/vity U is placed User is spoofed aEer tapping
ac/vity U on malware’s task back buGon (a) (b) (c)
(a) (b) (c)
Fig.5. Systemstateandactivitysessioninabackhijackingattack.A:victim Fig. 6. Screenshot of (a) Admin privilege confirmation window; (b)
app;M:malware;U:legitimateutilityapp. tapjacking attack window placed on top of (a) (message: “please update the
apptothelatestversion”);(c)SecurityalertdialogcreatedbyWindowGuard.
(e.g., playing a video). However, when activity U is created,
to acquire admin privileges of the device. Granting admin
it is tricked to be emplaced on top of a phishing malware’s
privilege requires user confirmation, as shown in Figure 6(a).
task, whose enclosing activities M1 and M2 are camouflaged
Bankbot overlays a free window (system alert window) on
as the appearance of A1 and A2. This happens due to the use
of NEW TASK intent flag when starting activity U and the top of the admin privilege confirmation activity, claiming that
abuse of taskAffinity by the malware. When the user later taps the software needs update to the latest version. Although the
free window is opaque, it is intentionally configured to not
the back button, the phishing activity M2 is resumed by the
receive user tap input, such that the tapping of the button at
system, while the user still believes he/she has gone back to
thebottomofthefreewindowisinturnreceivedbytheactive
the original activity A2. User’s sensitive information (such as
window underneath it, i.e., the system confirmation window.
bank login information) is then stolen by the malware.
As a result, the user agrees to the software update request
WindowGuard can readily detect the task hijacking be- without realizing that he/she is in fact granting the admin
havior when activity U is launched on the malware task. privilege to the malware. WindowGuard immediately detects
As shown in Figure 5(b), the activity session keeps track theattemptoffreewindowlaunchandpausesitbeforeasking
of the visible activity windows from the launcher activity for the user’s decision from a security alert dialog, as shown
all the way to activity U. When activity U is started, the in Figure 6(c). The attack is detected because the current
legitimacy of back stacks is checked by comparing related display owner is the system settings, who owns the focused
back stacks (i.e. launcher task, task A and task M) against confirmation activity. Any window operations (including free
the focused activity session. The disparity of the comparison and activity window) that affect the focused activity window
is obvious due to the relocation of activity U. In this case, a arereportedtotheuserandaskforuserpermissiontoproceed.
notification is created in the status bar to notify the user of
the possible security threat. Likewise, all other task hijacking Ransomware: Screen-lock ransomware blackmails victim
attacks violating the legitimacy of back stack can be defeated users by locking the screen for money in exchange for the
by WindowGuard as well. On the other hand, this kind of accessibilitytothesystemagain.Ransomwarehasmigratedto
task manipulation behavior can also be used for legitimate Android and has been growing at an alarming rate in the past
purpose. WindowGuard provides detailed information about few years. A ransomware usually renders a high-z-order free
the security risk to the user, and it is up to the user to make window to overlay the full screen and hence blocks all user
thefinaljudgmentbasedonthecontext.Forexample,auseful inputs to the system, leaving the system effectively “locked
task management app may frequently use various task-related up”. The ransomware can even use a combined GUI attack
features and inadvertently trigger the alarm. In this case, the vectors,e.g.,gettingadminprivilegeviatapjacking,tobecome
user can easily cease the surveillance of this particular app more powerful and hard to remove, like a recent ransomware
in the WindowGuard control panel. In some other context, the called Lockerpin [26]. In addition, [28] demonstrates that a
securityalertisparticularlyalarmingwhentheuserisworking ransomware can also launch activity windows to prohibit user
in a bank account, e.g., making a money transfer. accesstotargetedvictimapps,e.g.,ananti-virusapp.Ineither
experiment, WindowGuard can block the lock screen window
Tapjacking:Clickjackingattackiswellknowninwebsecurity. as long as the window’s initiator is not the current display
ThesimilarattackideaisbroughttotheAndroidenvironment, owner.Eveniftheuserisspoofedandaccidentallygetstrapped
called tapjacking. Tapjacking overlays windows on top of by a lock screen, the user can always escape by clicking the
screen and spoofs the user to perform undesirable operations. home or recent button, which starts the launcher or system UI
Bankbot [23] is a family of banking malware discovered in activities. Changing the display owner to launcher or system
SouthKoreaAndroidmarketinOctober2014.Itwasdesigned UI make the foreground malicious lock screen no longer valid
to steal authentication information from the clients of various and the lock screen is immediately removed. A notification
financial institutions. To avoid itself from being uninstalled, message is then created to inform the user about the security
BankbotdisguisesitselfasGoogleplaystoreappandattempts enforcement just occurred.
10SecurityFeature Alert #of %of legit purposes. For example, toast messages are raised by
Msg Apps Apps
ActivitySessionLegitimacy T,N 12 0.10 background app services to display warning messages; A free
NewWindowAccessControl D 39 0.32 window is decorated as a handy and always-visible controller
ExistingWindowLegitimacy T,N 14 0.12
for a music player app; Certain ad libs create free window
NewActivityControl D 69 0.57
ActivityResumeLegitimacy D 11 0.09 or new activities to display advertisements; and app locker
AnyFeature(s) 124 1.03 apps use free window or activity window to “lock” particular
TABLEII. NUMBERANDPERCENTAGEOFLEGITIMATEAPPSTHAT apps before the correct password is provided. Although these
TRIGGERDIFFERENTSECURITYFEATURESOFWINDOWGUARD.TOTALLY windows are all for legitimate purposes, the windows they
12,060MOSTPOPULARAPPSFROMGOOGLEPLAY.ALERTMESSAGESARE launched have in fact interfered with the GUI of other apps,
INFORMSOF-T:TOASTMESSAGE,N:SYSTEMNOTIFICATION,D:
even with no bad intention. It is therefore a good time to
CONFIRMATIONDIALOG.
let the user make the decision on if they are useful or not,
e.g., a floating music player controller window is useful but
#ofsecurity 1 2 3 4 5 an advertisement window might be annoying for the user. In
featurestriggered
our experiment, we also find that a significant portion of apps
#ofApps 107 15 0 2 0
re-write the back button behavior. Instead of “going back”,
TABLEIII. THENUMBEROFAPPSTHATTRIGGERDIFFERENT the back button is either disabled or re-directs the user to
NUMBERSOFSECURITYFEATURES.
anotheractivityofthesameapp.AsdiscussedinSectionIII-C,
WindowGuardconsidersbackbehaviormodificationlessrisky
B. Usability and Performance Impact and does not raise alarm when the back behavior fails to
meet user expectation. Despite that, changing the behavior
While providing comprehensive protection of the GUI
outrageously can be confusing to users and requires careful
system,WindowGuardisdesignedtomaximallypreserveuser
considerationinappdesign.Anotherfindingisthat,amongthe
experience.Inthissection,weseektounderstandtheusability
apps that trigger security alerts, Table IV shows the number
impact of WindowGuard on the legitimate apps. To this end,
of apps that trigger a particular aggregate number of security
we collect 12,060 most popular apps from Google play, each
alerts in the given testing period. As shown in the figure, a
app with over 1 million installs. The experiment is conducted
majority of apps triggers less than 3 security alerts even if the
on Nexus 5 devices with Android 4.4, the most distributed
app runner is a pseudo-random event generator.
Android version. To emulate user input, we employ Monkey,
a stress testing tool, to generate pseudo-random streams of We now proceed to the performance evaluation of Win-
user events to exercise each app continuously for 5 minutes. dowGuard. To evaluate the performance overhead, we use
In order to take into account of app interactions, at least 30 Monkey to generate the same sequence of 5000 user events
other apps are installed at the same time when an app is to the same app running on the system with and without
undertest.TheprotectionofWindowGuardisclassifiedinto5 WindowGuard module enabled. We collect the complete time
security features and each feature maintains a white list. Once T andT ,respectively,andtheoverheadiscalculatedas
with w/o
anappiswhite-listedbytheuser,itisexemptfromthesecurity (T −T )/T ×100%. We manually select 100 apps
with w/o w/o
check of the corresponding feature. For example, if app A is that are in different categories and have complicated activ-
added to the white list of “Free Window Control”, app A can ity/window hierarchies. WindowGuard turns out to perform
launchfreewindowsanytimewithoutalertingtheuserorbeing very efficiently, yielding only 0.45% of performance overhead
blocked by WindowGuard. Once a false alarm is raised, we on average.
assume the app is immediately added to the white list of the
corresponding security feature by the user (either manually or
automaticallyafteruserconsent).Tomeasurehow“annoying” VI. RELATEDWORK
thesecurityfeaturesaffectthenormalfunction,TableIIreports
GUI security has been well studied in traditional desktop
the percentage of apps that trigger each type of security alert
environments[3],[8],[14],[32].Ontheotherhand,theunique
in our experiment.
mobile environment has raised unique challenges.
As shown in Table II, WindowGuard has no impact on
most popular apps (98.97% apps). It indicates that most of GUI confidentiality attacks and defenses. Previous research
thesepopularappsfollowtheAndroidappmodelandthenorm proves that the confidentiality of GUI can be broken through
of app navigation. Among these 1.03% of apps that trigger sidechannelssuchasshared-memorysidechannel[7],peeking
WindowGuard’s alerts, most apps only trigger one security sensor information [21], [36], via system or app flaws [17],
feature, as shown in Table III. It means that WindowGuard [18],[29],orshouldersurfing[22].SensitiveGUIinformation
only interrupts the user once during the use of most of these can also be disclosed by taking screen shots because of adb
apps.Itisnoteworthythatthe“NewWindowAccessControl” flaws [17], or via embedded malicious UIs [18], [29]. One the
and “New Activity Control” features affect 0.32% and 0.57% other hand, GUI information disclosure can also be put into
of all apps respectively. We find that these apps launch free good use for forensics analysis [30], [31]. A few approaches
or activity windows on top of other apps for a variety of have been proposed to protect GUI confidentiality [6], [24],
[29], which help limit the attack surfaces for confidentiality
breaches. However, comprehensively protecting GUI confi-
#ofsecurity 1 2 3 4 5 6 7 8 9 >=10 dentiality from all aspects of the system remains to be an
alerts
#ofApps 34 28 14 5 6 1 4 0 4 18 open question. Our work instead focuses on the integrity
and availability of Android GUI, properties that are seriously
TABLEIV. THENUMBEROFAPPSTHATTRIGGERDIFFERENT
threatened by emerging GUI attacks.
NUMBERSOFSECURITYFEATURES.
11GUI integrity and availability attacks and defenses. Previ- is a phone call. Although the window is useful for the apps
ous research shows the possibility to launch phishing [2], [7], functionality, it has effectively disturbed another app’s GUI
[13] or tapjacking attacks [19], [25] in Android by overlaying and user experience. Determining the real intention of such
a window of attacker’s control on top of the victim app’s app behavior (e.g. an useful phone recorder control widget
window. It is also viable to manipulate the activity browsing oraphishingwindow)isfundamentallydifficultforautomatic
historytolaunchavarietyoftaskhijackingattack[28].Denial systems.Incontrast,usersaremorecapableofmakingthebest
ofserviceattacks[5],[28]andadware[11],[27],[33]arealso decision based on the runtime context. WindowGuard adopts
posing increasing threat to the GUI availability. Roesner et. the advantage of user to overcome this difficulty while still
al. [29] systematically study the design of secure embedded retaining the original user experience. Second, user involve-
user interfaces. Bianchi et. al. [2] propose a novel two- ment may adversely introduces false negative caused by user
layerdefensetowardsdefendingagainstGUIconfusionattack, mistakes,e.g.,anuserexplicitlyallowsaloginpop-upwindow,
an important type of GUI attack. Compared with previous which is in fact a phishing window. In this paper, although a
work, we propose a new security model to systematically security warning is displayed (e.g., in Figure 6), we specify
protect the integrity and availability of the GUI system, while WindowGuard to always respect user decision and report the
preserving the original user experience. The implementation, usibility findings in Section V-B. How to improve security-
WindowGuard,candefeatbroaderGUIattacksandispractical and-usability balance and the efficacy of defense requires
to be distributed to a large number of Android devices. comprehensive user study (e.g., the user study of Android
permission system [12]) and is beyond the scope of this
Integrity of program execution. Control flow integrity [20] paper.Lastly,theimplementationofWindowGuardisbasedon
defends against subverted machine-code execution such as Xposed, which can only be used on rooted Android devices.
return-oriented programming [10] and return-to-libc [15] at-
tacks.Oneoftheapproachesistosavethestateoftheprogram
VIII. CONCLUSION
(e.g. the native return address) in a shadow stack [16], [29],
[34].Whentheprogramstateisresumed(e.g.functionreturn), Inconclusion,weproposeanewsecuritymodel-Android
the resumed program state is compared with the saved copy Window Integrity - to systematically protect Android GUI
on the shadow stack. Similar idea is applied to the legitimacy system from attacks that compromise GUI integrity and avail-
check of activity session in our work. The previous-visited ability. We develop WindowGuard, an Xposed module that
GUIstates,activities,aresavedinaactivitysession.Todefeat implements AWI model while preserving the original Android
task hijacking attacks, the integrity of the foreground activity user experience. Our evaluation shows that WindowGuard can
session is scrutinized whenever an activity obtains focus. successfully defeat all known GUI attacks and yields small
impact on usability and performance.
VII. DISCUSSION
WindowGuard is not a malware detection system. The IX. ACKNOWLEDGMENT
goal of WindowGuard is to accurately detect the attacks that
We would like to thank anonymous reviewers whose comments
affect the GUI integrity and availability of other apps, instead
helpusimprovethequalityofthispaper.Thisworkwassupportedby
of detecting malicious behavior within an app itself, e.g., a
ARO W911NF-13-1-0421 (MURI), NSF CCF-1320605, NSF SBE-
phishing activity within the malware’s context. WindowGuard
1422215 and CNS-1618684.
always respects the user’s choice. Therefore, if a malware is
intentionally launched by the user (e.g., the user is spoofed
REFERENCES
by the social engineering tricks used by the malware) Win-
dowGuard does not disagree with user’s decision. Defending [1] “Task and Back Stack,” http://developer.android.com/guide/
against trojan horse malware like this is out of scope of components/tasks-and-back-stack.html.
this defense mechanism. On the other hand, WindowGuard [2] A. Bianchi and J. Corbetta and L. Invernizzi and Y. Fratantonio and
guarantees to prevent a malware from becoming the display C. Kruegel and G. Viana, “What the App is That? Deception and
Countermeasures in the Android User Interface,” in Proceedings of
owner if the user or the current display owner app does
IEEESymposiumonSecurityandPrivacy(S&P),2015.
not explicitly launch the malware, as we have seen in our
[3] D. Akhawe, W. He, Z. Li, R. Moazzezi, and D. Song, “Clickjacking
evaluation. In addition, WindowGuard is not a vulnerability
Revisited: A Perceptual View of UI Security,” in Proceedings of the
discovery system. It is not designed to discover or address USENIXWorkshoponOffensiveTechnologies(WOOT),2014.
the GUI security issues within an app itself, e.g. misleading [4] “Police Locker land on Android Devices,” 2014, http://malware.
app navigation design, or vulnerable access control of an app dontneedcoffee.com/2014/05/police-locker-available-for-your.html.
component, although WindowGuard does has the capability to [5] “Simplocker: First Confirmed File-Encrypting Ransomware
detectasubsetofthesedesignflawsandgivehintstotheuser, for Android,” 2014, http://www.symantec.com/connect/blogs/
such as inconsistency of back button behavior. simplocker-first-confirmed.
[6] J. Chen, H. Chen, E. Bauman, Z. Lin, B. Zang, and H. Guan,
There are several limitations of WindowGuard. First, al- “You Shouldn’t Collect My Secrets: Thwarting Sensitive Keystroke
though WindowGuard can successfully detect all known GUI LeakageinMobileIMEApps,”inProceedingsoftheUSENIXSecurity
attacks, it also introduces false positives. As we have seen in Symposium,2015.
evaluation, legitimate app developers, without understanding [7] Q.A.Chen,Z.Qian,andZ.M.Mao,“PeekingintoYourAppwithout
ActuallySeeingIt:UIStateInferenceandNovelAndroidAttacks,”in
the security implications, may conduct operations that violate
ProceedingsoftheUSENIXSecuritySymposium,2014.
AWIprinciples.Forinstance,aphonecallrecorderappnamely
[8] S.Chen,J.Meseguer,R.Sasse,H.wang,andY.Wang,“ASystematic
FonTel displays a window (which contains voice recording
Approach to Uncover Security FLaws in GUI Logic,” in Proceedings
controlbuttons)ontopofthesystemdialerappwheneverthere ofIEEESymposiumonSecurityandPrivacy(S&P),2007.
12[9] D.Dinkar,P.Greve,K.Landfield,F.Raget,andE.Peterson,“McAfee [31] B.Saltaformaggio,R.Bhatia,Z.Gu,X.Zhang,andD.Xu,“VCR:App-
LabsThreatsReport,”IntelSecurity,Tech.Rep.,2016. Agnostic Recovery of Photographic Evidence from Android Device
[10] E. Buchanan and R. Roemer and H. Shacham and S. Savage, “When Memory Images,” in Proceedings of ACM Conference on Computer
GoodInstructionsGoBad:GeneralizingReturn-orientedProgramming andCommunicationsSecurity(CCS),2015.
to RISC,” in Proceedings of ACM Conference on Computer and [32] J.Shapiro,J.Vanderburgh,E.Northup,andD.Chizmadia,“Designof
CommunicationsSecurity(CCS),2008. the EROS Trusted Window System,” in Proceedings of the USENIX
SecuritySymposium,2004.
[11] E.Erturk,“Acasestudyinopensourcesoftwaresecurityandprivacy:
Androidadware,”inWorldCongressonInternetSecurity(WorldCIS), [33] S. Son, D. Kim, and V. Shatikov, “What Mobile Ads Know About
2012. Mobile Users,” in Proceedings of Network and Distributed System
SecuritySymposium(NDSS),2016.
[12] A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wagner,
“AndroidPermissions: User Attention, Comprehension and Behavior,” [34] “AStackSmashingtechniqueProtectionToolforLinux,”http://www.
inProceedingsofSymposiumonUsablePrivacyandSecurity(SOUPS), angelfire.com/sk/stackshield/.
2012. [35] “The Android Trojan Svpeng Now Capable of Mobile
[13] A. P. Felt and D. Wagner, “Phishing on Mobile Devices,” in Web 2.0 Phishing,” 2013, https://securelist.com/blog/research/57301/
SecurityandPrivacy,2011. the-android-trojan-svpeng-now-capable-of-mobile-phishing/.
[14] N.FeskeandC.Helmuth,“ANitpickersGuidetoaMinimal-complexity [36] Z.Xu,K.Bai,andS.Zhu,“TapLogger:InferringUserInputsonSmart-
SecureGUI,”inProceedingsofAnnualComputerSecurityApplications phoneTouchscreensUsingOn-boardMotionSensors,”inProceedings
Conference(ACSAC),2005. oftheACMConferenceonSecurityandPrivacyinWirelessandMobile
Netowrks(WiSec),2012.
[15] H. Shacham, “The Geometry of Innocent Flesh on the Boan: Return-
into-libcwithoutfunctioncalls(onthex86),”inProceedingsofACM
ConferenceonComputerandCommunicationsSecurity(CCS),2007.
[16] L. Davi and A. Sadeghi and M. Winandy, “ROPdefender: A Detec-
tion Tool to Defend Against Return-Oriented Programming Attacks,”
in Proceedings of ACM Symposium on Information, Computer and
CommunicationsSecurity(AsiaCCS),2011.
[17] C.Lin,H.Li,X.Zhou,andX.Wang,“Screenmilker:HowtoMilkYour
AndroidScreenforSecrets,”inProceedingsofNetworkandDistributed
SystemSecuritySymposium(NDSS),2014.
[18] T. Luo, H. Hao, W. Du, Y. Wang, and H. Yin, “Attacks on WebView
inthe AndroidSystem,”in Proceedingsof AnnualComputerSecurity
ApplicationsConference,2011.
[19] T. Luo, X. Jin, and A. Ananthanarayanan, “Touchjacking Attacks on
Web in Android, iOS, and Windows Phone,” in Proceedings of the
5th international conference on Foundations and Practice of Security
(FPS),2012.
[20] M. Abadi and M. Budiu and U. Erlingsson and J. Ligatti, “Control
FlowIntegrity,”inProceedingsofACMConferenceonComputerand
CommunicationsSecurity(CCS),2005.
[21] E. Miluzzo, A. Varshavsky, and S. Balakrishnan, “TapPrints: Your
Finger Taps Have Fingerprints,” in Proceedings of the International
Conference on Mobile Systems, Applications, and Services (MobiSys),
2012.
[22] M. Mitchell, A. Wang, and P. Reiher, “Cashtags: Prevent Leaking
Sensitive Information through Screen Display,” in Proceedings of the
USENIXSecuritySymposium,2015.
[23] “MobileThreatsinOctober2014,”2014,https://news.drweb.com/show/
?i=7061&lng=en.
[24] N. Zhang and K. Yuan and M. Naveed and X. Zhou and X. Wang,
“Leave Me Alone: App-level Protection Against Runtime Information
GatheringonAndroid,”inProceedingsofIEEESymposiumonSecurity
andPrivacy(S&P),2015.
[25] M. Niemietz and J. Schwenk, “UI Redressing Attacks on Android
Devices,”inBlackhat,2012.
[26] “Aggressive Android ransomware spreading in the
USA,” 2015, http://www.welivesecurity.com/2015/09/10/
aggressive-android-ransomware-spreading-in-the-usa/.
[27] V. Rastogi, R. Shao, Y. Chen, X. Pan, S. Zou, and R. Riley, “Are
These Ads Safe: Detecting Hidden Attacks Through the Mobile App-
Web Interfaces,” in Proceedings of Network and Distributed System
SecuritySymposium(NDSS),2016.
[28] C.Ren,Y.Zhang,H.Xue,T.Wei,andP.Liu,“TowardsDiscoveringand
UnderstandingTaskHijackinginAndroid,”inProceedingsofUSENIX
SecuritySymposium(USENIXSecurity),2015.
[29] F.RoesnerandT.Kohno,“SecuringEmbeddedUserInterfaces:Android
andBeyond,”inProceedingsoftheUSENIXSecuritySymposium,2013.
[30] B. Saltaformaggio, R. Bhatia, Z. Gu, X. Zhang, and D. Xu, “GUI-
TAR:PiecingTogetherAndroidAppGUIsfromMemoryImages,”in
Proceedings of ACM Conference on Computer and Communications
Security(CCS),2015.
13