SGX-Shield: Enabling Address Space Layout
Randomization for SGX Programs
Jaebaek Seo, Byoungyoung Lee*, Seongmin Kim,
Ming-Wei Shih+, Insik Shin, Dongsu Han, Taesoo Kim+
KAIST, *Purdue, +Georgia Tech
1Cloud is big thing,
but security is concern
23SGX is a promising solution
4Intel Software Guard eXtensions (SGX)
Access
control
Encrypted
X
• Provide secret region “enclave”
Enclave
EPC
protected from
(enclave
page cache) kernel and HW-based attacks
User process’s
Physical memory
virtual address space
(RAM)
5Return
oriented
programming
Traditional attacks (e.g., code reuse attack)
are still available in SGX
6Address Space Layout Randomization
• ASLR is the most popular and effective defense
against code reuse attack
• ASLR is important, so Intel SGX SDK includes it
but it is limited
7Challenges
It is non-trivial when attacker is kernel
P1. Visible memory layout
P2. Small randomization entropy
P3. No runtime page permission change
8Challenges
It is non-trivial when attacker is kernel
P1. Visible memory layout à Secure in-enclave loading
P2. Small randomization entropy à Fine-grained ASLR
P3. No runtime page permission change à Soft-DEP/SFI
9P1. Visible Memory Layout
Enclave setup needs
Enclave
ring-0 instructions
User process
User space
Kernel space
Untrusted kernel
1. Request
10P1. Visible Memory Layout
Enclave setup needs
Enclave
ring-0 instructions
The setup includes
Enclave pro gram loading enclave program
(visible to kernel)
User process
User space
Kernel space
2. Setup
Untrusted kernel
1. Request
11P1. Visible Memory Layout
Enclave setup needs
Enclave
ring-0 instructions
3. Protected
running
The setup includes
loading enclave program
(visible to kernel)
User process
User space
Kernel space
2. Setup
Untrusted kernel
1. Request
12P1. Visible Memory Layout
Enclave setup needs
Enclave
ring-0 instructions
3. Protected
running
The setup includes
Enclave pro gram loading enclave program
(visible to kernel)
User process
User space
Kernel space
2. Set up enclave
No randomization
Untrusted kernel
in the view of kernel!
1. Request
13ASLR in Intel SGX SDK
• It only randomizes the base address of enclave
that is known to kernel
• In addition, memory layout of enclave is visible to kernel
à No ASLR in the view of kernel !
14Secure In-enclave Loading
Enclave
Secure in-enclave
loader
Code pages
Data pages
User process 15Secure In-enclave Loading
Enclave
Encrypted
enclave program
Secure in-enclave
loader
Code pages
Secure channel
Enclave program
Data pages
User process 16Secure In-enclave Loading
Secure
Enclave Enclave
in-enclave
loading
Encrypted
enclave program
Secure in-enclave
loader
Code pages Code pages
SGX related
data structure
Secure channel
Enclave program Runtime Data
Data pages Data pages
User process User pr1o7c essSecure In-enclave Loading
Secure
Enclave Enclave
in-enclave
loading
Secure in-enclave
loader
Untrusted kernel Code pages Code pages
SGX related
data structure
Hide m Ene clam ve po rogr ray m layouts!! Runtime Data
Data pages Data pages
User process User pr1o8c essChallenges
P1. Memory layout is visible to kernel
P2. Small physical memory (i.e., small entropy)
P3. Runtime page permission change is not supported
19P2. Low Entropy
Enclave
Small amount of physical memory
is provided
Paging
Virtual-to-Physical mapping
(i.e., paging)
Untrusted kernel
is managed by kernel
Brute-forcing attack
20Fine-grained ASLR
A
B
fi
esle
C
…
Usual control flow
Sequential execution
jg A
(e.g., fall-through)
21Fine-grained ASLR
Secure in-enclave
loading
…
jg A*
jmp C*
fi
esle
Control flow with fine-grained ASLR
Usual control flow
…
RU C
A
RU
A
B RU A
RU B
jg A
jmp C
RU
C
RU
B
22
fi
esle
C
…
jg AChallenges
P1. Memory layout is visible to kernel
P2. Small physical memory (i.e., low entropy)
P3. Runtime page permission change is not supported
23P3. No Runtime Permission Change
Loading
and relocation
à Write to code
24P3. No Runtime Permission Change
• Current SGX does not support
runtime page permission change
• We must keep some code pages writable
Code injection attack
à
25Goal of Soft Permission Enforcement
Hardware-based
permission
Out of enclave
Code of loader RWX
Code RWX
Data of loader RW
Data RW
Out of enclave
Virtual address space of an enclave
26Goal of Soft Permission Enforcement
Hardware-based Software+Hardware
permission permission
Out of enclave
Code of loader RWX No Permission
Loading
Code RWX X
Data of loader RW No Permission
Data RW
RW
Out of enclave
Virtual address space of an enclave
27Instrumentation
Inspired by NativeClient (Oakland’ 09)
Out of enclave
Code of loader
Write operation Before :
mov [rdx], rax
Code
rdx
Data of loader
After :
r15
lea r13, [rdx]
Data
< 4GB
sub r13, r15 r15+r13
mov r13d, r13d
Out of enclave
mov [r15 + r13], rax
28Implementation
• LLVM 4.0 with Clang frontend
• 1,261 LoC
• Static linker from scratch
• 1,043 LoC
• Secure in-enclave loader (i.e., dynamic loader) from scratch
• 2,753 LoC
29Evaluation
Q1. How effectively does SGX-Shield
defend against code reuse attacks?
Q2. How much performance overhead does SGX-Shield
bring for CPU-intensive workloads?
Q3. How much performance overhead does SGX-Shield
bring for real-world application?
30Effectiveness against Code Reuse Attack
• In Intel SGX SDK, attacker (i.e., kernel) knows
the location of each code object without any bit to guess
• The base address of enclave is known
• The memory layout is completely visible
• Attacker (i.e., kernel) must guess 20-bits for a code object in SG
X-Shield
31Effectiveness against Code Reuse Attack
• In Intel SGX SDK, attacker (i.e., kernel) knows
the location of each code object without any bit to guess
• The base address of enclave is known
• The memory layout is completely visible
• Attacker (i.e., kernel) must guess 20-bits for a code object in SG
X-Shield
SGX-Shield statistically defends against code reuse attacks!
32Small Performance Overhead
in CPU intensive workload
• Test application: nbench
• Major factor of performance overhead:
# of increased instructions
64-bytes RU 32-bytes RU
Only ASLR 1.05 % 7.80 %
ASLR + Soft-Enforcement 6.89 % 14.71 %
33Negligible Performance Overhead
in real-world workload
• Sample HTTPS server provided by mbedTLS (SSL/TLS library)
2.7 %
34Conclusion
• Goal: designing ASLR for SGX programs
P1. Visible memory layout to kernel
P2. Small entropy
P3. No runtime page permission change
• Solutions
P1 à Secure in-enclave loading
P2 à Fine-grained ASLR
P3 à Software-based permission enforcement
• Conclusion
SGX-Shield effectively defends against code reuse attacks
with negligible performance overhead
35Thank you!
Any question?
36Backup Slides
37Conflict between ASLR and Attestation
Enclave
SGX checks integrity by measuring
3. Protected Attestation
hash of enclave memory
running
Enclave program
Randomization changes the hash
Program
owner
value
User process
User space
Kernel space
2. Set up enclave
Conflict with attestation!
Untrusted kernel
1. Request
38