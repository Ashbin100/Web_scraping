Dachshund: Digging for and Securing Against
(Non-)Blinded Constants in JIT Code
Giorgi Maisuradze Michael Backes Christian Rossow
CISPA, Saarland University CISPA, Saarland University CISPA, Saarland University
Saarland Informatics Campus Saarland Informatics Campus Saarland Informatics Campus
giorgi.maisuradze@cispa.saarland backes@cs.uni-saarland.de rossow@cispa.saarland
Abstract—ModernbrowserssuchasChromeandEdgedeploy environments to dynamically generate gadgets (instead of
constant blinding to remove attacker-controlled constants from searchingforthem,likeinJIT-ROP).Forexample,anattacker
the JIT-compiled code. Without such a defense, attackers can can embed short gadgets in integer constants of JavaScript
encode arbitrary shellcode in constants that get compiled to code, which the JIT compiler translates to executable shell-
executable code. In this paper, we review the security and
code. To protect against dynamically-injected attack code, JIT
completeness of current constant blinding implementations. We
engine developers and researchers started to rely on constant
develop DACHSHUND, a fuzzing-driven framework to find user-
blinding. The goal of constant blinding is to generate code
specified constants in JIT-compiled code. DACHSHUND reveals
that does not contain user-specified constants. Technically, the
several cases in which JIT compilers of modern browsers fail
to blind constants, ranging from constants passed as function JIT compilation process does not emit any constant that may
parameterstoblindedconstantsthatsecond-stagecodeoptimizers be part of JavaScript statements (such as variable assignments
revert to a non-protected form. To tackle this problem, we like a=0x9090). For example, a simple implementation could
then propose a JavaScript rewriting mechanism that removes remove the constants by XORing two non-predictable values
all constants from JavaScript code. We prototype this cross- whose XOR result equals to the constant. This way, an adver-
browser methodology as part of a Web proxy and show that sary can no longer embed shellcode in predictable constants
it can successfully remove all constants from JavaScript code.
intheJIT-generatedcode.Consequently,constantblindinghas
becomeanimportantfoundationtoprotectagainstJITspraying
I. INTRODUCTION
attacks and is the basis for many other defenses [52], [29].
Web browsers continue to be one of the main targets MostmodernbrowserssuchasChromeorMicrosoftEdge(and
for software exploitation, as demonstrated by the rise of its predecessor Internet Explorer) deploy constant blinding.
browser-targeting exploit kits [26] and the sheer number of
In this paper, we analyze the completeness of constant
software vulnerabilities discovered in browsers. It is not just
blinding implementations in JIT engines of modern browsers.
the popularity and complexity of browsers that make them
We find that a correct and complete constant blinding imple-
an attractive target. Modern browsers also support various
mentation is not as trivial as it may sound. In fact, browsers
scripting languages such as JavaScript and ActionScript. On
typically strive for high efficiency and have to intertwine
the one hand, scripting environments have become indis-
security defenses with multi-layer optimization schemes. Fur-
pensable to dynamically generate highly-interactive content
thermore, there are dozens of ways to embed constants in
on the modern Web. On the other, scripting support also
JavaScript code, including global and local variable, function
allows adversaries to perform prolific attacks. Most notably,
parameters,arrayindexes,bitoperations,returnstatementsand
in Just-in-Time Return-Oriented Programming (JIT-ROP), an
manymore.Aswewillshow,itiseasytomisssomecases,and
attacker uses the scripting environment to dynamically search
it becomes a non-trivial challenge to understand the security-
for gadgets in existing code (e.g., of the browser or imported
relatedeffectsofthevariousoptimizationlayersinJITengines.
libraries) [49]. A viable defense against JIT-ROP attacks is
to compile programs in a way that they do not have usable
Inthiscontext,wepropose DACHSHUND,afuzzing-driven
gadgets, e.g., using gadget-free compilation [41] or Control
frameworkthatteststhecompletenessofconstantblindingim-
Flow Integrity [55], [56], [14], [37], [55].
plementationsinbrowsers(orothersoftwarewithJITengines,
However, such protections are typically limited to static such as PDF readers). The core idea of DACHSHUND is to
code.Consequently,thesedefensesareineffectiveagainstcode feed a JIT compiler with JavaScript code snippets that include
sprayingattacks[6],inwhichanadversaryleveragesscripting constants and to trigger the JIT compilation phase(s). We
leverage a JavaScript code generator to dynamically generate
a high number of diverse code snippets that contain “magic”
Permission to freely reproduce all or part of this paper for noncommercial constants. After JIT compilation, we search for these magic
purposes is granted provided that copies bear this notice and the full citation
values in the JIT-compiled code in order to test whether the
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author constants have survived blinding. A prototype implementation
(for reproduction of an entire paper only), and the author’s employer if the of DACHSHUND forChromeandEdgerevealedmanycasesin
paper was prepared within the scope of employment. which the JIT engines of these modern browsers fail to blind
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
user-specificconstants,underminingthesecurityguaranteesof
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23224 these implementations.Athanasakis et al. have already demonstrated that single- A. Return Oriented Programming (ROP)
byte or two-byte constants survive the blinding process, as
Although ROP was not the first code-reuse attack, it got
the constant blinding implementations simply do not blind
popular after the wide deployment of Data Execution Preven-
small constants for efficiency reasons [2]. However, we show
tion(DEP).DEPisadefensetechniqueagainstagenericstack
that the problem of incomplete constant blinding implemen-
overflow vulnerability where an adversary writes and executes
tations is far more fundamental than JIT compilers skipping
her shellcode directly on the stack. DEP tackles this problem
over smaller constants. Even blinding all (including smaller)
by marking executable pages non-writable.
constantswouldnothelptoremedythissituation.Infact,allof
the surviving constants that we discovered were 32 bits long, As a response to DEP, code-reuse attacks reuse existing
giving an attacker full flexibility to embed four-byte gadgets code portions of the program instead of injecting new ones.
(e.g., any system call). For example, in ret-to-lib(c) [38] an adversary mounts an
attack by reusing functions from imported libraries such as
There are multiple ways to overcome these problems. One
libc. This attack was generalized by Shacham [47] with ROP,
approach would be to change the JIT engines of browsers
whoproposedtouseso-calledgadgets(i.e.,smallsequencesof
to remedy the situation. However, as we have demonstrated,
instructionsendingwithareturninstruction)andchainthemto
reaching a complete implementation of constant blinding has
get arbitrary program execution. Return instructions are used
proven to be rather difficult and requires modification to each
to chain multiple gadgets together by writing their addresses
JIT engine separately. Alternatively, we propose to leverage a
on the stack. Later, Checkoway et al. [9] showed that one
Web proxy in order to rewrite the JavaScript code before it is
can also use any control-flow-changing instruction (e.g., jmp,
deliveredtothebrowser.Thisway,wecanprotectanybrowser
call) to achieve the same result.
behindtheproxywithoutsoftwaremodifications.Ourcoreidea
is to rewrite constants such that they do not appear in the JIT-
B. ASLR vs. JIT-ROP
generated code, regardless of the JIT engine and optimization
layer. To this end, we parse the abstract syntax tree (AST) of Address Space Layout Randomization (ASLR) [50] is a
HTML and JavaScript code, locate any JavaScript constants, widelydeployeddefensetechniqueagainstcode-reuseattacks.
and replace them with semantically-equivalent representations ASLRrandomizesthebaseaddressesoftheprogram’smemory
that are either not predictable by an attacker, or ideally are segments, thus preventing the attacker from predicting the ad-
moved out of the executable code sections. In addition, we dressesofthegadgets.Aremainingweaknessesofthiscoarse-
hook critical JavaScript functions (e.g., eval()) to remove grained ASLR scheme is that it only randomizes the base
constants from dynamically-generated JavaScript code. While addresses of memory segments. Researchers thus proposed
this approach is clearly less efficient than browser-specific fine-grained ASLR schemes that add randomness inside the
implementations, the average overhead of 22% in JavaScript segment as well [33], [51], [27], [43]. For more details, we
performance benchmarks is barely noticeable in practice. In refer the reader to Larsen’s survey [34].
addition, rewriting complex JavaScript libraries like jQuery is
relatively fast and takes a one-time effort of less than 60 ms. However, Snow et al. proposed a JIT-ROP to overcome
The rewriting outcome can be cached by the client and proxy ASLR [49]. JIT-ROP is a just-in-time code reuse scheme that
to eliminate any rewriting overhead in the future, leading to a follows the assumption that an attacker can repeatedly read
viable defense scheme in practice. arbitrary memory addresses, e.g., via a memory disclosure
vulnerability in a scripting environment such as JavaScript.
With this paper, we provide the following contributions:
The attacker uses this vulnerability to follow code pointers
• We design DACHSHUND, a fuzzing-based framework to andcollectsasmanycodepagesaspossible.Next,theattacker
searchforconstantsthatsurvivetheconstantblindingpro- searches for desired gadgets (such as Load, Store, Jump) and
cessofJITengines.DACHSHUNDcombinescodefuzzing API function calls (such as LoadLibrary, GetProcAddress) in
techniques with memory carving to discover potentially thesecodepages.Thisallowscarryingoutajust-in-timesearch
dangerous blinding leftovers. for suitable ROP gadgets and thus defeats fine-grained code
• We provide a thorough overview of security deficiencies randomization schemes.
of the constant blinding implementations in Chrome and
Edge, demonstrating that constant blinding by the JIT C. JIT Spraying
engines in these browsers is inherently insecure.
While JIT-ROP’s idea was to search for existing code, it
• We propose a proxy-based JavaScript rewriting engine
is not guaranteed that the required gadgets actually exist. In
that complements existing constant blinding implemen-
fact, Control Flow Integrity schemes may render any gadgets
tations by removing constants from the JavaScript code
unusable [55], [56], [14], [37], [55], or programs might have
at an average overhead of 22%.
been generated by compilers creating gadget-free code [41].
In such a setting, JIT spraying can be used to inject attacker-
II. BACKGROUND
controlledcode.JIT-compiledlanguages,suchasActionScript
We first provide an overview of the history of code-reuse (Flash) or JavaScript, have become popular in everyday pro-
attacks. We start with Return Oriented Programming (ROP), grams such as browsers. Being able to control the input to
which clearly demonstrates the general principle behind code- the compiler (i.e., JavaScript code), an attacker indirectly
reuse attacks. Next we show a special variant of ROP, called controls the compilation output. JIT spraying, proposed by
JIT-ROP, which discovers gadgets on-the-fly and evades exist- Blazakis [6], uses this property to evade DEP or ASLR.
ingrandomizationschemessuchasASLR.Besidestheattacks, By repeatedly injecting large amounts of code via attacker-
we also discuss potential defenses. controlled JavaScript objects, the attacker allocates (“sprays”)
2many executable pages with shellcode. After spraying, the Code Randomization: We assume that ASLR is enabled in
attacker then jumps to an address and hopes that she hits any the host operating system, which randomizes the base
of the sprayed code pages. addresses of the executable and other memory segments
everytimetheyareloadedintothememory.Additionally,
An advanced form of JIT spraying, shown by Athanasakis
we assume that fine-grained ASLR is applied to already
et al. [2], combines JIT spraying and JIT-ROP. Similar to
randomized (by ASLR) memory pages, further compli-
JIT spraying, the authors suggest to craft special JavaScript
cating the process to guess the address of a gadget.
statementsthatcompileintoanattacker-controlledsequenceof
Gadget-Free Code: We assume that static code (i.e., code
instructions.Forexample,JavaScriptvariableassignmentswith
thatisnotJIT-compiled)doesnotcontainusablegadgets.
immediate values (e.g., var v=0x90909090) will be com-
For example, this would be the case for gadget-free com-
piled into a sequence of assembly instructions containing the
pilation [41]. Note that JIT-ROP attacks are not possible
instruction that encodes the attacker-supplied immediate (e.g.,
in such a setting, given the lack of gadgets.
mov eax,0x90909090).Assuminganarbitrarymemoryread
JIT Defenses: WeassumeanydefensetechniquesagainstJIT
vulnerability, an adversary does not even have to spray many
sprayingthatisalreadypresentinmodernbrowsers,such
code pages, nor search for existing code (like in JIT-ROP).
as constant blinding (Chrome, Edge) or NOP insertion
Instead, she can emit arbitrary gadgets just by controlling
(Edge). As the main goal of our technique is to emit
constants in JavaScript code.
arbitrary gadgets in the executable code, we assume that
sandboxing in the browsers can either be bypassed (e.g.,
D. Constant Blinding via a vulnerability) or is disabled. For the same reason,
we do not consider CFI defenses to be applied to JIT-
To counter JIT spraying, most browsers have deployed
compiled code.
constant blinding. This defense technique changes the emitted
immediate value by XORing it with a randomly-generated
B. Threat Model
key. For example, instead of compiling the aforementioned
JavaScript code into mov eax,0x90909090, constant blind- With these defenses in mind, we now introduce the at-
ing will convert it to the following sequence of instructions: tacker model. Note that the assumptions listed below are in
accordance with existing attack techniques [2], [49].
mov eax, (RAND_KEY⊕0x90909090)
xor eax, RAND_KEY Arbitrary Memory Read: We assume that an adversary is
able to read arbitrary readable memory of the program.
Thiscouldbedone,forexample,byrepeatedlyexploiting
The constant RAND_KEY is a randomly generated key, and
a memory disclosure vulnerability.
(RAND_KEY⊕0x90909090) is a single integer generated at
Hijacking Control Flow: Weassumethatthetargetprogram
compile time. Constant blinding thus protects all immediate
has a control flow vulnerability that the attacker can
values with constant-specific keys, and makes the process of
exploit to divert the control flow to an arbitrary memory
JIT spraying highly non-predictable.
location.
Aperfectimplementationofconstantblindingwouldblind JIT Compilation: We assume that the target program incor-
allimmediatevaluesinJavaScriptcodewithper-constantkeys. porates a scripting environment. More specifically, we
In practice (e.g., in MSIE and Chrome), due to performance require that the program has a JavaScript JIT compiler
reasons, only constants larger than two bytes (> 216) are that accepts arbitrary (valid) JavaScript code as input and
blinded. Although such blinding might seem effective against compiles it to native code. This requirement is met by
code spraying, Athanasakis et al. demonstrate that two-byte all modern Web browsers. In principle, our attack is not
gadgetsaresufficienttomountanattackiftheyarefollowedby limited to browsers, as JavaScript is also actively used in
alignedreturninstructions(i.e.,intheepilogueofthefunction other applications (e.g., PDF readers).
containing the gadget).
IV. DACHSHUND:FINDINGCONSTANTS
III. ASSUMPTIONS We now take a closer look at the completeness of the
defense technique implementations in JIT compilers of mod-
Having discussed the foundation of existing attacks and
ern browsers. More specifically, we will search for ways,
defenses, we now introduce the threat model and our assump-
in which the attacker can emit arbitrary gadgets into the
tionsondefensetechniquesthatwillbeconsideredthroughout
executable pages of the browser’s memory. To this end, we
the paper. These assumptions are in accordance with the
present DACHSHUND, a fuzzing-based framework that reveals
environment of other proposed attack techniques [2], [49].
attacker-controllableconstantsinJIT-compiledcode.Thebasic
design of DACHSHUND is shown in Figure 1. The framework
A. Defense Techniques
consists of a fuzzing component (Section IV-A) that creates
We first list the defense techniques that we assume to be diverse JavaScript code snippets to feed them to a JIT com-
deployed in the operating system or the target application: piler for further processing. After JIT compilation, the JIT
inspector (Section IV-B) then searches for constants induced
Non Writable Code: We assume that Data Execution Pre- by the fuzzer in the executable code pages. The interaction
vention(DEP)isinplace,ensuringthatthecodepagesare betweenthesetwocomponentsissteeredbythe DACHSHUND
not writable and thus defending against direct shellcode controller (Section IV-C). In the following, we describe this
injections. interplay in more detail.
3Controller
C=0x9090 C=0x9090
Edge
Fuzzer JIT Inspector
Chrome
eval(" JIT ... FOUND
var a=0^ xor rax,rax
var a=0^0x9090; 0x9090 at
0x9090; mov rax,0x9090
"); 0x04072710
...
Optim.
Fig.1. OverviewoftheDachshundarchitectureanditsthreecomponents.
A. Fuzzing Component We feed the JavaScript code snippets that are generated
by the fuzzing component to two popular browsers: Microsoft
In the first component of DACHSHUND, we aim to trig- Edge and Google Chrome (and their corresponding JavaScript
ger attacker-controllable constants in JIT compiled code. We engines: Chakra and V8, respectively). We exclude Mozilla
followasimilargoaltoAthanasakisetal.[2]andleverageim- Firefox from our experiments, as its JavaScript engine does
mediate values in JavaScript statements to emit gadgets in the not implement constant blinding.
JIT-compiled code. In their paper, the authors exploit the fact
that browsers only blind large constants (e.g., Chrome and IE
B. JIT Inspector Component
blind values larger than two bytes). We do not limit ourselves
totwo-bytegadgetsandinsteadchallengethecompletenessof
The JIT inspector component relates integer constants in
the constant blinding implementation. That is, we aim to find
randomly generated JavaScript code to the sequence of bytes
edge cases in which constant blinding is not applied, or cases
representing the same number in the JIT-compiled machine
wherethisblindingisrevertedbyvariousbrowsercomponents
code. Technically, we attach to the renderer process of the
(such as optimizers).
browser and inspect its code pages created at runtime. Once
the magic value encoded by the fuzzing component is found,
To search for these edge cases, we leverage code fuzzing.
the JIT inspector has likely found a constant that has survived
Codefuzzinghasalonghistoryasadynamictestingapproach
the blinding phase.
to identify software vulnerabilities [45], [28] (including in
browsers). Instead of searching for bugs, we leverage code However, to fully understand when to inspect the code
fuzzingtogeneratealargediversityofJavaScriptcodesnippets pages,itisimportanttonotethatJavaScriptenginesimplement
to trigger cases in which constants might not be blinded. multiple levels of compilation. Typically, the first-level JIT
Our main idea is to encode “magic” constants in the fuzzed compiler is fast but produces low-performance code, which
JavaScript code that DACHSHUND’s JIT inspector (cf. Sec- is then optimized by a second-level JIT compiler if it has
tion IV-B) can identify. been executed frequently. We refer to the first level compiler
as a baseline compiler and the second level as an optimizing
We implemented our fuzzer based on jsfunfuzz [45], a
compiler. In our experiments, we consider the code generated
JavaScript fuzzer that is heavily used in testing the Firefox’s
bybothcompilers,astheattackerhasfullcontroloftriggering
JavaScript engine. Technically, jsfunfuzz generates random
either of the two compilers by carefully choosing how often
JavaScript function bodies (including invalid ones) to test
she executes a piece of code.
JavaScript engines for vulnerabilities, also covering newly
introduced features such as in ECMAScript 6. We extended A distinction between Chrome and Edge has to be made
jsfunfuzz to adjust it to our needs: (i) we modified the code when the compilers kick in. Edge has an interpreter that
generator to reduce the likelihood that code generates syntax interpretstheJavaScriptcodeuntilitbecomeswarm(i.e.,when
errors, and (ii) we increased the chance of large integer it is executed around 50 times). Only after that, a JavaScript
immediate values appearing in the generated code. The reason function is compiled by the baseline compiler. In contrast,
for modification (ii) is straightforward, as we want to test if Chrome skips the interpreting step and directly compiles the
allegedly-blinded immediate values (i.e., larger ones in the JavaScript function upon first execution. Consequently, to
range [217,232)) are emitted by the compiler. Thus, we want triggerabaselinecompilationofaJavaScriptfunction,onehas
to maximize their incidence in the generated JavaScript code. to call the function once for Chrome and 50 times for Edge—
Modification (i) is required to reach the compilation stage, again, a parameter that is under full control of the attacker.
which will not be the case if the generated JavaScript code In both browsers, a baseline-compiled JavaScript function is
contains a syntax error. This again highlights the difference recompiled by the optimizing compiler after it becomes hot
between our motivation for code fuzzing and the typical (i.e., after it is executed over 1000 times). The optimizing
motivation for triggering software vulnerabilities. compilerleveragescodeanalysistechniquestoproducehighly
4efficient code (e.g., by incorporating inferred type information (CC4) The controller then triggers the JIT inspector to find
orfunctioninlining).TotriggeranoptimizationofaJavaScript constants that survived blinding. It passes all constants
function, one has to call it more than 1000 times. However, that are in the JavaScript code generated in (CC1) to
given the runtime of short JavaScript functions, this is not a the JIT inspector. If the JIT inspector returns positive
practical burden to attackers, i.e., it can be optimized in a matches, these are logged accordingly.
matter of milliseconds.
(CC5) The controller then triggers the optimization compiler
Putting all this together, the basic algorithm of the JIT on jsfun by calling the function 2000 times and repeats
inspector is the following: step (CC4) on the optimized code.
(J1) The JIT inspector receives a set of integers (the magic
values) as an input that has to be found in the JIT-
D. Experimental Results
compiled code.
(J2) It attaches itself to the required renderer process of the After implementing DACHSHUND for Edge and Chrome,
testedbrowser(i.e.,thecorrectbrowsertabcontainingthe weexperimentedtotesttheconstantblindingefficacyofthese
tested JavaScript code). two browsers. We ran DACHSHUND in a VirtualBox virtual
(J3) By looking at the permissions of the memory pages, the machine,runningWindows10onanInteli5-4690CPUhaving
JIT inspector retrieves a set of pages that were generated 3.50 GHz and 8 GB RAM. We ran each experiment for two
bytheJITcompiler.Itdoessobyscanningforpageswith hours per browser. In this time, DACHSHUND detected 124
RWX protection in Chrome and RX protection in Edge. constants in Chrome and 58 in Edge. Some of these results
(J4) Functions in these code pages are separated by 0x00 containedsimilarJavaScriptstatementsinvolvingemittedcon-
bytes in Chrome and 0xcc (int3) bytes in Edge. There- stants;therefore,wemanuallyfilteredthemtogetuniquecases
fore,startingfromapageboundary,theJITinspectorcan only, which resulted in 22 different cases in Chrome and 21
easily identify all functions, and extracts the correspond- in Edge. We manually verified these cases and in all instances
ing machine code. foundatruepositive,i.e.,wesuccessfullyfoundanon-blinded
(J5) As a final step, the JIT inspector searches for the input constant. In Chrome, constants were only emitted by the
integers (J1) in the machine code. In case of a match, the optimizing compiler, while in Edge constants were found in
JIT inspector returns the disassembly of the function that bothbaselineandoptimizingstages.Thesummarizedoutcome
contains the constant(s). of the experiments is that many JavaScript constants are
directlyemittedintomachinecode—despiteconstantblinding.
Note that in the last step (J5), where we search for the
Inthefollowing,wewillcategorizethesecasesintoclassesof
integer values in the machine code, we may encounter false
constants that bypassed the blinding process.
positives. That is, machine code may accidentally contain the
value that we searched for, which was however not a conse- Experiment results from both of the browsers showed that
quenceoftheJavaScriptcode.Wecandealwithfalsepositives amajorsourceofconstantswereargumentstoMathfunctions.
in two ways: (i) We can manually inspect the disassembled Math is a built-in JavaScript object, containing basic mathe-
outputofthemachinecodetoverifythatitindeedcorresponds matical functions and constants. Immediate values passed as
to a JavaScript statement, or (ii) we can reuse the same an argument to Math functions (like Math.round(0x1234))
JavaScript function with a different set of immediate values, end up in the JIT-compiled code. Manual verification showed
andcheckifwegetthematchagain.Forthesakeofsimplicity, that the optimizing compiler of Chrome also emits constants
weusedthefirstapproachandmanuallyinspectedallconstants when calling any other functions, such as built-in functions
found by DACHSHUND, while the latter solution is a fully- of JavaScript (e.g., Array.push(...)) or even user-defined
automated way to exclude any chance of false positives. ones. In assembly, these constants are emitted when argument
registers are set or when arguments are pushed on the stack.
Consequently, calling a function with more parameters (e.g.,
C. Controller Component
Math.max(X, Y)) or calling them multiple times emits more
constants.
As a third and last component, we add a controller that
steers the interplay between the fuzzer and inspector compo-
In Edge, however, the situation is different. Manual veri-
nents. The goal of the controller is to steer synchronization
fication showed that all the emitted constants (not only from
between fuzzer and inspector. The controller does so in the
function calling) are coming from the same assembly instruc-
following repeating steps:
tion, namely storing the constant into a register. Moreover,
this instruction is always located at the beginning of the
(CC1) The controller instruments the fuzzing component to
function,aftertheprologue,andnotwheretheactualstatement
generate a textual representation of a new JavaScript
(involvingtheconstant)iscompiled.Thisislikelycausedbya
function (jsfunStr).
caching mechanism of Edge, which stores an immediate value
in an unused register to use it later in a function.
(CC2) Usingeval,thecontrollergeneratesaJavaScriptfunc-
tion from jsfunStr (jsfun=eval(jsfunStr)). For example, consider the following JavaScript code:
(CC3) Ifevalfails(i.e.,jsfunStrhasasyntaxerror),return function jsfun() {
to step (CC1). Otherwise, the controller compiles jsfun return Math.trunc(0x12345678);
by calling it either once (Chrome) or fifty times (Edge), }
triggering the respective baseline compilers.
5Chakra, Edge’s JIT engine, will compile this statement into m = i ? 0x12345678 : 0 test rax,rax
the following sequence of assembly instructions: 0x23456789 1 je 4
2 mov ebx,23456789h
3 jmp 5
... ; prologue
mov rsi,0x1000012345678 ; Emitted constant 4 mov ebx,12345678h
... ; Other function code switch(j){ 0 mov rdx,[rbp+20h]
mov r9, rsi ; Setting Math.trunc parameter case 0x23232323: m++; 1 cmp edx,23232323h
... ; Setting other parameters } 2 jne XXX
call r12 ; Call Math.trunc 0x34343434[j] 0 mov rdx,3434343400000000h
... ; Other code + epilogue
1 ;set other parameters
2 call GetProperty
m = j ˆ 0x45454545 0 mov rax,[rbp+20h]
As it can be seen, the constant 0x12345678 is emitted as
1 xor eax,45454545h
partofa64-bitconstant.NotethatEdgeuses48-bitvaluesfor
globvar = 0x56565656 0 mov rax,1AF729D6001h
constants. Thus, the least significant bit of the first two bytes
1 mov r10,5656565600000000h
denotes the tag bit and indicates type of the encoded value,
2 mov [rax+0Fh],r10
that is an integer constant in our example. The instruction
mov rsi,XXX is the integer constant caching behavior of globarr[i] = 0x67676767 0 mov [rdx+XXX],67676767h
Edge, which we mentioned earlier. Interestingly, Edge uses return 0x12121212 0 mov rax,1212121200000000h
the cached integer value not only when the constant value Fig. 2. Gadget emitting JavaScript statements in Chrome and their corre-
itself is used, but also when other (similar) integers are used. spondingdisassemblyafterrewriting.
Forexample,tosetanintegerconstant0x12340000inanrax
register,Edgeutilizesthecachedvalueandemitsthefollowing
code: For demonstration purposes, we inject the same set of
gadgets that was used by Athanasakis et al. [2] to set the
lea rax,[rsi-0x5678] ;set rax to 0x12340000 argument registers for the VirtualProtect function:
pop r8, ret ; 4158 c3
The difference between the cached and target value is
pop r9, ret ; 4159 c3
encoded in lea. If needed, this can be further exercised by
pop rcx, ret ; 59 c3
an attacker to emit more than one constant per function. pop rdx, ret ; 5a c3
pop rax, ret ; 58 c3
Summing up, Edge emits constants in both phases of
compilation (baseline and optimizing), but emits only one
constantperfunction,locatedatthebeginningofthecompiled 1)Chrome: In Chrome, we created the following single
function. This does not limit the attacker, as she is able to JavaScript function containing the immediate constants that
compile many small functions to emit multiple gadgets. In correspond to the required gadgets:
contrast,Chrome’sJavaScriptoptimizeremitsintegerconstants
as part of the compiled statement involving the constant, and
function chromeGadgets() {
thus can be used multiple times to emit many constants in the
globar[0] = 0xc35841;
same function
globar[1] = 0xc35941;
globar[2] =-0x3ca7a5a7;
In general, DACHSHUND found many more ways
}
to embed integers that survive blinding. Other non-
blinded JavaScript statements include: ternary operators
(c?0x12345678:0x9abcdef), return statements (return
Aswehaveseen,writinganimmediateconstanttoanarray
0x12345678), cases of a switch statement (case
element emits it to the JIT code after compilation. Therefore,
0x12345678:), a bit-wise operations (i=jˆ0x12345678),
in chromeGadgets, we write the required constants into
writinganintegertoaglobalvariable(glob=0x12345678),or
globar,whichisaglobalarraydeclaredoutsidethefunction.
to an array element (arr[0]=0x12345678). Figure 2 shows
Note that the order of the bytes are swapped in integer con-
the aforementioned gadget emitting statements in Chrome
stantsbecauseofthelittle-endianformatoftheunderlyingx86
and their corresponding x86 code after compilation. This
machine. Furthermore, to also use the most significant bit in
demonstrates that popular constant blinding implementations
the last gadget, we use a negative number -0x3ca7a5a7 that
arefarfromcomplete,asmanytypicalcodeconstructsarenot
willbe representedin binary as0xc3585a59. Afterexecuting
touched by the compiler—not even the textbook JIT spraying
this function multiple times, i.e., triggering the optization,
example of variable assignments.
the optimizing compiler of Chrome generates the following
sequence of instructions:
E. Proof-of-Concept Gadget Generation
mov [rbx+0x1B], 0x00C35841 ; c7431b4158c300
As a final step of our evaluation, we leverage the mov [rbx+0x23], 0x00C35941 ; c743234159c300
previously-observed shortcomings in constant blinding imple- mov [rbx+0x2B], 0xC3585A59 ; c7432b595a58c3
mentations in order to create JavaScript functions that emit
meaningful gadgets into the executable memory.
62)Edge: InEdge,givenconstantcaching,wehadtocreate The possible downside of a proxy-based solution is that
threeseparatefunctionstogeneratetherequiredsetofgadgets we rely on all clients in a network to use a Web proxy for
(note that this is not a limitation as we are not constrained by browsing. This also means that the proxy has to intermediate
the maximum number of created functions): HTTPStrafficandthusprovidescustomcertificatesforHTTPS
communication between the browser and the proxy. While
function r8(){ Math.trunc(0xc35841); }
this might sound cumbersome, most corporate proxy vendors
function r9(){ Math.trunc(0xc35941); }
function racdx(){ offer such capability. HTTPS traffic inspection is de facto
Math.trunc(-0x3CA7A5A7); standard in many organizations that leverage next-generation
} firewalls, such as Baracuda Networks [4], Forcepoint [21],
Palo Alto Networks [42], MS Forefront [22], Blue Coat [7],
Fortigate[23],Zscaler[57].Wewilldiscussthisinmoredetail
Triggering the compilation of each of these functions, i.e.,
in Section VI. Note, however, that the design choice of where
calling them 50 times, resulted the required gadgets at the
todeployJavaScript-basedrewritingcanbechangeddepending
beginningofthecorrespondingfunctions.Thefollowingisthe
on the needs.
disassembly of the instructions emitting the gadgets:
mov rsi,0x1000000C35841; 48be4158c30000000100 A. Basic Idea
mov rsi,0x1000000C35941; 48be4159c30000000100
The core of our idea is to rewrite JavaScript code into
mov rsi,0x10000C3585A59; 48be595a58c300000100
semantically equivalent code that does not contain any integer
constants. There are several alternatives for how integer con-
stants can be replaced. A simple example of such replacement
V. DEFENDINGAGAINSTCONSTANTS
would be to split an integer constant into parts (similar to
DACHSHUND hasrevealedthatmajorbrowsersaresuscep- constant blinding), changing the constant X into Y◦Z, where
tible to emitting attacker-controlled four-byte values into exe- ◦ is any JavaScript operation such that Y◦Z=X. However,
cutable code. Even though Chrome and Edge deploy constant as we modify the JavaScript code, this operation would be
blinding to defend against gadget emission, their implemen- easily folded by the compiler and X would still be emitted.
tation is still not complete. While it was already known that Another solution is to generate a new Number object every
constant blinding implementations emit two-byte gadgets [2], time a constant is used, e.g., via parseInt, which takes a
our automated DACHSHUND framework discovered that even string representation of a number as an input and outputs
four-byte integer constants are emitted in certain scenarios. its corresponding Number object. This replacement would
transform a constant X into a statement: parseInt(’X’).
There are several options to solve the aforementioned
A drawback of this method is that it executes a parseInt
problems. The na¨ıve and likely the most efficient solution
functioncalleverytimeanintegerconstantisused,thusgreatly
would be to modify the JavaScript engines in the browsers to
decreasing performance. In the following, we show how this
incorporateconstantblindinginallmissingcases(e.g.,inlining
can be optimized.
integerconstantsinChrome’soptimizingcompilerorpreload-
ing registers in Edge). This would remove the problem of In our prototype, we hide integer constants by replacing
arbitrary four-byte gadget generation, presumably without too them with global objects. For example, a JavaScript statement
much overhead. However, to also get rid of two-byte gadgets, var i=1234 will be replaced by the following pair of state-
constant blinding schemes in the browsers must be extended ments:
to cover integer constants of all sizes, significantly degrading
the performance [2]. In addition, changing the JIT compiler is window.__c1234=parseInt(’1’);
not always possible, especially in closed-source browsers; at window.__c1234=parseInt(’1234’);
the very least, it requires compiler-specific engineering effort
These statements will be prepended at the beginning of the
to cover all browsers.
script. During the initialization of these global variables, we
Alternatively,weproposetorandomizetheJavaScriptcode use parseInt such that the assignment does not emit the
before the code is delivered to the browser. As DACHSHUND constant. In the case of a call to parseInt, the argument is
identified, the main source of gadgets in JIT-compiled code a string and therefore only the reference to that string (and
is inlined or cached integer constants. Consequently, the main notitsvalue)willbeemittedtotheexecutablecompiledcode.
idea of our defense is to remove these constants by rewriting Additionally, as it is seen in the example, we initialize the
the JavaScript code. We prototype our technique as part of sameobjecttwice:firstwithsomerandomnumber,andsecond
a Web proxy that mediates Web traffic between clients and withtheoriginalvalue.Thisisnecessarytotricktheoptimizer
servers. Once implemented, our solution protects any client into thinking that the value of the global object is changing,
behind the Web proxy. One could also implement the same otherwise the global integer will be inlined into the compiled
approach as a browser extension to target specific browsers code.Thismodificationshowstheintuitionbehindourdefense:
separately. Browser-aware implementation can be optimized First, by replacing integer constants with global objects, we
to only rewrite the parts of the JavaScript that are attacker- get rid of integer literals from JavaScript code, which is the
controllable in the specific browser, thus reducing the per- mainreasonofgadget-emissioninEdge;Andsecond,wemark
formance overhead caused by the rewriting. However, as our these global objects as volatile (i.e., they can be modified by
main goal was to prove the efficacy (and not efficiency) of a other parties at any point) by setting their values multiple
solution based on JavaScript rewriting, we opted for a proxy- times. This will force the optimizer to resolve their values
based rewriting that is agnostic to the specific browsers. at runtime instead of inlining them into the code, successfully
7removingthesourcesofgadgetsinChrome.Wehavemanually The general workflow of the rewriter can be summarized
verified that compilers replace neither window.__c1234 nor in the following steps:
parseInt(’1234’) with the integer 1234 in none of the
browsers. (RW1) TherewritertakesJavaScriptcodeasinputandderives
its AST.
However, removing constants from JavaScript code is a
(RW2) The rewriter traverses the generated AST. For each
little more complex than that. Because JavaScript has implicit
literal node (i.e., integer or string immediate values), the
conversion between types, which can also be inlined, e.g., by
rewriter distinguishes the following cases:
the optimizing compiler of Chrome. Therefore, we have to
• Integer constants (e.g., 123) are replaced
additionally protect against possible implicit type conversions.
with a node corresponding to the statement
For example, a JavaScript statement var i=’1234’&5678
(e.g., window.__c123). Then, the rewriter
will also emit 1234 as an integer constant. We handle these
adds initialization code for this node (e.g.,
cases by finding all strings that can be implicitly converted
init+=’window.__c’+
to integers and call the toString method on them (var
123+’=parseInt("’+123+’");’)
i=(’1234’).toString()&5678).Thisreturnsanewstring
• String constants representing numbers (e.g., ’1234’)
object every time it is called and therefore is not optimized.
are replaced with an AST node of the statement:
Other string methods (such as substr) can also be used as
(’1234’).toString() to avoid implicit casts to
an alternative. There are other possibilities in JavaScript of
(possibly constant) numbers.
implicit type conversions to integers, e.g., from Boolean to
(RW3) Finally, the rewriter generates JavaScript code that
integer (true→1, false→0), from Array to integer ([]→0). To
corresponds to the updated AST, notably including the
trigger the conversion, these objects must be used as a part of
global variables’ initialization scripts.
arithmetic operations, which will then try to convert them to
the most reasonable integers. We will discuss these cases in
The JavaScript rewriter becomes an integral part of the
Section VI.
Web proxy. That is, we modify responses from server to
To eradicate all integer constants, we rewrite all possible client (i.e., browser). If the response is a JavaScript file (C1),
places where JavaScript code can be written. We distinguish we directly return the rewritten result to the client. In case
between the following five cases: of an HTML file, we extract and rewrite inline JavaScript
between script tags (C2) and inline event handlers (C3). For
(C1) An external JavaScript file referenced using a src at-
dynamic code (C4), we inject new JavaScript code as the
tribute of an HTML script tag, such as:
first element of the head tag, which hooks the dynamic code
<script src="jsfile.js"></script>
generator functions (e.g., eval, Function, setTimeout,
(C2) JavaScript inside an HTML script tag, such as: setInterval) and dynamically rewrites the code (i.e., the
<script>/*JS code*/</script> first argument of these functions) before calling the original
function. For dynamic HTML elements (C5), we attach a
(C3) Inline event handlers, defined inside HTML tags, e.g.:
mutation observer to the document object. This allows us to
<img onclick="/*JS code*/" />
reacttoDOMtreemodificationsbytheattacker.Foreachnode
(C4) Dynamically created JavaScript code, e.g., by using one that is modified in the DOM tree, we check if it is a script tag
of the following methods: or if it contains a script tag in its child nodes, and if so, we
eval("/*JS code*/") extract and rewrite its JavaScript content.
Function("/*JS code*/")
Note that in order to rewrite dynamically generated
setTimeout("/*JS code*/", 0)
code (e.g., for (C4) and (C5)), we use synchronous
setInterval("/*JS code*/", 0)
XMLHttpRequest requests from our hooked JavaScript func-
(C5) Dynamically created HTML nodes, which an attacker tions and mutation observer to the proxy. The JavaScript code
might use to inject new JavaScript code, such as: thatneedstobemodifiedisaddedtotherequest.Theresponse
head.appendChild(/*DOM node*/) from the proxy contains the rewritten JavaScript code.
el.innerHTML="<script>/*JS code*/</script>"
In the following, we will describe the implementation C. Evaluation
details of how we actually handled these cases.
In the following, we evaluate our implemented defense
technique. First and foremost, we test the efficacy of the
B. Implementation Details
solution and apply DACHSHUND to reveal if there are re-
We implemented our prototype in Node.js [39], using the maining attacker-controlled constants in the JIT-emitted code.
http-mitm-proxypackage[30]asabasisforanHTTPproxy.To Second,weevaluatetheperformanceoverheadoftheproposed
identifyallconstantsinJavaScriptcode,weuseEsprima[19], solution.AswerewritetheJavaScriptcodethatisexecutedina
a JavaScript parser with full support for ECMAScript 6. We browser,weconsidertwosourcesofoverhead:(i)theoverhead
leverage the abstract syntax tree (AST) to identify integer caused by rewriting JavaScript code, and (ii) the performance
constants or string constants representing numbers. We lever- overhead of the rewritten JavaScript code, running inside a
age Estraverse [20] to traverse the AST and replace AST browser. We evaluate the latter in Google Chrome 50 and
nodes (e.g., replacing number literals with global objects). Microsoft Edge 25. The underlying system is Windows 10
Finally, we use Escodegen [18] to generate JavaScript code running on an Intel Core i7-2670QM machine with 2.20GHz
that corresponds to the updated AST. frequency and 6GB RAM.
8m = i ? __c12345678 : 0 test rax,rax m+=0x12000000| 0 mov ebx, [rbx+13h]
__c23456789 1 je 5 0x00340000| 1 add ebx,12345678h
2 mov rbx,&__c12345678 0x00005600|
3 mov ebx,[rbx+13h] 0x00000078;
4 jmp 7 m+=__c12000000| 0 mov rax,&__c12000000
5 mov rbx,&__c23456789 __c00340000| 1 mov eax,[rax+13h]
6 mov ebx,[rbx+13h] __c00005600| 2 mov rbx,&__c00340000
switch(j){ 0 mov rbx,&__c23232323 __c00000078; 3 mov ebx,[rbx+13h]
case __c23232323: m++; 1 mov ebx,[rbx+13h] 4 or ebx,eax
} 2 cmp edx,ebx 5 mov rax,&__c00005600
3 jne XXX 6 mov eax,[rax+13h]
__c34343434[j] 0 mov rax,&__c34343434 7 or eax,ebx
1 mov eax,[rax+13h] 8 mov rbx,&__c00000078
2 ;set other parameters 9 mov ebx,[rbx+13h]
3 call GetProperty 10 or ebx,eax
m = j ˆ __c45454545 0 mov rbx,&__c45454545
Fig.4. ConstantsplittinginJavaScript(Chrome)beforeandafterrewriting.
1 mov ebx,[rbx+13h]
2 mov rdx,[rbp+20h]
3 xor ebx,edx
implicitlyconvertedtointegers.Forexample,Hieroglyphy[32]
globvar = __c56565656 0 mov rax,&__c56565656
uses conversion between arrays ([...]) and objects ({...})
1 mov edx,[rax+13h]
to integers. Using these conversions inside the function does
2 mov rax,&globvar
notemitattacker-controlledvalues.However,theycanbeused
3 mov [rax+0Fh],rdx
by the attacker to initialize a global variable and then use
globarr[i] = __c67676767 0 mov rax,&__c67676767
the global variable inside the function to inject the required
1 mov eax,[rax+13h]
value. Because the global variable will be initialized once, by
2 mov [rbx+XXX],eax
the attacker, it will be inlined into the code (by Chrome),
return __c12121212 0 mov rax,&__c12121212 emitting the gadgets. This problem can be solved using a
1 mov eax,[rax+13h] similar technique that we used before. That is, we can replace
Fig. 3. Gadget emitting JavaScript statements in Chrome and their corre- global variable initializations in the code by initializing the
spondingdisassemblyafterrewriting.&__cXXXXXXXXdenotestheaddressof global variable with a random number first, and then setting it
thecorrespondingJavaScriptglobalvariable. to the original value. This way, optimizer will have to resolve
thevalueoftheglobalvariableatruntimeandwillnotbeable
to inline it into the code. Although we manually verified that
1)RewritingEfficacy: First,weevaluatethecorrectnessof thismodificationindeedremovestheattacker-controlledvalues
therewritertoseeifallintegerconstantsareindeederadicated fromthecode,itisnotincludedinthecurrentimplementation
from the JIT-compiled code. Therefore, we tested the rewriter of our defense scheme.
against all JavaScript functions found by DACHSHUND. Ini-
tially, we verified that all these functions actually emitted Other obfuscation techniques of JavaScript code also con-
integer constants, i.e., we did not get any false positives from tain integer splitting to hide their values. For example, in-
DACHSHUND. We found that all 22 different functions in stead of having a single constant var i=0x12345678, the
Chrome and 21 in Edge did emit integer constants into the attacker might try to split it (e.g., into separate bytes):
code. We then modified these functions with our JavaScript var i=0x12000000|0x340000|0x5600|0x78. After opti-
rewriter and ran the experiment again. After rewriting, none mization, these constants will be folded by the compiler
of the JavaScript functions emitted any integer constants in into a single integer and will be emitted into the JIT-code.
the JIT code, neither for Chrome nor Edge, proving the However, our rewriter will turn each of these constants into
completeness of the rewriter. Figure 2 shows the disassembly global objects, forbidding both constant folding and inlining
ofthenativecodeofthegadget-emittingstatementsinChrome, (Figure 4).
whereas Figure 3 shows the same statements and their disas-
sembly after applying our rewriter. 2)Rewriting Overhead: To evaluate the overhead of the
JavaScript rewriter, we chose to measure the rewriting over-
Thecodeexamples,foundbyDACHSHUND,coveronlydi- head of two popular and large JavaScript libraries, jQuery
rectlyusedJavaScriptintegerconstants.Whilethisissufficient (version 2.2.3) and AngularJS (version 1.5.5). These libraries
for Edge, where the source for emitted gadgets are integer are commonly embedded in typical Web applications and
caching, optimizing compiler of Chrome can still inline the are relatively large compared to other custom JavaScript
values after implicit conversion. To test the rewriting efficacy implementations (jQuery has 259 kB, AngularJS 1.1 MB).
of implicit constants (i.e., from string objects to integers in Moreover, both of these libraries also provide the compressed
our case), we did manual verification. More specifically, we (i.e.,“minified”)versionstoreducethedownloadsize(jQuery
created JavaScript functions containing string literals that are 86 kB, AngularJS 158 kB). For the evaluation, we rewrote
implicitly converted to integer types. After rewriting, all these theselibraries(bothcompressedanduncompressed)200times.
string literals were converted to string objects (via invoking We measured the time required to rewrite these libraries,
toString on them), and thus did not emit any integer values. including all steps (RW1) up to (RW3). The results of the
However, strings are not the only JavaScript objects that are evaluation are presented in the following.
9150
100
50
0
AngularJS JQuery
)sm(emiTetirweR
541
101
36
15
Uncompressed
Minified
Fig.5. AveragedtimesforrewritingJavaScriptlibraries
·104
2
1
0
Chrome Edge
erocSenatcOegarevA
594,62
028,02
542,42
825,81
zlib Inordertotesttheperformanceofthecompiler,zlibuses
eval. This causes the rewrite time of our rewriter to be
added to the runtime of the script, as the code passed
to eval needs to be rewritten dynamically. Additionally,
thecompiledzlibscriptextensivelyusesintegerconstants
that further degrade the performance.
CodeLoad This benchmark measures how quickly a Java-
Script engine can execute a script after loading it. Code-
Load uses eval to compile JQuery and Closure libraries
and therefore again includes the rewriting time.
While the use of dynamic code (like in eval) degrades
performance, we cannot exclude such code from our rewriter,
as it would give a possibility to the attacker to enter con-
stants using dynamic code. However, the experiments have
shown that it is mainly dynamic code rewriting that causes
performance impacts, and libraries that do not leverage such
Orig Proxy dynamic code have an acceptable overhead. Without the two
poorly-performingbenchmarks,theoverheaddecreasesto12%
in Chrome and 13% in Edge. Note that the overhead of
popular libraries could be eliminated by whitelisting (and
thus not rewriting) trusted scripts, as our threat model is
only relevant to non-trusted and attacker-controlled JavaScript
inputs.Alternatively,ourrewritercouldcachepopularlibraries
after they have been already rewritten to provide them to the
client without any rewriting overhead.
Toputthingsintoperspective,wenowcomparetheperfor-
manceofourschemewiththeperformanceofanon-optimized
JIT compiler. The intuition here is that our suggested attack
technique against Chrome relies on abusing output of the
optimizingcompiler.Disablingtheoptimizingcompilerthusis
Fig.6. AveragedOctanescoresinChromeandEdge aviablealternativetoprotectagainstattacker-inducedgadgets.
Therefore,weperformedanotherexperimentandalsoincluded
Chrome with a disabled optimizing compiler (by running
The minified versions of the libraries took less time to be Chrome with the V8 flags noopt and nocrankshaft).
rewritten. On average, rewriting AngularJS took 145 ms and Figure 7 shows the complete list of all Octane benchmarks,
101 ms for the uncompressed and minified versions, respec- running in three modifications of Chrome: (i) original, (ii)
tively. Rewriting jQuery took 63 ms and 51 ms, respectively original with proxy (i.e., rewritten JavaScript), and (iii) with
(see Figure 5). We argue that this overhead of a mere 100 ms the optimizing compiler disabled. As can be seen, with the
is acceptable to typical Web users, as network latencies and exceptionofthetwolibrariesthatrequirerewritingofdynamic
bandwidthconstraintsaremoresignificantwhenloadingthese code,ourproposedsolutionoutperformsthedisabledoptimizer
libraries. In addition, note that rewriting is a one-time effort byaroundafactorofeightandthusseemstobethepreferable
andtherewrittenJavaScriptlibrarycanbecachedbytheproxy option.
aswellasontheclientside.Suchcachingmechanismsarepart
Although the overhead for dynamic scripts seems
ofCOTSbrowsersandrequirenofurtherclientsoftwaremod-
significant, our JavaScript rewriter usually completes in a
ifications. Finally, rewriting multiple scripts simultaneously is
matter of milliseconds. Rewriting a JavaScript library as big
an effort that can be trivially parallelized to further improve
as jQuery takes, on average, less than 60 ms (see Figure 5).
performance.
This can be further improved by incorporating caching in
3)RuntimeOverhead: Next,weevaluatetheruntimeover- our proxy, using hashes of the dynamic script as a key. This
head that is incurred on the client side due to the modified way, for example, when compiling a jQuery library 100
JavaScriptcode.Tothisend,weleverageOctane,acommonly- times using eval (e.g., as done in CodeLoad), the rewriter
used benchmark framework for JavaScript engines [40]. For spends 60 ms on the initial request and serves the subsequent
the evaluation, we took the averaged scores from 5 runs of requests without any delay caused by the rewriting process.
Octane benchmarks. JavaScript runtime showed the follow-
ing results: Figure 6 illustrates the performance comparisons
between the original and the rewritten engine. The unit is
the score measured by the Octane benchmarks, and higher is
better. On average, we measure 21% performance decrease in
Chromeand24%inEdge.Theaverageoverheadissignificant,
but performance is mainly degraded by a few outliers in the
benchmark suite, such as:
10·104
6
4
2
0
Richards DeltaBlue Crypto RayTrace EarleyBoyer RegExp Splay NavierStokes PdfJS Mandreel Gameboy CodeLoad Box2D zlib Typescript
erocSenatcO
829,32 592,42
881,1
559,63 811,83
883,1
082,02
251,51
407,2
139,05 986,05
889,2
538,82 097,82
692,8
501,3 001,3 250,2
292,61
469,3 949,1
952,32 782,32
343,2
069,11 355,01
190,7
457,71
757,21
013,1
782,44
182,53
300,9 055,9
733,1
022,9
855,93 226,83
303,3
741,74
207,2 791,4
885,32 766,32
663,11
Orig Proxy NoOpt
Fig.7. OctaneresultsinChrome(OriginalvsProxyvsNot-Optimized)
VI. DISCUSSION easier. But the more fundamental observation is the fact that
we found that constants that should have been blinded were,
In this section, we revisit the two proposed frameworks,
in fact, not successfully blinded.
and discuss their implications and possible limitations.
B. Limitations of Dachshund
A. Implications of Dachshund
DACHSHUND uses code fuzzing, which is known to be
DACHSHUNDhasrevealedseveralwaysattackerscaninject
incompleteintermsofcodecoverageandcasesthatitexplores.
arbitrary long gadgets into JIT-compiled code. We will now
We have shown that our technique is quite successful for
discuss how this is relevant from a security perspective.
discovering leftover constants in JIT-compiled code. However,
How bad is attacker-induced shellcode, really? similar to other fuzzing techniques, DACHSHUND cannot be
One could argue that additional defense schemes in browsers used to prove that JIT engines do not emit attacker-controlled
will protect against control-flow diversion attacks, regardless constants. DACHSHUND could be combined with static code
of whether an attacker can inject shellcode or not. While analysis to fulfill this higher goal.
this argument is not wrong per se, we believe that our
Furthermore, DACHSHUND leverages immediate constants
findings have important implications anyway. First, constant
in JavaScript code to evade constant blinding. It may also be
blindingispartofthetwomostpopularbrowsers,and—aswe
possible to find other types of attacker-controllable constants,
find—a security feature that can be easily circumvented by
such as values embedded in control-flow statements (e.g.,
attackers. Relying on such schemes is only helpful if they are
constants encoded in relative offsets). However, our findings
also implemented correctly. Otherwise, as we find, they give
show that an attacker does not even need to search for other
securityguaranteesthatdonotholdinpractice.Second,attacks
types of constants, given plenty of immediate ones.
in the past have demonstrated that even additional security
mechanisms such as CFI or sandboxing cannot protect against
C. Limitations of the Defense
successful browser exploitation. We thus argue that it is not
an “either-or” question which security mechanisms to use; we Our proposal to defend against constants has certain lim-
see the need for complementary techniques to defend against itations, which we address next. As already mentioned, our
browser threats. Finally, predictable gadgets may also have proxy-basedsolutionrequiresthatHTTPS-securedcontentcan
severe security implications on even stronger threat models. alsoberewritten.Thismeansthatcertificatevalidationwillbe
For example, assuming that the location of gadgets can be done by the proxy and the client needs to trust certificates
identified, schemes that propose non-readable code (such as handed out by the proxy. However, in corporate settings, such
Execute-no-Read proposals [3], [12], [13]) can potentially be HTTPS-enabledproxiesarequitecommonandservetoinspect
evaded. We will perform such an evaluation in future work. client communication for multiple purposes (e.g., caching,
protecting against information leakage, identifying HTTPS-
Does it matter that you found four-byte constants?
based malware communication, etc.) Our rewriting logic can
DACHSHUND is not the first work to target constant blinding
easily be integrated into existing proxies.
schemes. Athanasakis et al. [2] had already proven that two-
byte constants are sufficient to assemble suitable ROP chains. An alternative to a proxy implementation would be to
However, we looked at the problem from a different angle. embed our method as a browser extension. This way users
Instead of using constants that are excluded from the blinding willhavemore controlovertherewriter,e.g., theycanrequest
process (because they are too short), we inspected whether on-demand rewriting of certain pages or whitelist trusted
constants actually survive constant blinding. Indeed, four-byte pages. Also, HTTPS-based content will be no problem for
gadgets give an adversary more flexibility in the types of an extension-based rewriter, as rewriting happens after a page
gadgets to use and make building a ROP chain significantly is already loaded. However, the extension will face a race
11condition with the running JavaScript, i.e., JavaScript on the on the stack are referenced by adding their offset to rbp. The
page may be executed before the extension finishes rewriting. offsetisencodedasapartoftheinstruction,andthusisemitted
This problem can be solved by disabling JavaScript execution to the code. By varying the number of function parameters,
for all pages until the rewriter terminates. the attacker might generate useful gadgets. However, this
attack is limited by the number of possible arguments that
A technical challenge for our solution is potential defi-
a function can have, limiting the attacker to incomplete two
ciencies in the HTML/JavaScript parser. We might face cases
bytes. Alternatively, Maisuradze et al. [36] demonstrated that
in which the parser fails to parse the code. There are two
an adversary can use relative offsets encoded in control flow
possibilities for dealing with unparsable scripts: (i) we block
instructions (e.g., conditional jumps or calls). By carefully
the script, or (ii) we allow the script without modification.
choosingcertaincodesizes,attackerscanchangethevaluesen-
Solution (ii) lowers the security, because an adversary may
codedintheseinstructions,suchasrelativeoffsetsofbranches
find out a way to create a script that is unparsable but is still
(e.g., if/else) or calls (e.g., between caller and callee).
tolerated (and executed) in browsers. However, using (i) may
Complementary techniques, such as code randomization (e.g.,
block scripts that come from legitimate sources, thus modify-
NOPinsertions)orcontrol-flow-changingcoderewritingmight
ingthesemanticsofthepage.Asolutiontotheaforementioned
help to defend against such cases as a probabilistic defense.
problem could be to extract all immediate constants by alter-
We leave these ideas open for future work.
nativemeans(e.g.,usingregularexpressions)fromunparsable
scriptsandreplacethemwiththesafealternatives.However,in The discussion above has shown that we are not aware
summary,non-parseablescriptsarenotafundamentalproblem of any obfuscation technique that evades our defense. That
of our approach, but more a technical challenge for parser said,itmightbepossiblethatJITcompilerschange,orsimply
implementations. that attackers may find novel evasion tricks that we have not
discussed. In any case, this is not a fundamental limitation of
One weakness of our defense technique is that future JIT
our defense, but (as the examples above show) we can likely
compilers might convert global objects into integers as part
furtherimprovecoderewritingtogaincompletecoverageover
of the JIT code optimization. The basic idea why we replace
any attacker-controlled constant that we might have missed in
integerconstantswithglobalobjectsisthattheglobalvariables
the current prototype implementation.
inJavaScriptarevolatileandcanbemodifiedbyeveryfunction
running in the same context, e.g., by a JavaScript function
running at some time intervals. Therefore, these global vari-
VII. RELATEDWORK
ables, even though they encode integer values, will not be Inthefollowing,wesurveyrelatedwork,includinganevo-
inlined.However,ifaglobalvariableisfirstmovedintoalocal lution of attack techniques and their corresponding defenses.
variable,thenthelocalvariablecanbeinlinedifnecessary.We
manually tested multiple such cases in Chrome and found out
A. ASLR vs. Code-Reuse Attacks
thattheJITcompilerofChromedoesnotinlinesuchvariables.
However,inthefuture,ifthecompilerisextendedtoalsoinline ASLR continues to be the most-widely deployed defense
these variables, our rewriter has to be adapted accordingly. againstcode-reuseattacks[50].However,apartfrombeingin-
complete[46](i.e.,notbeingappliedtoallmemorysegments)
Furthermore, we unfortunately have no way to prove the
or having low entropy due to a 32-bit systems [48], ASLR
completeness of the rewriter. For example, our current proto-
is also vulnerable to code-reuse attacks utilizing information
typeimplementationdoesnotcoverallbordercasesofimplicit
leakage [31], [17], [5]. To make up for ASLR’s weaknesses,
conversions.InourJavaScriptrewriter,weaccountforimplicit
fine-grained randomization schemes complement ASLR by
conversions between a string and a number, e.g., from the
randomizing the code within memory segments reordered by
string ’123’ to the number 123. JavaScript, however, allows
ASLR. Therefore, leaking a code pointer does not reveal
morecasesofallowedimplicitconversions.Forexample,using
any information about the remaining code in that page. For
Boolean constants true and false as numbers 1 and 0
example,Pappasetal.[43]randomizeinstructionsinsidebasic
respectively (true+true is 2, true*100 is 100). Similarly,
blocksbycoderewriting.ASLP,byKiletal.[33],shufflesthe
unary operators can be applied to various types of JavaScript
addresses of functions along with important data structures
objects to convert them to integers. For example, +[] equals
by statically rewriting an executable. STIR, by Wartell et
to 0, and +!![] equals to 1. These types of conversions are
al.[51],permutesbasicblocksoftheprogramatstartup.Luet
usedbyJavaScriptobfuscatorstohidethesourcecode[32].As
al.advancetheseschemesbyprovidingapracticalruntimere-
Edgeonlycaches(i.e.,emitsinJIT-code)integerconstantsthat
randomization solution [35].
are directly encoded as immediate values in JavaScript, these
implicitconversionswillnotbeaproblemforit.However,they However,scriptingenvironmentsenabledattackerstolever-
can still be emitted by the optimizing compiler of Chrome. age information leak to bypass ASLR. In JIT-ROP [49], Snow
By manual verification, we found out that these cases are not et al. demonstrated that by repeatedly exploiting a memory
optimizedbyChrome’scurrentJITcompilerandthereforecan disclosure vulnerability, the attacker can read code pages of a
be ignored by our defense altogether. In the future, if these program and generate a gadget chain on the fly.
values get inlined into the executable code, our defense can
Closest related to our work, Athanasakis et al. [2] em-
be easily extended to also cover them.
powered JIT-ROP by utilizing the code output from the JIT
Apart from immediate constants, an attacker might encode compilers to inject their own gadgets. Knowing that JIT
implicit constants in JITted code. She can do so by abusing engines do not blind smaller constants, they show that an
other parts of the JavaScript code that indirectly influence attacker may be able to carefully align two-byte gadgets to
valuesencodedinJIT-compiledcode.Forexample,parameters mount successful attacks. We follow the same motivation,
12but show that the deficiencies of constant blinding are far C. Protecting JIT Compilers
morefundamentalthanignoringsmallconstants.DACHSHUND
Next to general code reuse defenses, researchers have also
has proven that constant blinding implementations in modern
suggested to specifically protect JIT compilers against ex-
browsers are inherently incomplete, irrespective of the size of
ploitation.InJITDefender,Chenetal.[10]proposeddefending
the constants. In addition, we propose and implement a viable
against JIT spraying by removing executable rights from JIT-
defense against attacker-induced gadgets in JavaScript code.
compiled code pages, until they are called by the compiler.
Similarly, executable rights will be stripped after the function
returned. This way, diverting the control flow to the sprayed
B. Defenses against Code Reuse
code will crash the program. Although this defense may work
Researchers have proposed various defenses against code- in some situations, the attacker can extend the time a code
reuse attacks, as summarized in the following. pages is executable, e.g., by using a thread that continuously
calls a JavaScript function.
Non-Readable Code: Backes et al. [3] and Crane et
Chen et al. proposed JITSafe [11]. JITSafe is an extended
al. [12] proposed tackling JIT-ROP attacks by forbidding
version of JITDefender, incorporating a similar technique as
the attacker to read executable pages of the program. XnR
suggested by Wu et al. with RIM [53], to inject invalid
(Execute-no-Read)marksexecutablepagesasnon-presentand
instructions into long chains of NOP sleds. While this defense
utilizes a page-fault handler to allow only valid accesses (i.e.,
is successful to prevent code spraying with long NOP sleds, it
instruction fetches). Similarly, Readactor uses Extended Page
cannot protect against more fine-grained code injections (such
Tables (EPT) to mark all executable pages as non-readable
as injecting single gadgets, as in our attack).
andappliesfine-grainedrandomizationtoallexecutablepages.
SomeremainingweaknessesofReadactor(e.g.,functionpoint- Homescu et al. [29] and Wei et al. [52] propose librando
ers in import tables and vtables) have been resolved in its and INSeRT, respectively. These techniques are similar to
successor Readactor++ [13]. Targeting ARM, also Braden et techniques deployed in modern browsers. For example, both
al. [8] suggest to leverage execute-only memory to protect of these techniques randomize the JIT-compiled code by
against code-reuse attacks. Finally, Gionta et al. suggest to randomly inserting either NOP (librando) or illegal (INSeRT)
hide code via a split TLB [24]. instructions into the code. Moreover, both of these techniques
deploy some form of constant blinding, e.g., by using an
Although the idea of non-readable code is promising,
XOR (INSeRT) or LEA (librando) instruction to encrypt the
withdrawing read privileges alone does not suffice to protect
constants. Our evaluation on popular browsers has proven that
against attacker-induced gadgets, in particular if gadgets are
such constant blinding schemes are actually hard to get right.
deterministic and their locations predictable. This is also the
To foster future research in this direction, we thus provide
reason why the schemes are typically combined with fine-
DACHSHUND as framework to evaluate the completeness of
grained randomization schemes, and hence, their security
constant blinding implementations.
against our attack heavily depends on the randomization.
Control Flow Integrity: CFI schemes restrict the control D. JavaScript Rewriting
flow to valid code paths. CFI implementations range from
Whilewithtotallydifferentgoalsinmind,otherresearchers
coarse-grained to fine-grained schemes [55], [56], [14], [37],
also used JavaScript rewriting as technique to guarantee vari-
[55],followingthetypicalcompromisebetweenefficiencyand
ous other security aspects. For example, Doupe et al. suggest
security [15], [25]. Shying the complexity of JIT engines, few
a Web rewriting framework called deDacota that separates
CFI schemes have been tested on JIT compilers. One of the
code (JavaScript) from data (HTML) to defend against cross-
notable exceptions is NaCl SFI [1], which provides a coarse-
site scripting (XSS) attacks [16]. Reis et al. rewrite Web
grainedCFIimplementationforJITengines,butfacesanover-
documents in such a way that also dynamic contents (e.g.,
head of 51% on x64 systems. Similarly, RockJIT instruments
script code) is instrumented and can be validated against
JIT-compiled code with coarse-grained checks, verifying the
security policies [44]. Similarly, Yu et al. provide a prov-
control flow instruction targets at runtime. Forcing the jump
ably correct JavaScript code rewriting methodology to defend
targets to be aligned instructions, RockJIT thus successfully
against threats like XSS [54]. These ideas follow similar
defends against our attack. Note that, apart from being fine-
concepts to identify JavaScript code in a Web site, however,
grained,thecompletenessofCFIschemesisequallyimportant,
do not focus on the security of JIT compilers.
i.e., even in the presence of a single unchecked (or wrongly
checked)jumptarget,theattackerwillbeabletomountasuc-
VIII. CONCLUSION
cessful attack. In particular, with arbitrary four-byte gadgets,
the attacker only uses unaligned instructions, and therefore DACHSHUND has uncovered that constant blinding im-
no additional CFI checks will be executed in between. Note plementations in many popular browsers are incomplete and
that this may not be the case for Athanasakis’ attack that inherently insecure. This has severe implications on the se-
requires to align multiple shorter gadgets to obtain a useful curity of browsers, as (i) the guarantees that are assumed to
one. Summarizing, complete CFI schemes are a powerful be given by constant blinding are not met in practice, (ii) we
defense, and may become a viable solution in the long run. demonstrate how easy an attacker can inject arbitrary gadgets
However, special attention must be paid to the completeness (uptofourbytes)toformROPchains,and(iii)astheproblems
and to the precision of the sandbox. In the past, sandbox of constant blinding are far deeper than it was previously
escaping attacks demonstrated that orthogonal defenses, like believed. Our JavaScript-based rewriting approach is a first
ours, present a useful additional layer of security. step to remove the risk of attacker-induced constants and to
13safe the guarantees of constant blinding, without any need [13] S.Crane,S.Volckaert,F.Schuster,C.Liebchen,P.Larsen,L.Davi,A.-
to rewrite browser software. In the long run, we presume R.Sadeghi,T.Holz,B.D.Sutter,andM.Franz,“It’saTRAP:Table
that more fundamental changes are required to guarantee RandomizationandProtectionagainstFunctionReuseAttacks,”inPro-
ceedingsof22ndACMConferenceonComputerandCommunications
browser security, such as enforcing Control Flow Integrity
Security(CCS),2015.
schemes even on JIT-compiled code, or exploring provably-
[14] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz, R. Hund,
secure gadget-free JIT compilers.
S. Nu¨rnberger, and A.-R. Sadeghi, “Mocfi: A framework to mitigate
control-flowattacksonsmartphones.”inNDSS,2012.
ACKNOWLEDGMENT [15] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose, “Stitching the
gadgets:Ontheineffectivenessofcoarse-grainedcontrol-flowintegrity
The authors would like to thank the anonymous reviewers
protection,”in23rdUSENIXSecuritySymposium,2014.
fortheirvaluablecomments.Moreover,wewouldliketothank
[16] A. Doupe´, W. Cui, M. H. Jakubowski, M. Peinado, C. Kruegel, and
Michael Brengel for his feedback during the writing process G. Vigna, “dedacota: toward preventing server-side xss via automatic
of the paper. code and data separation,” in Proceedings of the 2013 ACM SIGSAC
conferenceonComputer&communicationssecurity. ACM,2013,pp.
This work was supported by the German Federal Ministry 1205–1216.
of Education and Research (BMBF) through funding for the [17] T. Durden, “Bypassing PaX ASLR protection.” [Online]. Available:
Center for IT-Security, Privacy and Accountability (CISPA) http://phrack.org/issues/59/9.html
and for the BMBF project 13N13250. [18] “Escodegen:Ecmascriptcodegeneratorfrommozilla’sparserapiast.”
[Online].Available:https://github.com/estools/escodegen
REFERENCES [19] “Esprima:Ecmascriptparsinginfrastructureformultipurposeanalysis.”
[Online].Available:http://esprima.org/
[1] J.Ansel,P.Marchenko,U´.Erlingsson,E.Taylor,B.Chen,D.L.Schuff,
[20] “Estraverse: Ecmascript traversal functions from esmangle project.”
D.Sehr,C.L.Biffle,andB.Yee,“Language-independentsandboxing
[Online].Available:https://github.com/estools/estraverse
of just-in-time compilation and self-modifying code,” ACM SIGPLAN
Notices,vol.46,no.6,pp.355–366,2011. [21] “Forcepoint.” [Online]. Available: https://www.websense.com/content/
support/library/web/v81/wcg\ help/ssl\ enable.aspx
[2] M.Athanasakis,E.Athanasopoulos,M.Polychronakis,G.Portokalidis,
andS.Ioannidis,“TheDevilisintheConstants:BypassingDefensesin [22] “Forefront threat management gateway.” [Online]. Available: https:
BrowserJITEngines,”inProceedingsoftheNetworkandDistributed //technet.microsoft.com/en-us/library/dd441073.aspx
SystemSecurity(NDSS)Symposium,February2015. [23] “Fortigate.” [Online]. Available: http://cookbook.fortinet.com/
[3] M. Backes, T. Holz, B. Kollenda, P. Koppe, S. Nu¨rnberger, and why-you-should-use-ssl-inspection/
J. Pewny, “You Can Run but You Can’T Read: Preventing Disclosure [24] J. Gionta, W. Enck, and P. Ning, “Hidem: Protecting the contents
Exploits in Executable Code,” in Proceedings of the 2014 ACM of userspace memory in the face of disclosure vulnerabilities,” in
SIGSAC Conference on Computer and Communications Security, ser. Proceedings of the 5th ACM Conference on Data and Application
CCS ’14. New York, NY, USA: ACM, 2014, pp. 1342–1353. Security and Privacy, ser. CODASPY ’15. New York, NY, USA:
[Online].Available:http://doi.acm.org/10.1145/2660267.2660378 ACM, 2015, pp. 325–336. [Online]. Available: http://doi.acm.org/10.
[4] “Baracuda networks.” [Online]. Available: https://campus.barracuda. 1145/2699026.2699107
com/product/websecuritygateway/article/BWF/UsingSSLInspection/ [25] E. Goktas, E. Athanasopoulos, H. Bos, and G. Portokalidis, “Out of
[5] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazie`res, and D. Boneh, control: Overcoming control-flow integrity,” in Security and Privacy
“Hacking Blind,” in Proceedings of the 2014 IEEE Symposium on (SP),2014IEEESymposiumon. IEEE,2014,pp.575–589.
Security and Privacy, ser. SP ’14, Washington, DC, USA, 2014, pp. [26] C. Grier, L. Ballard, J. Caballero, N. Chachra, C. J. Dietrich,
227–242. K. Levchenko, P. Mavrommatis, D. McCoy, A. Nappa, A. Pitsillidis,
[6] D. Blazakis, “Interpreter Exploitation,” in Proceedings of the 4th N. Provos, M. Z. Rafique, M. A. Rajab, C. Rossow, K. Thomas,
USENIXConferenceonOffensiveTechnologies,ser.WOOT’10,2010. V.Paxson,S.Savage,andG.M.Voelker,“Manufacturingcompromise:
The emergence of exploit-as-a-service,” in Proceedings of the 2012
[7] “Blue coat.” [Online]. Available: https://www.bluecoat.com/
ACM Conference on Computer and Communications Security, ser.
products-and-solutions/ssl-visibility-appliance
CCS’12. NewYork,NY,USA:ACM,2012,pp.821–832.[Online].
[8] K. Braden, S. Crane, L. Davi, M. Franz, P. Larsen, C. Liebchen, Available:http://doi.acm.org/10.1145/2382196.2382283
andA.-R.Sadeghi,“Leakage-resilientlayoutrandomizationformobile
[27] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson,
devices,” in 23rd Annual Network & Distributed System Security
“ILR: Where’D My Gadgets Go?” in Proceedings of the 2012 IEEE
Symposium(NDSS),Feb.2016.
Symposium on Security and Privacy, ser. SP ’12, Washington, DC,
[9] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, USA, 2012, pp. 571–585. [Online]. Available: http://dx.doi.org/10.
and M. Winandy, “Return-oriented Programming Without Returns,” 1109/SP.2012.39
in Proceedings of the 17th ACM Conference on Computer and
[28] C.Holler,K.Herzig,andA.Zeller,“Fuzzingwithcodefragments,”in
CommunicationsSecurity,ser.CCS’10. NewYork,NY,USA:ACM,
Proceedings of the 21st USENIX Conference on Security Symposium,
2010, pp. 559–572. [Online]. Available: http://doi.acm.org/10.1145/
Berkeley,CA,USA,2012.
1866307.1866370
[29] A.Homescu,S.Brunthaler,P.Larsen,andM.Franz,“Librando:Trans-
[10] P. Chen, Y. Fang, B. Mao, and L. Xie, “JITDefender: A Defense
parentCodeRandomizationforJust-in-timeCompilers,”inProceedings
against JIT Spraying Attacks,” in Future Challenges in Security and
ofthe2013ACMSIGSACconferenceonComputer&communications
PrivacyforAcademiaandIndustry,ser.IFIPAdvancesinInformation
security,ser.CCS’13,2013.
and Communication Technology, J. Camenisch, S. Fischer-Hbner,
Y. Murayama, A. Portmann, and C. Rieder, Eds. Springer Berlin [30] “Http mitm proxy.” [Online]. Available: https://github.com/joeferner/
Heidelberg, 2011, vol. 354, pp. 142–153. [Online]. Available: node-http-mitm-proxy
http://dx.doi.org/10.1007/978-3-642-21424-0\ 12 [31] a.huku,“ExploitingVLC.ACaseStudyonJemallocHeapOverflows.”
[11] P. Chen, R. Wu, and B. Mao, “JITSafe: a Framework against [Online].Available:http://www.phrack.org/issues/68/13.html
Just-in-timeSprayingAttacks,”IETInformationSecurity,vol.7,no.4, [32] “Javascript obfuscation.” [Online]. Available: http://patriciopalladino.
pp. 283–292, 2013. [Online]. Available: http://dx.doi.org/10.1049/ com/blog/2012/08/09/non-alphanumeric-javascript.html
iet-ifs.2012.0142 [33] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning, “Address Space
[12] S.Crane,C.Liebchen,A.Homescu,L.Davi,P.Larsen,A.-R.Sadeghi, LayoutPermutation(ASLP):TowardsFine-GrainedRandomizationof
S.Brunthaler,andM.Franz,“Readactor:PracticalCodeRandomization Commodity Software,” in Proceedings of the 22Nd Annual Computer
ResilienttoMemoryDisclosure,”in36thIEEESymposiumonSecurity Security Applications Conference, ser. ACSAC ’06, Washington, DC,
andPrivacy(Oakland),May2015. 2006.[Online].Available:http://dx.doi.org/10.1109/ACSAC.2006.9
14[34] P.Larsen,A.Homescu,S.Brunthaler,andM.Franz,“SoK:Automated [52] T.Wei,T.Wang,L.Duan,andJ.Luo,“INSeRT:ProtectDynamicCode
Software Diversity,” in Proceedings of the 2014 IEEE Symposium on Generation against Spraying,” in Information Science and Technology
Security and Privacy, ser. SP ’14, Washington, DC, USA, 2014, pp. (ICIST),2011InternationalConferenceon,March2011,pp.323–328.
276–291.[Online].Available:http://dx.doi.org/10.1109/SP.2014.25 [53] R. Wu, P. Chen, B. Mao, and L. Xie, “RIM: A Method to Defend
[35] K.Lu,S.Nrnberger,M.Backes,andW.Lee,“Howtomakeaslrwin from JIT Spraying Attack,” in Proceedings of the 2012 Seventh
theclonewars:Runtimere-randomization,”inNetworkandDistributed International Conference on Availability, Reliability and Security, ser.
System Security Symposium. Symposium on Network and Distributed ARES ’12, Washington, DC, USA, 2012, pp. 143–148. [Online].
SystemSecurity(NDSS),K.Lu,S.Nrnberger,M.Backes,andW.Lee, Available:http://dx.doi.org/10.1109/ARES.2012.11
Eds. InternetSociety,2015. [54] D.Yu,A.Chander,N.Islam,andI.Serikov,“Javascriptinstrumentation
[36] G. Maisuradze, M. Backes, and C. Rossow, “What cannot be read, forbrowsersecurity,”inACMSIGPLANNotices,vol.42,no.1. ACM,
cannot be leveraged? revisiting assumptions of jit-rop defenses,” in 2007,pp.237–249.
25thUSENIXSecuritySymposium(USENIXSecurity16). Austin,TX: [55] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
USENIX Association, Aug. 2016, pp. 139–156. [Online]. Available: D.Song,andW.Zou,“Practicalcontrolflowintegrityandrandomiza-
https://www.usenix.org/conference/usenixsecurity16/technical-sessions/ tionforbinaryexecutables,”inSecurityandPrivacy(SP),2013IEEE
presentation/maisuradze Symposiumon. IEEE,2013,pp.559–573.
[37] V. Mohan, P. Larsen, S. Brunthaler, K. W. Hamlen, and M. Franz, [56] M. Zhang and R. Sekar, “Control flow integrity for cots binaries.” in
“Opaquecontrol-flowintegrity.”inNDSS,2015. UsenixSecurity,vol.13,2013.
[38] Nergal.TheAdvancedReturn-into-lib(c)Exploits.[Online].Available: [57] “Zscaler.” [Online]. Available: https://www.zscaler.com/products/
http://phrack.org/issues/58/4.html ssl-inspection
[39] “Node.js:Ajavascriptruntimebuiltonchrome’sv8javascriptengine.”
[Online].Available:https://nodejs.org/
[40] “Octane: The javascript benchmark suite for the modern web.”
[Online].Available:https://developers.google.com/octane/
[41] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda,
“G-Free: Defeating Return-oriented Programming Through Gadget-
less Binaries,” in Proceedings of the 26th Annual Computer
Security Applications Conference, ser. ACSAC ’10. New York,
NY, USA: ACM, 2010, pp. 49–58. [Online]. Available: http:
//doi.acm.org/10.1145/1920261.1920269
[42] “Palo alto networks.” [Online]. Available: https://www.
paloaltonetworks.com/documentation/60/pan-os/pan-os/decryption
[43] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing
the Gadgets: Hindering Return-Oriented Programming Using In-place
Code Randomization,” in Proceedings of the 2012 IEEE Symposium
on Security and Privacy, ser. SP ’12, Washington, DC, USA, 2012.
[Online].Available:http://dx.doi.org/10.1109/SP.2012.41
[44] C. Reis, J. Dunagan, H. J. Wang, O. Dubrovsky, and S. Esmeir,
“Browsershield: Vulnerability-driven filtering of dynamic html,” ACM
TransactionsontheWeb(TWEB),vol.1,no.3,p.11,2007.
[45] J. Ruderman, “Introducing jsfunfuzz.” [Online]. Available: http:
//www.squarefree.com/2007/08/02/introducing-jsfunfuzz/
[46] E.J.Schwartz,T.Avgerinos,andD.Brumley,“Q:ExploitHardening
Made Easy,” in Proceedings of the 20th USENIX Conference on
Security, ser. SEC’11. Berkeley, CA, USA: USENIX Association,
2011, pp. 25–25. [Online]. Available: http://dl.acm.org/citation.cfm?
id=2028067.2028092
[47] H. Shacham, “The Geometry of Innocent Flesh on the Bone: Return-
into-libc Without Function Calls (on the x86),” in Proceedings of the
14th ACM Conference on Computer and Communications Security,
ser. CCS ’07. New York, NY, USA: ACM, 2007, pp. 552–561.
[Online].Available:http://doi.acm.org/10.1145/1315245.1315313
[48] H.Shacham,M.Page,B.Pfaff,E.-J.Goh,N.Modadugu,andD.Boneh,
“OntheEffectivenessofAddress-spaceRandomization,”inProceedings
of the 11th ACM Conference on Computer and Communications
Security,ser.CCS’04. NewYork,NY,USA:ACM,2004,pp.298–
307.[Online].Available:http://doi.acm.org/10.1145/1030083.1030124
[49] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and
A.-R. Sadeghi, “Just-In-Time Code Reuse: On the Effectiveness of
Fine-Grained Address Space Layout Randomization,” in Proceedings
of the 2013 IEEE Symposium on Security and Privacy, ser. SP
’13, Washington, DC, USA, 2013, pp. 574–588. [Online]. Available:
http://dx.doi.org/10.1109/SP.2013.45
[50] P. Team, “Address Space Layout Randomization (ASLR).” [Online].
Available:http://pax.grsecurity.net/docs/aslr.txt
[51] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary
Stirring: Self-randomizing Instruction Addresses of Legacy x86
Binary Code,” in Proceedings of the 2012 ACM Conference on
Computer and Communications Security, ser. CCS ’12. New
York, NY, USA: ACM, 2012, pp. 157–168. [Online]. Available:
http://doi.acm.org/10.1145/2382196.2382216
15