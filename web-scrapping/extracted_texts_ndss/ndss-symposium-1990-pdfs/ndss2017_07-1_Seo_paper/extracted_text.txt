SGX-Shield: Enabling Address Space Layout
Randomization for SGX Programs
Jaebaek Seo∗§ , Byounyoung Lee†§, Seongmin Kim∗, Ming-Wei Shih‡,
Insik Shin∗, Dongsu Han∗, Taesoo Kim‡
∗KAIST †Purdue University ‡Georgia Institute of Technology
{jaebaek, dallas1004, ishin, dongsu_han}@kaist.ac.kr, blee@purdue.edu, {mingwei.shih, taesoo}@gatech.edu
Abstract—TraditionalexecutionenvironmentsdeployAddress system and hypervisor. It also offers hardware-based measure-
Space Layout Randomization (ASLR) to defend against memory ment, attestation, and enclave page access control to verify the
corruption attacks. However, Intel Software Guard Extension integrity of its application code.
(SGX), a new trusted execution environment designed to serve
security-criticalapplicationsonthecloud,lackssuchaneffective, Unfortunately, we observe that two properties, namely,
well-studiedfeature.Infact,wefindthatapplyingASLRtoSGX confidentiality and integrity, do not guarantee the actual
programs raises non-trivial issues beyond simple engineering for security of SGX programs, especially when traditional memory
a number of reasons: 1) SGX is designed to defeat a stronger
corruption vulnerabilities, such as buffer overflow, exist inside
adversarythanthetraditionalmodel,whichrequirestheaddress
SGX programs. Worse yet, many existing SGX-based systems
spacelayouttobehiddenfromthekernel;2)thelimitedmemory
tend to have a large code base: an entire operating system as
uses in SGX programs present a new challenge in providing a
library in Haven [12] and a default runtime library in SDKs
sufficient degree of entropy; 3) remote attestation conflicts with
the dynamic relocation required for ASLR; and 4) the SGX for Intel SGX [28, 29]. Further, they are mostly written in
specification relies on known and fixed addresses for key data unsafe programming languages (e.g., C and C++) or often
structures that cannot be randomized. in an assembly language to provide direct compatibility with
the Intel SGX hardware and to support its instruction sets.
This paper presents SGX-Shield, a new ASLR scheme de-
Running such a large code base inside an enclave altogether
signed for SGX environments. SGX-Shield is built on a secure
simply makes SGX programs vulnerable to traditional memory
in-enclave loader to secretly bootstrap the memory space layout
corruptionattacks,facingthesamesecuritychallengesastypical
with a finer-grained randomization. To be compatible with SGX
hardware (e.g., remote attestation, fixed addresses), SGX-Shield computer environments. This not only nullifies the security
is designed with a software-based data execution protection guarantee that SGX claims to provide, but also, perhaps more
mechanism through an LLVM-based compiler. We implement critically,allowsattackerstoexploitisolationandconfidentiality
SGX-ShieldandthoroughlyevaluateitonrealSGXhardware.It to lurk—there is no way to know what the compromised
showsahighdegreeofrandomnessinmemorylayoutsandstops enclave runs, and even worse, no way to analyze or monitor
memory corruption attacks with a high probability. SGX-Shield its execution behavior. For example, by exploiting a stack
shows 7.61% performance overhead in running common micro-
overflow vulnerability in a trusted web server or database
benchmarks and 2.25% overhead in running a more realistic
server running in an enclave, an adversarial client can launch
workload of an HTTPS server.
traditional return-oriented-programming (ROP) attacks [42, 49]
to disclose security-sensitive data in an enclave, which violates
I. INTRODUCTION the confidentiality guarantee of SGX, yet avoiding any runtime
analysis or monitoring thanks to its isolation guarantee.
Hardware-basedsecuritysolutions,suchastrustedexecution
environments, are gaining popularity in today’s market. Intel To defeat such attacks in modern computing systems, many
SGXisoneofsuchmechanismsreadilyavailableincommodity modern defense mechanisms (e.g., stack canary [20], DEP
Intel CPUs since the Skylake microarchitecture. It guarantees [40], CFI [7], etc) have been proposed, implemented, and
confidentiality and integrity of applications, even if their deployed recently to significantly raise the bar for exploitation
underlying components are compromised. More specifically, in practice. Address space layout randomization (ASLR) is
SGXprovidesanisolatedexecutionthatprotectsanapplication one of the most comprehensive, yet solid defense schemes
running inside a secure container, called an enclave, against proven to be effective in the field. In particular, when properly
potentially malicious system software, including the operating implemented, ASLR can provide a statistical guarantee of
preventing all attackers’ attempts. Since ASLR hides the
§ThisworkisdonewhiletheseauthorswerevisitingandPh.D.studentsin memorylayoutsfromadversariesbyrandomlyplacingcodeand
GeorgiaInstituteofTechnology. datainruntime,itforcestheattackerstoguesswherethevictim
code or data is located in order to launch control-flow hijack
or data-flow manipulation attacks. This probabilistic defense
Permission to freely reproduce all or part of this paper for noncommercial
mechanism has demonstrated its effectiveness in thwarting
purposes is granted provided that copies bear this notice and the full citation
on the first p age. R eproduction f or c ommercial p urposes i s s trictly prohibited countlessexploitationattempts,andnowitisade-factosecurity
without the prior written consent of the Internet Society, the first-named author solutionintoday’smodernoperatingsystems,includingmobile
(for reproduction of an entire paper only), and the author’s employer if the and server environments.
paper was prepared within the scope of employment.
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
For this reason, Intel also acknowledges the need for
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23037 ASLR in the SGX environment and includes a simple ASLRscheme for SGX in Intel SGX SDKs for Linux and Windows. Privilege Type Instruction Description
However, we find that Intel’s ASLR design has several critical
ring-0 EXE ECREATE Createanenclave
limitationsthatinvalidatethesecurityguaranteesofASLR(e.g., ring-0 MEM EADD AllocateanEPCpagetoanenclave
a whole memory layout is completely known to an adversary, ring-0 MEM EEXTEND Measure512bytesofanEPCpage
the malicious operating system). We emphasize that these ring-0 EXE EINIT Finalizetheenclaveinitialization
ring-3 EXE EENTER Entertoanenclave
limitations are not implementation issues that can be fixed
ring-3 EXE EEXIT Exitfromanenclave
easily, but originate from fundamental design challenges that
result in conflicts between SGX and ASLR. TABLE I: Intel SGX instructions. MEM: Memory management
related; EXE: Enclave execution related.
This paper uncovers four key challenges in securely deploy-
ing ASLR for SGX:
• New challenges. We identify fundamental challenges in
• The strong, unique attack model of SGX exposes the enabling ASLR for the SGX environment. In particular,
enclave memory layout to untrusted system software, we launch ROP attacks to test the effectiveness of the
leaving SGX programs completely unprotected by ASLR. current ASLR implementation in Linux and Windows
By design, SGX delegates page mapping managements to SDKsforIntelSGXandfindthattheASLRiscompletely
untrusted system software, and thus leaks the information ineffective against strong attackers (e.g., untrusted kernel).
of virtual memory mapping to the underlying software.
• Defense scheme. We implement SGX-Shield, a new
Note that this was never a security issue in non-SGX
ASLR implementation for SGX programs that overcomes
computingenvironmentswherethesystemsoftwarealways
the fundamental challenges facing the SGX environment.
serves as the trust computing base of user processes.
SGX-Shield supports both Linux and Windows environ-
• SGX provides the limited memory to an enclave; typically ments, and it incorporates a secure in-enclave loader,
64MB or 128MB in total can be supported [29]. Thus, software DEP, and software fault isolation all together
ASLR for SGX cannot fully utilize virtual address space, to provide truly secure ASLR in the SGX environment.
significantly limiting the degree of randomness and the
• Evaluation. We provide a thorough analysis on
security of ASLR.
SGX-Shield; not only do we conduct performance bench-
• ASLR requires a dynamic relocation scheme that updates marksontherealIntelSGXhardware,butalsoweprovide
relative addresses in the code and data section, which the security analysis on our approach.
conflict with the attestation process of SGX; specifically,
SGXfinalizestheintegritymeasurementbeforeanenclave The rest of this paper is organized as follows. §II pro-
execution starts, but the relocation for ASLR must be vides background information on Intel SGX and ASLR. §III
performed afterwards. This inherent design disagreement elaborates fundamental challenges in deploying ASLR for
results in writable code pages, nullifying another funda- the SGX environment. §IV presents a design of SGX-Shield.
mental hardening technique, executable space protection. §V describes implementation details of SGX-Shield, and §VI
evaluates security effectiveness and performance overheads of
• The SGX specification forces the use of a fixed address
SGX-Shield. §VII discusses impacts of controlled side-channel
for some security-critical data in an enclave. For security
attacks against SGX-Shield. §VIII describes related work of
reasons, SGX makes several data structures within an
SGX-Shield, and §IX concludes the paper.
enclave immutable, exposing such data structures abused
for bypassing ASLR.
II. BACKGROUND
To address these issues, this paper proposes SGX-Shield,
a new ASLR scheme for SGX programs. It introduces the Intel SGX. Intel SGX is an extension of the x86 instruction
concept of a multistage loader, which pushes back all ASLR- set architecture [39] that allows a user process to instantiate
related operations to its secure in-enclave loader, hiding all a protected memory region, called an enclave, inside its own
security-sensitiveoperationsfromadversaries.Tomaximizethe addressspace.SGXpreventssystemcomponents,includingthe
degreeofrandomnessofmemorylayouts,SGX-Shieldemploys privileged software (e.g., kernel), from accessing the enclave,
fine-grained randomization by splitting the code into a set of which guarantees integrity and confidentiality of the enclave.
randomization units. SGX-Shield also enforces a software data In this subsection, we summarize the enclave setup and the
executionprotection(DEP)toguaranteeW⊕X(i.e.,WriteXOR interactionbetweenanenclaveanditshostprogram.Therelated
Execute) in enclave’s code pages and isolates security-sensitive SGX instructions are described in Table I.
data structures from adversaries.
Enclave initialization: Since instructions for the enclave
We have implemented a prototype of SGX-Shield on Intel initialization must be executed in the ring-0 mode, the kernel
SGX running on both Linux and Windows and evaluated its (i.e., SGX device driver) helps a user process initialize the
security properties and performance overhead. We also verify enclave. The enclave initialization can be categorized into
that the SGX programs protected with SGX-Shield have a the following four procedures: creation, memory allocation,
high degree of entropy to thwart memory corruption attacks measurement, and finalizing the initialization: (1) ECREATE
insidetheSGXenvironment,yetwithareasonableperformance creates an enclave within the address space of a user process.
overheads: 7.61% on average in the micro-benchmark and ECREATE requires a public key and the signature of the enclave
2.25% in the macro-benchmark. program as a parameter; (2) EADD allocates an Enclave Page
Cache (EPC), a physical memory to be used for an enclave,
Tosummarize,thispapermakesthefollowingcontributions: and then copies specified memory pages in the host process
2to the EPC. The size of the total physical EPC memory is Untrusted kernel Enclave
predetermined by the BIOS, and the default size is less than
128MB.(3)EEXTENDmeasurestheSHA-256digestof512bytes
of an EPC. Multiple EEXTEND can be invoked to measure more Code C3.
RWX
EPCmemorypagesaswell.(4)EINITfinalizestheinitialization, C1.
which lets the CPU verify the integrity of the enclave program Page Table
using the measurement result and the pair of the public key C4. SSA Fr ame RW
and signature provided in ECREATE. After EINIT, no EPC page
can be added to the enclave and the permissions of EPC pages User process
cannot be changed1.
While this enclave initialization process indeed guarantees C2. EPC pages
the integrity of an enclave program, the initial contents of an < 128MB
enclave program are completely visible to system components Enclave Program RAM ST Gr Xus Cte Pd U
(i.e., the kernel). It is worth noting that the notion of confiden-
Fig.1:Aworkflowofrunningprograms(e.g.,executableELFandPE
tiality in SGX is limited only to the runtime memory contents files) within a SGX enclave. We identify four fundamental challenges
after the enclave initialization. in securely performing ASLR in this procedural (i.e., marked from
C1 to C4).
Host-enclaveinteraction:BythedesignofSGX,anenclave
cannot directly invoke system calls in the OS. Instead, using
EENTER and EEXIT, each of which allows entrance or exit which are not valid in an SGX environment. The strong and
between an enclave and host execution contexts, the enclave uniqueattackmodelofSGXexposestheprocessmemorylayout
can indirectly invoke system calls. Moreover, because EEXIT tountrustedsystemsoftware,leavingSGXprogramsvulnerable
allows the enclave to jump into any location of the host, these to traditional exploitation techniques. In initializing enclaves,
two instructions are also used to call the host function from the untrusted kernel should coordinate the launching procedure
the enclave. to allocate and manage system resources, such as EPC pages.
From a security standpoint, this initialization procedure relying
EENTER needs a Thread Control Structure (TCS) to specify
on an untrusted party seriously weakens the security of ASLR,
theentrypointofanenclaveexecution.ATCSisaspecialEPC,
as page allocations and its virtual address mapping for an
added by EADD with a TCS flag that contains information for a
enclave are all visible and thus known to attackers.
thread execution, such as the entry point, the base addresses
of FS/GS segments, the offset of a State Save Area (SSA), etc. Specifically, in order to map a physical address of the EPC
An SSA is a buffer used to save the context of a thread (e.g., region to a virtual address, SGX requires the untrusted kernel’s
values of registers) when an interrupt occurs. Since TCS is collaboration —the kernel executes EADD, a privileged SGX
critical for the security of enclave programs, SGX prohibits an instruction, with the information on both physical and virtual
explicit access to the TCS after initialization. We explain the addressestobemapped.Thisdesigndecisionisunavoidableand
security implication of SSA and TCS in §III. rathernatural,asthekernelshouldbeinvolvedinevictingsome
EPC pages to non-EPC pages if EPC pages are oversubscribed.
ASLR. Address space layout randomization (ASLR) is a
powerfulmemory-protectiontechnique,primarilyusedtoguard However, this results in critical security issues from the
against memory corruption attacks. Without ASLR, memory ASLR perspective—the untrusted kernel always knows about
corruption vulnerabilities (e.g., buffer overflow) can easily be the complete memory layout of an enclave application. More-
exploited by attackers to hijack control-flows or manipulate over, the base address and the size of an enclave are given to
data-flows and execute malicious code. By randomizing the ECREATE as parameters when creating the enclave. Using the
memory layout (e.g., location of executables and data), ASLR base address and the memory layout, the kernel can calculate
makes it hard for attackers to exploit the vulnerabilities the exact location of the memory object that does not move
becausecontrol-flowhijackingormanipulatingin-memorydata during the runtime (e.g., code objects).
requiresunderstandingtheprocessmemorylayout.Thus,ASLR
provides probabilistic defense. In particular, with ASLR, the This problem is more critical in another popular usage of
operating system randomly places code and data at load time, SGX: hostile cloud environment where people use SGX to
making it difficult for attackers to infer the location of code securely offload the computation. The current design of Intel
and data, which forces attackers to rely on bruteforce attacks SGX always exposes the memory layouts of enclave programs
on memory layouts. to adversaries, such as cloud providers, where they have full
control of underlying software stacks including the kernel,
III. TECHNICALCHALLENGES firmware, and all the way down to the SMM program. Under
such a strong adversarial model, the greatest care should be
In this section, we articulate the technical challenges in taken to design a secure ASLR scheme for SGX. In §VI, we
designing ASLR on an SGX environment (Figure 1). demonstrate that the kernel can succeed in an ROP attack
against a vulnerable enclave program with only a single trial
C1.Strongadversary. TypicalASLRmechanismsarebuilton
in the current Intel SGX SDKs.
top of an assumption: memory layout is hidden from attackers,
C2. Limited memory space. The entropy of the ASLR
1 InSGXversion2,thereareinstructionstoaddEPCpagesandchange
implementation is inherently limited by the SGX design; SGX
permissionsofEPCpagesattheruntime.Atthetimeofwritingthispaper,
therearenoavailablehardwaresupportingSGXversion2. has not only a limited memory space overall (i.e., 128MB
3EPC [29]), but also the allocated physical memory per enclave The TCS is initialized and loaded by the kernel through an
is very limited (i.e., an order of 10MB in typical usages). In EADD instruction and contains information for executing an
these situations, an attacker can easily bruteforce the entire SGX program, such as the entry point of the enclave, the base
search space to bypass ASLR, as long as they can freely addresses of FS/GS segments, the offset of SSA, etc. Since
try to mount an exploitation. As such, this limited memory TCS is critical for the security of enclave programs, SGX
space would significantly reduce the entropy (i.e., the amount prohibitsanexplicitaccesstotheTCSafterinitialization.After
of randomness) in enclave programs, compared to what we initialization, some fields of the TCS might be updated by the
typicallyexpectinanon-SGXenvironment:forexample,ASLR CPU during execution (e.g., saving the execution context to
in x86_64 can utilize the full virtual address space per process the SSA frame in Asynchronous Enclave Exit), and the fields
(i.e., 48-bit). To address this issue, SGX-Shield takes a fine- specifying the location of SSA (i.e., OSSA) cannot be updated.
grained randomization approach to maximize the randomness In other words, the virtual address of SSA is always known
of memory layouts. to the untrusted kernel, and the location of SSA cannot be
randomized after initialization.
C3. Writable code pages. Dynamic relocation for ASLR
makes it difficult to utilize a powerful, comprehensive defense This leaves potential opportunities for abuse. Let’s assume
mechanism against control-hijacking attacks: the No-eXecute two threads T1 and T2 are running concurrently in an enclave.
(NX) bit [41], which exclusively grants either an executable or When T1 temporarily exits an enclave due to an interrupt, its
writablepermissiontoindividualmemorypages.Thisfeatureis executioncontext,includingallregisterandvalues,issavedinto
effective in preventing code-injection attacks because attackers the SSA. Then, using T2, an attacker can mount an arbitrary
cannot directly jump to execute (i.e., executable) the injected memory write to overwrite the field for the instruction pointer
code (i.e., writable). in the SSA frame, thereby hijacking control of the T1 thread.
Similarly, with an arbitrary memory read, attackers can infer
However, there are some situations where both executable
the complete address space layout by following the pointers
andwritableflagsneedtobesetatthesametime.Just-In-Time
and instructions from the initial information found in the SSA
(JIT) compilation is a notable exception, as it first writes the
frame, similar to just-in-time code reuse [57]. In SGX-Shield,
compiledcodetothememoryandexecutesafterthat.Atypical
weisolateallmemoryaccessestotheknownyetsecurity-critical
way to handle this situation is to disable the NX bit for the
data structures in an SGX program.
corresponding memory pages, which are the apparent target
for attackers to place the malicious code.
ThekeyfeatureofSGX,integritychecking(attestation),has
a similar problem; it first has to load the code (i.e., writable) IV. DESIGN
and then execute after the measure (i.e., executable). For this
reason, the integrity measurement for SGX is only valid for Inthissection,wepresentthedesignofSGX-Shield,which
fixed code and data pages, and it cannot be easily extended to fortifies the security aspect of the ASLR scheme in an SGX
support the dynamically changing pages. Specifically, before environment.Inparticular,weaddressallchallengeshighlighted
launchinganenclave(i.e.,EENTER),theintegritymeasurement in §III.
should be finalized and cannot be changed after that. However,
implementingASLRforanenclaveprograminherentlyrequires • C1: Strong adversaries. SGX-Shield introduces the
changing the permission bit (from writable to non-writable) of concept of a multistage loader, which can hide ASLR-
codepagesaftertheinitialmeasurement,inparticular,thecode related security decisions and operations from adversaries
sectionsthatneedtoberelocated.Unfortunately,SGXprohibits (§IV-B).
changing a permission bit after the initial measurement [30].
• C2: Limited memory. SGX-Shield employs a form of
Therefore, code pages have to be both writable and executable
fine-grained randomization that is tailored to maximize its
toperformaproperrelocationforASLRafterthemeasurement:
entropy on the SGX environment (§IV-C).
the relocation takes place within an enclave after EINIT.
We confirm that some Windows enclave programs requiring • C3: Writable code pages. SGX-Shield implements a
dynamic relocation contain writable and executable pages. In softwareDEPtoenforceW⊕Xinanenclave’scodepages
fact, Intel already acknowledged this issue [27] and further (§IV-D).
recommended that the enclave code contain no relocation (i.e.,
• C4: Known address space. SGX-Shield incorporates
no code randomization after the initialization) to enable the
coarse-grained software-fault isolation (SFI) to protect
NX feature. To properly guarantee the security of ASLR in
fixed, security-sensitive data structures from arbitrary
SGX programs, we need to carefully rethink the design criteria
memory reads and writes (§IV-E).
that are compliant with the SGX environment.
C4. Known, fixed addresses. Worseyet,somedatastructures For the rest of this section, we start by describing our
in SGX do not allow relocation at all. For example, the State threat model (§IV-A), and then explain techniques to overcome
Save Area (SSA) frame in SGX does not allow relocation to each challenge in the following subsections: §IV-B shows
arbitrary memory addresses; the SSA frame is dedicated to our multistage loader; §IV-C describes the fine-grained ASLR
storing the execution context when handling interrupts in SGX. scheme for SGX; §IV-D explains software DEP; and §IV-E
More precisely, the address of SSA Frame is determined by shows our SFI scheme designed for SGX programs. In §IV-F,
an OSSA field, the offset from the base address of an enclave we introduce performance optimization techniques that we
to SSA, embedded in the Thread Control Structure (TCS). adopt.
4Multistage loading (§IV-B)
Enclave Enclave
3. Secure
in-enclave
1. Preparation
Secure in-enclave loading Secure lo i an d- ee rn clave
loader
SGX-Shield’s
Compile toolchains 2. Bootstrapping
Software-DEP
(LLVM, static linker) Fine-grained (§IV-D)
Secure in-enclave SGX-Shield supports ASLR
loader both Linux and Windows (§IV-C)
Source
cS oo Sdu eor uc re c e Target SGX Program
co cd oe d e Code pages (RWX) Code pages (X)
SFI (§IV-E)
SSA, TCS, Guard
No permission
r15
(NRW boundary)
Runtime Data
Data pages (RW) Data pages (RW)
User process User process
Fig. 2: Overall workflow of SGX-Shield: 1) the preparation phase builds a SGX binary from the target program’s source code; 2) the
bootstrappingphaseloadsthesecurein-enclaveloaderintocodepagesandthetargetSGXprogramintodatapages;and3)thesecurein-enclave
loading phase finally loads the target SGX program.
A. Threat Model visible to the non-trusted party in this phase, it is designed to
makeasminimaldecisionsonresourceprovisioningaspossible
SGX-Shield assumes the same attack model as SGX, as
anddeferallsecurity-sensitivedecisionstothesecurein-enclave
our ASLR scheme is designed for SGX programs. Specifically,
loader. This phase allocates two types of enclave data pages
we assume that only the CPU package with SGX support is
with read and write permissions and code pages with read,
trusted and all other hardware components are not. A user
write, and execute permissions. The read/write permissions
runs his or her own target program within an enclave, and all
granted to code pages enable the secure in-enclave loader
other components in the software stack are not trusted (i.e.,
to write the target SGX program into an enclave memory
other processes, an operating system, and a hypervisor). Our
(performing the relocation as well) and then execute it. While
attack model consideration focuses on an attacker who wishes
this design decision facilitates multistage loading, it ends up
to exploit a vulnerability, a memory corruption vulnerability in
having both writable and executable memory pages, similar to
particular, in the target program running in the enclave. While
the challenge C3 (§III). To address this issue, §IV-D presents
completely addressing side-channel issues is not the primary
how SGX-Shield removes read and write permissions from
goal of this paper, SGX-Shield provides a barrier to guess the
these pages using a software-level enforcement.
memory layout of an enclave against the attack based on the
page fault side-channel (i.e., controlled side-channel) [61]. We Finally, the secure in-enclave loader loads the target SGX
discuss the effectiveness of SGX-Shield against the controlled program into the memory space from its data pages. The
side-channel attacks in §VI-A1 and §VII. secure in-enclave loader randomly picks the base address using
the RDRAND instruction, which relies on the non-deterministic
on-processor entropy. Then, it loads each section of the
B. Multistage Loader
target program, where the address of each section is further
To prevent the untrusted kernel from learning the memory adjusted independently at random. Before finishing the loading,
layoutofanenclave,SGX-ShieldperformsallASLRoperations SGX-Shieldresolvesallrelocationinformation,whichincludes
within the enclave, taking advantage of its isolated execution. global variables, static variables, and the destination of all
SGX-Shield consists of three phases, as shown in Figure 2: branches. As a last step, SGX-Shield wipes out the secure
preparation, bootstrapping, and secure in-enclave loading. in-enclave loader from the memory space, and then jumps to
the entry point of the target SGX program to hand over the
First, the preparation phase builds the target SGX program
execution.
that a user wants to deploy. This built executable contains a
secure in-enclave loader in its code section and the target SGX Because the target program is loaded within an enclave by
program in its data section, where the secure in-enclave loader the secure in-enclave loader, SGX-Shield completely hides the
will load the target SGX program later. This phase can be address space layout information from the untrusted kernel.
carried out anytime before deployment and does not have to The random value is directly obtained from the CPU, and all
be performed on the same SGX machine in which the target the following computations and decisions for ASLR of the
program will be run. target program are performed inside the enclave.
Second, in the bootstrapping phase, SGX-Shield performs Itisworthnotingthatourmultistageloadingschemeisfully
the first part of multistage loading. The primary role of the compatible with SGX’s attestation scheme. At the moment a
bootstrapping phase is to create an enclave and initialize the measurementforanenclaveisfinalizedbyanEINITinstruction
secure in-enclave loader with the help of the untrusted kernel. (i.e., between the bootstrapping and secure in-enclave loading
Because the memory layout of an enclave is assumed to be phase), all required resources for SGX-Shield are finalized
53. Secure in-enclave
loading
…
jg A*
jmp C*
fi
esle
2. Bootstrapping
RU A
RU B fi
esle
RU C
…
1. Preparation
jg A
fi
esle
…
jg A
jmp C
…
RU C
RU A RU A
RU A
RU B RU B
jg A
jmp C
RU C RU C
RU B
Fig. 3: Fine-grained ASLR scheme based on a randomization unit. jg A∗ and jmp c∗ represent the relocated instructions of jg A and jmp C,
respectively.Thepreparationphaseinstrumentsanunconditionalbranch(i.e.,jmp C)nexttoaconditionalbranch(i.e.,jg A).Asaresult,during
a secure in-enclave loading phase, the following unit (i.e., RU C) can be randomly placed independently to the location of the instrumented unit
(i.e., RU B) by resolving relocation.
and fully measured. Thus, from the perspective of performing ASLR at the cost of more frequent branching and decreased
attestation,SGX-ShieldisthesameastypicalSGXprograms— spatial locality. We evaluate this trade-off in §VI.
SGX-Shield simply runs code, the secure in-enclave loader,
with data, the target SGX program. Specifically, all memory Stage 1: Bootstrapping. We let the loading scheme in the
pages for SGX-Shield including the secure in-enclave loader bootstrapping phase over-estimate the memory space required
in code pages and the target SGX program in data pages are to load the target program, as this size is directly related to
added to EPC pages and extended for measurement through the ASLR entropy. Strong adversaries, including the untrusted
EADD and EEXTEND, respectively. kernel, always know of ranges of truly active memory space.
Thus, unlike traditional ASLR settings where an attacker
needs to bruteforce the entire virtual address space, the strong
C. Fine-grained Randomization for Enclaves
adversary needs to bruteforce only a small space based on
SGX-Shield employs fine-grained randomization her/his prior-knowledge. To this end, we over-estimate both
schemes [13, 23, 24, 32, 45, 59] to maximize the ASLR code and data pages, where both are configured as 32 MB in
entropy. In the following, we describe how SGX-Shield is the current version of SGX-Shield.
designed to randomize the memory space layout across three
Stage 2: Secure in-enclave loading. Using the target SGX
phases.
program in data pages, the secure in-enclave loader starts to
Preparation. To enable fine-grained ASLR for code, placeeachrandomizationunitintopreviouslyallocatedmemory
SGX-Shield relocates code at smaller granularity, called a spaces.SGX-Shieldfullyutilizesover-estimatedmemoryspace,
randomization unit. Randomization units are of fixed size that reserved for loading the target program, to randomly scatter
can be configured. Our implementation supports 32- and 64- each randomization unit, which in turn maximizes the ASLR
byte units. SGX-Shield modifies commodity compilation and entropy. SGX-Shield randomizes all data objects as well,
linkage procedures because they support only simple module- which includes stack, heap, and global variables. Specifically,
level(i.e.,section-level)randomization.Duringthecompilation, SGX-Shield performs the following steps: (1) for a stack
SGX-Shield ensures that the terminating instructions of ran- area, SGX-Shield picks the random base address and reserves
domization units are not fall-through cases. This is because continuous memory space from this base; (2) for a heap area,
fall-through assumes that randomization units are placed it randomly picks k memory pools from the rest of the data
consecutively, which is not true when they are relocated for pages, where the size of each memory pool is configurable
ASLR. Thus, for each fall-through case, SGX-Shield appends (i.e., 1 MB in the current version of SGX-Shield); (3) global
an unconditional branch instruction that points to the entry and static variables are randomly placed into the rest of the
point of the next randomization unit (i.e., the randomization data pages.
unit pointed to by the fall-through case).
SinceSGX-Shieldrandomizesallcodeanddataobjects,all
For example, as shown in Figure 3, right after the condi- references to memory objects including the absolute address
tional branch instruction (i.e., jg A), an unconditional branch and the PC-relative address must be determined after placing
instruction (i.e., jmp C) is added, allowing RU C to be randomly them. The secure in-enclave loader conducts the relocation
relocated independently to the location of RU B. Note that this for all memory objects after loading them. For example, as
instrumentationpasscannotbedonenaivelyattheintermediate shown in Figure 3, instructions jg A and jmp C are relocated
language (IR) level. Even when IR does not have conditional to correctly point to the shuffled locations for randomization
branch instructions with fall-through features (e.g., LLVM IR), units A and B, respectively.
the compiler backend may automatically introduce this. For
Consideringcontrolledside-channelattacks[61],ourdesign
example, the Intel x86-64 architecture always uses fall-through
also randomizes control-flow dependencies upon data values
with conditional branch instructions.
during the secure in-enclave loading phase. More precisely, the
Finally, the size of the randomization unit introduces a secure in-enclave loader randomizes the order of loading and
trade-off between security and performance. When the size relocation so that simply observing memory access patterns at
of the randomization is small, there will be more candidate page granularity would not leak information on which data or
slots to place the randomization unit, increasing the entropy of code is being loaded or relocated. Actual runtime behaviors
6Before Secure in-enclave loading After Secure in-enclave loading
BASE (4KB aligned)
Secure in-enclave loader No Permission
User address space RWX
BASE + 0x40000
Target
SR Ges Xe r Pv re od
g
f ro ar
m Code
Fin (Ae §- ISg VLr -a CRin
)
ed Code
Only X Software-DEP
(§IV-D)
BASE (4KB aligned)
C3. RWX Code
BASE + 0x2000000 BASE + 0x2000000
Heap Target SGX
BASE + 0x2001000 Program
Guard BASE + 0x2400000
Enclave BASE + 0x2011000 TTCCSS * BASE + 0x2401000 Heap Secure
BASE + 0x2012000 Guard In-ecnlave
RW TLS
B BA AS SE E + + 0 0x x2 20 01 23 30 00 00 0 Guard Enclave BB AA SS EE ++ 00 xx 22 44 111 20 00 00 0 TTCCSS * Loading TTCCSS * No Permission Sof at (w §n Ida Vr S -e DF-D I , EP
C4. SSA Frame TLS §IV-E)
BASE + 0x2025000 BASE + 0x2413000
Guard RW Guard Multistage
BASE + 0x2035000 Stack BASE + 0x2423000 loading
BASE + 0x2045000 SSA Frame (§IV-B) SSA Frame
BASE + 0x2425000
Page Table RAM BASE + 0x2435000 Guard Guard r15
C1. untrusted kernel C2 <. E 12P 8C M p Bag es Stack SR taa cn k,d Ho em ap,i z Te Ld S , bo( uN nR dW ary R) W
Stack growth Global Variables
BASE + 0x4445000
(a)IntelSGXSDK (b)SGX-Shield
Fig. 4: Runtime memory layouts of an enclave under Intel SGX SDK and SGX-Shield. Both are taken by running Windows 10, but they are
similar to those for Linux. After going through secure in-enclave loading phase, SGX-Shield randomizes all code and data pages to maximize
the entropy aspects of ASLR as well as implementing software-DEP and SFI.
of the target program might be vulnerable, however, and we 1 ; Before enforcing non-writable code
2 mov [rdx+0x10], rax
describe and evaluate more details of this aspect in §VI-A1 3
and §VII. 4 ; After enforcing non-writable code
5 ; (r15 is initialized to hold the NRW boundary)
6 ; (enforce rdx >= r15)
D. Software DEP in Enclaves 7 lea r13, [rdx+0x10] ; r13 = rdx+0x10
8 sub r13, r15 ; r13 = r15 - r13
As noted in §IV-C, the multistage loading scheme of 9 mov r13d, r13d ; r13 = r13 & 0xffffffff
10 mov [r15 + r13], rax ; *(r15+r13) = rax
SGX-Shield leaves code pages both writable and executable.
In this subsection, we describe how SGX-Shield removes read Fig. 5: Instrumenting explicit memory access instructions to enforce
non-writable code. Since the instruction tries to write to where rdx
andwritepermissionsfromcodepagesbyusingsoftware-based
points, SGX-Shield enforces that rdx always points to the location
DEP. Specifically, code pages are granted not only execution
higher than the NRW-boundary. r15 is initialized to hold the NRW
but also read and write permissions. As such, SGX-Shield
boundary value by the secure in-enclave loader. It is assumed that
eliminates read and write permissions on code pages once
r13 is an available register (or spilled beforehand) and thus used as a
the secure in-enclave loading is finished (i.e., after the target temporary register.
program is randomly mapped to the memory). The key idea
behindthisisenforcingtheNRWboundary(i.e.,NonReadable
and Writable boundary), which is a virtual barrier between number of instrumented instructions, we transform the original
code and data pages (See Figure 4). SGX-Shield guarantees instruction such that it accesses memory using a positive offset
this by (1) shepherding all memory access instructions and (2) from the NRW boundary. We then enforce that the maximum
ensuring only aligned control transfers are made. positive offset is smaller than 232 − 1 to ensure that the
instruction never accesses memory beyond the NRW boundary.
Shepherding memory access. In general, there are two types
of memory access instructions: (1) explicit memory accessing Figure5showshowanmovinstructionthatwritestoaddress
instructions (e.g., mov, inc, add instructions with memory rdx+0x10 is instrumented. SGX-Shield enforces that rdx+0x10
operands in x86) and (2) stack accessing instructions (e.g., is always higher than r15. For this, it first moves the value of
implicitstackpointeradjustinginstructionsincludingpush,pop, rdx+0x10 to r13 (line 7), subtracts it from r15 (line 8), and
call, ret, etc., or explicit stack pointer adjusting instructions clears high 32-bits of r13 (line9). After this point, if rdx+0x10
including sub, add, etc. with a stack register operand). ≥r15,r13willholdthepositiveoffsetfromtheNRWboundary,
and the next instruction (line 10) performs the memory write
In order to prevent read or write attempts through the first operation as intended. Otherwise, if rdx+0x10 ≤ r15, r13 will
type of instruction, SGX-Shield makes sure that a memory
hold the AND-masked value (line 9) because a subtraction in
address to be accessed is always higher than the NRW
line 8 results in a negative value (i.e., the most-significant bit
boundary (i.e., the operand should not point to code pages).
is set). Therefore, this offense is properly guarded, as it does
To avoid extra memory dereferences and thus optimize the
not overwrite the code page under SGX-Shield.
performance, SGX-Shield reserves the register r15 to hold the
NRW boundary, which is initialized by the secure in-enclave To enforce non-writable code pages on stack accessing
loader before executing the target program. To minimize the instructions, SGX-Shield makes sure that a stack pointer (i.e.,
71 ; Before enforcing non-writable code E. Isolating Access to Security-Critical Data
2 sub rsp, 0x40
3
4 ; After enforcing non-writable code By its design, SGX places the page for the State Save Area
5 ; (r15 is initialized to hold the NRW boundary) (SSA)ataknownlocationanddoesnotpermititsrelocation,as
6 ; (enforce rsp >= r15) describedinC4(§III).Inordertopreventattackersfromabusing
7 sub rsp, r15 ; rsp = rsp - r15
8 sub rsp, 0x40 ; rsp = rsp - 0x40 this non-randomizable data location, SGX-Shield implements
9 mov esp, esp ; rsp = rsp & 0xffffffff softwarefaultisolation(SFI)toisolateSSA.Inparticular,since
10 lea rsp, [rsp + r15] ; rsp = rsp + r15
we already mark the memory page for SSA as non-executable,
Fig.6:Instrumentingstackaccessinstructionstoenforcenon-writable we prevent the target enclave program from reading or writing
code.Sinceavalueofrspischanging,SGX-Shieldenforcesthatrsp
to SSA.
≥ NRW-boundary always holds.
We found that SGX-Shield can easily retrofit its software
1 ; Before enforcing aligned indirected branch dataexecutionprevention(DEP)mechanism(§IV-D)toachieve
2 jmp rax this requirement. Our software DEP mechanism ensures that
3
4 ; After enforcing aligned indirected branch no read or write accesses are permitted to pages lower than
5 ; (enforce rax % [random unit size] = 0) the NRW boundary. Therefore, as shown in §IV-D, we place
6 and rax, $-0x20 ; rax = rax && 0xffffffffffffffe0 SSA below the NRW boundary, thereby isolating SSA from
7 jmp rax ; jump to the address pointed by rax
being read or written.
Fig.7:Instrumentingindirectbranchestoenforcealignedjumps.This
makessurethatthereisnobranchtoanoffsetinthemiddleofbundled
instructions, i.e., bypassing the enforcement of the non-writable code. F. Performance Optimization
A general goal of our optimization is to reduce the number
rsp) never points to code pages. To handle instructions that of checks while preserving the same security guarantees, as the
adjust stack pointers implicitly, we simply map a guard page checks instrumented by SGX-Shield directly impact runtime
(i.e., no permission is granted) at the top and bottom of performance. In particular, we focus on two types of checks,
the stack area. Because these instructions shift the stack bothofwhichwereidentifiedasmajorperformancebottlenecks
pointer with a small fixed offset and access the stack, the during our preliminary performance evaluation: (1) masking
guard page would always be hit if any of them accesses operations onto memory read/write instructions for software-
beyond the legitimate stack range. Note, this guarded page DEP (§IV-D) and (2) a jump operation replacing fall-through
scheme on stack instructions optimizes the performance of cases for randomization units (§IV-C).
SGX-Shield. This is because conceptually it replaces a large
First, we remove redundant masking operations within a
number of instrumented instructions with two guarded memory
loop. More precisely, we observed that the target address of a
pages along with retrofitting the existing exception handling
memoryreadorwriteinstructionwithinaloopeitherreusesthe
mechanism.Inthecaseofinstructionsexplicitlyadjustingstack
same address or simply increases through the loop counter, for
pointers, SGX-Shield explicitly instruments them, as shown
example, functions manipulating string or buffer (e.g., memset,
in Figure 6. This is similar to our instrumentation techniques
memcpy,memmove)loopsoverabufferusingapointerconvoluted
for explicit memory accesses in that both of them compute the
with a loop counter. Therefore, we develop a simple loop
positive offset values from the NRW-boundary.
analysis considering data dependency, which identifies a range
of addresses referenced inside. Next, if such a range can be
Ensuring aligned control transfer. Because x86 and x86- foundconservatively,thenwereplacemaskingoperationsinside
64 ISA have variable length instructions, code alignment a loop with two masking operations outside a loop — masking
is critical; unexpected instructions can be executed when only on the minimum and maximum address value before
alignment is broken. This would violate our enforcement on entering the loop. It is worth noting that this replacement has
memory accesses, as these instructions would perform memory to be performed in the same randomization unit or more strict
accessesnotguardedbySGX-Shield.SGX-Shieldresolvesthis control-flowintegrityhastobegiventothisrandomizationunit.
issue by restricting the control transfers only to the entry point Otherwise, an adversary may jump into the randomization unit,
of the randomization unit. As a result, it enforces that there which allows avoiding masking operations before executing
is only one way to decode instructions, ensuring that only memory read/write instructions.
shepherded memory access takes place. This enforcement is
performedforallcontroltransferinstructions,includingindirect Second, we also minimize the number of fall-through cases
branches as well as return instructions. In the case of indirect if possible. Specifically, we instructed the compiler to avoid
branches, masking operations are added as shown in Figure 7 emitting jump or switch tables, as we observed that these were
so that the destination only points to one of the randomization a major source of conditional jumps, which results in a huge
unit’s entry points. In the case of a return instruction, it is first number of fall-through cases.
replaced with equivalent instructions, pop reg and jmp reg,
where reg can be any available register. Then, the latter jmp
V. IMPLEMENTATION
instruction is instrumented as it is done for indirect branch
instructions. Finally, to enable efficient masking on control SGX-Shield consists of 23,068 lines of code (see Table II),
transfer, our implementation aligns the randomization unit to where 2,753 lines of code contributes to the secure in-enclave
its size (i.e., if the size of a randomization unit is 32-bytes, an loader that is running within an enclave. We implement secure
entry point address of a randomization unit ends with five zero in-enclave loaders (i.e., dynamic loaders) for both Linux and
bits). Windows, where the ELF format is used to build an enclave
81 ; gadget #1
#ofFiles LoC BaseFramework
2 pop rdi ; src. of memcpy(), the address in enclave to leak
Preparation 13 2,304 LLVMBackend 3 pop rsi ; dst. of memcpy(), the address in host
Bootstrapping∗ 19 1,625 IntelSGXSDK 4 ret ; jump to gadget2
Securein-enclaveloader∗ 15 2,753 IntelSGXSDK 5 6 ; gadget #2
Windowsversion 12 3,514 IntelSGXSDK 7 pop rdx ; len. of memcpy()
Others 71 12,872 - 8 ret ; jump to memcpy()
Total 130 23,068 - Fig.8:GadgetsforCFI-bypassingROP.Theattackerneedstocorrectly
∗indicatesLinuxversionofSGX-Shield guessfouraddressvaluestolaunchasuccessfulattack:theaddressof
gadget #1, gadget #2, and memcpy(), and the address in the enclave
TABLE II: The implementation complexity of SGX-Shield. We
to leak (i.e., rdi). We assume that an attacker already knows the
implement the preparation based on LLVM 4.0. We implement the
implementation details of memcpy() in that rsi, rdi, and rdx were
runtime supports (i.e., bootstrapping and secure in-enclave loader)
used for corresponding function parameters.
both in Linux and Windows.
Windows version. In order to support Windows enclave
program2. Once the enclave program is compiled as an ELF programs, we implemented a separate PE editor, bootstrapping
format, we can run it regardless of the platform. program, and secure in-enclave loader. The PE editor embeds
dummy sections in the secure in-enclave loader to reserve
Preparation. The preparation phase includes an LLVM enough code and data pages. The bootstrapping program and
compiler 4.0, a static linker, and a sign tool of Intel SGX the secure in-enclave loader for Windows are almost the same
SDK for Linux. By modifying the backend of LLVM [6], as those for Linux, but we only solve the compatibility issues,
we insert two kinds of instructions: (1) unconditional jump including type definitions and system calls.
instructions(insteadoffallthrough)attheendofrandomization
units and (2) instructions to enforce the software-DEP (i.e., Others. TherestofthecomponentsofSGX-Shieldarelibraries
masking the target memory address to access). In addition, the used by an enclave program and debugging tools. We port
LLVM emits each randomization unit as a symbol. The fine- musl-libc [5] as a libc and mbedTLS [4] as a TLS library to
grained symbol information is used in the secure in-enclave SGX-Shield. Since libc code often invokes system calls, we
loading.Thesoftware-DEPcurrentlyenforcesonlythememory replace those system calls to trampolines/springboards.
write protection. To prevent reading the code, the code page
is added as writable and executable, but not readable, through
VI. EVALUATION
EADD. As the relocation does not read the code, non-readable
code pages do not cause faults. In this section, we evaluate SGX-Shield by answering the
The current version of SGX-Shield supports only static linking. following questions:
We implement a static linker from scratch. While linking
1) How effectively does SGX-Shield defend against various
relocatables generated by the LLVM, it keeps the fine-grained
types of memory-based attacks (§VI-A1)?
symbol and relocation information for the fine-grained ASLR.
We modify Intel SGX SDK for Linux to provide the enclave 2) How much randomness does SGX-Shield show in its
program with sufficient code and data pages for shuffling. We address space layouts (§VI-A2)?
embed the binary of enclave program into the binary of secure
3) How much performance overhead would SGX-Shield
in-enclave loader as a section using the objcopy command.
impose in running the micro-benchmarks (§VI-B1)?
Since the source code for Intel SGX SDK for Windows is not
available, we implement a PE editor that adds dummy memory 4) How much performance overhead would SGX-Shield
sections tothe securein-enclave loaderto provideenough code impose in running typical workloads for SGX (§VI-B2)?
and data regions.
Experimental setup. All our experiments were conducted on
Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz (Skylake with
Bootstrapping. The bootstrapping simply creates an enclave
8MBcache)with32GBRAM.WeranUbuntu14.04withLinux
and loads the secure in-enclave loader to the enclave. We
3.19 64-bits3, and installed Intel SGX SDK and device drivers
implemented a simple program that conducts the bootstrapping
releasedbyIntel[28].Intheentropyanalysis(§VI-A2)andthe
in both Linux and Windows.
micro-benchmark (§VI-B1), we used nbench [2] benchmark
suites.
Secure in-enclave loader. The secure in-enclave loader
is a dynamic loader that conducts the randomization unit-
level memory object loading and relocations. It resolves the A. Security Evaluation
relocation information for all the memory references including
This subsection evaluates how many security guarantees
the absolute addresses and the PC-relative addresses. We
are offered by SGX-Shield. We first evaluate the practical
implemented these from scratch and made a best effort to
security aspects of SGX-Shield by measuring the possibility of
reduce the size of the trusted computing base. In the current
successful memory corruption-based attacks (§VI-A1). Then,
version, the core part (i.e., parsing the ELF file, randomly
we evaluate the theoretical and general security aspects of
loading, and relocation) is written in a single C file with 384
SGX-Shield by measuring the entropy (§VI-A2).
LoC.
3 We also performed the same evaluation in the Windows version of
2 InWindows,thesecurein-enclaveloaderiscompiledasaPEformat,but SGX-Shield. While the result is almost same, we do not show it in this
itloadstheELFformatexecutable. paperbecauseofthepagelimitation.
9Exploitationtechnique
Attackmodel Ret-to-func ROP CFI-bypassingROP SGX-Shield Stack Heap Global
SGXSDK
Remote 0/214(48-bits) 0/214(88-bits) 0/214(108-bits) RU-64 RU-32 HRel S SG GX X-SS hD iK eld 0.980 8.0 6 0.990 9. 50 0.990 6.0 7
Passivekernel 214/214(0-bits) 214/214(0-bits) 214/214(0-bits) HRel 0.0 0.9989 0.9993
Activekernel 214/214(0-bits) 214/214(0-bits) 214/214(0-bits) HAbs 0.9869 0.9999 0.9999 HAbs S SG GX X-SS hD iK eld 0 1. .9 08 06 09 0 0 1. .9 08 06 09 0 0 1. .9 08 06 09 0
(a)IntelSGXSDK(baseline) (a)Codepages (b)Datapages
TABLEIV:TheASLRentropyoncodeanddatapageswhilerunning
Exploitationtechnique the nbench binary 1,800 times. The higher entropy value indicates
Attackmodel Ret-to-func ROP CFI-bypassingROP morerandomnessonaddresslayouts.HReldenotesentropyforrelative
Remote 0/214(48-bits) 0/214(88-bits) 0/214(108-bits) addressesandHAbs denotesentropyforabsoluteaddresses.SGXSDK
Passivekernel 0/214(20-bits) 0/214(60-bits) 0/214(80-bits) denotes the baseline results using the existing Intel SGX Linux SDK.
Activekernel 148/214(7-bits) 0/214(21-bits) 0/214(28-bits) RU-64 and RU-32 represent the configured size of a randomization
(b)SGX-Shield unit, 64- and 32-bytes, respectively.
TABLE III: Security effectiveness of SGX-Shield against memory
corruption-based attacks. For each attack model, we launched 214 of the remote attack model, all our attack attempts (214 times)
attacks to the vulnerable enclave program running with either the failed, as theoretically an attacker has to try about 247, 287,
current Intel SGX SDK or SGX-Shield. In each cell, x/y (z-bits) and 2107 times to achieve a 50% successful attack probability
denotes the following: x - the number of successful attacks; y - the
per exploitation technique, respectively. In the case of passive
total number of attacks we tried; and z - the theoretical number of
and active kernel attack models, since the attacker is already in
bits that the attack needs to bruteforce.
possession of required address values for all three exploitation
techniques, exploitation attempts were always successful for
1)Effectiveness against Memory Corruption Attacks: In all 214 attacks that we tried.
order to see how effective SGX-Shield is in stopping memory
WithSGX-Shield,however,theprobabilisticdefensenature
corruption-based attacks, we launched an attack against a
of ASLR is regained for all attack models and exploitation
vulnerable enclave program while running either Intel SGX
techniques. In the remote attack model, SGX-Shield showed
SDKs and SGX-Shield. We assume following the three attack
the same security results as the Intel SGX SDK. In the case of
modelsinwhicheachhasdifferentprior-knowledgeonmemory
the passive kernel attack, all 214 attack attempts failed. If the
address layouts according to their inherent runtime constraints:
size of a randomization unit is 32 bytes, there are 220 possible
(1) a remote attack, which launches an attack through network
entry points that attackers have to bruteforce for each address
sockets serviced by a vulnerable enclave program. This model
value(i.e.,32MB/32B=225/25,asthecodeordataregionsize
is a blind attack (i.e., it knows nothing related to the address
is32MB).Thus,theoreticallytheattackerhastoguess220,260,
layouts); (2) a passive kernel attack, which has the privilege of
and 280 address values for each exploitation technique. In the
an underlying operating system but does not intervene a page
activekernelattack,theattackernowmayknowwhichmemory
fault handling mechanism. Since the kernel executes EEINIT
page is responsible for executing certain code in the worst case
andEADD,thisattackmodelhasinformationonthebaseaddress
of SGX-Shield. However, since SGX-Shield still shuffles both
and the size of an enclave; (3) an active kernel attack, which
code and data pages in the memory page, the unknown bits for
not only has the privilege of an underlying operating system
a single address value would be 7 (i.e., 4KB/32B = 212/25,
but also actively intervenes the page fault handling mechanism.
as the memory page size is 4KB and the randomization unit
The active intervention on the page fault follows the controlled
size is 32B). Therefore, a theoretical bound of SGX-Shield’s
side-channelattack[61],whichgrantsadditionalinformationon
security guarantee is 27, 221, and 228, for each exploitation
which memory page is being accessed by an enclave program
technique, respectively. Accordingly, this theoretical estimation
(more details are discussed in §VII).
is also evidenced by our real attack trials — while successful
attacks were observed 148 times for return-to-function, all
In order to focus on ASLR-related issues, we wrote an
failedforROPandCFI-bypassingROP.AlthoughSGX-Shield’s
easily exploitable victim program with a simple stack-overflow
probabilistic bound against the return-to-function exploitation
vulnerability.Then,foreachattackmodel,werunthefollowing
technique can be a security concern, we believe the security
four exploitation techniques, where each imposes different
benefit of SGX-Shield is still valuable considering that return-
difficulties in guessing address values: (1) return-to-function,
to-function is difficult to be a general exploitation in practice.
which requires inferring a single address value (i.e., a function
address);(2)ROP,whichrequiresthreeROPgadgets(i.e.,need
2)Entropy Analysis: We measure the randomness of the
to infer three address values). The gadgets are the same as
address space layout using the notion of entropy [15]. The
the ones in RIPE benchmark [60], but we replaced call with
entropy captures the uncertainty of a given random variable,
syscall to work in an SGX environment; (3) CFI-bypassing
and we apply this by considering possible address values
ROP, which requires four ROP gadgets (i.e., need to infer four
as a random variable. Specifically, let A be a discrete
RU
address values as shown in Figure 8). This CFI-bypassing ROP
random variable with the absolute entry point addresses
manipulates only the data flow, so it would not be detected by
{a ,a ,...,a } for a certain randomization unit RU across
1 2 n
CFI techniques [7] but requires more gadgets than non-CFI-
ndifferentruns,andp(a )isaprobabilitymassfunction(pmf).
i
bypassing ROP. Then,HAbs(A ),thenormalizedaddressspacelayoutentropy
RU
of the randomization unit RU, is defined as:
As expected, the current Intel SGX SDK was effective n
against a remote attack model, but ineffective against passive HAbs(A
)=−(cid:88)
p(a
)lnp(a i)
.
and active attack models. As shown in Table III, in the case RU i lnn
i=1
10Moreover, due to the normalization factor lnn, SGX-Shield
0≤HAbs(A RU)≤1 Benchmark Baseline RU-64 RU-32
always holds. HAbs(A ) is zero when the randomization unit
RU (µs) ASLR ASLR&DEP ASLR ASLR&DEP
is always mapped to the same address for all n runs. It is
Numsort 1262 -1.22% 1.88% 3.65% 2.30%
one when all runs always result in a different address. We also Stringsort 6077 2.62% 18.98% 7.29% 31.67%
measuretheentropyontherelativeaddresstobetterunderstand Fpemu. 12140 0.81% 10.05% 5.78% 29.77%
the randomness of our ASLR scheme when the base address Assignment 43613 1.28% 1.79% 6.89% 3.89%
Idea 387 -0.14% -0.55% -0.72% -0.67%
of an enclave memory is known. This entropy is resented as
Huffman 445 2.85% 15.29% 28.65% 25.96%
HRel(A RU). Neuralnet 34618 2.10% 7.26% 8.73% 22.20%
Ludecomp. 1080 0.09% 0.39% 2.08% 2.52%
Usingthesetwoentropymeasures,wecomputedtheentropy
Average 0.00% 1.05% 6.89% 7.80% 14.71%
for code pages and data pages, as shown in Table IV: SGX
SDK denotes the baseline results; for the entropy of code TABLE V: Runtime performance overhead of SGX-Shield when
pages, we configured the size of the randomization unit as 32- running nbench. Baseline column is a native run under SGX without
SGX-Shield and it is measured in microseconds. All columns in
or 64-bytes (i.e., RU-32 and RU-64); for the entropy of data
SGX-Shield are represented with relative overheads in a percentage
pages, we measured it for stack, heap, and global data objects.
compared to the baseline. RU-64 and RU-32 denote a size of
Note, especially for data pages, we computed the entropy by
a randomization unit, 32- and 64-bytes, respectively. ASLR and
replacing an entry point address of a randomization unit into
ASLR&DEPdenotebeforeandafterapplyingSGX-Shield’sDEPand
the base address of each data object. SFI techniques, respectively. The average relative standard deviation
is 0.71% (the maximum is 2.45%).
Code page entropy. HRel in Table IV-(a) shows the effective-
ness of SGX-Shield’s approach against strong adversaries. As
expected,whileIntelSGXLinuxSDKprovidesnorandomness we run SGX-Shield with various settings, changing the size of
(i.e., the entropy value is zero), SGX-Shield provides a very randomization units and opt out software-DEP and SFI.
high degree of randomness. This is because the SDK picks a
Table V shows the performance overhead imposed by
randombaseaddressandloadstheprogramtothebaseaddress
SGX-Shield in running nbench. An elapsed time in microsec-
in a deterministic way. Smaller randomization units (RU-32)
onds is represented in the baseline column, while all other
provide a higher degree of randomness (compared to RU-64).
columns under SGX-Shield are represented in a relative
On the other hand, if the attacker is completely blind, then overhead compared to the baseline in a percentage. In this
both Intel SGX Linux SDK and SGX-Shield provide good table, RU-32 and RU-64 denote the size of a randomization
randomness, as shown in HAbs. unit, 32- and 64-bytes, respectively.
Data page entropy. We now describe the entropy of As the size of a randomization unit becomes smaller,
SGX-Shield compared to Linux SGX SDK for data objects, in- the performance overhead increases. More specifically, before
cludingstack,heap,andglobalvariables,asshowninTableIV- applying DEP and SFI, RU-32 imposes 6.75% more overhead
(b). Similar to the code page entropy, Linux SGX SDK shows compared to RU-64 (i.e., from 1.05% to 7.80%). Once DEP
no randomness on all data pages against strong adversaries andSFIareapplied,RU-32imposes7.82%moreoverhead(i.e.,
(i.e., HRel is zero for stack, heap, and global). In contrast, from 6.89% to 14.71%). This additional overhead is expected,
SGX-Shieldshowsveryhighrandomnessacrossalldataobjects. as SGX-Shield introduces more randomization units in RU-32,
Stack object shows the least randomness among these. The and thus instruments more unconditional branches. Moreover,
reason is that SGX-Shield still needs to allocate the continuous a smaller randomization unit implies a negative impact on
spacetopreservethefunctionalityofstack,eventhoughitpicks code cache performance, as there will be more frequent control
stack’sbaseaddressatrandomandimposesnoalignmentonthe transfers.
base address in order to maximize the randomness. Assuming
DEP and SFI techniques of SGX-Shield also slow the
blind attackers with no information, Intel SGX SDK shows
reasonable randomness, but SGX-Shield shows close to perfect
execution of nbench. With RU-64, SGX-Shield shows 1.05%
randomness given the number of sample runs (HAbs). Across overheadifDEPandSFIwerenotapplied.Ifthesewereapplied
together, SGX-Shield showed 6.89% overhead on average.
all 1,800 runs, SGX-Shield exhibited unique and random base
Similarly, with RU-32 SGX-Shield showed 7.80% and 14.71%
addresses for all data objects.
overhead on average before and after applying DEP and SFI,
respectively. In other words, the performance overhead of
B. Performance Overhead
SGX-Shield’s DEP and SFI is 5.84% and 6.91% in RU-32
We now evaluate the performance overhead imposed by and RU-64, respectively.
SGX-Shield. In order to understand the performance as-
To better understand the performance impacts of
pects in the worst-use-cases as well as typical-use-cases, we
SGX-Shield, we also counted the number of executed instruc-
run SGX-Shield on both the micro-benchmark and macro-
tions in runtime while running the benchmarks. The perfor-
benchmark.
mance overhead that SGX-Shield imposes is directly related
1)Micro-benchmark: We run each testcase of the nbench to the number of executed instructions. To implement fine-
benchmark suites [2] 200 times and report the median value. grained randomization, SGX-Shield instruments a terminator
In each run, nbench iterates through its task at least 10,000 instructionattheendofarandomizationunit.Thisaloneresults
times, and it returns the average time to perform the task once. in 8.86% or 13.1% more executed instructions on average (See
To clearly see where the performance overhead comes from, Table VI). Moreover, to implement DEP and SFI, SGX-Shield
11SGX-Shield Total Request Time (A) SSL Handshaking (B)
Benchmark Baseline RU-64 RU-32 8%
7.6
ASLR ASLR&DEP ASLR ASLR&DEP
Numsort 5,245K 6.55% 21.38% 14.68% 28.36% %) 6% 6.2
S Ft pri en mg us .ort 3 68 6, ,0 51 57 3K
K
81 7. .8 09 7%
%
2 274 3. .34 79 %% 19 47 .. 42 69 %% 31 354. .84 47 %%
ctor
(
A Ids es aignment 3 20 21 4, ,1 00 04 0K K 8 5. .1 86 0% % 7 6. .7 43 7% % 1 13 3. .2 56 7% % 1 15 2. .9 75 9% % wn fa 4%
Huffman 295,379K 6.23% 12.07% 13.44% 19.14% wdo
3.1
3.5
Neuralnet 263,275K 8.76% 21.56% 18.86% 32.82% o 2.7 2.7
Ludecomp. 7,967K 7.43% 9.22% 17.27% 21.73% Sl 2%
1.8 1.8
Average 16.49% 47.04% 25.35% 60.14%
TABLE VI: The number of instructions executed in runtime while 0%
RU­64 ASLR RU­64 RU­32 ASLR RU­32
running nbench ASLR&DEP ASLR&DEP
Fig. 9: Performance overheads in running an HTTPS server with
SGX-Shield mbedTLS.Eachbarrepresentstheslowdownfactor(%)ofSGX-Shield
RU-64 RU-32 compared to the baseline (i.e., Intel SGX SDK for Linux): the bar
Baseline ASLR ASLR&DEP ASLR ASLR&DEP on the left (marked as A) shows the slowdown in the total elapsed
time for a request, and the bar on the right (marked as B) shows the
#instr. 29k 37k 42k 39k 45k
#RU - 5,663 5,938 8,430 9,161 slowdown in the elapsed time for SSL handshaking. We ran 50 times
Binarysize 212KB 548KB 584KB 724KB 792KB and report the median value. The median of the total elapsed time
—code+data 131KB 160KB 177KB 170KB 193KB in the baseline is 1.1 second, while the one for SSL handshaking is
—metadata 68KB 374KB 391KB 541KB 586KB
0.359 second. The average relative standard deviation is 3.35% (the
TABLE VII: A static overhead of SGX-Shield to the nbench binary. maximum is 5.83%).
Note that the nbench benchmark suites contain a single binary, which
takes an argument to specify a certain testcase. # instr. denotes the
provides authentication and key sharing mechanisms for SSL
number of instructions in a binary; # RU. denotes the number of
handshaking, and it also encrypts (or decrypts) messages on
randomization units that SGX-Shield generated. Binary size denotes
a size of a binary, including code and data as well as metadata; sending(orreceiving).WeranthisHTTPSserver,whichserves
code+datadenotesasizeofbothcodeanddatasegmentsinabinary. theHTMLfileof12KBsize.Theaverageround-triptime(RTT)
metadata denotes a size of symbal, relocation, and string table in a between the server and the client was 175.5 ms, an average of
binary. 50 times running a ping command with 0.32% average relative
standard deviation.
instruments many memory accessing instructions. This further Figure 9 shows the overheads of requesting the HTML
increases the number of executed instructions by 30.55% and file from the HTTPS server. We computed the median of 50
34.79% for RU-64 and RU-32, respectively. The results show times of the requests and plotted the slowdown factor as a
that DEP and SFI have a stronger impact on the number of percentage between the baseline (i.e., Intel SGX SDK for
executed instructions. Linux) and SGX-Shield: the first bar (marked as A) represents
the slowdown in the total request, and the second bar (marked
Intermsofmemoryoverhead,SGX-Shieldactuallyimposes
as B) represents the slowdown during the SSL handshaking.
fixed overhead due to over-estimation. More precisely, in the
current version of SGX-Shield, it imposes total 64 MB memory Overall, SGX-Shield imposed negligible overheads in the
overheads (i.e., 32 MB for code pages and 32 MB for data pages). totalrequesttime,from1.8%to2.7%,dependingonthesetting.
Thisperformancenumberismuchbettercomparedtothemicro-
Looking into more detail on possible factors of memory
evaluation results, and we suspect this is because the total
overhead, while SGX-Shield preserves the size of data objects,
request time is dominated by the network latency, which is
it enlarges the size of code due to the randomization unit-level
independent of SGX-Shield’s extra work with instrumentation.
ASLR and software-DEP. Particularly, ASLR also increases
This can be supported by the increased slowdown numbers
the size of metadata including fine-grained symbol, string, and
in SSL handshaking, which is less related to the network
relocation table entries. Table VII shows that the increased
operationsandmorerelatedtocomputationaljobs,rangingfrom
binary size is mainly from more metadata.
3.1% to 7.6%. Similar to the micro-evaluation results, enabling
Based on these evaluation results, we recommend that RU- DEP incurred more slowdowns due to its extra instrumentation
64withDEPandSFIwouldbeareasonableconfiguration.The for software-based DEP — 0.4% increases in RU-64 and 1.4%
address space layout showed fairly good randomness compared increases in RU-32. According to these results, we believe
to RU-32, and its runtime performance is 7.82% faster than SGX-Shield would be fast enough to run realistic workloads
RU-32. for SGX while providing ASLR security guarantees together.
2)Macro-benchmark: In order to see how SGX-Shield
VII. DISCUSSIONONCONTROLLEDSIDE-CHANNEL
would work with real-world workloads, we ran an HTTPS
ATTACKS
server within an enclave. We ported mbedTLS [4], which
is an open source Transport Layer Security (TLS) library. The controlled side-channel [61] allows an attacker to infer
mbedTLS also includes a sample HTTPS server, where its work data values at runtime by observing coarse-grained execution
process can be broken into the following two parts: (1) SSL flows (i.e., a sequence of page faults). If an application running
handshaking, an initial and fixed cost for a request and (2) within an enclave exhibits control-flow dependencies relying
readinganHTMLfileandthensendingittotheclient.mbedTLS on specific data values, this attack is indeed possible because
12page resources are managed by adversaries (i.e., the kernel) in OpenSGX [31] is a software platform that emulates the
the SGX model. SGX hardware and provides basic software components (e.g.,
system call interface and debugging support) and toolchains.
WhilethisattackisnotdirectlyrelatedtobreakingASLR,it
canstillbeappliedtopartiallyinferaddresslayoutinformation. Security issues of Intel SGX. While Intel SGX provides
In other words, although the kernel does not know memory the protection of the program against access from privileged
layouts after in-enclave loading, it may infer some layout software and hardware, several studies argue the vulnerabil-
information by observing (or intentionally triggering) page ities of the enclave program as an open problem. Attackers
faults. For example, assume that there are four code objects (A, can perform various types of Iago attacks [19] through the
B, C, and D) and a global variable (v), and A has the branch: if communication channel between the enclave program and the
v is 1, jump to B; if v is 0, jump to C, and then jump to D. In external world. Moreover, potential side-channels [61] (e.g.,
this case, if the attacker observes the number of page faults as page fault) exist that helps the untrusted privileged software
2, she/he may conclude that x is 1. On the other hand, if the to guess the secret data of the program. To address this
number of page faults is 3, she/he may conclude that x is 0. problem, Shinde et al. [54] designed a defense mechanism
SGX-Shield’s design decisions on randomization units that enforces a program to access its input-dependent pages
effectively thwart this side-channel attack, as shown in §VI-A1. in the same sequence regardless of the input variable. This
Specifically, because SGX-Shield randomly places multiple approach,calleddeterministicmultiplexing,ensuresthattheOS
randomization units in a memory page, when the size of the cannot distinguish the enclave execution.Since the performance
randomization unit is 32 bytes, an attacker needs to bruteforce overheadofShindeetal.[54]istooexpensiveinpractice(4000
27 times (i.e., 4KB/32bytes = 212/25, as the memory page size timeswithoutdeveloper’shelp),T-SGX[53]suggestsadefense
is 4 KB) to guess a single address value, while each failure based on Intel Transactional Synchronization Extensions (TSX)
would end up crashing a target enclave program. Considering to hide page faults against the untrusted kernel.
the number of address values that need to be guessed in Also, incorrect use of SGX instructions or bugs related to
practical memory corruption exploits (e.g., three or more in memory accesss inside the enclave makes enclave programs
ROP [17, 18, 60]),we believe thisprobabilisticdefense against vulnerable. To handle this problem, Moat [56] suggests a new
the controlled side-channel would be effective and reasonable programming model that checks services related to the security
in practice. of the SGX program (e.g., remote attestation and cryptographic
sealing). It not only verifies the confidentiality of an enclave
VIII. RELATEDWORK
program, but also checks whether the enclave program actually
leaks the data. Rohit et al. [55] introduce a runtime library that
Secure systems based on Intel SGX. The early adoption
offers an interface to securely communicate with the external
of Intel SGX focused on the cloud environment to cover
partyoftheenclave.Italsoprovidescoreservicesforthesecure
securityproblemsfromanuntrustedcloudplatform(e.g.,cloud
memory management and runtime checks for verification.
provider). Haven [12] is a system to securely run the entire
libraryOS(LibOS)inanenclaveasaguestOStopreventaccess
Commodity TEEs and software-based solutions. While
from untrusted software with a malicious purpose. Similar to
much commodity hardware, including Intel SGX [30, 39] and
SGX-Shield, the LibOS loads the actual target programs at
ARM TrustZone [8],provide Trusted Execution Environments
runtime. However, it does not support ASLR, which leads to
(TEEs), Sancus [43] designs a hardware architecture for TEEs.
several threats as mentioned in §IV-A. Additionally, the TCB
Tothebestofourknowledge,SecureOSoftheARMTrustZone
of Haven is very large (more than 200MB) because of the
does not support ASLR and software DEP [51]. However,
nature of OS, while the TCB of SGX-Shield is only 8KB
applyingASLRandsoftwareDEPtoARMTrustZoneisanother
(1821 instructions in the x86-64 assembly). To reduce the TCB
research issue to be explored with different challenges (e.g.,
size of the libOS approach, Scone [9] suggests the container
different side-channel) compared to SGX-Shield.
based sandbox in an enclave.
There are several approaches to shield applications from
Starting from the cloud environment, the systems and
untrustedprivilegedsoftwareinthesoftwaremanner[22,25,35,
frameworks that apply Intel SGX to enhance security have
63].Minibox[35]ensuresmutualdistrustbetweentheprogram
beenproposed.VC3[46]isasecuredataprocessingframework
code and the OS on top of a trusted hypervisor with small
based on the Hadoop framework [1] to keep the confidentiality
TCB (pieces of application logic). CloudVisor [63] protects
and integrity of the distributed computations on the untrusted
the virtual machines of customers by separating resource
cloud. VC3 suggests a self-integrity invariant that prevents
managementfromthevirtualizationlayer.InkTag[25]proposes
an enclave program from reading from or writing to the
the defense mechanism against compromised system call
non-enclave memory region. It basically aims to avoid data
interfaces to protect persistent storage, and Virtual Ghost [22]
leakages and memory corruptions. This technique is similar
similarilyprotectsthememoryfromthehostOSusingcompiler
to software-DEP or SFI of the SGX-Shield, but the one of
instrumentation.
SGX-Shield aims to prevent an attack from injecting code to
execute. Ryoan [26] also adopts SFI in SGX to guarantee data ASLR and runtime re-randomization. ASLR is applied
privacy between multiple distrusted parties. The S-NFV system to commodity OS [3, 44] to defend against return-to-libc
architecture [52] proposed a new design of the secure Network [42] and return-oriented-programming (ROP) attacks [49]
Function Virtualization (NFV) system based on the Intel SGX. by obfuscating locations of code gadgets. However, several
Kim et al. [33] suggest security enhancements of the network ways to bypass ASLR have been reported [36, 48, 50, 58],
systems such as software-defined inter-domain routing and stemming from the low entropy of randomness [36, 50] and
peer-to-peer anonymity networks by adopting the Intel SGX. memory disclosures [48, 58]. To address the low entropy issue,
13many fine-grained ASLR techniques [13, 23, 24, 32, 45, 59] [4] “mbedtls,”2016.[Online].Available:https://tls.mbed.org/
claim that randomizing the code in various fine-grained units [5] “musl-libc,”2016.[Online].Available:https://www.musl-libc.org/
(e.g.,basicblockorinstructionlevel)canbeasolution.Several
[6] “Writinganllvmbackend,”2016.[Online].Available:http://llvm.org/
studies[10,21,38]showthattheencryptionofvisiblepointers docs/WritingAnLLVMBackend.html
and non-readable executable pages prevents attackers from [7] M.Abadi,M.Budiu,Ú.Erlingsson,andJ.Ligatti,“Control-flowintegrity
abusing memory disclosures. principles, implementations, and applications,” ACM Transactions on
InformationandSystemSecurity(TISSEC),vol.13,no.1,p.4,2009.
The runtime re-randomization [14, 34, 37] is a strong
[8] T.AlvesandD.Felton,“Trustzone:Integratedhardwareandsoftware
defensemechanismagainstbothbrute-forceattacksandmemory security,”ARMwhitepaper,vol.3,no.4,pp.18–24,2004.
disclosure exploits. In particular, RUNTIMEASLR [37] and
[9] S.Arnautov,B.Trach,F.Gregor,T.Knauth,A.Martin,C.Priebe,J.Lind,
Oxymoron [11] aim to protect from attacks using random D.Muthukumaran,D.OâA˘Z´Keeffe,M.L.Stillwelletal.,“Scone:Secure
memory corruption tests during the process forks [16]. By re- linuxcontainerswithintelsgx,”inProceedingsofthe12thSymposium
randomizing the memory layout of child processes, attackers on Operating Systems Design and Implementation (OSDI), Savannah,
GA,Nov.2016.
cannot guess the memory layout of the parent process. Similar
[10] M.Backes,T.Holz,B.Kollenda,P.Koppe,S.Nürnberger,andJ.Pewny,
to process fork, in Android system address space of the user
“You can run but you can’t read: Preventing disclosure exploits in
process is copied from a pre-initialized process called Zygote
executable code,” in Proceedings of the 21st ACM Conference on
that makes the memory layouts of user processes the same at ComputerandCommunicationsSecurity,Scottsdale,Arizona,Nov.2014.
the initial state. Morula [34] re-randomizes the child process [11] M.BackesandS.Nürnberger,“Oxymoron:Makingfine-grainedmemory
to mitigate this problem. randomizationpracticalbyallowingcodesharing,”inProceedingsofthe
23rdUsenixSecuritySymposium(Security),SanDiego,CA,Aug.2014.
Software DEP. The software DEP design of SGX-Shield is [12] A. Baumann, M. Peinado, and G. Hunt, “Shielding applications from
inspired by Native Client (NaCL) [47, 62]. NaCl [62] proposes anuntrustedcloudwithhaven,”inProceedingsofthe11thSymposium
an efficient SFI mechanism based on masking instructions and onOperatingSystemsDesignandImplementation(OSDI),Broomfield,
Colorado,Oct.2014.
adopting the memory segment of an x86 system. The goal
of NaCl is to sandbox a memory region in a user process to [13] S. Bhatkar, D. C. DuVarney, and R. Sekar, “Efficient techniques for
comprehensiveprotectionfrommemoryerrorexploits.”inProceedings
run a third-party component such as an untrusted library in
ofthe14thUsenixSecuritySymposium(Security),Baltimore,MD,Aug.
the region. The next version of NaCl [47] extends it to ARM 2005.
and x86-64 architectures. The instrumentation of software DEP
[14] D.Bigelow,T.Hobson,R.Rudd,W.Streilein,andH.Okhravi,“Timely
in SGX-Shield is similar to NaCl on x86-64, but we cannot rerandomizationformitigatingmemorydisclosures,”inProceedingsof
assume that the base address of data pages is aligned with the22ndACMConferenceonComputerandCommunicationsSecurity,
4GB, while NaCl for x86-64 makes the assumption. Because Denver,Colorado,Oct.2015.
of this limitation, our software DEP has a penalty to add one [15] C.M.BishopandN.M.Nasrabadi,Patternrecognitionandmachine
learning. springerNewYork,2006.
more sub instruction for the instrumentation.
[16] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazières, and D. Boneh,
“Hackingblind,”inProceedingsofthe35thIEEESymposiumonSecurity
IX. CONCLUSION andPrivacy(Oakland),SanJose,CA,May2014.
In this paper, we identified fundamental challenges in [17] N. Carlini and D. Wagner, “Rop is still dangerous: Breaking modern
defenses,” in Proceedings of the 23rd Usenix Security Symposium
enabling ASLR for the SGX environment. We took the real-
(Security),SanDiego,CA,Aug.2014.
world example, Linux and Windows SDKs for Intel SGX, and
[18] S.Checkoway,L.Davi,A.Dmitrienko,A.-R.Sadeghi,H.Shacham,and
found its critical security limitations. This paper also proposes
M. Winandy, “Return-oriented programming without returns,” in Pro-
asolution,SGX-Shield,anewASLRimplementationsforSGX ceedingsofthe17thACMConferenceonComputerandCommunications
programs. SGX-Shield incorporates a secure in-enclave loader, Security,Chicago,Illinois,Oct.2010.
software DEP, and software fault isolation to provide secure [19] S.CheckowayandH.Shacham,IagoAttacks:WhytheSystemCallAPI
ASLR for SGX. The evaluation that we conducted on the real isaBadUntrustedRPCInterface,Houston,TX,Mar.2013.
Intel SGX hardware demonstrates SGX-Shield’s effectiveness [20] C.Cowan,C.Pu,D.Maier,J.Walpole,P.Bakke,S.Beattie,A.Grier,
in both security and performance. P.Wagle,Q.Zhang,andH.Hinton,“Stackguard:Automaticadaptive
detectionandpreventionofbuffer-overflowattacks,”inProceedingsof
the 7th Usenix Security Symposium (Security), San Antonio, TX, Jan.
X. ACKNOWLEDGMENT 1998.
[21] S.Crane,C.Liebchen,A.Homescu,L.Davi,P.Larsen,A.-R.Sadeghi,
We thank the anonymous reviewers and our proofreader,
S.Brunthaler,andM.Franz,“Readactor:Practicalcoderandomization
Tricia Grindel, for their helpful feedback. This work was resilient to memory disclosure,” in Proceedings of the 36th IEEE
supported in part by BSRP (NRF-2015R1D1A1A01058713), Symposium on Security and Privacy (Oakland), San Jose, CA, May
Office of Naval Research Global (ONRG), IITP (B0101-15- 2015.
0557) funded by the Korea Government (MEST), KAIST [22] J. Criswell, N. Dautenhahn, and V. Adve, “Virtual ghost: Protecting
Venture Research Program for Graduate & Ph.D students, and applicationsfromhostileoperatingsystems,”2014.
NSF awards DGE-1500084, CNS-1563848 and CRI-1629851. [23] C.Giuffrida,A.Kuijsten,andA.S.Tanenbaum,“Enhancedoperating
systemsecuritythroughefficientandfine-grainedaddressspacerandom-
ization,”inProceedingsofthe21stUsenixSecuritySymposium(Security),
REFERENCES Bellevue,WA,Aug.2012.
[1] “Apachehadoopproject.”[Online].Available:http://hadoop.apache.org/ [24] J.Hiser,A.Nguyen-Tuong,M.Co,M.Hall,andJ.W.Davidson,“Ilr:
Where’dmygadgetsgo?”inProceedingsofthe33rdIEEESymposium
[2] “Linux/unix nbench.” [Online]. Available: http://www.tux.org/~mayer/
onSecurityandPrivacy(Oakland),SanFrancisco,CA,May2012.
linux/bmark.html
[25] O.S.Hofmann,S.Kim,A.M.Dunn,M.Z.Lee,andE.Witchel,“Inktag:
[3] “Documentationforthepaxproject(addressspacelayoutrandomization),”
Secureapplicationsonanuntrustedoperatingsystem,”inProceedings
2003.[Online].Available:https://pax.grsecurity.net/docs/aslr.txt
14of the 18th International Conference on Architectural Support for usingsgx,”inProceedingsofthe36thIEEESymposiumonSecurityand
ProgrammingLanguagesandOperatingSystems(ASPLOS),Houston, Privacy(Oakland),SanJose,CA,May2015.
TX,Mar.2013. [47] D.Sehr,R.Muth,C.Biffle,V.Khimenko,E.Pasko,K.Schimpf,B.Yee,
[26] T.Hunt,Z.Zhu,Y.Xu,S.Peter,andE.Witchel,“Ryoan:Adistributed and B. Chen, “Adapting software fault isolation to contemporary cpu
sandbox for untrusted computation on secret data,” in Proceedings of architectures.”inProceedingsofthe19thUsenixSecuritySymposium
the12thSymposiumonOperatingSystemsDesignandImplementation (Security),Washington,DC,Aug.2010.
(OSDI),Savannah,GA,Nov.2016. [48] F.J.Serna,“Theinfoleakeraonsoftwareexploitation,”BlackHatUSA,
[27] Intel, Intel Software Guard Extensions Enclave Writer’s Guide, 2012.
2015, https://software.intel.com/sites/default/files/managed/ae/48/ [49] H.Shacham,“Thegeometryofinnocentfleshonthebone:Return-into-
Software-Guard-Extensions-Enclave-Writers-Guide.pdf. libcwithoutfunctioncalls(onthex86),”inProceedingsofthe14thACM
[28] ——,IntelSoftwareGuardExtensionsEvaluationSDKforWindowsOS, ConferenceonComputerandCommunicationsSecurity,Alexandria,VA,
2016,https://software.intel.com/en-us/sgx-sdk-support/documentation. Oct.–Nov.2007.
[29] ——, Intel(R) Software Guard Extensions SDK for Linux* OS, 2016, [50] H.Shacham,M.Page,B.Pfaff,E.-J.Goh,N.Modadugu,andD.Boneh,
https://01.org/sites/default/files/documentation/intel_sgx_sdk_developer_ “Ontheeffectivenessofaddress-spacerandomization,”inProceedingsof
reference_for_linux_os_pdf.pdf. the11thACMConferenceonComputerandCommunicationsSecurity,
[30] ——,IntelSoftwareGuardExtensionsProgrammingReference(rev2), Washington,DC,Oct.2004.
Oct.2014. [51] D.Shen,“Attackingyourtrustedcore:Exploitingtrustzoneonandroid,”
[31] P.Jain,S.Desai,S.Kim,M.-W.Shih,J.Lee,C.Choi,Y.Shin,T.Kim,
Blackhat,2015.
B.B.Kang,andD.Han,“Opensgx:Anopenplatformforsgxresearch,” [52] M.-W.Shih,M.Kumar,T.Kim,andA.Gavrilovska,“S-nfv:Securing
in Proceedings of the 2016 Annual Network and Distributed System nfvstatesbyusingsgx,”inProceedingsofthe2016ACMInternational
SecuritySymposium(NDSS),SanDiego,CA,Feb.2016. WorkshoponSecurityinSoftwareDefinedNetworks&NetworkFunction
[32] C.Kil,J.Jun,C.Bookholt,J.Xu,andP.Ning,“Addressspacelayout Virtualization. ACM,2016,pp.45–48.
permutation(aslp):Towardsfine-grainedrandomizationofcommodity [53] M.-W. Shih, S. Lee, T. Kim, and M. Peinado, “T-sgx: Eradicating
software,”inAnnualComputerSecurityApplicationsConference. IEEE, controlled-channel attacks against enclave programs,” in Proceedings
2006,pp.339–348. ofthe2017AnnualNetworkandDistributedSystemSecuritySymposium
[33] S. Kim, Y. Shin, J. Ha, T. Kim, and D. Han, “A first step towards
(NDSS),SanDiego,CA,Feb.2017.
leveraging commodity trusted execution environments for network [54] S.Shinde,Z.L.Chua,V.Narayanan,andP.Saxena,“Preventingyour
applications,”inProceedingsofthe14thACMWorkshoponHotTopics faults from telling your secrets: Defenses against pigeonhole attacks,”
inNetworks(HotNets),Philadelphia,PA,Nov.2015. arXivpreprintarXiv:1506.04832,2015.
[34] B.Lee,L.Lu,T.Wang,T.Kim,andW.Lee,“Fromzygotetomorula: [55] R. Sinha, M. Costa, A. Lal, N. Lopes, S. Seshia, S. Rajamani, and
Fortifyingweakenedaslronandroid,”inProceedingsofthe35thIEEE K.Vaswani,“Adesignandverificationmethodologyforsecureisolated
SymposiumonSecurityandPrivacy(Oakland),SanJose,CA,May2014. regions,” in Proceedings of the 2016 ACM SIGPLAN Conference on
[35] Y. Li, J. McCune, J. Newsome, A. Perrig, B. Baker, and W. Drewry,
ProgrammingLanguageDesignandImplementation,Jun.2016.
“Minibox:Atwo-waysandboxforx86nativecode,”inProceedingsof [56] R. Sinha, S. Rajamani, S. Seshia, and K. Vaswani, “Moat: Verifying
the 2014 ATC Annual Technical Conference (ATC), Philadelphia, PA, confidentialityofenclaveprograms,”inProceedingsofthe22ndACM
Jun.2014. ConferenceonComputerandCommunicationsSecurity,Denver,Colorado,
[36] L. Liu, J. Han, D. Gao, J. Jing, and D. Zha, “Launching return- Oct.2015.
orientedprogrammingattacksagainstrandomizedrelocatableexecutables,” [57] K.Z.Snow,F.Monrose,L.Davi,A.Dmitrienko,C.Liebchen,andA.-R.
in Trust, Security and Privacy in Computing and Communications Sadeghi,“Just-in-timecodereuse:Ontheeffectivenessoffine-grained
(TrustCom),2011IEEE10thInternationalConferenceon. IEEE,2011, addressspacelayoutrandomization,”inProceedingsofthe34thIEEE
pp.37–44. SymposiumonSecurityandPrivacy(Oakland),SanFrancisco,CA,May
[37] K.Lu,S.Nürnberger,M.Backes,andW.Lee,“Howtomakeaslrwin 2013.
theclonewars:Runtimere-randomization,”Feb.2016. [58] R.Strackx,Y.Younan,P.Philippaerts,F.Piessens,S.Lachmund,and
[38] K.Lu,C.Song,B.Lee,S.P.Chung,T.Kim,andW.Lee,“Aslr-guard:
T.Walter,“Breakingthememorysecrecyassumption,”inProceedings
Stoppingaddressspaceleakageforcodereuseattacks,”inProceedingsof oftheSecondEuropeanWorkshoponSystemSecurity. NewYork,NY,
the22ndACMConferenceonComputerandCommunicationsSecurity, USA:ACM,2009.
Denver,Colorado,Oct.2015. [59] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary stirring:
[39] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shafi, Self-randomizinginstructionaddressesoflegacyx86binarycode,”in
Proceedingsofthe19thACMConferenceonComputerandCommunica-
V. Shanbhogue, and U. R. Savagaonkar, “Innovative instructions and
softwaremodelforisolatedexecution.”inHASP@ISCA,2013,p.10. tionsSecurity,Oct.2012.
[40] I.Molnar,“Execshield,”newLinuxsecurityfeature,2003. [60] J. Wilander, N. Nikiforakis, Y. Younan, M. Kamkar, and W. Joosen,
“Ripe: Runtime intrusion prevention evaluator,” in Proceedings of the
[41] ——,“Nx(noexecute)supportforx86,2.6.7-rc2-bk2,”LWN.net,2004. 27thAnnualComputerSecurityApplicationsConference. ACM,2011,
[42] Nergal, “The advanced return-into-lib(c) exploits: Pax case study,” pp.41–50.
Phrack.[Online].Available:http://phrack.org/issues/58/4.html
[61] Y.Xu,W.Cui,andM.Peinado,“Controlled-channelattacks:Determin-
[43] J. Noorman, P. Agten, W. Daniels, R. Strackx, A. Van Herrewege, isticsidechannelsforuntrustedoperatingsystems,”inProceedingsof
C. Huygens, B. Preneel, I. Verbauwhede, and F. Piessens, “Sancus: the36thIEEESymposiumonSecurityandPrivacy(Oakland),SanJose,
Low-costtrustworthyextensiblenetworkeddeviceswithazero-software CA,May2015.
trusted computing base.” in Proceedings of the 22th Usenix Security [62] B.Yee,D.Sehr,G.Dardyk,J.B.Chen,R.Muth,T.Ormandy,S.Okasaka,
Symposium(Security),Washington,DC,Aug.2013.
N. Narula, and N. Fullagar, “Native client: A sandbox for portable,
[44] S.A.T.R.OllieWhitehouse,Architect,“Ananalysisofaddressspace untrustedx86nativecode,”inProceedingsofthe30thIEEESymposium
layoutrandomizationonwindowsvista,”Whitepaper,2007. onSecurityandPrivacy(Oakland),Oakland,CA,May2009.
[45] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing the [63] F.Zhang,J.Chen,H.Chen,andB.Zang,“Cloudvisor:retrofittingprotec-
gadgets: Hindering return-oriented programming using in-place code tionofvirtualmachinesinmulti-tenantcloudwithnestedvirtualization,”
randomization,”inProceedingsofthe33rdIEEESymposiumonSecurity in Proceedings of the 23rd ACM Symposium on Operating Systems
andPrivacy(Oakland),SanFrancisco,CA,May2012. Principles(SOSP),Cascais,Portugal,Oct.2011.
[46] F.Schuster,M.Costa,C.Fournet,C.Gkantsidis,M.Peinado,G.Mainar-
Ruiz,andM.Russinovich,“Vc3:Trustworthydataanalyticsinthecloud
15