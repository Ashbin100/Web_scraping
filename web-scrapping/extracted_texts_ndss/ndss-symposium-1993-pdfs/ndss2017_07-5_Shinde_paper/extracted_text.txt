P : Low-TCB Linux Applications
ANOPLY
with SGX Enclaves
Shweta Shinde Dat Le Tien† Shruti Tople Prateek Saxena
National University of Singapore University of Oslo National University of Singapore National University of Singapore
shweta24@comp.nus.edu.sg dattl@ifi.uio.no shruti90@comp.nus.edu.sg prateeks@comp.nus.edu.sg
Abstract—Intel SGX, a new security capability in emerging has been a threat to privileged software layer, often targeting
CPUs, allows user-level application code to execute in hardware- vulnerabilitiesinprivilegedcodesuchastheOS.Inthispaper,
isolated enclaves. Enclave memory is isolated from all other we envision providing the benefits of privilege separation and
software on the system, even from the privileged OS or hypervi- isolationbasedonastronglineofdefenseagainstOS-resident
sor. While being a promising hardware-rooted building block,
malware. Such a defense is based on a new trusted computing
enclaves have severely limited capabilities, such as no native
primitive, which can isolate a sensitive user-level application
access to system calls and standard OS abstractions. These OS
from a compromised OS. Hardware support for this primitive
abstractions are used ubiquitously in real-world applications.
has become available in commodity CPUs in the form of
Inthispaper,wepresentanewsystemcalledPANOPLYwhich Intel SGX, which can run such hardware-isolated application
bridges the gap between the SGX-native abstractions and the instances in enclaves [40]. Intel SGX provides a hardware-
standard OS abstractions which feature-rich, commodity Linux isolated memory region which can be remotely attested. SGX
applicationsrequire.PANOPLYprovidesanewabstractioncalleda
hardwaresupportsexecutionofmanyenclavessimultaneously.
micro-container(ora“micron”),whichisaunitofcodeanddata
isolated in SGX enclaves. Microns expose the standard POSIX Recent research has demonstrated how to enforce useful
abstractions to application logic, including access to filesystems, low-level guarantees using SGX — for instance, protection
network, multi-threading, multi-processing and thread synchro-
of certain cryptographic keys in memory [30], [32], [42],
nizationprimitives.Further, PANOPLY enforcesastrongintegrity
[44], [47], verifiable execution of code snippets [51], and
property for the inter-enclave interactions, ensuring that the
authenticated data delivery [56]. While these properties are
execution of the application follows the legitimate control and
useful, their applicability has been limited to small, selected
data-flow even if the OS misbehaves. Thus, commodity Linux
applications can enhance security by splitting their application piecesofapplicationlogicratherthanend-to-endapplications.
logic in one or more microns, or by importing micron-libraries, For larger, richer applications, the best known approache has
with little effort. In contrast to previous systems that enable been to use library OSes [21], [52]. In such architectures, the
comparable richness, PANOPLY offers two orders of magnitude application is bundled together with a large TCB of millions
lower TCB (about 20 KLOC in total), more than half of which of lines of code, emulating the OS logic inside the enclave.
is boiler-plate and can be automatically verified in the future.
We demonstrate how PANOPLY enables much stronger security In this paper, we propose a new system called PANOPLY,
in4real-worldapplications—includingTor,OpenSSL,andweb designedwithaneyetowardsminimizingTCBandyetoffering
services — which can base security on hardware-root of trust. rich OS abstractions to enclaved code. PANOPLY introduces
a new abstraction we call a micro-container (or “micron”
for short). A micron is a unit of application logic which
I. INTRODUCTION
runs on the Intel SGX hardware enclaves — thus it offers
Privilege separation and isolation are cornerstones in de- a strong isolation against an adversarial OS. Microns expose
sign of secure computer systems. Machine isolation is used the rich gamut of standard Linux abstractions to application
for designing fault-tolerant network services, virtualization logic, much more expressiveness in enclave-bound code than
for isolating OSes, library OSes and containers for isolat- several previous systems (e.g. Haven). For instance, micron-
ing applications. However, these primitives trust a privileged enabledlogiccanreadilyusemulti-processing(fork-exec),
software component (e.g. a hypervisor or OS) for ensuring multi-threading, event registration / callbacks (e.g. signals), in
theirclaimedsecurityguarantees.Forseveraldecades,malware addition to supporting the standard Linux system calls.
†This work was done while the author was a visiting graduate intern at PANOPLY prioritizes a minimal TCB over performance
NationalUniversityofSingapore. as a goal. It uses a simple design philosophy of delegate-
rather-than-emulate that contrasts previous systems (e.g. li-
brary OSes). PANOPLY delegates the implementation of OS
Permission to freely reproduce all or part of this paper for noncommercial abstractions to the underlying OS itself, rather than emulating
purposes is granted provided that copies bear this notice and the full citation
on the first page. Reproduction for commercial purposes is strictly prohibited
it inside the enclave. PANOPLY microns implement a small
without the prior written consent of the Internet Society, the first-named author set of checks which enables them to detect malicious re-
(for reproduction of an entire paper only), and the author’s employer if the sponse from the OS, and abort if so. In line with this design
paper was prepared within the scope of employment. choice, unlike library OSes, PANOPLY does not “virtualize”
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
micronsbygivingthemeachtheirownnamespace.Thischoice
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23500 eliminates a massive amount of namespace management logicthat emulates the underlying OS from the enclave TCB. With level protocol guarantees for their host application beyond
these simple design principles, we show that the total TCB key-protection. In all of our case studies, the porting effort
of PANOPLY can be about 20 KLOC (apart from the original is modest, incurring average 905 lines of code changes.
applicationlogic),whichis2ordersofmagnitudesmallerthan
previous LibraryOS systems. We believe such TCB is within We have compared PANOPLY application to a state-of-
realm of automated verification in the near future. the-art Linux library-OS called Graphene-SGX [3], [52] that
supportsSGXhardware.First,PANOPLYapplicationshavetwo
A second feature of PANOPLY is that it enables a plug- order of magnitude smaller TCB. Second, we find that the
and-play architecture, wherein security architects can create performanceofthetwoonourcasestudiesiscomparable.We
as many microns as needed and host them across multiple provide a detailed breakdown of the performance overheads
OS processes. Such a design keeps compatibility with multi- on real hardware in both systems. We find that most source
process and multi-threaded application designs — several of overhead is from the Intel’s SDK, incurred for creating and
applications such as servers inherently use multiple processes initializingemptyenclaves. PANOPLY-specificcodeintroduces
forsecurity(e.g.forprivilegeseparation),performance,aswell an additional average CPU overhead of 24%.
as for isolating crash failures (better availability). Security
architects can split monolithic applications across multiple
Contributions. In summary, we make the following contribu-
microns easily, or import security-sensitive libraries that are
tions in this paper:
implemented as microns. The PANOPLY architecture allows
analysts to partition application by adding modest amount • PANOPLY System. PANOPLY is the first system which
of annotation to source code and compiling with PANOPLY’s supports applications with multi-threading, multi-
infrastructure. PANOPLY instruments each micron to ensure processing, event management in enclaves. Our inter-
that all inter-micron control and data-flow interactions are micron flow integrity ensures that the applications
secured against the OS. In effect, PANOPLY ensures that an preserve the high-level guarantees.
application partitioned into multiple microns will either exe- • Usage in real-world Applications. We retrofit 4 appli-
cute with the same control and data-flow as the unpartitioned cations into PANOPLY architecture that require on an
originalapplication,evenunderadversarialinfluence,orabort. average 905 lines of code changes.
To achieve such a guarantee, we propose defenses that extend • Evaluation. After porting to PANOPLY, we report a
beyond simple data tampering attacks (e.g. Iago attacks [26]) performanceoverheadof24%andanaverageTCBin-
— our defenses enforce control and data-flow integrity for crease of 19.62 KLOC per application. In comparison
inter-enclave transitions, with freshness and authentication to previous systems, PANOPLY reduces the TCB by 2
guarantees built-in. orders of magnitude while lowering the performance
overhead by 5−10%.
PANOPLYmicronsexposeexpressiveOSabstractionstoap-
plication logic. To support these, we make several conceptual
advancesinitsdesignthatarenotofferedbyoff-the-shelfIntel
SDKs for SGX [8]. First, microns expose the POSIX abstrac- II. PROBLEM
tion of creating threads on demand, dynamically requesting
as many threads as the application needs. Previous systems A. Background: Intel SGX Enclaves
have limited this design to a pre-determined number of static
threads executable in an enclave. PANOPLY runtime library Existing hardware-based / hypervisor-based defenses
multiplexesadynamicnumberofthreadsovermultipleunder- againstcompromisedOSesprovideanisolatedexecutionspace
lyingenclaves.Second,PANOPLYproposesseveraldesignsfor for executing user-level applications. In the case of SGX,
supporting the semantics of fork-exec. PANOPLY allows these are referred to as enclaves, and a single application
microns to be hosted across multiple OS processes. Third, process can comprise of one or more enclaves. SGX assures
PANOPLY supportsthepthreadssynchronizationinterfaces, the confidentiality and integrity of all the sensitive code and
which includes mutexes, barriers, and so on using SGX- datacontainedwithinanenclave.TheIntelSGXSDKprovides
specific abstractions. Finally, as explained earlier, PANOPLY a function call mechanism for SGX applications via ECALL
automaticallyembedschecksatthemicroninterfaces,ensuring and OCALL. Specifically, an ECALL is a trusted function call
thatinter-enclavecontrolanddata-flowconformstothatofthe
thatentersanenclaveandOCALLisanuntrustedfunctioncall
original code. that leaves an enclave [17]. Thus, a user-level application can
invoke code inside an enclave via an Enclave Call (ECALL)
Results. We show 4 case studies of real applications that and get the return values. The enclave can invoke an Outer
use expressive features. The first case study is Tor, a popular Call(OCALL)toexecuteafunctionintheuntrustedportionof
distributed anonymous communication service [11]. We show the application and receive a return value. The enclave code
how Tor can leverage PANOPLY micron to provide a strong can access all the application memory outside whereas, the
security for its directory service protocol, basing security on non-enclave code cannot access the enclave’s memory. SGX
the SGX hardware-root-of-trust. The second case study is on CPU supports local and remote attestation, so as to check if
a web-servercalled H2O,which canself-attest thecorrectness the enclave has loaded the correct code. To this end, the CPU
/ integrity of the served content (e.g., such as in CDNs, computes a measurement by securely hashing the enclaves
serving static content over HTTPS). We also support two case initialstate.Thusanentitycanattestthemeasurementtoverify
studies of popular libraries, OpenSSL and FreeTDS, that can the initial state of the enclave confirming that the initial state
beimportedasmicronsinotherhostapplication.Thelibraries is “clean” [18], [23]. The enclave is created and loaded as
can be secured to protect secret keys and provide higher- expected without OS tampering.
21session_t session; Unprivileged  Privileged 
2certificate_credentials_t xcred; OS
Enclave Enclave
3/* Specify the callback function to be used*/
4#begin privilege_enclave
5 certificate_set_verify_function (xcred, _callback); (a) certificate_set_verify_function()
6#end privilege_enclave
7/* Initialize TLS session */
8 9i /n *it Se( t&s ne os ns -i do en f, auT lL tS_ pC rL iI oE rN iT t) i;
es */
x509_crt_check_hostname()
x509_crt_check_hostname()
10if(non-default)
11 #begin privilege_enclave (b)
12 priority_set_direct (session, "%UNSAFE_RENEGO"); false
true
13 #end privilege_enclave
14err = handshake(session); priority_set_direct
15... } (c) (“UNSAFE_RENEGOTIATION”)
16
17static int _callback (session_t session) {
18 x509_crt_t cert;
19 const char *hostname; Fig.2. (a)Calldropping,b)callspoofingandc)callreplayattacksperpetrated
20 ... bytheOSduringinter-enclaveinteractions.
21 #begin privilege_enclave
22 ret = x509_crt_check_hostname (cert, hostname);
23 #end privilege_enclave
24 if (!ret) SGXenclaves.Thetrustedcertificatemanagerserviceisshared
25 return CERTIFICATE_ERROR; across many applications, and by principle of least privilege,
26 ...
27 /* Validation successful, continue handshake */ is the only service with access to the “root certificate”. As
28 return 0; can be seen in Figure 1, the FreeTDS application validates a
29} presentedcertificatebyinvokingthetrustedcertificatemanager
30
31static SSL_CTX *tds_init_ssl(void) via standard OpenSSL interfaces. Specifically, the FreeTDS
32{... application does this in 3 steps: it registers a callback with
33 tds_mutex_lock(&tls_mutex);
the trusted certificate manager (Line 5), passes configuration
34 if (!tls_initialized) {
35 SSL_library_init(); options (Line 12), and invokes the certificate check (Line 22).
36 tls_initialized = 1;
37 } Attacks on Inter-Enclave Interactions. Note that the
38 tds_mutex_unlock(&tls_mutex);
FreeTDS application enclave invokes the certificate manager
39...}
enclave several times, passing rich data. Such communication
necessarily goes through an adversarial channel under the OS
Fig.1. CodesnippetfromFreeTDSapplicationforcertificatevalidatingof
control (e.g. an IPC call or control transfer in unprotected
remotedatabaseserver’scertificateusingOpenSSL.The#pragmasareadded
code). The OS knows the standard OpenSSL interfaces and
whileportingtheapplicationtoPANOPLY.
the semantics of its interfaces. If enclaves use the standard
interfaces of the Intel SDK, the OS can subvert the ap-
B. Attacks & Challenges plication’s guarantee by causing FreeTDS to accept invalid
certificates. We show concrete attacks on this interface in
To enable end-to-end security guarantees in real applica- Figure 2. First, the OS can drop the call on Line 5, thereby
tions,weaimtoaddressthreemainchallenges:(1)supportfor disallowing the application to register a callback. The attack
rich OS abstractions, (2) secure interactions between multiple is powerful because abort fails silently, with the effect that
enclaves, and (3) a minimal additional TCB. We demonstrate the certificate validity checks on Line 22 never execute. A
the gap in existing abstractions to meet these challenges with second attack opportunity is to effect a session downgrade
an example, for ensuring higher-level security properties. attack, by forcing the certificate manager to re-negotiate weak
SSLparameters[12],[13].TheSSLprotocolhasaknownflaw
Example. Consider FreeTDS [2], an application that imple- called a session re-negotiation vulnerability, which is patched
ments a streaming protocol (TDS [9]) for remote databases. bythecallonLine12.However,theOScanabortthismessage
Figure1showsaFreeTDScodesnippet,whichshowsthatthe andthiscausesthecertificatevalidationtoproceedwithunsafe
application uses the OpenSSL SSL/TLS library to establish a defaults silently. As a third example, the OS can perform
secure channel with a remote database. Each time it connects a session downgrade by replaying a call from a different
to a remote database, FreeTDS checks if the remote database (previous) session. Specifically, the OS can record the inter-
is an authorized service and has a valid SSL certificate, by enclave message transcript from a different session consisting
connecting to trusted certificate manager service. Our goal is of a invalid certificate with weaker parameters (requesting
tofortifytheFreeTDSapplicationagainstacompromisedOS, UNSAFE_RENEGOTIATION). The previous session would
ensuring a key end-to-end security property — the FreeTDS havefailed;however,theOScanreplayonerecordedmessage
application accepts a certificate as valid if and only if the from that transcript in a session with a strong certificate to
original application would have accepted it as is valid. The causeittodowngrade.AfinalandfourthattackisonLine22.
assumption is that the original application is bug-free, but the This is a data replay attack wherein the certificate manager
system administrators wish to secure it against the hosting returns false (signaling an invalid certificate), but the OS
service provider’s infrastructure, which may be infected. We drops the message and replays a true return value from a
can achieve such a defense by using Intel SGX enclaves. previous execution run.
In this example, we wish to run the FreeTDS application These attacks highlight that applications that aren’t de-
and the trusted certificate manager, each in their own separate signed with the objective of running on enclaved-abstraction
3TABLEI. COMPARISONOFPROGRAMMINGCONSTRUCTSUPPORTAND TABLEII. POSIXAPISUPPORTINPANOPLY.COLUMN3DENOTES
SECURITYPROPERTIESOFPANOPLYANDOTHEREXISTINGSYSTEMS NUMBEROFAPISFORSUB-CLASSESOFSERVICES.COLUMN4LISTSIF
THEPANOPLYCANGUARANTEETOPRESERVETHESEMANTICSOFTHE
Multi Thread SERVICE(SAFE)ORNOT(WILD).
Abstr Sys Threading Synch Fork Low
STI
actions Calls Stat Dyn Mutex All Exec TCB
POSIX #of API
IntelSDK (cid:55) (cid:88) (cid:55) (cid:88) (cid:55) (cid:55) (cid:55) (cid:88) ServiceDescription
Standard APIs Type
Haven (cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:55) (cid:55) (cid:55)
SGXGraphene (cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:88) (cid:55) (cid:55) ProcessCreationandControl 5 Safe
PANOPLY (cid:51) (cid:88) (cid:88) (cid:88) (cid:51) (cid:51) (cid:51) (cid:51) Signals 6 Wild
Timers 5 Wild
Core
FileandDirectoryOperations 37 Safe
Services
Pipes 4 Safe
will be susceptible to subtle vulnerabilities. Further, there is CLibrary(StandardC) 66 Wild
gap between the SGX-native low-level guarantees (of remote I/OPortInterfaceandControl 40 Wild
Real-TimeSignals 4 Wild
attestation and memory isolation) and those needed to ensure
ClocksandTimers 1 Wild
safe end-to-end execution of applications. Several previous Semaphores 2 Safe
Real-time
works have enforced confidentiality of private keys and au- MessagePassing 7 Safe
Extensions
thenticated data delivery, while our emphasis is on securing SharedMemory 6 Safe
AsynchronousandSynchronousI/O 29 Wild
the end-to-end application semantics.
MemoryLockingInterface 6 Wild
ThreadCreation,Control&Cleanup 17 Safe
Supporting Rich OS Abstractions With Low TCB. The ThreadScheduling 4 Wild
Threads
examplehighlightsanevenmorebasicchallengeinsupporting ThreadSynchronization 10 Safe
Extensions
real-world applications. The FreeTDS code snippet makes SignalDelivery 2 Wild
SignalHandling 3 Safe
extensive use of OS abstractions. The code is multi-threaded,
Total Total 254
where a new thread of execution is dynamically created for
each request to initiate connection with a new server. Line
33−38inFigure1showsthatallthreadsusemutexobjectsfor invoke system calls (e.g. filesystem, network, and so on)
synchronizing operations such as initializing the TLS library. just as non-enclave code in the same Linux process would.
The original application is not designed to be executed in Microns do have their private address space, which is isolated
multiple enclaves, which do not share any address space in enclaves, and can share an arbitrary amount of public
(unlike threads). The application assumes it can create an address space with the host process. By default, the code and
arbitrary number of threads at runtime on-demand. FreeTDS data of the micron-based logic is allocated in private memory.
uses standard system calls, such as gethostname() and There exists an explicit PANOPLY API by which micron can
poll () (implicitly for callback registrations). However, communicate with code outside.
SGX and Intel SDK do not provide native support for any
MicroncodehasaccesstoarichsubsetofthePOSIXv1.3
of these abstractions. Table I shows the gap between the
expressiveness offered by the Intel SDK, library OSes and the
API, listed in Table II which PANOPLY supports. The exposed
API includes system calls for filesystems, network, multi-
requirementsofreal-worldapplications.Theresearchquestion
processing, multi-threading, synchronization primitives (via
is how to enable support for such abstractions with minimal
pthreads), signals and event management (via libenv).
effort, enabling security architects to quickly experiment with
The service API’s are classified as SAFE or WILD based on
ways to privilege-separate their applications.
whether PANOPLY guarantees to preserve their semantics or
The state-of-the-art solutions for offering rich expressive- not.Specifically,forSAFEAPI’sPANOPLYguaranteesPOSIX
ness rely on library OSes (such as Haven [21] and Graphene- semantics and application can assume that semantic correct-
SGX [52]). Library OSes provide an abstraction of a vir- ness (barring aborts). The API design choice is intentionally
tualized process namespace to application code. Namespace chosensoastoeliminatemuchofsharedlibraries(e.g.libc)
virtualization requires emulating much of the OS logic within from the TCB of the enclave-enabled micron code. Figure 3
enclaves.Thisapproachoffersgoodcompatibilitywithexisting shows parts of a standard Linux application that would be in
code; however, it comes at the peril of bloating the enclave the TCB (shaded grey) in our architecture. PANOPLY embeds
TCB. Library OSes have reported TCB sizes in millions of a thin shim library which interfaces with the PANOPLY API.
lines code. Systems which have been formally verified have Theshimlibraryisaddedtoeachenclaveatcompile-time,and
been smaller by orders of magnitude [37]; thus, library OSes is largely transparent to the developer.
are not within the realm of practical verification in the near
future.
Compiled micron code includes PANOPLY’s shim library,
which plays a key role in protecting against a malicious
OS. First, the shim library acts as controller or manager and
III. SOLUTION
provides micron management functionalities such as support
A. PANOPLY Overview tocreate/destroymicronsandprovidingidentitymanagement
for microns, using SGX-specific features. More importantly,
PANOPLY provides a new design point in systems that
the shim code enforces a stronger integrity property across all
enable rich Linux applications on SGX enclaves. PANOPLY
microns in an application — it ensures that control and data-
providestheabstractionofamicro-containerormicron,which
flows between microns conforms to the control and data-flow
is a unit of application logic that is enclave-bound.
of the original application. We call this the inter-micron flow
A Linux process can import or host one or more microns. integrityproperty.Theshimensuresinter-micronflowintegrity
Microns do not get their own virtualized namespace, but by establishing an authenticated secure-channel protocol be-
instead share it with their host Linux process; that is, they tween microns automatically. To assert the importance of this
4Micron Source 1 Compiler 2 Creating
Code Instrumentation Microns
Enclave-bound Logic Enclave Enclave -bEou1n d M1
Add c alls to
Panoply Shim Lib Trusted SDK Lib Code
Non L- oe gn ic cl ave
libc.so
U Sn Dtr Ku s Lt ibe d
Programmer
Pa An Cdo hdp
e
F
cly
l ko
sA
w
P I
Pa Sn ho impl y
I
S
Sn
G
DtE
e KXl
2
PP aL
n
oplM y2
Linux User-level Process Annotations Panoply Application
Linux Kernel SGX Driver
Fig. 4. System Overview. PANOPLY takes in the original program and the
partitioningschemeasinput.Itfirstdividestheapplicationintoenclavesand
Fig.3. Overviewofcodenamearchitecture.Alltheregionswithinanenclave
aretrusted,theregionsshadedasblackareuntrusted,greyshadedregionsare
thenenforcesinter-micronflowintegrity,toproducePANOPLYapplication.
newlyadded/modifiedasapartofcodenamesystem.
system.Thecompilationphaseaddscodeforinter-micronflow
global property, we demonstrate real attacks on several case integrity and PANOPLY APIs.
studies similar to those in Section II-B, which succeed even if
Out-of-scope Goals. The choice of partitioning scheme is or-
memory isolation properties are enforced locally on all of the
thogonaltoourworkandislefttothesecurityanalyst.Existing
enclaves. Second, the shim library performs checks for Iago
tools for program partitioning could be leveraged here [22],
attacks[26],safeguardingagainstlow-leveldata-tamperingfor
[24].Instead,PANOPLYfocusesonportingthepartitionedcode
OSservices.Itactsasaninterfacetoinvokeotherservicessuch
to enclaves. PANOPLY does not reason about the functional
as threading, synchronization and event management.
correctness of original application implementation. Any bugs
ToachievelowTCB, PANOPLY choosesadelegate-rather- orvulnerabilitiesintheoriginalapplicationwouldpersistinthe
than-emulatestrategy.First,PANOPLYdelegatesallthesystem micron-based application. PANOPLY cannot prevent denial-of-
calls to the untrusted OS. PANOPLY intercepts the calls to serviceattacksfromtheOS,sinceSGXitselfdoesnotprovide
the glibc API, which allows us to leave the glibc library this guarantee. Our system currently does not take special
outside enclave TCB (Figure 3). Second, PANOPLY re-thinks measures to thwart enclave side-channels. However, one can
the design of threading, forking and other interfaces so as employ orthogonal defenses for enclave side-channels [30],
to not emulate the entire OS logic in the TCB, but instead [44]. Lastly, we blindly trust all analyst-inserted annotations
delegating it to the OS. PANOPLY delegates the scheduling and instrumentation to be secure and correct. We trust the
logicwiththeunderlyingOS.Thus,theapplicationscheduling SGX hardware, which includes a secure implementation of
is not guaranteed to be same as the original code (hence API (a)isolatedmemory,(b)cryptographicattestationforenclaves,
is WILD). However, this trade-off is justified because OS can and (c) random-number generator.
anyways launch a DOS attack and is in-charge of enclave
scheduling. As an advantage, it allows us to place minimal IV. PANOPLYDESIGN&SECURITY
number of checks within the enclave, thus significantly re-
ducing the TCB. Lastly, PANOPLY modularly includes API In designing PANOPLY, we aim to support essential UNIX
calls in the enclave i.e., only the APIs which are used by a abstractions as well as provide necessary security guarantees
givenenclave-boundcodeareincludedinsidetheenclave.This for single or multi-micron execution of an application. We
choice is inspired from micro-kernels to reduce the TCB. implement several checks within each micron, which allows
us to adhere to delegate-rather-than-emulate design decision.
We describe the important design choices in PANOPLY and its
B. Usage Model & Scope security guarantees.
PANOPLY consists of a set of runtime libraries (including
A. Runtime Micron Management
the shim library), and a build toolchain that assists developers
in preparing microns. PANOPLY takes as input the application PANOPLY processes the source code along with user an-
programsourcecodeandper-functionprogrammerannotations notations to identify how the analyst wishes to separate the
to specify which micron should execute that function. Thus, application logic among microns. As done in several other
if the analyst wishes to partition the application into multiple works [24], [35], PANOPLY partitions the micron application
microns,shecanannotatedifferentfunctionswithcorrespond- code accordingly. PANOPLY instruments it to output a micron
ing micron identifiers. Functions that are not marked with binary file (a shared library) at the end. The PANOPLY shim
any micron identifiers can be bundled and delegated to one library ensures that the final micron code supports secure
separate micron by default. In cases that PANOPLY is not micron initialization and inter-micron flow integrity.
able to identify the micron for a function, it prompts the
analyst for providing additional annotations or sanitization MicronInitializationandIdentityEstablishment.PANOPLY
code. PANOPLY instruments the application, creating multiple creates an instance of a micron within an enclave via Intel
micronbinaries,eachembeddedwithitsownshimcode.Each SGXSDKAPIwhichtakesthemicronbinaryfileasaninput.
microniscompiledasalibrarypackage(e.g.micron-A.so). PANOPLY generatesthemicronbinaryfilebasedonthedevel-
It consists of 3 libraries internally: PANOPLY shim library, the oper annotations provided in the source code. If the micron is
Intel SDK library and any other libraries that micron code created successfully, the hardware returns an identifier which
uses. Figure 4 shows the schematic view of the PANOPLY isauniquevalueforthatinstanceofmicron.TheOSassignsa
5Micron A Micron B Micron C Message Freshness: The OS can replay a previously cap-
B i A i B j tured message to arbitrarily invoke functions of the receiver
C j
microns (for e.g., line 25 in Figure 1). To prevent against
Call foo()
i replay attacks, PANOPLY ensures that every call message
Execute
foo() Call bar() from one micron to another is distinctly identifiable. This
j
allows us to maintain the freshness guarantees for every valid
W Aca ki _t ff oo or
i
W Aca ki _t bfo ar r
j
E bx ae rc (u )te m see ns ds ea rge mie cx rc oh nan gg ee nd erab te et swe aen 12m 8-i bcr iton fs r. esT ho na oc nh ci eev ue sit nh gis, Int th ee
l
j = j+1 Execute Send Ack_bar j j = j+1 SGX’s random number generator (RDRAND)1 at the start of
foo()
i = i+1 Send Ack_foo i = i+1 session with each micron, as a session-id between a pair of
i
microns. The nonce is incremented as a counter / sequence
(a) (b) (c) number in all the subsequent messages and authenticated-
encrypted to prevent the OS from tampering it. Each micron
Fig. 5. (a) Micron A is a sender micron that makes a call to foo function stores a mapping of micron-id (cid:55)→ session-id for ev-
in micron B. (b) Micron B is both a sender as well as receiver micron that erymicronitcommunicateswith.Figure5showstheprotocol
executesfunctionfooandinvokesfunctionbarinmicronC.(c)MicronCis
forcommunicatingbetweenthreemicrons.Thesenderattaches
areceivermicronthatexecutesfunctionbar.
this nonce in the first call message. The receiver verifies if the
incomingmessageisfromanauthorizedsender.Onvalidating
handle for this identifier, however PANOPLY does not trust the theauthenticityofthesender,itchecksifitisthefirstmessage
OS handles. Instead, PANOPLY shim library assigns a micron- from the particular sender during the application execution.
identity for each micron instance and internally maintains a If it is the first message of a session, the receiver sets the
mapping of this name and the hardware identifier returned nonce value as the session-id for communicating with the
by SGX. PANOPLY uses this micron-identity for all further sender micron. For other subsequent messages, the receiver
inter-micron interactions. Before starting any interactions, the micron checks if the session-id is in the expected sequence.
PANOPLY shim code attests other microns by the processor For all valid incoming call messages, the receiver micron
for an attestation quote and verifies the measurement from the executes the requested function and increments the session-id
public attestation service [33]. onsuccessfulexecutionofthefunction(Figure5(b),(c)).The
sender micron waits for the receiver micron to complete the
Inter-micron Flow Integrity. Inter-micron flow integrity en- execution and return (Figure 5 (a), (b)). Thus, the application
sures that the application exhibits the same control and data executes sequentially and proceeds in lock steps.
flow across multi-micron execution, as intended in the orig-
inal application. In our design, we consider the interaction Reliable Delivery: When delivering a message from one
between multiple microns as a communication protocol where microntoanother,theOScanarbitrarilydropthecallmessages
the adversarial OS acts as a mediator between the microns. (fore.g.,line4inFigure1).Thisresultsinsilentabort/failure
PANOPLYguaranteesthatmicronexecutionisprotectedagainst of the communication between two microns. To avoid this,
attacks such as silent aborts or message replay from the PANOPLY introduces an acknowledgment message similar to
underlying OS. For this purpose, PANOPLY enforces a secure ACK in the TCP protocol. After the receiver micron executes
and authenticated inter-micron protocol with the following the requested function in the call message, it appends the
design. session-id with an ACK message to the sender micron and
increments the session-id. The sender micron checks whether
Confidentiality & Integrity: During inter-micron commu- the session-id attached with the ACK is valid. If the check
nication, the (mediator) OS can observe all the information is successful, the sender micron increments its own session-id
that is exchanged between the microns. Moreover, it can and is ready to make the next call message to the receiver
changethevaluesoftheincomingandoutgoingmessagesfrom micron (Figure 5 (a), (b)). If the sender fails to receive
the microns. To block this capability of the OS, PANOPLY an acknowledgment, it successfully detects that the OS has
performs authenticated encryption of every incoming and silently dropped its messages. The sender micron aborts its
outgoing message of the micron. execution if the ACK is either not received or contains an
invalid session-id.
Sender / Receiver Authentication: When a micron is ex-
ecuting, the OS can impersonate to be a sender micron and
spoof spurious calls to a receiver micron (for e.g., Line 13 in B. Expressiveness with Low TCB
Figure1).Itcanalsoimpersonatetobeareceiverandhijackall
Enclaves are limited in terms of the programming ex-
the micron-bound calls. To prevent such spurious messaging
pressiveness they support. Specifically, standard C primitives
from the OS, PANOPLY ensures that only a pre-defined set of
such as system calls, networking APIs, file system operations,
authorized microns included in the application interact with
multi-threading, multi-processing and event handling do not
each other. For this, it makes use of the secure mapping of
workout-of-the-boxwithinenclaves.Asarecourse, PANOPLY
micron identities to its instance which is established during
addresses each of these limitations by creating microns.
themicroninitializationphase.PANOPLYshimcodechecksthe
authenticityofeachmicron-identityforallcall-retspoints
System Calls. Enclave code cannot directly make a system
—onlylegitimatecallsitescaninvoketherespectivefunctions
call to the OS. Therefore, PANOPLY redirects all the system
andreturnback.Further,italsochecksifaparticularmicronis
authorized to perform a given interaction. PANOPLY discards 1Thisnumberispassedthroughanextractortogenerateacryptographically
messages from unauthorized microns and aborts execution. securerandomnumber.
6calls from the enclave code to our custom wrappers in the Virtual Threads
PANOPLYshimlibrary.Theshimlibraryisresponsibletomake
the correct OCALL and ECALL to invoke these calls in the
OS. It is in-charge of exiting out of the enclave, executing the
systemcallintheuntrustedcomponentandrelayingthereturn
values back to the enclave. TCS TCS TCS TCS TCS TCS TCS TCS
1 2 3 4 1 2 3 4
Inside the shim, PANOPLY performs custom checks on Micron A Micron A’
the system call return values inside the enclave to defend Panoply Shim Lib Panoply Shim Lib
againstwell-knownclassofIagoattacks[26].Nearlytwothird
(205/309)ofthesystemcallsreturn0orerror,andanotherone Shared Variables
third (104/309) return an integer. In addition to return values, Thread Control
system calls can also return data via parameters passed by Manager
reference. Most of the parameters are data structures which
contain control fields. After checking the specifications of
Fig.6. Designforondemandmulti-threadinginPANOPLY.
all the system calls, we identify 50 system calls (16%) that
write information into 20 distinct structures. Most of them
(18 structures) only have integer field types, similar to return notperformedby PANOPLY sincethebuffersizeisnotknown
values. Other structures contain structure pointers or function statically. The developer can provide an upper bound based
pointers. Specifically, we add sanitization code to ensure that on the maximum file size. However, since there is no concrete
return values are consistent with the POSIX semantics. checkonthesizeofbuf,theoriginalcodeitselfissusceptible
to buffer overflow attacks.
Forreturnvaluesthathavestaticdatatypessuchasinteger
fieldswith0orerrorcalls,PANOPLYcomparesthereturnvalue
Multi-threading. Enclaves have a limited support for thread-
with 0 and a set of valid error numbers per system call. If it
ing — there is a gap between program abstractions in UNIX
detects return values such as invalid error numbers, then the
and that provided by SGX. In SGX SDK, the application
check reports failure. For return values that lie within a range,
has to statically determine how many and where the threads
PANOPLY checks that the return value conforms to a valid
are initialized. Intel SGX ensures that all the thread-local
rangedependingonthereturntype.Fore.g.,thereadsystem
memory (such as thread stack) is isolated from each other.
call in Linux has an integer return type as shown below.
It also provides a Thread Control Structure (TCS), a data
size_t read(int fd, void *buf, size_t len); structure to hold thread-specific information such as program
counter, stack pointer, register values, and execution context
The shim code knows the input length (len) requested state of the thread. Since the enclave has to know the total
by the application to read. Thus, it checks that the system call size to be allocated for saving TCS structures, the enclave
returnvalueandpass-by-referenceparameter(buf)islessthan has a statically pre-specified number (say, k) of TCS data
or equal to the requested length. This check limits the return structures. Thus, it can only support maximum k concurrent
value within a much smaller range than the original range of threads during the entire execution of the enclave. Thus, SGX
variable type. Similar to return values, PANOPLY sanitization does not allow to dynamically execute arbitrary threads on-
logic checks all the structures with integer fields returned by demand. Although the application can create threads outside
the system call. The policy is similar to the check on return theenclave,thenumberofconcurrentthreadsexecutinginthe
values — based on the field type, the code ensures that the enclave at a given time is limited to the pre-determined value.
value is within a valid range. Many applications do not fit in this regime of thread usage.
For instance, number of concurrent threads in a web server is
Fewofthesystemcallsreturnstructurepointersorfunction
a function of number of requests that the server has to serve.
pointers which are handled specially in our system. For e.g.,
connect system call returns a pointer to a structure of On-demand Threading: PANOPLY gives the abstraction of
sockaddrtypeasshownbelow.Forsuchdynamicdatatypes, arbitrary number of threads by supporting POSIX threading
PANOPLY library needs developer assistanace for performing (pthread) API. Applications can dynamically create threads
deep checks for such structures. For example, PANOPLY can by calling the standard pthread API. To support this abstrac-
check the fields of sa_family_t structure which itself is a tion, PANOPLY realizes the notion of virtual threads for the
field of sockaddr that is returned by the connect system applications. Figure 6 shows an overview of PANOPLY design
call with developer annotations for the correct bounds. to support on-demand multi-threading. Under the hood, it
multiplexes these virtual threads on the underlying enclave
int connect(int sockfd,
threads and uses the TCS structure and SGX threading APIs.
const struct sockaddr *serv_addr,
socklen_t addrlen); Specifically, PANOPLY threading API creates TCS structures
for a pre-determined pool of threads per micron (say k).
struct sockaddr {
sa_family_t sa_family; When a specific thread wants to enter an enclave, PANOPLY
char sa_data[14]; } first checks if the host-enclave can accommodate the thread
concurrently.Ifso,PANOPLYsetsthecorrectmicronid,thread
Note that PANOPLY’s checks do not protect against any arguments, and redirects the thread execution to enter the
vulnerabilities such as buffer overflow that are present within micron. The challenge is when a micron has already reached
the original application. For example, in the read call if the its maximum concurrent thread limit. At this point, there are
len is not provided, then a check for the buf variable is twodesignchoices:(a)evictanexecutingthreadandschedule
7the execution of the new thread (b) spawn a new micron to does not use all the parent data.
catertothek+1thread.Althoughevictionisacleansolution,
Strategy 2. A second alternative is a copy-on-demand
it incurs additional operations of save-restore and scheduling
strategy, similar to copy-on-write optimization for fork calls
inside the enclave. PANOPLY does not adopt this design and
in model Linux implementations. To achieve this for microns,
instead spawns a host enclave on-demand. Specifically, if the
we can implement a page-fault based on-demand data passing
micron reaches its maximum capacity of concurrent threads,
from parent to child micron. Specifically, the parent replicates
PANOPLY launches a new micron thus increasing the size of
and communicates its data to the child if and only if the
threads from k to 2k. This design choice comes with a caveat
thatallthesharedmemorybetweenthreadshastobeaccessible
child accesses it. To achieve this, PANOPLY can mark all
the parent micron’s pages as read-only (copy-on-write) and
across the two microns. To this end, PANOPLY introduces a
register custom page-fault handlers 2 inside both the microns.
thread control manager for such global thread memory that
acts as a reference monitor. For supporting (k +1)th thread, Whenever the child faults on a data page, the custom handler
can request the parent to communicate the data. We point
PANOPLY launches a new micron and all the shared memory
out that the support for registering page fault handling within
operations are performed via the thread control manager, as
enclaves is not currently enabled in the SGX hardware. To
done in a write-through cache. The PANOPLY shim library
overcome this limitation, we can modify the OS to notify the
is responsible for redirecting the micron code to this thread
micron on faults. The OS is not trusted to reliably uplift the
control manager if the total number of concurrent threads
fault to the user level. However, even if the OS suppresses
running is greater than k. When the threads are less than k,
faults, it does not weaken the security as the parent’s pages
they access the local copy via shim within the host enclave.
will still be sealed.
Synchronization:SGXSDKonlysupportsbasicthreadsyn-
Strategy3.Afinalstrategyistostaticallyidentifywhatdata
chronization primitives — spin locks and mutexes. However,
is accessed by the forked child micron. When the application
higher level synchronization primitives such as semaphores,
performsafork,theparentmicroncanreplicate/communicate
conditionalvariables,barriers,andread/writelocksarenotyet
these statically identified data values to the child micron. To
supported in SGX. Thus, the programmer has to realize these
reason about the incompleteness of the static analysis, the
constructs by using mutexes available with the limited SGX
systemcanraisearun-timeerrortoflaganydatavalueswhich
threading support. Instead, PANOPLY exposes the full suite
of pthread synchronization primitives inside the enclave. were not replicated. This way, the developer can add custom
code to replicate these values. In our experiment applications,
It implements these operations using the SGX’s mutex syn-
we observe that most of the data that is required by the
chronizationsupport. PANOPLY supportsthePOSIXthreading
APIpthreadforsemaphores,conditionalvariables,barriers, child micron is small and does not need full data space
and read / write locks operations based on SDK-supported
replication.Thus,PANOPLYcanstaticallyidentifythevariables
and communicate their values at fork and replicate them in
mutexes. For all synchronization operations which are local to
the child micron. Developer can additionally annotate data
a micron’s code, PANOPLY keeps the synchronization objects
variablesthataresharedbetweenparentandchildrenmicrons.
insidethemicron.Forglobalsynchronizationsacrossmicrons,
In many cases, strategy 3 is cleaner.
PANOPLY creates a notion of inter-micron locks. The thread
control manager micron holds and manages all such shared
PANOPLYprovidesagenericimplementationusingstrategy
objects and all global changes are synchronized via this
1, such that any application which uses fork can continue to
micron. Specifically, to either release or get hold of a lock,
execute without excessive developer efforts. In Section IV-D,
a micron has to invoke the thread control manager. The value
we discuss the details for implementing strategy 1 in existing
of the global objects can only be changed by a well-defined
SGXSDK.InthefuturewhentheSGX2hardwareisavailable,
set of microns, thus enforcing the right semantics of mutexes
strategy 2 can also be integrated in PANOPLY, subject to
for the objects.
specific design details of the SGX hardware. Currently for
cases where performance is critical, developers can chose to
Multi-processing. PANOPLY supports applications which use
resort to strategy 3.
the UNIX fork and exec APIs. For a fork system call,
PANOPLY library instructs the OS to launch a new untrusted In the case of exec, PANOPLY requests the OS to create
child process. This child process then creates a new micron a new untrusted process which launches a new micron for
with the same code as the parent micron. The PANOPLY the exec-ed code. This micron code is attested by using the
shim library performs micron initialization step and assigns SGXhardwareprimitivebeforetheexecutionbegins.Theshim
a micron-identity to this micron instance. Next, PANOPLY library assigns a micron identity to this micron for further
establishes a communication channel between the parent and interactionswithothermicrons.Forexec,staticidentification
all the children microns for maintaining the inter-micron flow and copy-on-demand strategy saves a lot of redundant copy
integrity. As per the POSIX fork semantics, the child must operations,sincethechildmicrondoesn’tneedaccesstoparent
replicate the data memory state of the parent micron. There data. For cases where strategy 3 is not sufficient, PANOPLY
are three possible strategies to ensure that the child micron resorts to using strategy 2.
has access to the parent’s data.
Shared Memory. To support shared memory between two or
Strategy 1. A straightforward way is to do a full replica of
more microns, PANOPLY establishes a shared secret between
parent micron’s data and communicate it to the child micron
over a secure communication channel at the fork call. This
2WithSGX2extensions,thehardwarecandirectlynotifytheenclavewhen
approach involves excessive micron-micron data copy and
the enclave code incurs a page fault along with the faulting virtual address,
slows down the application needlessly, even when the child pagepermissions,faulttypeandtheregistercontext[16],[39].
8thesemicronsusingsecureinter-micronprotocol.Themicrons correcttargetfunctiontobeexecutedinanothermicron,along
then use a public page as their shared memory resource. with the its current state. Hence, the adversary cannot tamper
Every microns seals the content and writes to the public page. the caller (checked at the entry) or forge the callee (created
Rest of the microns unseal the page content within their own at the exit). PANOPLY replaces all calls to non-micron code
addressspace.Thesealingisstandardauthenticatedencryption (such as system library APIs) with OCALLs. Further, each
with version control for preventing replay attacks [46]. This OCALLinterfaceisinstrumentedwithasetofchecksoninput
mechanism creates a notion of shared memory, such that each and output call parameters as discussed in Section IV. These
micron internally maintains a private copy of the memory and checks are best-effort, and the developer can add call-specific
allchangesaresynchronizedandbroadcastedbywritingsealed sanitization logic at any of these interfaces.
data to the public page.
For supporting multi-threading, PANOPLY needs to know
Event Management. PANOPLY applies the delegate strategy the set of memory that is concurrently accessed by multiple
tosupporteventbased-programminginsidetheenclaves.SGX threads. The developer can annotate all the such variables
hardware natively supports synchronous and asynchronous which are subject to operations from multiple threads. In
exits from the enclave. For synchronous and asynchronous ourcurrentimplementation,wemanuallyidentifiedconcurrent
exits, the hardware saves the execution state before exiting memoryaccessesforourcasestudies.Inthefuture, PANOPLY
the enclave, and restores it back when the enclave resumes. can perform precise pointer analysis to aid the developer
Forexample,iftheenclavereceivesaninterrupt,thehardware in identifying the complete set of corresponding operations
performsanAsynchronousEnclaveExit(AEX),savesthecur- on shared memory addresses. Once the shared variables and
rent processor state into enclave memory, enters the Interrupt operations are identified, PANOPLY redirects the access to all
Service Routine (ISR) and then finally restores the processor thesharedvariables,viatheshim.Theshimcodeisresponsible
state for resuming the enclave execution. In this case, the OS for deciding if the operations on shared variables are to be
is responsible for executing the ISR and scheduling back the performed locally to the micron or are to be carried out as
enclave execution. The hardware ensures that the OS cannot globaloperationsintandemwiththreadsinothermicrons.We
tamper any context registers during the exits. Thus, it is safe follow similar strategy to mark and mediate access to shared
todelegatetheeventlisteningandnotificationtaskstotheOS. memory and fork-exec process memory semantics.
PANOPLY uses the OS primitives of signals and interrupts
D. Implementation
toregistereventlisteners,callbacksandadddispatchhandlers.
Internally, PANOPLY hooks the underlying OS APIs and inter- We implement PANOPLY on top of the Intel SDK [8] 1.5
faces via OCALLs. Thus, PANOPLY enables event wait/notify Open Source Beta shipped for Linux Kernel v3.13. PANOPLY
mechanism, polling, event buffering, signal handling for en- comprises of a set of API libraries and build extensions. For
claves which are necessary for event management. Our API our case-studies, we annotate the application code to mark
is expressive to support event libraries such as libevent, which functions should execute in which micron. Then we
libev, in addition to hand-coded event loops. modifytheapplicationMakefiletousePANOPLYextensions
andlibrary.Weaddtheinterfacefile(.edl)forspecifyingall
C. The PANOPLY Infrastructure the enclave entry-exit points. The Intel SDK edger8r tool
uses these files to generate boiler-plate code stubs for enclave.
To use PANOPLY, akin to several partitioning tools [22],
PANOPLY then adds specific checks to each of these stubs.
[24], [35], the developer marks all functions to denote which
micron executes these functions. In case of our example in We implement the support for multi-processing (specifi-
Section II, the functions called on Line 5, 13, and 25 are cally, fork and exec) by patching the SGX SDK [6] and
markedtobeexecutedinapriviledgedmicronbyannotations. the corresponding SGX linux driver [7]. By default, when a
Rest of the functions in the program are explicitly marked to new process is created by fork, the SGX kernel driver data
be executed in a non-priviledged mircon. structures which map the enclave virtual addresses to the EPC
physical addresses for the parent process are copied over to
After establishing the set of all such micron-bound func-
the child process. Hence, when the child process spawns its
tions, PANOPLY analysisidentifiestheinter-microninteraction
enclave, the driver reads the data structures and assumes that
boundaries. Specifically, it constructs the program dependence
the VA space and the EPC PA addresses are already taken
graph consisting of control flow and data flow. The control
up. However, in reality these are stale mappings from the
flow graph comprises of micron function nodes connected by
parent enclave. If left unmodified, the SDK driver spawns the
call edges. Data flow graph comprises of all the parameters
child enclave in a new VA space, which does not overlap
passedbetweenmicronsandanysharedmemorysuchasglobal
with the existing mapping. This leads to a mismatch in the
variables. For cases where PANOPLY cannot precisely identify
child and parent’s VA layout. To work around this, our driver
the control and data-flow graph, it prompts the user to specify
code ensures that the start virtual addresses of all the children
the intended flows by adding annotations.
enclaves is same as that of the parent enclave. Specifically,
PANOPLY instrumentsalltheboundariesofthemicroni.e., when spawning a child enclave, PANOPLY ignores the VA-PA
the entry and exit points of the micron wherein the control mappinginheritedfromtheparentsenclave.Further,weensure
starts or ends the micron-bound execution. Each ECALL to be that the child’s enclave starts at the same virtual address as
executed inside the micron is mapped to an entry point and a the parent’s enclave. Once the address layouts are identical,
returnpoint.Forallsuchentrypointsinthemicron, PANOPLY PANOPLY shim code in the child enclave reads the sealed
adds code to check the caller’s identity as well as the caller’s contents (BSS, data, heap and stack sections) saved by parent
state.Atalltheexitpointfromthemicron, PANOPLY addsthe enclave and updates its own corresponding sections.
9V. EVALUATION ensure that even if 8 out of 9 DA servers are compromised, a
blacklistednodeisnotacceptedinthenetwork’s“good”view.
In this section, we show the effectiveness of PANOPLY
The attacker can only shut down the network. This high level
by porting popular real-world applications to microns and
property is hard to achieve without the use of byzantine fault
testingthemagainstasuiteofapplication-specificbenchmarks.
toleranceprotocol[25],[27],whicharebandwidthhoggingand
Specifically, we aim to evaluate PANOPLY for the following:
thus are not used in this application. Previous work by Jain et
• Expressiveness.Is PANOPLY successfulinsupporting
al. has only looked at a low-level property of protecting the
expressive programming constructs inside microns?
DA server’s private keys using SGX [32]. They port only the
• Stronger Security. Does PANOPLY enable stronger
key related operations to enclaves, and execute the rest of the
security guarantees for applications?
code outside the enclave. While this ensures that the attacker
• TCB. How much TCB reduction does PANOPLY
doesnotgetdirectaccesstothekey,itdoesnotguaranteethat
achieve over Library OSes?
Tor will always maintain the true state of the network.
• Performance.HowdoesPANOPLYperformcompared
to Library OSes? The Tor DA servers act as nodes and the messages they
exchangeactascontrolanddataflowedgesoftheblacklisting
All our experiments are measured on Inspiron-13-7359
consensus protocol. Even though each DA server’s secrets
machine with 6th Generation Intel(R) Core(TM) i7-6500U
are secured by enclaves, it does not ensure the integrity
processor and 8GB RAM. We configure the BIOS to use
of interactions between the DA servers. Specifically, in our
128 MB memory for SGX EPC. We use Linux 1.5 Open
extended technical report [45], we demonstrate 4 concrete
SourceBetaversionofIntelSoftwareGuardExtensionsSDK,
attacks, similar to our running example in Section II. The
Intel SGX Platform Software (PSW), and driver on Ubuntu
attacks use the following strategies to disrupt the consensus
Desktop-14.04-LTS 64-bits with Linux kernel version 3.13.
protocol between DA servers:
All our applications are compiled with GCC v4.8 and built
forSGXhardwarepre-releasemode(HW_PRERELEASE)with • Call tampering to change the network status votes
• Force silent failures, leading to vote withholding
default optimization flags and debug symbols. To measure
• Replace messages to allow compromised certificates
various statistics at run-time, we use Intel VTune Amplifier
• Replay compromised public keys
with SGX Hotspots analysis which is configured with the
standard parameters for SGX. All performance measurements
On the other hand, if we view the protocol amongst
are reported over an average of 5 runs.
these distributed nodes as a single process executing in a
singlecontiguousisolatedmemory,thenthecorrectnessofthe
A. Case Studies
consensusfollowsdirectly.Inthiscase,allthemessages(such
We select 4 application case-studies which highlight the as votes, and status objects) are generated and passed without
advantages of multi-micron architecture in applications. We any tampering from the byzantine adversary. There are only
successfullydemonstratethat PANOPLY canenableend-to-end two things that the adversary can do — abort the process or
guarantees rooted on SGX primitives as building blocks and proceed.Thispropertyholdstruebecausetheadversarycannot
support expressive programming constructs. The case studies tamper the execution flow inside the isolated memory.
include:
IfwemovetheentirelogicofeachDAservertoaseparate
• Tor v0.2.5.11, where multiple directory servers form
micron(i.e.,9micronsfor9DAservers),thenallthemessages
a distributed network
generated inside the micron are ensured to be untampered,
• H2O v2.0.0 webserver, with privilege separated sup-
they are executed in an isolated memory. Further, by the
port for Neverbleed [5]
virtue of inter-micron flow integrity, PANOPLY ensures that
• OpenSSL v1.0.1m library-as-a-service which can be
thecontrolanddataflowofinter-microninteractions(inter-DA
imported by any application
interactioninthiscase)ispreserved.Thus,PANOPLYallowsus
• FreeTDS v0.95.81 database client application
to achieve the same security guarantee as executing the entire
1)Stronger Security Property — Tor: Tor is an anony- Tor blacklisting consensus protocol in a single contiguous
mous communication system that routes the client request isolated memory. As discussed above, this ensures that the
through a circuit of (three or more) nodes. Tor is an open byzantine adversary can only abort the consensus, it cannot
distributednetworkwhichusesadirectoryprotocoltomaintain bias it. We implement this architecture for Tor with the help
a global view of “good” (or non-blacklisted) nodes in its of PANOPLY, as discussed in Section V-B.
network. All the routers in the network periodically send their
2)SupportingPrivilege-separation—H2O: In2014,the
status to a directory authority server (DA). Each DA collects
HeartbleedbuginOpenSSL’simplementationofTLSprotocol
these status reports to generate its local view of the network.
lead to leaking server’s private key due to a buffer over-read.
DA servers then run a form of consensus protocol to agree
Webserver implementations such as H2O HTTP2 server have
upon the set of global network nodes, wherein each DA sends
taken precautionary measures by separating the RSA private
asignednetworkstatusvoteobjecttopeerDAservers.Various
key operations in a privilege separated process since version
real-world attacks have targeted DAs by compromising either
1.5.0-beta4[5].Thisminimizestheriskofprivatekeyleakage
their private keys or forging status votes to create a dishonest
in case of vulnerability such as Heartbleed. In PANOPLY
view of the network, thereby causing malicious or blacklisted
design,theRSAkeyoperationsaremovedtoaseparatemicron
Tor nodes to be accepted in the network [10].
(RSAmicron)whereastherestofthewebservercodeexecutes
Goal: Our goal is to secure the Tor DA protocol against in another micron (H2O micron). The RSA micron comprises
a malicious OS on the DA servers. Specifically, we want to offunctionstoloadtheprivatekeyandtouseitforencrypting
10/ decrypting a given buffer and to sign the contents of a localattestation.Wechosethesameconfigurationasevaluated
buffer. The H2O micron invokes the RSA micron functions by previous works [32], [36]. We observe a maximum of 2
to perform functions such as rsa_sign, rsa_priv_enc threads executing in parallel for our configuration.
and rsa_priv_dec. PANOPLY ensures that the RSA keys
H2O. We configure H2O web server with Neverbleed plug-
aresafeinonemicrondifferentfromtherestoftheapplication.
in, YAML parser and the in-built event-loop implemented by
The application micron invokes the key-storage micron via
H2O. We further statically link H2O with OpenSSL library
PANOPLY’s interface.
which executes inside the webserver micron and includes
3)Supporting Enclaved-libraries — FreeTDS & the networking and multi-threading module of PANOPLY. We
OpenSSL: FreeTDS is an open source implementation of the make 154 LOC changes to the code to achieve this. The
TDS(TabularDataStream)protocolwhichallowsprogramsto application exposes 3 functions for inter-micron invocation.
natively talk to Microsoft SQL Server and Sybase databases. Further, we evaluate H2O performance with h2load which
It links to OpenSSL library to support SSL/TLS for its traffic. is a benchmarking tool for HTTP/2 [4]. We observe a total
TherunningexampleinSectionIIdemonstrateshowPANOPLY of 2 inter-micron messages and 128 PANOPLY API calls at
enables to split the FreeTDS logic inside two microns. run-time for H2O.
OpenSSL is a widely used open-source library for SS- FreeTDS. Our FreeTDS application uses OpenSSL library,
L/TLS protocols. It provides client and server-side imple- along with threading and network support from PANOPLY.
mentations for SSLv3, TLS along with the X.509 support We make 473 LOC changes to the application to compile
needed by SSL/TLS (libssl). Further, the core library also it with PANOPLY. We configure FreeTDS client application
implementsbasiccryptographicfunctions(libcrypto).Sev- witharemoteMicrosoft SQLdatabaseserver.Ourbenchmark
eral large-scale real life applications require SSL/TLS support makes 48 queries (1 create, 46 insert and 1 select) to the
for networking with clients, servers or peers. Hence, we use remotedatabaseserverandcollectstheresponsetime.Forthis
PANOPLY to execute OpenSSL inside a single micron. This workload, FreeTDS makes 3 inter-micron calls.
allows large scale applications to use OpenSSL library by
executing it inside the micron. It is up to the application’s OpenSSL.WeporttheOpenSSLlibraryincludingthecrypto-
security architect to decide if the application code executes graphicutilities(libcrypto)andtheTLS/SSLimplementa-
in the same micron as OpenSSL or as in a separate micron. tion (libssl). We re-use the partially ported OpenSSL code
For our case study we take a sample certificate verification available with the Intel SDK which only ports libcrypto.
application shipped with Intel SGX SDK [8]. The application Specifically, we enable the SSL protocol and the support for
comprises of two parts: (a) IO operations to read a list of executing OpenSSL engines inside the micron. We use the
certificatesfromaninputfileanddisplaytheresults(b)X.509 PANOPLY networking and file system APIs to achieve this
certificateverificationbyusingtheroot-certificate.Weseparate and change 307 LOC. We test the OpenSSL library with
the application into two microns — one for IO and one for its regression suite, and use the speed and tspeed utility
OpenSSL library. The OpenSSL micron uses programming to benchmark the performance of our OpenSSL library. We
constructssuchasthreadingandnetworkAPIs.TheIOmicron observe a total of 8 PANOPLY API calls at run-time along
usesfilesystemandstandardIOAPIs.Further,theattackercan with 1 inter-micron call.
attackthemicron-microninteractionsbyreplayingordropping
Comparison to Graphene-SGX. We attempted to port our
themessagesasoutlinedinourrunningexampleinSectionII.
4 case-studies to Graphene-SGX, by following the public
Theseattackstricktheapplicationtoacceptinvalidcertificates,
instructions [3] available at the time we performed our ex-
thusviolatingthehigherlevelguaranteeofacceptingonlyvalid
periments. We report that we were not able to port 3 out
certificates. PANOPLY enforcesinter-micronflowintegrityand
of 4 applications to Graphene-SGX— the applications either
ensures that all such attacks are thwarted.
crash or suspend during execution. Since there is no public
companion report, but only a large-scale system, it is hard to
B. Porting Effort evaluatethedesignreasonsofwhytheapplicationscrash.After
further investigation of the Graphene-SGX source-code, we
We make an average change of 905 lines of code per
were able to narrow down 2 cases which are problematic: (1)
applicationtoportittoPANOPLY[54].Wetestourapplications
the fork semantics break in H2O which launches neverbleed
with their regression test suite to ensure that our porting does
in a separate process (2) the epoll call does not receive the
not break the application.
socket events, thus the applications such as Tor and FreeTDS
Tor. Tor code uses 4 libraries — OpenSSL’s libcrypto never progress. Thus, our evaluation comparisons are best-
and libssl for SSL/TLS protocol, libevent for event effort. We have informed the authors to implement possible
handling, and libz for compression. We port all 4 libraries mitigations in their system for these issues.
along with Tor code to microns. In doing so, we make use of
PANOPLY’sthreading,multi-processandnetworkingAPIs.We C. Reduction in TCB
createtwomicronsasperthedesigndiscussedinSectionV-A.
PANOPLY achieves 2 orders of magnitude lower TCB
We make a total of 2685 LOC changes to the complete code-
as compared to state-of-art approaches such as Graphene-
base with the help of PANOPLY. To test for correctness, we
SGX [52] and Haven [21]. The size of compiled microns in
ensurethatmicron-codepassesallthe32testsintheregression
MB is an orders of magnitude smaller than Graphene-SGX.
suite shipped with Tor code. We evaluate Tor with a private
network comprising of 3 DA servers and 3 routers using PANOPLY TCB. PANOPLY adds an average of 19.62 KLOC
Chutney[1].Allthenodesexecuteonasinglemachineanduse perapplicationwhichis5.8%oftheoriginalapplicationcode.
11TABLEIII. TCBEVALUATION.THETABLESUMMARISESTHETCBCOMPONENTSOFPANOPLYANDGRAPHENE-SGXINTERMSOFLOCANDSIZEOFCOMPILED
ENCLAVEBINARIES.COLUMNS2-5REPORTTHEBREAK-DOWNFORTHELOCOFEACHCOMPONENTINCLUDEDINTHEMICRON,ANDCOLUMN6HIGHLIGHTSTHEPERCENTAGE
INCREASEINTHETCBDUETOPANOPLY.COLUMNS7-13REPORTTHELIBRARIESINCLUDED((cid:51))INTHECOMPILEDENCLAVEBINARY,ANDA(cid:55)DENOTESTHATTHEMICRONS
DONOTREQUIRETHELIBRARY.COLUMN14DENOTESTHETOTALSIZEOFCOMPILEDMICRONS.COLUMNS15-18DENOTETHECOMPILEDSIZEOFVARIOUSCOMPONENTS
INCLUDEDBYGRAPHENE-SGXTCB.COLUMN19REPORTSTHETOTALSIZEOFCOMPILEDENCLAVESFORGRAPHENE-SGX.
CaseStudy
PANOPLYTCBinLOC Split-upforPANOPLYTCB(inMB) Graphene(inMB)
E Ln oc gla iv ce Boi Cle or dp elate PA LN oO gP icLY Total %Inc (0li .b 7s 6s 5l ) lib (c 3r .y 7p )to (0l .i 1b 3z 7) lib (y 0r .0m 6c )ds l (i 0b .y 1a 8m 5)l l (ib 0.e 5v 7e 9n )t (S 0D .0K 5) En Sc izla eve PAL Enclave Tr Lu is bt sed SDK En Sc izla eve
OpenSSL 256987 9004 10425 276416 7.56 (cid:51) (cid:51) (cid:55) (cid:55) (cid:55) (cid:55) (cid:51) 5.88 1.84 0.067 64.58 0.05 64.69
H2O 414918 9189 10425 434532 4.72 (cid:51) (cid:51) (cid:55) (cid:51) (cid:51) (cid:55) (cid:51) 7.98 1.84 16 64.70 0.05 80.75
FreeTDS 297108 9788 10425 317321 6.80 (cid:51) (cid:51) (cid:55) (cid:55) (cid:55) (cid:55) (cid:51) 6.08 1.84 1.2 64.58 0.05 65.83
Tor 436385 8817 10425 455627 4.41 (cid:51) (cid:51) (cid:51) (cid:55) (cid:55) (cid:51) (cid:51) 13.18 1.84 7.0 63.94 0.05 70.99
TABLEIV. PERFORMANCEEVALUATION.COLUMNS2-5REPORTTHESTATISTICSABOUTPANOPLYMICRONS.COLUMNS6-9DENOTETHECPUCYCLESCONSUMEDBY
PANOPLY.COLUMNS10-12DENOTETHEEXECUTIONTIMEFOREACHCASESTUDYANDTHECONTRIBUTIONOFPANOPLYTOTHETOTALTIME.
Case No.of Inter- No.of No.of Split-upofCPUCycles(inbillions) CPUTime(inseconds)
Study Microns Micron OCALLs ECALLs Non-Micron Create Enclave Empty %
APIs /SDK Delete Logic
Total
Enclave
PANOPLY
Increase
OpenSSL 2 1 23695 1 0.25 6.06 0.11 6.43 2.79 3.16 13
H2O 2 1 124287 5 0.35 17.08 6.11 23.54 6.56 8.79 34
FreeTDS 2 1 86198 1 0.47 22.31 0.07 22.64 8.60 8.74 1
Tor 6 30 286459 5 6.65 11.77 2.58 17.41 4.54 6.72 48
Average 24
TABLEV. BREAKDOWNOFLOCANDTCBSIZESOFGRAPHENE-SGX
D. PANOPLY Performance
COMPONENTS.GLIBCLOCANDSIZECOMPUTATIONACCOUNTSFORTHEWHOLE
CODEBASECOMPRISINGOFALLLIBRARIESANDPLATFORM-SPECIFICCODE.
PANOPLY adds a 24% CPU overhead to the application’s
Component LOC Size(inMB) execution time (Table IV) on an average, over the baseline
glibc 1156740 56.9
costofcreatingemptyenclaves.Itachievescomparableperfor-
libPAL-LinuxSGX 16901 0.9
libPAL-enclave 33103 0.2 mance as Graphene-SGX, with PANOPLY’s overheads higher
SGXSDK 119234 0.5 by 5-10%. PANOPLY strictly prioritizes TCB over perfor-
Total 1325978 58.5
mance,anddoesnotincludeanyoptimizationssuchasbuffer-
ing. However, future systems can improve over PANOPLY by
incrementally adding optimization with careful considerations
Columns 2-5 in Table III shows the LOC split-up for each
for TCB bloat.
case-study. Out of the total LOC included by PANOPLY in
each micron, 9.2 KLOC (46.3%) of code is automatically
Performance Breakdown. We measure the micron execution
generated boilerplate code to facilitate OCALLs and ECALLs
bottlenecks as well as the breakdown for the total number of
mechanism. This code is generated by the Intel edger8r
CPU cycles it consumes. (Table IV) Column 6-9 present the
tool, which takes in a .edl interface file and creates stubs
averagenumberCPUcyclesthateachapplicationconsumesfor
for passing parameters across micron boundaries. We believe
variousoperationsduringitsentireexecution.Ourpreliminary
that this code is easy to automatically verify in the future. In
performance measurements identified that bulk of the CPU
terms of compiled code size, each micron binary includes the
cyclesarespentintheIntelSDK.Onfurtherinvestigation,we
original application logic, corresponding application libraries,
identified three main factors which contribute to this.
the trusted libraries added by Intel SDK and PANOPLY shim
library. Columns 7-14 in Table III show the split-up for the
First, the operation of creating and destroying enclaves
micron binary size. Note that PANOPLY selectively adds a takes up 6-7 billion CPU cycles for various sizes of enclaves.
library to a micron, if-and-only-if the micron code needs it.
We launch each of the application enclaves and destroy them
More importantly, PANOPLY does not include system libraries without executing any logic inside the enclave. Column 7 in
such as libc, libdl, libpthread in the micron.
Table IV denotes the number of cycles to do this for each
Comparison to Graphene-SGX TCB. We refer to the public
specificcase-study.TheseoperationsareperformedbytheIntel
release of Graphene-SGX [3] to compute the total LOC SDK,andarenotanartifactof PANOPLY’sdesign.Thus,96%
of system. Table V shows the LOC of each component in
of the CPU cycles are due to enclave launch and tear-down
Graphene-SGX, and the corresponding binary size. Graphene- (Column 7 vs Column 9 in Table IV). Taking this cost as a
SGX library comprises of a Platform Adaptation Layer, Linux baseline, PANOPLY has a 24% overhead.
library,andsystemlibrariesrequiredtosupportapico-process.
IntermsofLOC,thisamountstoanincreaseof1.326MLOC. Second, copying enclave data to-and-from non-enclave
When compared with PANOPLY, this amounts to 2 orders of memory contributes to significant fraction of CPU cycles
magnitude (127.19×) larger TCB. Note that the TCB and consumed by the application. Specifically, these operations
binary sizes are dependent on the application. We port our involve encryption-decryption of data entering/leaving the en-
four case studies to Graphene-SGX and measure the total clave memory, which consumes CPU cycles. For example, in
size of the binaries, since counting per-binary LoC is more the H2O application, the number and volume of such a copy
complicated.Columns15-19inTableIIIliststhebreakdownof operationisdirectlyproportionaltothesizeoftheservedweb-
size of each component. On an average, Graphene-SGX pico- page. To test this aspect, we measure the throughput of H2O
process binaries are an order of magnitude larger as compared webserver by serving two sizes of web-pages: 200 Bytes, 1
toPANOPLYmicrons.HavenreportsaTCBofmillionsoflines KB,and6KBforatotalof100,000requestsfrom100clients.
of code in the paper [21], however we do not have access to As shown in Figure 7, the webserver throughput decreases
the system to directly compare with PANOPLY. as we increase the size of the web-pages. The shaded-region
12100000 94933.2
90000 82480.69 80000
70000 66042.22
60000
50000 42293.46 48490.84
40000
30000
20000 12818.84
10000
0
200 Bytes 1KB 6KB
dnoces/stseuqeR
ni
tuphguorhT
Baseline H2O Panoply H2O
Size of served sta8c web-page
Fig.7. PANOPLYPerformancefor100000requestsofvariouspagesizes.
35
30
25
20
15
10 5 0 0 10 20 30 40 50 60 70
)sm(sdnocesilim
ni
ycnetaL
12
10.13 10.18 10 9.64 8.84
8
6
4
2 0.9 1 0.9 1.02
0.1 0.109 0.1 0.109
0
(512,10) (512,100) (512,1000) (1024,10) (1024,100) (1024,1000)
Baseline Graphene-SGX Panoply
Load size in MB
Fig.8. LMBenchLatencyPerformanceofPANOPLY&Graphene-SGX.
of the bar-graph denotes the fraction of execution time spent
in the SDK routine for OCALLs. Thus, larger the number of
OCALLs, the more is the overhead. As we can also see from
Table IV, applications which have less number of OCALLs,
exhibit lower overheads.
Third, all of our case studies use OpenSSL routines for
various operations ranging from SSL connections to cryp-
tographic operations. The OpenSSL library first checks if
the underlying hardware supports AES-NI via cpuid. If it
detects that the hardware supports, it uses the hardware AES
instructions for its cryptographic operations, otherwise it falls
back to a software implementation. In our experiments, we
observe that the OpenSSL library executing inside the enclave
fails to detect that our hardware has AES-NI support. Thus, it
uses a slower AES routine which adds latency by consuming
more CPU cycles. We suspect that the SDK has not rolled out
support for executing cpuid instruction inside the enclave.
This change was also proposed by previous work [21].
We point out that the Linux SDK itself does not use hard-
wareAES-NIinstructionsforencryption-decryption.Insteadit
uses software implementation of AES routine, as was pointed
out by recent public disclosures [34]. In our case studies,
this further amplifies the slow-down of each encrypt / decrypt
operation inside microns by 20% of the total execution.
Comparison to Graphene-SGX. Our design does not sig-
nificantly degrade the performance as compared to Graphene-
SGX.Wecomparetheperformanceoftwosystemsforexecut-
ingOpenSSL.Specifically,wetestvariedsizesandfrequencies
of data written out of the micron-enclave, since it is the main
factor for PANOPLY overheads. To this end, we configure
)dnoces(
emiT
Graphene-SGX Panoply
(Bytes, Connec2ons)
Fig.9. OpenSSLThroughputPerformanceofPANOPLY&Graphene-SGX.
120
100
80
60
40
20
0
afp _i t ucp npe i xs o sc ok ce k t strea rem ad r oe pa e Md n m2 acl p Mo rs m ee a a lip d br o ce pa be cd n o2 pcl y l u
u
io n nu bs r rcne o
o
a l lbl l li c e eg o d dn pe b py cd a ra oli >pg ay l n ue bn cd a oli pg y n ue nd al Mi M eg en mme ood r r yy pr ae ra >d a Ml M er e Me m ema ood mr r y oy r p y w ar r pi at > re a l > alw r rit ee a d M/ ewr mit ore y bzero
htdiwdnaB
Graphene-SGX Panoply
Fig.10. LMBenchBandwidthPerformanceofPANOPLY&Graphene-SGX.
a SSL client-server setup and measure the CPU execution
time for 6 configurations of number of requests and size of
payloads: 512 / 2014 bytes of data for each of the 10 / 100
/ 1000 client connections. Figure 9 depicts the performance
of Graphene-SGX and PANOPLY. For these configurations,
PANOPLY has 5-10% higher overheads than Graphene-SGX.
Sincecomparisonofasingleuser-applicationmaynotbea
conclusive evidence for the overall performance of PANOPLY,
we present a fair comparison of these two systems. Specifi-
cally, we port the LMBench benchmark to PANOPLY, which
is supported 3 by Graphene-SGX as well. Figures 8 and 10
present the latency and bandwidth performance of PANOPLY
and Graphene-SGX. Our first observation is that the perfor-
mance overheads of both the systems are significant over the
absolutebaselineofanativeapplicationexecutingwithoutany
enclave infrastructure. This re-iterates our earlier findings that
theslow-downduetoenclavelife-cycleoperations(createand
destroy) are common to any system that uses SGX. Secondly,
the memory latencies exhibited by PANOPLY and Graphene-
SGX are comparable. As shown in Figure 8, the PANOPLY
latency is almost-always lower than Graphene-SGX, whereas
both the systems exhibit similar overheads over an absolute
baseline. Finally, we measure the bandwidth for various types
of operations including network, memory, file IO for the two
systems.PANOPLYperformscomparabletoGraphene-SGXfor
memory and network operations (Figure 10). For file-backed
mmap operations, the overhead for PANOPLY is observably
3TheGraphene-SGXsystemisnotstablewhenexecutingthefullLMBench
benchmarksuite,andcrashesnon-deterministicallywithsegmentationfaults.
Theresultspresentedhereareassimilatedover24attemptedrunstogathera
fullsetofevaluation.
13larger than Graphene-SGX. Since PANOPLY performs these al.[20]proposefourpartitioningschemesrangingfromcoarse-
operations via libc interface, the number of enclave entry and grained partitioning (single enclave for whole application) to
exitsperoperationislarger.Ontheotherhand,Graphene-SGX ultra-fine partitioning (one enclave per application secret) for
usesanarrowerinterfaceandhenceforfileIO,itincursalower executing OpenSSL library in enclaves.
numberofenclavetransitions.Thisisoneofthefactorswhich
SGX Containers & Sandboxes using Enclaves. Scone [19]
causesthebandwidthvariationforthissubsetofIOoperations.
is a concurrent system which uses Intel SGX enclaves to
isolate docker containers running in a public cloud setting.
VI. RELATEDWORK
We summarise the key design differences between Scone and
PANOPLY is a new design point in SGX enclave design PANOPLY. Firstly, the interface exposed by PANOPLY is at
spacethatachieveslowTCBwhilemaintainingexpressiveness POSIX level, whereas Scone exposes a system call interface
forenclave-boundcode.PANOPLY’sinter-micronflowintegrity to the enclaves. As an artifact of this design choice, PANOPLY
guarantees a higher level security property, unlike previous does not execute any libc library inside the enclave. On the
systems which target low-level confidentiality primitives [47], other hand, Scone executes the libc library (specifically musl
[48]. We discuss how PANOPLY differs from existing systems libc) inside the enclave. Secondly, PANOPLY does a syn-
in terms of TCB, design goals, scope and end-to-end guaran- chronous exit for executing code outside the enclave, whereas
tees. Sconedoesanasynchronousexit.Thesetwovariationsleadto
a different design in terms of TCB, performance and system
TCB. PANOPLY design is driven by the delegate-rather-than- challenges. Thirdly, the on-demand threading model proposed
emulate philosophy, which is the key for lowering the TCB. byPANOPLYspawnsnewmicronsinseparateenclavestoscale
Specifically,wedonotperformnamespacemanagementinside thenumberofthreads.Thisway,eachthreadintheapplication
theenclave,whichiscommonapproachforlibraryOSdesigns. is associated with a unique thread in the enclave. Scone uses
ThegoaloflibraryOSesistoachieveanarrowABI[21],[41], a M:N threading model. Hence, when the application scales
[52], so as to maintain compatibility and portability. Hence, it threads, it is forced to multiplex on a limited number
these systems implement bulk of the system logic inside the of existing threads in a single enclave. Lastly, PANOPLY
library OS to map the system call APIs to their narrow ABI is designed for multi-process applications, which comprise
interface. In PANOPLY, we are not limited by these design of multiple micron containers and user processes. Hence its
choices. We expose a larger POSIX API to microns, and design comprises of in-built support for fork, exec, clone and
delegate all the system logic to underlying operating system. a secure communication interface between multiple microns
This is a reasonable choice because the OS can perpetrate the andprocesses.Sconeonlysupportsapplicationswithasingle-
same set of attacks even with a narrow interface. Thus, our container process running inside a single-enclave, which is a
designchoiceallowsustokeepsystemlibrariessuchaslibc subset of PANOPLY.
outside of TCB, while achieving the same level of security.
Ryoan [31] is a concurrent work for executing distributed
Security of Single Enclave. PANOPLY is the first system to SGX native client (NaCl) sandboxes. PANOPLY’s execution
demonstrate control and data-flow attacks on enclave-enclave modelofmulti-micronapplicationsvariesfromRyoan,sincein
interactions. It prevents such attacks by ensuring inter-micron PANOPLY,allmicronsthatbelongtothesameapplicationtrust
flow integrity. Recent works have pointed out that enclaves each other. Ryoan introduces a request-oriented data model
aresusceptibletosidechannelattacksviapagefaults[55]and where each enclave is in-charge of processing the input only
cache [28]. Currently, PANOPLY does not guarantee defenses once. Ryoan ensures that each service sandbox confines the
against such side-channels. However, applications can employ user-data to itself, while allowing mutually distrustful parties
off-the-shelf defenses proposed recently [29], [38], [43], [44]. to compute over sensitive data. In Ryoan, the NaCl executes
Weichbrodt et al. [53] recently showed that if the enclave the system calls and all the buffer and file IO operations are
logic has use-after-free or TOCTOU bugs, then the OS can backed by in-enclave memory.
exacerbate the effect of these bugs to perpetrate control-flow
attacks inside the enclave code. PANOPLY assumes that the VII. CONCLUSION
enclave is free of any logic or memory bugs. Strackx et al.
PANOPLY bridges the gap between expressiveness of
highlight that the adversary can shut down enclaves and abuse
the SGX-native abstractions and requirements of feature-rich
the execution by doing a hardware state-replay attack [49],
Linuxapplications. PANOPLY offersanewdesignpoint,prior-
[50]. PANOPLY can use their proposed solution to ensure
itizing TCB over performance, without sacrificing compatibil-
hardware state contiguity in the future.
ity.Itachieves2ordersofmagnitudelowerTCBthanprevious
systems.
Partitioning Applications for SGX. PANOPLY enables ex-
pressive enclave-bound code with a low TCB. Thus, it can
ACKNOWLEDGMENTS
execute maximum application logic inside one or more mi-
crons while ensuring that the PANOPLY application maintains We thank Mona Vij and Simon Johnson from Intel for
the security guarantee. However, PANOPLY leaves the choice their feedback. Thanks to Chia-Che Tsai and Donald Porter
of partition design to the security architect [22], [24], [35]. for releasing code and discussions on Graphene-SGX. This
Jain et al. [32] propose the use of enclaves to protect Tor research was partially supported by a grant from the National
DA server keys inside enclaves to protect against well-known ResearchFoundation,PrimeMinistersOffice,Singaporeunder
attacks[14],[15].Kimetal.[36]proposedesignstouseSGX its National Cybersecurity R&D Program (TSUNAMi project,
for networking applications such as SDN-based inter-domain No. NRF2014NCR-NCR001-21) and administered by the Na-
routing, Tor directory servers and ORs. Atamli-Reineh et tional Cybersecurity R&D Directorate.
14REFERENCES [32] P. Jain, S. Desai, S. Kim, M.-W. Shih, J. Lee, C. Choi, Y. Shin,
T.Kim,B.Kang,andD.Han,“OpenSGX:AnOpenPlatformforSGX
[1] “Chutney - The Chutney tool for testing and automating Tor network Research,”inNDSS2016.
setup,”https://gitweb.torproject.org/chutney.git.
[33] S. Johnson, V. Scarlata, C. Rozas, E. Brickell, and F. Mckeen, “Intel
[2] “FreeTDS:MakingtheleaptoSQLServer,”http://www.freetds.org/. Software Guard Extensions: EPID Provisioning and Attestation Ser-
[3] “Graphene-SGX Library OS - A Library OS for Linux Multi-process vices,”ser.IntelCorporation.
Applications, with Intel SGX support,” https://github.com/oscarlab/ [34] L.M.JPAumasson,“SGXSecureEnclavesinPractice:Securityand
graphene,(Accessedon12/06/2016,Commit9958214). CryptoReview—KudelskiSecurity,”BlackHatUSA,2016.
[4] “h2load - HTTP/2 Benchmarking Tool,” https://nghttp2.org/ [35] D. Kilpatrick, “Privman: A Library for Partitioning Applications,” in
documentation/h2load-howto.html. USENIXATC2003.
[5] “H2O Neverbleed: Privilege Separation Engine for OpenSSL / Li- [36] S. Kim, Y. Shin, J. Ha, T. Kim, and D. Han, “A First Step Towards
breSSL,”https://github.com/h2o/neverbleed. Leveraging Commodity Trusted Execution Environments for Network
[6] “IntelSGXforLinux,”https://github.com/01org/linux-sgx. Applications,”inHotNets2015.
[7] “IntelSGXLinuxDriver,”https://github.com/01org/linux-sgx-driver. [37] G.Klein,K.Elphinstone,G.Heiser,J.Andronick,D.Cock,P.Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell,
[8] “Intel Software Guard Extensions SDK - Documentation — Intel
H.Tuch,andS.Winwood,“seL4:FormalVerificationofanOSKernel,”
Software,”https://software.intel.com/en-us/sgx-sdk/documentation.
inSOSP2009.
[9] “[MS-TDS]: Tabular Data Stream Protocol,” https://
[38] S.Lee,M.Shih,P.Gera,T.Kim,H.Kim,andM.Peinado,“Inferring
msdn.microsoft.com/en-us/library/dd304523.aspx.
fine-grainedcontrolflowinsideSGXenclaveswithbranchshadowing,”
[10] “Tor Network Is Under Attack through Directory Authority Servers 2016.[Online].Available:http://arxiv.org/abs/1611.06952
Seizures,”http://thehackernews.com/2014/12/tor-network-hacked.html.
[39] F.McKeen,I.Alexandrovich,I.Anati,D.Caspi,S.Johnson,R.Leslie-
[11] “TorProject:AnonymityOnline,”https://www.torproject.org/. Hurd, and C. Rozas, “Intel Software Guard Extensions Support for
[12] “CVE-2009-3555 TLS Session Renegotiation Vulnerability,” https:// DynamicMemoryManagementInsideanEnclave,”inHASP2016.
cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555,2009. [40] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shafi,
[13] “RFC5746-TransportLayerSecurity(TLS)RenegotiationIndication V. Shanbhogue, and U. R. Savagaonkar, “Innovative Instructions and
Extension,”https://tools.ietf.org/html/rfc5746,February2010. SoftwareModelforIsolatedExecution,”inHASP2013.
[14] “Tor Project Infrastructure Updates in Response to Security Breach,” [41] D.E.Porter,S.Boyd-Wickizer,J.Howell,R.Olinsky,andG.C.Hunt,
http://archives.seul.org/or/talk/Jan-2010/msg00161.html,012010. “RethinkingtheLibraryOSfromtheTopDown,”inASPLOS2011.
[15] “Possible Upcoming Attempts to Disable the Tor Network — The [42] F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado,
TorBlog,”https://blog.torproject.org/blog/possible-upcoming-attempts- G.Mainar-Ruiz,andM.Russinovich,“VC3:TrustworthyDataAnalyt-
disable-tor-network,122014. icsintheCloud,”inIEEESymposiumonSecurityandPrivacy2015.
[16] “Software Guard Extensions Programming Reference Rev. 2.” [43] M.-W. Shih, S. Lee, T. Kim, and M. Peinado., “T-SGX: Eradicating
software.intel.com/sites/default/files/329298-002.pdf,Oct2014. Controlled-ChannelAttacksAgainstEnclavePrograms,”inNDSS2017.
[17] “Intel Software Guard Extensions Enclave Writer’s Guide,” [44] S.Shinde,Z.L.Chua,V.Narayanan,andP.Saxena,“Preventingpage
https://software.intel.com/sites/default/files/managed/ae/48/Software- faultsfromtellingyoursecrets,”inAsiaCCS2016.
Guard-Extensions-Enclave-Writers-Guide.pdf,2015. [45] ShwetaShindeandDatLeTienandShrutiTopleandPrateekSaxena,
[18] I. Anati, S. Gueron, S. P. Johnson, and V. R. Scarlata, “Innovative “Panoply:Low-TCBLinuxApplicationsWithSGXEnclaves,”National
TechnologyforCPUBasedAttestationandSealing,”inHASP2013. UniversityofSingapore,Tech.Rep.,Dec2016.
[19] S. Arnautov, B. Trach, F. Gregor, T. Knauth, A. Martin, C. Priebe, [46] ShwetaShindeandShrutiTopleandDeepakKathayatandPrateekSax-
J.Lind,D.Muthukumaran,D.O’Keeffe,M.L.Stillwell,D.Goltzsche, ena,“PodArch:ProtectingLegacyApplicationswithaPurelyHardware
D.Eyers,R.Kapitza,P.Pietzuch,andC.Fetzer,“SCONE:SecureLinux TCB,”NationalUniversityofSingapore,Tech.Rep.,Feb2015.
ContainerswithIntelSGX,”inOSDI2016. [47] R. Sinha, M. Costa, A. Lal, N. P. Lopes, S. Rajamani, S. A. Seshia,
[20] A. Atamli-Reineh and A. Martin, ch. Securing Application with Soft- and K. Vaswani, “A Design and Verification Methodology for Secure
warePartitioning:ACaseStudyUsingSGX. IsolatedRegions,”inPLDI2016.
[21] A.Baumann,M.Peinado,andG.Hunt,“ShieldingApplicationsfrom [48] R. Sinha, S. Rajamani, S. Seshia, and K. Vaswani, “Moat: Verifying
anUntrustedCloudwithHaven,”inOSDI2014. ConfidentialityofEnclavePrograms,”inCCS2015.
[22] A.Bittau,P.Marchenko,M.Handley,andB.Karp,“Wedge:Splitting [49] R. Strackx, B. Jacobs, and F. Piessens, “ICE: A Passive, High-speed,
ApplicationsintoReduced-privilegeCompartments,”inNSDI2008. State-continuityScheme,”inACSAC2014.
[23] E. Brickell, J. Camenisch, and L. Chen, “Direct Anonymous Attesta- [50] R. Strackx and F. Piessens, “Ariadne: A Minimal Approach to State
tion,”inCCS2004. Continuity,”inUSENIXSecurity2016.
[24] D. Brumley and D. X. Song, “Privtrans: Automatically Partitioning [51] F. Tramer, F. Zhang, H. Lin, J.-P. Hubaux, A. Juels, and E. Shi,
ProgramsforPrivilegeSeparation,”inUSENIXSecurity2004. “Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell
Knowledge,”CryptologyePrintArchive,Report2016/635,2016.
[25] M. Castro and B. Liskov, “Practical Byzantine Fault Tolerance,” in
OSDI1999. [52] C.-C.Tsai,K.S.Arora,N.Bandi,B.Jain,W.Jannen,J.John,H.A.
Kalodner,V.Kulkarni,D.Oliveira,andD.E.Porter,“Cooperationand
[26] S. Checkoway and H. Shacham, “Iago Attacks: Why the System Call
SecurityIsolationofLibraryOSesforMulti-ProcessApplications,”in
APIisaBadUntrustedRPCInterface,”inASPLOS2013.
EuroSys2014.
[27] A.Clement,E.Wong,L.Alvisi,M.Dahlin,andM.Marchetti,“Making
[53] N.Weichbrodt,A.Kurmus,P.Pietzuch,andR.Kapitza,“AsyncShock:
ByzantineFaultTolerantSystemsTolerateByzantineFaults,”inNSDI
ExploitingSynchronisationBugsinIntelSGXEnclaves,”inESORICS
2009.
2016.
[28] V. Costan and S. Devadas, “Intel SGX Explained,” Cryptology ePrint
[54] D.Wheeler,“SLOCcount,”http://www.dwheeler.com/sloccount/.
Archive,Report2016/086,2016,http://eprint.iacr.org/2016/086.
[55] Y. Xu, W. Cui, and M. Peinado, “Controlled-Channel Attacks: De-
[29] V. Costan, I. Lebedev, and S. Devadas, “Sanctum: Minimal Hardware
terministic Side Channels for Untrusted Operating Systems,” in IEEE
ExtensionsforStrongSoftwareIsolation,”inUSENIXSecurity2016.
SymposiumonSecurityandPrivacy2015.
[30] T.T.A.Dinh,P.Saxena,E.-C.Chang,B.C.Ooi,andC.Zhang,“M2R:
[56] F.Zhang,E.Cecchetti,K.Croman,A.Juels,andE.Shi,“TownCrier:
Enabling Stronger Privacy in MapReduce Computation,” in USENIX
An Authenticated Data Feed for Smart Contracts,” Cryptology ePrint
Security’15.
Archive,Report2016/168,2016,http://eprint.iacr.org/2016/168.
[31] T.Hunt,Z.Zhu,Y.Xu,S.Peter,andE.Witchel,“Ryoan:ADistributed
SandboxforUntrustedComputationonSecretData,”inOSDI2016.
15