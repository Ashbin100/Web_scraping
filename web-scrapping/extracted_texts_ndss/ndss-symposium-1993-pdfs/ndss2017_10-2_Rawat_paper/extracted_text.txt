VUzzer: Application-aware Evolutionary Fuzzing
Sanjay Rawat∗†, Vivek Jain‡, Ashish Kumar‡, Lucian Cojocar∗†, Cristiano Giuffrida∗† and Herbert Bos∗†
∗Computer Science Institute, Vrije Universiteit Amsterdam
<s.rawat,lucian.cojocar>@vu.nl; <giuffrida,herbertb>@cs.vu.nl
†Amsterdam Department of Informatics
‡ International Institute of Information Technology, Hyderabad
<vivek.jain,ashish.kumar>@research.iiit.ac.in
Abstract—Fuzzing is an effective software testing technique answeringtwo questions:where to mutate (whichoffset inthe
to find bugs. Given the size and complexity of real-world input) and what value to use for the mutation? The problem
applications, modern fuzzers tend to be either scalable, but not is that AFL is completely application-agnostic and employs
effective in exploring bugs that lie deeper in the execution, or a blind mutation strategy. It simply relies on generating a
capableofpenetratingdeeperintheapplication,butnotscalable.
huge amount of mutated inputs in the hope of discovering
In this paper, we present an application-aware evolutionary a new basic block. Unfortunately, this approach yields a slow
fuzzingstrategythatdoesnotrequireanypriorknowledgeofthe fuzzingstrategy,whichcanonlydiscoverdeepexecutionpaths
application or input format. In order to maximize coverage and by sheer luck. Fortunately, we can increase the efficiency of
exploredeeperpaths,weleveragecontrol-anddata-flowfeatures AFL-like fuzzers manifold by accounting for information that
basedonstaticanddynamicanalysistoinferfundamentalprop- answers the questions above.
erties of the application. This enables much faster generation of
interesting inputs compared to an application-agnostic approach. In this direction, the use of symbolic and concolic execu-
We implement our fuzzing strategy in VUzzer and evaluate it tion has shown promising results [33], [47]. Driller [47] uses
on three different datasets: DARPA Grand Challenge binaries
concolic execution to enable AFL to explore new paths when
(CGC), a set of real-world applications (binary input parsers),
it gets stuck on superficial ones. However, fuzzers like AFL
andtherecentlyreleasedLAVAdataset.Onallofthesedatasets,
are designed to target arbitrarily large programs and, in spite
VUzzer yields significantly better results than state-of-the-art
of several advancements, the application of symbolic/concolic
fuzzers, by quickly finding several existing and new bugs.
techniques to such programs remains a challenge [10]. For
example, Driller was benchmarked with 126 DARPA CGC
I. INTRODUCTION
binaries [15] and when AFL got stuck on 41 such binaries, its
Fuzzing is a testing technique to catch bugs early, before concolic engine could only generate new meaningful inputs
they turn into vulnerabilities. However, existing fuzzers have from 13 of such binaries. The results reported in the LAVA
been effective mainly in discovering superficial bugs, close to paper[17]evidencesimilarproblemswithsymbolicexecution
the surface of software (low-hanging bugs) [13], [17], while approaches. In another recent study [50], the authors reported
struggling with more complex ones. Modern programs have that symbolic execution-based input generation (using KLEE)
a complex input format and the execution heavily depends isnotveryeffectiveatexploringmeaningfulanddeeperpaths.
on input values conforming to the format. Typically, a fuzzer In essence, while combining fuzzing with symbolic execution
blindly mutates values to generate new inputs. In this (pes- is an interesting research area, this approach also significantly
simistic)scenario,mostoftheresultinginputsdonotconform weakens one of fuzzing’s original key strengths: scalability.
to the input format and are rejected in the early stages of
the execution. This makes a traditional random fuzzer often In this paper, we present VUzzer, an application-aware
ineffective in finding bugs that hide deep in the execution. evolutionaryfuzzerwhichisbothscalableandfasttodiscover
bugs deep in the execution. In contrast to approaches that
State-of-the-art fuzzers such as AFL [52] employ evolu-
optimizetheinputgenerationprocesstoproduceinputsatmax-
tionary algorithms to operate valid input generation. Such
imumrates,ourworkexploresanewpointinthedesignspace,
algorithmsemployasimplefeedbacklooptoassesshowgood
where we do more work at the front-end and produce fewer
an input is. In detail, AFL retains any input that discovers a
but better inputs. The key intuition is that we can enhance the
new path and mutates that input further to check if doing so
efficiency of general-purpose fuzzers with a “smart” mutation
leads to new basic blocks. While simple, this strategy cannot
feedback loop based on control- and data-flow application
effectively select the most promising inputs to mutate from
features without having to resort to less scalable symbolic
the discovered paths. In addition, mutating an input involves
execution. We show that we can extract such features by
lightweight static and dynamic analysis of the application
during fuzzing runs. Our control-flow features allow VUzzer
Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation to prioritize deep (and thus interesting) paths and deprioritize
on the first page. Reproduction for commercial purposes is strictly prohibited frequent (and thus uninteresting) paths when mutating inputs.
without the prior written consent of the Internet Society, the first-named author Our data-flow features allow VUzzer to accurately determine
(for reproduction of an entire paper only), and the author’s employer if the
where and how to mutate such inputs.
paper was prepared within the scope of employment.
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
Thanks to its application-aware mutation strategy, VUzzer
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23404 is much more efficient than existing fuzzers. We evalu-ated the performance of VUzzer on three different datasets: inthehopeoftriggeringbugsonsomeofthesepath[14],[28],
a) the DARPA CGC binaries [15], a collection of artificially [44], [47], [52]. VUzzer is a coverage-based fuzzer.
created interactive programs designed to assess bug-finding
Bydefinition,acoverage-basedfuzzeraimsatmaximizing
techniques; b) a set of Linux programs with varying de-
the code coverage to trigger paths that may contain bugs. To
greesofcomplexity(djpeg,mpg321,pdf2svg,gif2png,
maximize code coverage, the fuzzer tries to generate inputs
tcpdump, tcptrace) and c) the recently released binaries
such that each input (ideally) executes a different path. There-
from the LAVA team [17], a number of Linux utilities with
fore, it is of paramount importance for a fuzzer to account for
several injected bugs. In our experiments on the different
the gain obtained for each generated input, a property that we
datasets, we outperformed AFL by generating orders of mag-
term input gain (IG). IG is defined as the ability of an input
nitude fewer inputs, while finding more crashes. For example,
to discover a new path either by executing new basic blocks
in mpg3211, we found 300 unique crashes by executing 23K
or increase the frequency of previously executed basic blocks
inputs, compared to 883K inputs to find 19 unique crashes
(e.g., loop execution).
with AFL.
Obviously, a coverage-based fuzzer is effective if it fre-
Contributions: We make the following contributions:
quently generates inputs with non-zero IG. It is not hard to
1) We show that modern fuzzers can be “smarter” without notice that the ability to generate inputs with non-zero IG
resorting to symbolic execution (which is hard to scale). requires addressing our two questions in Section I (where
Our application-aware mutation strategy improves the and what to mutate). Unfortunately, most existing fuzzers,
input generation process of state-of-the-art fuzzers such especially mutation-based ones make little effort to achieve
as AFL by orders of magnitude. this goal. For example, let us consider the code snippet in
2) We present several application features to support mean- Listing. 1.
ingful mutation of inputs.
1...
3) WeevaluateVUzzer,afullyfunctionalfuzzerthatimple- 2read(fd, buf, size);
ments our approach, on three different datasets and show 3if (buf[5] == 0xD8 && buf[4] == 0xFF) //noticetheorderofCMPs
4 ... some useful code ...
that it is highly effective. 5else
4) To foster further research in the area and in support of 6 EXIT ERROR(”Invalid file\n”);
openscience,weareopensourcingourVUzzerprototype, Listing1. SimplemultibyteIFcondition.
available at https://www.vusec.net/projects/fuzzing.
In this code, buf contains tainted data from the input. On
II. BACKGROUND this simple code, AFL runs for hours without making any
progress to go beyond if condition. The reason for this rather
In this section, we cover the background required for our pessimisticbehavioristwofold:(i)AFLhastoguesstheFFD8
discussion of VUzzer in subsequent sections.
byte sequence exactly right; (ii) AFL has to find the right
offsets (4 & 5) to mutate. As AFL is a coverage-based fuzzer,
A. A Perspective on Fuzzing for an input which fails the if condition and thus results in a
new path (the else branch), AFL may focus on exploring this
Fuzzing is a software testing technique aimed at finding
new path even if the path leads to an error state. In such case,
bugs in an application [35], [48]. The crux of a fuzzer is
AFL gets stuck in the else branch. Symbolic execution-based
its ability to generate bug triggering inputs. From an input
solutions such as Driller [47] may help AFL by providing an
generationperspective,fuzzerscanbemutation-orgeneration-
inputwiththerightbyteattherightoffset.However,thisisnot
based.Mutation-basedfuzzersstartwithasetofknowninputs
a definitive solution, because, with this new input, AFL again
foragivenapplicationandmutatetheseinputstogeneratenew
starts mutating at random. In the process, it may try mutating
inputs. In contrast, generation-based fuzzers first learn/acquire
these offsets again, wasting processing power and time.
theinputformatandgeneratenewinputsbasedonthisformat.
VUzzer is a mutation-based fuzzer. 1...
2read(fd,buf,size);
Withrespecttoinputmutation,fuzzerscanbeclassifiedas 3...
4if (...) {
whitebox,blackboxandgreybox.Awhiteboxfuzzer[21],[22],
5 if (...) //nestedIF
[26]assumesaccesstotheapplication’ssourcecode—allowing 6 ...
it to perform advanced program analysis to better understand 7} else {
8 ...
theimpactoftheinputontheexecution.Ablackboxfuzzer[1], 9}
[39] has no access to the application’s internals. A greybox
Listing2. Nested-levelconditionsanddeeperpaths
fuzzer aims at a middle ground, employing lightweight pro-
gram analysis (mainly monitoring) based on access to the
Now consider another simple (pseudo) code snippet, in List-
application’s binary code. VUzzer is a greybox fuzzer.
ing.2.Atline5,thereisanothermultibyteif conditiononthe
Anotherfactorthatinfluencesinputgenerationistheappli- inputbytes,whichisnestedintheouterif.AsAFLwilllikely
cation exploration strategy. A fuzzer is directed if it generates failtosatisfy thebranchconstraint,itwill generateinputsthat
inputstotraverseaparticularsetofexecutionpaths[20]–[22], traverse the else branch. As there is code to explore in the
[26],[38].Acoverage-basedfuzzer,ontheotherhand,aimsat elsebranch,AFLwillnotbeabletoprioritizeeffortstotarget
generating inputs to traverse different paths of the application the if branch. It is hard to impart such knowledge to AFL
even via symbolic execution. As a result, any bug inside the
1http://linux.die.net/man/1/mpg321 nested if code region may remain hidden. In another case,
2when AFL gets stuck at the if condition at line 5, symbolic the case of magic bytes). Irrespective of the result of this
execution-based approaches such as Driller [47] will try to check, a new path is taken. However, the true branch
find new paths by sequentially negating path conditions. In willleadtobuggyspotatline18.Again,whenprocessing
this process, they may negate constraints at line 4 to find a this example, AFL spends a long time guessing the valid
new path, which may lead to some error handling code. AFL, combination of bytes and offsets. In general, after a few
however, has no knowledge of such error handling code and, iterationsofinputgeneration,alargepercentageofinputs
as a result, it will start exploring in that direction. In general, will be falling into the error-handling code. AFL and
there are several complex real-world code constructs that may any other coverage-based fuzzer that searches for new
hinder the progress of coverage-based fuzzers. basicblocksarelikelytofurtherexplorefromsuchinputs
as these inputs have indeed found new code. However,
In order to understand such code constructs, we will walk
if we consider the exploration of more meaningful and
through a more complex code snippet presented in Listing 3.
interesting paths, reusing such inputs yields no benefit
Although VUzzer does not require source code, we use high-
and hinders further exploration of the application code.
level C code for better illustration. The code reads a file and,
3) Markers:Inordertoreachthebuggyspotatline18,there
based on certain bytes at fixed offsets in the input, it executes
is a branch constraint to satisfy at line 17. It should be
certain paths.
noted that such bytes may not be present at fixed offsets,
1int main(int argc, char ∗∗argv){ butratherworkasmarkersforcertainfieldsinmanyinput
2 unsigned char buf[1000]; formats, such as JPEG, PNG, or GIF. Miller & Peterson
3 int i, fd, size , val;
4 if ((fd = open(argv[1], ORDONLY)) == −1) showthatthepresence(andabsence)ofsuchmarkershas
5 exit(0); a direct impact on the executed code [36]. As often such
6 fstat(fd, &s);
markers are multibytes, AFL struggles with generating
7 size = s.st size;
8 if (size > 1000) such bytes to execute certain paths.
9 return −1; 4) Nested conditions: In the context of coverage-based
10 read(fd, buf, size);
fuzzing,eachpathisimportant.However,reachingcertain
11 if (buf[1] == 0xEF && buf[0] == 0xFD) //noticetheorderofCMPs
12 printf(”Magic bytes matched!\n”); paths may be more difficult than others. For example, in
13 else order to reach line 18, an input has to satisfy the check
14 EXIT ERROR(”Invalid file\n”);
15 if (buf[10] == ’%’ && buf[11] == ’@’) { at line 17, which is only triggered when the constraint
16 printf(”2nd stop: on the way...\n”); at line 15 is satisfied. Therefore, in order to increase the
17 if (strncmp(&buf[15], ”MAZE”, 4) == 0) //nestedIF
chanceofreachingline18,weneedtofuzzanyinputthat
18 ...somebughere...
19 else { reaches line 15 more often. In the case of AFL, even if it
20 printf(”you just missed me...\n”); passesorfailsconstraintsatline15,itdiscoversnewpaths
21 ... some other task ...
in both cases and it tries to fuzz inputs corresponding to
22 close(fd); return 0;
23 } boththebrancheswithequalprobability.Inthisprocess,it
24 } else { spendsalongtimemutatingtheinputexecutingtheeasier
25 ERROR(”Invalid bytes”);
26 ... some other task ... path and thereby minimizing the chances of reaching
27 close(fd); return 0; line 18. This is the result of spending less time in
28 }
satisfying the constraint at line 17. Clearly, this strategy
29 close(fd); return 0;
30} is not able to prioritize efforts to focus on the interesting
path.Abetterstrategywouldbetooptimizeeffortsbased
Listing3. Motivatingexamplethatillustratesissuesinexistingfuzzers
on the control-flow characteristics of the application.
It is interesting to note that, when we ran the code snippet Interestingly, one of the LAVA authors noted similar issues
inListing3withAFL[52],wecouldnotreachthebuggystate with AFL in a recently published post [16]. This supports
within24hours.Whatissospecialaboutthiscodesnippetand our observation that black/greybox fuzzers like AFL tend to
whatismissinginfuzzerslikeAFL?Weaddressthisquestion be application-agnostic, which makes them significantly less
by considering the following code properties: effective at discovering hard-to-reach bugs.
1) Magic bytes: The second and the first byte are first Wenotethatsomeoftheissuesdiscussedabovecanbe,in
compared to validate the input (line 11). If these bytes principle,handledbysymbolic/concolic-basedapproaches[9],
are not properly set at certain input offsets, the input [20], [22], [33] such as Driller [47]. Driller combines AFL
is discarded immediately. In our example, offset 1 is and concolic execution to explore deeper execution paths.
checkedfirstandoffset0next.Weobservedthisbehavior With symbolic execution, we may be able to learn magic
in real applications, such as the djpeg utility. This also bytes quickly and assist AFL in crossing the first hurdle at
explainsthatittookmillionsofinputsforAFLtogenerate line 11. However, AFL will get stuck again in the following
a valid jpeg image2. As AFL is not application-aware, it lines. Moreover, this combination is again agnostic to nested
has no idea of such bytes and offsets. It will simply keep conditions and thus path prioritization remains an issue. A
on guessing a valid combination of bytes and offsets. more general and practical problem is the poor scalability
2) Deeperexecution:Inordertogodeeperintheexecution, of symbolic execution-based solutions. Although not an issue
one has to get past another check at line 15, which in this small motivating example, real-world applications are
compares offsets 10 and 11 (note that such offsets may complex enough to drive symbolic execution into a state-
bereadfromtheinputandthusvaryacrossinputs,unlike explosion scenario. This is evident from the results presented
in the Driller paper [47]: out of 41 binaries from DARPA
2http://lcamtuf.blogspot.nl/2014/11/pulling-jpegs-out-of-thin-air.html CGC,Driller’sconcolicenginecouldgeneratenewmeaningful
3inputs only for 13 binaries. Another study [50] empirically EvolutionaryfFuzzingfLoop
established that symbolic execution is not suitable for finding
inputs that explore interesting paths. Therefore, in spite of BBfmonitoring evolutionaryffuzzing Testfcase
promising results on CGC binaries, the poor scalability of DTA loopfclose
symbolic/concolic execution-based approaches is still a strong
Application
limiting factor on real-world applications. binary E Br Bro sr Exe Bc Bu sted Append
input
B. Evolutionary Input Generation Interestingfoffsets Crossover
Fitnessffunction detection Mutation
Despitesomepitfalls,AFLisaverypromisingfuzzer.The Staticfanalysis
success of AFL is mainly attributed to its feedback loop, i.e, Fitness M LEa Agi fc of fb fsy ete tss
incremental input generation. In the case of our motivating BBfweights list
CMPfimm
example, it is almost impossible to generate an input that
will reach the buggy state in one mutation. This motivated Knowledge Knowledge Knowledge
us to adopt an evolutionary fuzzing strategy, that is a fuzzing
strategythatreliesonanevolutionaryalgorithm(EA)forinput
Fig.1. Ahigh-leveloverviewofVUzzer.BB:basicblock,CMPimm:cmp
generation. In the following, we briefly describe the main
instructionwithoneimmediateoperand,DTA:dynamictaintanalysis,LEA:
steps that a typical EA follows (see Algorithm 1). In the later loadeffectiveaddressinstruction.
sections, we will refer to these steps while detailing the main
components of VUzzer.
A. Features
Algorithm 1 Pseudo-code of a typical evolutionary algorithm
The two main components of VUzzer are a static analyzer
INITIALIZEpopulationwithseedinputs (shown on the left) and the main (dynamic) fuzzing loop
repeat
(shown on the right). We use these components to extract
SELECT1parents
RECOMBINEparentstogeneratechildren a variety of control- and data-flow features from the appli-
MUTATEparents/children cation. Figure 1 shows that VUzzer continuously pumps this
EVALUATEnewcandidateswithFITNESSfunction
SELECT2fittestcandidatesforthenextpopulation informationbackintotheevolutionarymutationandcrossover
untilTERMINATIONCONDITIONismet operators to help generate better inputs in the next generation.
return BESTSolution
We first introduce the features and then discuss the static
analyzer and the main fuzzing loop.
Every EA starts with a set of initial inputs (seeds), which
undergo the evolutionary process as follows. With some se- Data-flow features: Data-flow features provide infor-
lection probability, one or two inputs (parents) are selected mation about the relationship between input data and com-
(SELECT1 state). Such inputs are then processed by two putations in the application. VUzzer extracts them using well-
genetic operators, namely crossover (RECOMBINE state) and knowntechniquessuchastaintanalysisandusesthemtoinfer
mutation (MUTATE state). In crossover, two inputs are com- thestructureoftheinputintermsofthetypesofdataatcertain
bined by choosing an offset (cut-point) and exchanging the offsets in the input. As an example, it finds input bytes that
corresponding two parts to form two children. In mutation, determine branches (“branch constraints”) by instrumenting
we apply several mutation operators (like addition, deletion, eachinstructionofthecmpfamilyofthex86ISAtodetermine
replacement of bytes) on a single parent input to form one which input bytes (offsets) it uses and against which values
child. With this strategy, we get a new set of inputs which it compares them. In this way, VUzzer can determine which
undergo the evaluation state (EVALUATE). In this state, we offsets are interesting to mutate and what values to use at
monitor the execution of each new input based on a set of those offsets (providing partial answers to the questions in
properties. These properties are used in a fitness function to Section I). VUzzer is now able to mutate more sensibly by
assess the suitability of the input. We choose the input with targeting such offsets more often and by using the intended
the highest fitness score for the next generation of inputs. The values at those offsets to satisfy branch constraints. Doing
whole process continues until a termination condition is met: so solves the problem of magic bytes, without resorting to
either the maximum number of generations is reached or the symbolic execution.
objective is met (in case of fuzzing, a crash is found).
Likewise,VUzzermonitorstheleainstructiontocheckif
the index operand is tainted. If so, it can determine that the
III. OVERVIEW value at the corresponding offset is of type int and mutate
the input accordingly. Besides these two simple, but powerful
To address the challenges mentioned in the previous sec-
features, many others are possible.
tion, we propose VUzzer, an application-aware evolutionary
fuzzer.Figure1providesanoverviewofitsmaincomponents. Control-flow features: Control-flow features allow
As VUzzer is an evolutionary fuzzer, there is a feedback loop VUzzer to infer the importance of certain execution paths.
to help generate new inputs from the old ones. When generat- For example, Figure 2 shows a simplified CFG of the code in
ing new inputs, VUzzer considers features of the application Listing 3. Inputs that exercise error blocks are typically not
basedonitsexecutiononthepreviousgenerationofinputs.By interesting. Therefore, identifying such error-handling blocks
consideringsuchfeatures,wemakethefeedbackloop“smart” may speed up the generation of interesting inputs. We show
and help the fuzzer find inputs with non-zero IG with high how we detect error-handling code in the following sections.
frequency. Fornow,weassumethatwecanheuristicallyidentifythebasic
4blocks containing error handlers. computetheprobabilityp ofreachingeachbasicblock bina
b
function. We then calculate the weight w of each basic block
Another example concerns the reachability of nested b
b as 1/p . Thus, the lower the probability of reaching a basic
blocks. Any input that reaches block F is more likely to b
block,thehighertheweight.Usingthismodel,theprobability
descend deeper into the code than an input that reaches block
andtheweightofeachbasicblockisshownnexttoeachnode
H, since the latter is not nested. We use control-flow features
inFigure2(seeSectionIV-A3).Weobservethat,forexample,
to deprioritize and prioritize paths. As enumerating all the
the probability of reaching basic block G is less than that of
possible paths in the application is infeasible, we implement
reaching basic block F, which in turn has lower probability
this metric by assigning weights to individual basic blocks.
than basic block H. VUzzer uses these lists in later steps of
Specifically, basic blocks that are part of error-handling code
the fuzzing loop.
getanegativeweight,whilebasicblocksinhard-to-reachcode
regions obtain a higher weight.
C. The main fuzzing loop
main A We describe the main fuzzing loop by using the steps
1,1
1 in Algorithm 1. Before the main loop starts, we execute the
1,1 application with the set of seed inputs SI to infer an initial
B
0xFDEF setofcontrol-flow anddata-flowfeatures.Forall theinputsin
0.5
D SI, we run dynamic taint analysis (DTA) to capture common
0.5 validgfile 0.5,2 characteristics of valid inputs. Specifically, we do so for
the magic-byte and error-handling code detection mentioned
1
error E earlier. Using these features, we generate an initial population
0.5,2 . 0.5,2 ofinputsaspartoftheINITIALIZEstepinAlgorithm1.Note
0.5 0.5 0.5 F that our magic-byte detection ensures that these new inputs
0.25,4 cross the first such check of the application. As DTA has a
@
H 0.5 0.5 high overhead, we use it as sparingly as possible after the
.5,2 somegtask nestedgIF 0 M. A13 Z, E8 G main loop starts.
error 0.5 0.5 Input execution: We execute the application with each
C J of the inputs from the previous step and generate the corre-
exit 0.44,2.3 0.0I 6,16bug sponding traces of executed basic blocks. If any of the inputs
executes previously unseen basic blocks, we taint the input
and use DTA to infer its structural properties by monitoring
Fig. 2. A high-level CFG of the code shown in Listing 3. The number
at each edge denotes the probability of the corresponding branch outcome. the data-flow features of the application.
The number at each node denotes the overall probability of reaching the
correspondingbasicblock.Forexample,ifalledgeprobabilitiesare0.5and Fitness calculation: In the EVALUATE step of Algo-
the program can reach a node N2 either from N0 directly or indirectly via rithm 1, we calculate the fitness of each input as the weighted
N1,thenodeprobabilityofN2←0.5+0.5∗0.5=0.75.Thenumbernext sumofthefrequenciesofexecutedbasicblocks.Wedistribute
tothenodeprobabilityistheassignedweight.
the weights over the basic blocks using the weights list L .
BB
Basic blocks that belong to error-handling code get a negative
Figure 1 shows that a single iteration of fuzzing consists
weight—for now we still assume that we can identify such
of several steps. VUzzer expects an initial pool SI of valid
basic blocks. The intuition behind this fitness calculation is to
inputs, called seed inputs. The first step is to perform an
provide high scores to inputs that execute basic blocks with
intraprocedural static analysis to derive a few control-flow
higher weights and thereby prioritize the corresponding paths,
and data-flow features (Section III-B), which is followed by
whilealsoexecutingcertainbasicblockswithhighfrequencies
the main evolutionary fuzzing loop. In the remainder of this
to catch large loops. For example, let us consider two paths
section, we walk through all the steps to describe the whole
p and p , executed by two inputs i and i respectively
process. 1 2 1 2
such that p = A → B → D → E → H → J and
1
p = A → B → D → E → F → J. For simplicity, let
B. The static analyzer 2
usassumetheerror-handlingbasicblockJ getsweight-1and
At the beginning of the fuzzing process, we use a the frequency of execution of each basic block is 1. Using the
lightweight intraprocedural static analysis to (i) obtain weightsfromFigure2,theweightedsumsofthefrequenciesof
immediate values of the cmp instructions by scanning the p 1 and p 2 are 7 (1+1+2+2+2-1) and 9 (1+1+2+2+4-1). Hence,
binary code of the application and (ii) compute the weights inputi 2 getsahigherfitnessscoreandwillparticipatemorein
for the basic blocks of the application binary. generating new inputs than i 1. This step eventually generates
a sorted list L of inputs in decreasing order of their fitness
The presence of many immediate values from cmp in- fit
scores.
structions in the application’s code typically indicates that the
application expects the input to have many of these values at Genetic operators and new input generation: This is
certain offsets. For example, the analysis for the program in the final and most important functionality in our fuzzing strat-
Listing3yieldsalistL ofweightsforeachbasicblockand egy,encompassingtheSELECT,RECOMBINE,andMUTATE
BB
a list L of byte sequences containing {0xEF, 0xFD, steps in Algorithm 1. Together, these substeps are responsible
imm
%, @, MAZE}. To determine the basic block weights, we for generating interesting inputs. In each iteration of the main
model the CFG of each function as a Markov model and loop, we generate a new generation of inputs by combining
5and mutating the inputs from SI, all tainted inputs, and the DTA provides taint information for each byte b separately.
i
top n% of L . We refer to this set as the ROOT set. We denote the set of offsets that taint the jth byte of the ith
fit
operand of a given cmp instruction as Ti. We also record the
Specifically, we generate new inputs via crossover and j
values of these operands. Symbolically, we represent a tainted
mutation. First, we randomly select two inputs (parents) from
cmp instruction as cmp = (offset,value), where offset
ROOT and apply crossover to produce two new inputs (chil- i
and value are the sets of offsets from tainted input and the
dren). With a fixed probability, these two inputs further un-
set of values for the untainted operand of the cmp instruction.
dergo mutation. Mutation uses several sub-operations, such as
For each lea instruction, DTA tracks only the index register.
deletion, replacement, and insertion of bytes at certain offsets
L contains all the offsets that taint such indexes.
in the given input. The mutation operator makes use of the lea
data-flow features to generate new values. For example, when 2)Magic-byte Detection: Based on our understanding of
inserting or replacing bytes, it uses characters from L to file formats that have magic bytes, we postulate that a magic
imm
generatebytesequencesofdifferentlengths.Similarly,various byte is a fixed sequence of bytes at a fixed offset in the input
offsets from current inputs’ parents are selected for mutation. string.Wehaveverifiedthisassumptiononseveralfileformats
Hence, if any magic bytes exist, they will be replaced at the thathavemagicbytes,forexample,jpeg,gif,pdf,elf,andppm.
proper offsets in the resulting inputs. As VUzzer assumes the availability of a few valid inputs for
a given application, we use the results of DTA on these inputs
This loop of input generation continues until we meet a
at the beginning of fuzzing. As applications expect the input
termination condition. Currently, we terminate when we find
tocontainmagicbytes,DTA’sresultsoncmpinstructionswill
a crash or when VUzzer reaches a pre-configured number of
contain the corresponding check for magic bytes.
generations.
Forexample,thecodefromListing3expectsamagicbyte
Foreasierreference,TableIprovidesalistofsymbolsthat
0xFDEF in the beginning of the input file. Hence, DTA will
we use throughout the paper. In the next section, we elaborate
capture two cmp instructions—cmp reg, 0xFD with reg
taintedbyoffset0andcmp reg, 0xEFwithregtaintedby
TABLEI. GLOBALSYMBOLSANDTHEIRMEANING.
offset 1. If we have a set of valid inputs for this program, we
Symbol Description canobservethesetwocmpinstructionsinallthecorresponding
DTA dynamictaintanalysis
executions. Conversely, if for a set of valid inputs we get
SI setofseedinputs(validinputs).
LBB listofbasicblockweights,obtainedbystaticanalysisoftheapplica- cmp
i
= (o i,v i) in DTA’s results for all the inputs, v
i
is a
tionbinary. part of the magic byte at offset o .
Limm list of immediate values from cmp instructions, obtained by static i
analysisoftheapplicationbinary.
Itshouldbenotedthatthealgorithmweusetodetectmagic
Lfit Sortedlists(indecreasingorder)offitnessscoresofinputs,obtained
inthefitnesscalculationstep. bytes can incur false positives. This may happen if all the
Oother setofalltaintedoffsets,otherthantheoneswhichareplaceholderfor initial valid inputs share identical values at the same offsets.
magicbytes.ThissetisobtainedbyDTA.
Nonetheless, this will still be useful for generating inputs that
Llea setofoffsetsthattainttheindexoperandofleainstructions.
gobeyondtheveryinitialcheckformagicbyteswithareduced
on the algorithms that we use to derive relevant information probabilityofexploringdifferentpaths.Toavoidthissituation,
about the input structure by using control-flow and data-flow we prefer to start with a diverse but valid set of inputs.
features.
During magic-byte detection, for a given cmp instruction,
i
if the corresponding value depends on multiple offsets per
IV. DESIGNANDIMPLEMENTATION byte, we do not consider such offsets to be magic-byte can-
didates. For example, for a given cmp instruction, if DTA
Inthissection,wedetailthetechniquestocalculateseveral
detects that |Ti| > 1, we exclude such offsets (∈ Ti ) from
primitives discussed in the previous section. The section also j j
any further consideration for magic-byte placeholders. Such
presents implementation details of VUzzer.
a case indicates that the value of the corresponding operand
may be derived from tainted values at those offsets ∈ Ti.
A. Design Details j
The dependence on multiple bytes breaks the assumption that
1)Dynamic Taint Analysis (DTA): DTA is the core of magicbytesarefixed(constant)sequencesofbytes.Wedenote
VUzzer as it plays a major role in evolving new inputs. This the set of all such offsets as O .
other
is also the technique that sets VUzzer apart from existing
3)Basic Block Weight Calculation: From a coverage-
fuzzers.DTAisusedtomonitortheflowoftainted input(e.g.,
based fuzzing perspective, every feasible path is important to
network packets, files, etc.) within the application. DTA can
traverse. A simple fuzzing strategy is to spend equal efforts
determine,duringprogramexecution,whichmemorylocations
to generate inputs for all feasible paths. However, due to the
and registers are dependent on tainted input. Based on the
presence of control structures, the reachability of some paths
granularity,DTAcantracebackthetaintedvaluestoindividual
may not be the same as that of other paths. This situation
offsets in the input. VUzzer uses DTA to trace tainted input
arisesveryfrequentlyifwehavenestedcontrolstructures[41].
offsets used at cmp and lea instructions. For every executed
Therefore, any input that exercises such hard-to-reach code
cmp instruction cmp op1, op2 (op1 and op2 can either
should be rewarded more compared to other inputs.
beregister,memory,orimmediateoperands),DTAdetermines
ifop1and/orop2aretaintedbyasetofoffsets.OurDTAim- We incorporate this reward by assigning higher weights to
plementationisabletotracktaintatthebytelevel.Foragiven basicblocksthatarecontainedwithinnestedcontrolstructures.
tainted operand op, DTA provides taint information for each As enumerating all the paths at the interprocedural level has
byteofop.Symbolically,ifopisdenotedasb ,b ,b ,b ,then troublescaling,weconstrainouranalysisattheintraprocedural
3 2 1 0
6level,i.e.,wecalculateweightsforeachbasicblockwithinthe inputsarecaughtbydifferenterror-handingcode.Nonetheless,
containing function. Later, we gather and add the weights of notethatwewillneverclassifyabasicblockcorrespondingto
allthebasicblocksinapaththatisexecutedbyagiveninput. a valid path as an error-handling basic block. More formally,
With this strategy, we simulate the score of an interprocedural let
path by stitching several intraprocedural path scores together. Valid =∪ BB(i), then
BB i∈SI
EHB ={b:∀k ∈TR,b∈BB(k)&b∈/ Valid }
Ifweconsiderthatthetransitionofaninputataparticular BB
basic block to the next basic block is dependent on some where EHB is a set of error-handling basic blocks.
probability,wecanderiveaprobabilisticmodelcalledMarkov
Incremental analysis: We observe that since our error-
process for the input behavior from the control-flow graph
handling detection strategy is based on the dynamic behavior
(CFG). A Markov process is a stochastic process in which
oftheapplication,notallerror-handlingcodemaybetriggered
the outcome of a given trial depends only on the current state
during the initial analysis. As inputs evolve, they explore
of the process [30]. We model the CFG of a function as a
more paths and thus encounter new error-handling code. For
Markov process with each basic block having a probability
this reason, we initiate an incremental analysis during later
based on its connections with other basic blocks.
iterations of fuzzing. In our experimental setup, we observed
For a given basic block, we assign equal probability to all that,asweproceedwithmoreiterationsoffuzzing,thenumber
its outgoing edges. Hence, if out(b) denotes the set of all out- of new error-handling code instances decreases. This reflects
goingedgesof basic blockb,then ∀e b∗ ∈out(b),prob(e b∗)= theintuitionthatsoftwarehasafinitenumberoferror-handling
1/|out(b)|. The transition probability (likelihood) of a basic code instances, which are reused in different parts of the
block b is calculated as follows: application. Therefore, we run our incremental analysis less
(cid:88) frequently as we execute more iterations.
prob(b)= prob(c)∗prob(e ) (1)
cb
The intuition behind our incremental analysis is the ob-
c∈pred(b)
servation that as fuzzing proceeds, the majority of newly
where pred(b) is the set of all the predecessors of b. We generated inputs will end up triggering some error-handling
employ a fixed-point iteration algorithm to compute the prob- code. At a given iteration, let I be the set of inputs generated
ability associated with each basic block in the CFG. The root in the iteration. Let the majority be quantified by n% of |I|.
basic block of the CFG is initialized with a probability of 1. Our (offline) experiments show that n = 90 is a reasonable
Loopsarehandledbyassigningafixedprobabilityof1toeach choice. Let BB(I) be the set of all the basic blocks executed
backedge, thereby neglecting the effect of the backedge itself by inputs in I. We classify a basic block b from BB(I) as
(i.e., we flatten the loop to speed up fixed point calculation). an error-handling basic block if it is associated to at least n%
From Equation 1, the weight of each basic block b is given of the inputs from I and it is not in the Valid set. More
BB
by: formally, let P(I) denote the power set of I. Then
1
w = (2)
b prob(b) EHB ={b:∀k ∈P(I), s.t. |k|>|I|∗n/100,
b∈BB(k)&b∈/ Valid }
BB
4)Error-Handling Code Detection: As noted earlier, dur-
ing fuzzing, the majority of mutated inputs will be executing Weight calculation for error-handling basic blocks:
a path ending up in some error state. Deprioritizing such After detecting error-handling basic blocks (EHBs), we want
executionpathsisakeysteptowardsincreasingthechancesof to deprioritize paths that contain such blocks. We achieve this
creating interesting inputs faster. Our error-handling detection by penalizing the corresponding inputs so that such inputs
heuristic relies on the availability of valid inputs, which is have less chances of participating in next generation. For
a prerequisite of VUzzer. As our error-handling detection this purpose, each EHB is given a negative weight, which
depends on the dynamic behavior of the application, it detects impacts the fitness score of the corresponding inputs (see
error-handling basic blocks in an incremental manner. Section IV-A5). However, this strategy is alone insufficient
since, as EHBs are a small minority when compared to the
Initialanalysis: Foreachvalidinputi∈SI,wecollect
totalnumberofbasicblocksexecutedbyaninput,suchasmall
asetBB(i)ofbasicblocksthatareexecutedbyi.LetValid
BB quantity will have negligible impact. We solve this problem
denote the union of all such sets of executed basic blocks by defining an impact coefficient µ (a tunable parameter) that
by all valid inputs. We then create a set of totally random decides how many (non-error handling) basic blocks may be
inputs, denoted as TR. For each input in this set, we collect nullifiedbyasingleerror-handlingbasicblock.Intuitively,this
itsexecutiontraceintermsofbasicblocks.Abasicblockfrom
parameter determines that, once an input enters error-handling
suchasetofexecutionsisassumedtobeaerror-handlingbasic
code,thecontributionofanyofthecorrespondingbasicblocks
block (i.e., belonging to error-handling code) if it is present when calculating fitness scores must be reduced by a factor µ.
in each execution of inputs from TR and it is not present in For a given input i, we use the following formula for weight
Valid .TheintuitionisthatsinceSI isasetofvalidinputs,
BB calculation purposes.
no error-handling code will be triggered. Therefore, Valid
BB
will contain only basic blocks that correspond to valid paths. |BB(i)|×µ
w =− (3)
And since TR is a set of totally random inputs, they will be e |EHB(i)|
verylikelycaughtbyerror-handlingcodeduringtheexecution.
where |BB(i)| is number of all the basic blocks executed by
Ours is a very conservative error-handling basic block input i, |EHB(i)| is the number of all the error-handling basic
detection strategy as we may miss few basic blocks if certain blocks executed by i, and 0.1≤µ≤1.0.
75)Fitness Calculation: Fitness calculation is one of the Mutation: Mutation is a more complex operation,
most important components of evolutionary algorithms. This which involves several suboperations to change a given par-
iscrucialtoimplementthefeedbackloop,whichfuelsthenext ent input into the corresponding child input. The process is
step of input generation. Once a new input is generated, the detailed in the following steps:
chances of its participation in generating new inputs depend
Step 1: Randomly select tainted offsets from the set O
on its fitness score. other
and insert strings at those offsets. The strings are formed
VUzzer assess the fitness of an input in two ways. If the by bytes obtained from the set L imm.
execution of an input results in discovering a new non-EHB Step 2: Randomly select offsets from the set L lea and mutate
basic block, the input qualifies for participation in the next such offsets in the string from Step 1 by replacing them
generation. This is similar to AFL (with the additional use withinterestingintegervalues,suchas,0,MAX UINT,
of the EHB set). However, this measure of fitness considers negative numbers.
all newly discovered paths equal, which is problematic, as Step 3: For all the tainted cmp instructions for the parent
explained earlier. The importance (and thus the fitness) of input, if the values of op1 (cid:54)= op2, replace the value at
an input depends on the interestingness of the path that the tainted offset in the string from Step 2 with the value
it executes, which, in turn, depends on the weights of the ofop2orelsewithafixedprobabilityreplacethetainted
corresponding basic blocks. Therefore, we define fitness f byte by a random sequence of bytes.
i
of an input i as a function that captures the effect of all the Step 4: Place the magic bytes at the corresponding offsets as
corresponding basic block weights. determined by our magic-byte detector.
 (cid:80) log(Freq(b))Wb B. Implementation Details
b∈BB(i)
BBNum if l >LMAX
f
i
=
(cid:80)
log(li) i (4) ThecorefunctionalityofVUzzerisimplementedinPython

log(Freq(b))W
b
otherwise.
2.7. Some of the implemented analyses, for example incre-
b∈BB(i)
mental analysis for error-handling basic block detection, are
memory intensive and therefore we also make use of efficient
where BB(i) is the set of basic blocks executed by input i,
data structures provided by more recent versions, such as
Freq(b) is the execution frequency of basic block b when
BitVector3. VUzzer internally consists of two main compo-
executed by i, W is the weight of basic block b (by using
b nents, comprising static and dynamic analyses, as further
Equation 2), l is the length of input i, and LMAX is a pre-
i detailed below.
configuredlimitoninputlength.LMAXisusedtoaddressthe
phenomenon of input bloating. In the parlance of genetic al- Static analysis: VUzzer implements both of the static
gorithms,bothofthe fitnesscriteria(i.e.abilitytodiscovering analyses (constant string extraction and basic block weight
new basic block and a higher f ) correspond to the notion of calculation)withinIDA[27].TheanalysisiswritteninPython
i
exploration and exploitation—discovering a new basic block using IDAPython [18].
indicates a new direction (i.e., exploration) and a higher f
i Dynamic analysis: VUzzer implements both dynamic
indicates higher execution frequencies (among other factors)
analyses (basic-block tracing and DTA) on the top of the Pin
of basic blocks (i.e., exploitation in the same direction).
dynamic analysis framework [31]. For basic block tracing,
we implemented a pintool to record each basic block, along
6)Input Generation: VUzzer’s input generation consists
with its frequency, encountered during the execution. Our
of two parts, crossover and mutation, which are not mutually
pintool can selectively trace basic blocks executed by certain
exclusive, that is, crossover is followed by mutation with a
libraries on-demand. Selective library monitoring allows us to
fixed probability.
reducetheexecutiontraceoverheadandfocusontheintended
Crossover: Crossover is a simple operation wherein application code.
two parent inputs are selected from the previous generation
Our DTA implementation is based on DataTracker, pro-
and two new child inputs are generated. Figure 3 illustrates
posedbyStamatogiannakiset.al[46],whichinturnisbasedon
the process of generating two child inputs from two parent
LibDFT [29]. As LibDFT can only handle 32-bit applications,
inputs.
the current VUzzer prototype can only be used to fuzz 32-bit
applications(alsousedinourevaluation).Notethatthisisnota
fundamentallimitationandweare,infact,intheprocessofim-
this is input1 this the other input2
plementing64-bitsupportinVUzzer.Anyupdatedversionwill
be made available at https://www.vusec.net/projects/fuzzing.
Tomakeitsuitableforourpurposes,wealsomadeseveral
I am the other input2 I am is input1
changes to DataTracker:
• In DataTracker, taint tags associated with each
Fig. 3. Crossover operation in VUzzer. In this single-point crossover, we
selectthe5th offsetascut-point.Forthefirstparent(this is input1), memory location are modeled as tuples: <ufd,
this strategy breaks it into two parts: i1=this and i2= is input1. For file_offeset>, i.e., unique file descriptor and the
1 1
the second parent, we again get two parts: i1 2=I am and i2 2= the other offset of the file associated with that descriptor. Each
input2. Now, we form two children by using i1 1 | i2 2 and i2 1 | i1 2, that is, of these tuples is 64 bit long (32 bits for ufd and 32
this the other input2andI am is input1.
3https://pypi.python.org/pypi/BitVector/3.4.4
8bits for file_offset). Each memory location has a are 131 binaries in total, with various types of bugs injected
set of these tuples associated with it to determine the in them. However, we could not run VUzzer on all of them
offsets and the files by which the memory location is for the following reasons:
tainted. We changed this to a EWAHBoolArray type4
which is a compressed bitset data type. Since we only • All of the binaries are interactive in nature by accepting
need data-flow information from one (input) file, we inputs from STDIN. Once started, many of them present
modified DataTracker to propagate taint only through a menu to choose an action, including the option to quit.
that file. Thus, in our modified version, the taint tags Furthermore, in many cases, there are multiple menus (in
associated with each memory location are modeled as a different state of the program) with different options to
a EWAHBoolArray which only contains offsets. As a quit.AsVUzzerrequiresasteptogeneratetotallyrandom
result, our implementation is at least 2x faster and uses inputs (error-handling code detection, Section IV-A4),
several times less memory than DataTracker. executing such inputs puts the application in a loop,
• Weaddedinstrumentationcallbacksforthecmpfamilyof looking for valid options, including the option to quit.
instructions like CMP, CMPSW, CMPSB, CMPSL and This causes the application to run forever. This is an
the lea instruction to catch byte-level taint information interfacing problem and not a fundamental limitation of
for the operands involved in the computations. our fuzzing method.
• We rewrote hooks for each implemented system call • Some of these binaries are compiled with floating-point
and also added hooks for some extra system calls such instructions, which are not handled by LibDFT and thus
as pread64, dup2, dup3, mmap2, etc. To evaluate our VUzzer cannot get correct data-flow information.
performance on the DARPA dataset [15], we also im- • As VUzzer is based on Pin [32], we followed the given
plementedhooksforDECREE-basedsystemcalls,which procedure to run pintools in DECREE5. However, we
are different from normal Linux system calls. could not run some of the binaries with Pin.
• Some of the binaries involve interaction with other bina-
Crash triage: Once fuzzing starts producing crashes, ries, which is not handled by VUzzer.
it may continue to produce more crashes and there should be
some mechanism to differentiate crashes due to different bugs After considering the obstacles mentioned above, we are left
(orthesamebugbutdifferentinstances).Inordertodetermine with a total of 63 binaries. In order to make a comparison
theuniquenessofacrash,VUzzerusesavariantofstackhash, with AFL, we also ran AFLPIN, a pintool-based AFL imple-
proposedbyMolnaret.al.[37].Inourpintool,weimplemented mentation6.AFLPINhasthesamefuzzingengineasAFL,but
a ring buffer that keeps track of the last 5 function calls and a different mechanism to get execution traces. Our choice to
the last 10 basic blocks executed before we get a crash. We useAFLPINinsteadofAFListohaveanidenticalinterfacing
calculate the hash of this buffer and each time a new crash is mechanism with the SUT, that is, passing input to the pintool
encountered, we compare the newly generated hash with the via file descriptor 0 (STDIN).
older ones to determine if the reported crash is a new unique
one. VUzzer found crashes in 29 of the CGC binaries, whereas
AFLPIN found only 23 crashes. As each CGC is also accom-
panied with a patched version, we verified each bug found
V. EVALUATION
by VUzzer by running the patched version of the binary to
In order to measure the effectiveness of our proposed observe no further crashes. The most important result was the
fuzzing technique, this section presents an evaluation of number of executed inputs per crash in both of these fuzzers.
VUzzer. To expose VUzzer to a variety of applications, we We ran both fuzzers for a maximum of 6 hours. Figure 4
chose to test VUzzer on three different datasets A. DARPA depicts the number of executions for the cases where both of
CGC binaries [15], B. miscellaneous applications with binary thefuzzersfoundcrashes(13intotal),evidencingthatVUzzer
format as used in [43], and C. a set of buggy binaries recently can significantly prune the search space compared to AFL.
generated by LAVA [17].
While fuzzing a specific binary NRFIN_00015, we ob-
We ran our experiments on an Ubuntu 14.04 LTS system served the importance of computing the fitness score f in a
i
equipped with a 32-bit 2-core Intel CPU and 4 GB RAM. discrete manner. The vulnerability in this binary is a typical
For the DARPA CGC dataset, the (provided) environment case of buffer overflow in a loop. We observed that after
is a VM with a customized OS called DECREE. We want generation 18, there was no new BB discovered, but f
i
to emphasize that our main evaluation goal is to show how kept increasing, indicating typical loop execution behavior. At
effective VUzzer is in identifying bugs (that may be buried generation 63 (total executions 13K), we reach the boundary
deep in the execution) with much fewer inputs than state-of- of the buffer. AFLPIN could not detect this crash.
the-art fuzzers such as AFL. Our current VUzzer prototype
is not as optimized for fast input execution as AFL and we Wenotethatourcurrentresultsonthisdatasetaremodest,
therefore seek no comparison in this direction. especially in the view of the results reported in Driller [47].
Wefurtherinvestigatedtheresultsandfoundsomepeculiarities
thatmayinterferewiththeperformanceofourcurrentVUzzer
A. DARPA CGC Dataset
prototype on CGC.
As part of Cyber Grand Challenge, DARPA released a set
ofbinariesthatruninacustomizedOScalledDECREE.There 5https://github.com/CyberGrandChallenge/cgc-release-
documentation/blob/master/walk-throughs/pin-for-decree.md
4https://github.com/lemire/EWAHBoolArray 6https://github.com/mothran/aflpin
99 4 2 1
100
0.6 1.8 18. 0.7 22. 1.8 14. 0.7 0.8 0.5 20. 3.8 1.9
80
52
60 69 83 76 72 86 75 79 81
98 98 99 99
40
48
20
31 17 24 28 14 25 21 19
0 2 2 1 1
0 2 4 6 8 10 12
)%(detucexestupniforebmunevitaleR To improve readability, we restate the results from the
original LAVA paper in Table II. The last column in Table II
shows the results produced by VUzzer. The numbers shown
are the total unique bugs identified by VUzzer. In the case
of md5sum, we could not run VUzzer as it crashed on the
first round of input generation without allowing the program to parse more of any input. Each injected fault in the LAVA
binaries has an ID and the ID is printed on standard output
before each binary crashes due to that fault. This allowed us
to precisely identify the faults triggered by VUzzer. Table III
reports the IDs of the faults triggered by VUzzer for each
LAVA binary.
TABLEII. LAVA-MDATASET:PERFORMANCEOFVUZZER
COMPAREDTOPRIORAPPROACHES.
Program Totalbugs FUZZER SES VUzzer(uniquebugs,to-
talinputs)
VUzzer AFLPIN uniq 28 7 0 27(27K)
base64 44 7 9 17(14k)
md5sum 57 2 0 1*
Fig. 4. Relative number of inputs executed for each of the CGC Binaries, who 2136 0 18 50(5.8K)
whereinbothVUzzerandAFLPINfindcrashes.Thenumbersabovethebars
arethetotalnumberofinputs(inthousands)executed. A few interesting points emerge from our LAVA dataset
results. Most of the LAVA injected faults are based on artifi-
ciallyinjectedpathconditions,likelavatoreachaparticular
• In several binaries, a buggy state is reached only by per- pathandtriggerthebug.ThisisverywellcapturedbyVUzzer,
forming a very specific set of actions from a given menu. thanks to its data-flow features. For example, during base64
For exmaple, in the CROMU_00001 application, one fuzzing, we learned that the first four bytes should be either
has to perform: login A -> send many msg to ‘val or lav‘ to follow a particular path. Similarly, we
user B -> login B -> check msg . Currently, discoveredthatthelastfewbytesshouldcontainanyofthefol-
VUzzer does not have capabilities to repeat a sequence. lowingvaluestotakedifferentpaths:las[,lat\x1b,Wsal,
• The notion of valid input is blurry. Recall that we use a etc. It should be noted that most of the path constraints
wholesession,providedintheformofXMLfilesbyevery injected by LAVA are multibyte constraints. Such constraints
CGC binary, as one input. Therefore, there is essentially pose a serious problem for AFL to traverse deeper in the
no notion of invalid inputs. Because of this, we cannot execution (as also noted in [16]). Another interesting point
exploit the full power of VUzzer. is the performance of VUzzer on who. The fuzzer used in the
• Related to the above point is the issue of interesting LAVA paper failed to find even a single bug, whereas VUzzer
offsets. As the CGC binaries are interactive, the input is found several unique crashes.
essentially a sequence to explore application state, which
may vary from one input to another. For example, one TABLEIII. FAULTIDSOFBUGSDETECTEDBYVUZZERONTHE
of the binaries allows a user to load a file. The bug is LAVA-MDATASET.
triggered while processing the file. The corresponding
Program FaultIDs
file loading menu can appear anywhere in the input and uniq 468, 318, 293, 170, 130, 443, 171, 393, 169, 368, 112, 322,
thereforetheoffsetsinthefilearerelativetowhereitwas 166, 227, 371, 472, 321, 215, 222, 297, 372, 396, 446, 397,
471,296,447
loaded in the input, making it difficult to automatically base64 1,843,817,386,786,805,576,276,222,806,284,841,584,
reason over offsets. 235,278,583,788
md5sum -
who 4159,4343,3800,83,1188,60,137,138,1960,59,1458,1,
In light of the aforementioned issues, we believe that VUzzer 159,5,1803,1314,79,475,18,4,9,1804,1816,10,7,3,58,
is not suitable for interactive programs, mainly because ot its 985,179,14,319,2617,81,22,2,63,4364,8,672,341,26,
255,20,75,474,6,4358,4362,587,89
poor interfacing mechanism with such programs.
Overall, on both artificial datasets, VUzzer reported en-
couraging results, although, as expected, it did struggle with
B. LAVA Dataset
interactive programs in the DARPA CGC dataset. We now
Inarecentpaper,Dolan-Gavittet.al.developedatechnique moveontoevaluateVUzzeronreal-worldprogramsthathave
to inject hard-to-reach faults and created buggy versions of also been considered by other fuzzers.
a few Linux utilities [17] for testing fuzzing- and symbolic
execution-based bug finding solutions. We used the LAVA-M
C. Various Applications (VA) Dataset
dataset [17] to evaluate VUzzer. This dataset consists of 4
Linux utilities—base64, who, uniq, and md5sum—each We use a dataset of real-world programs (djpeg/eog,
injected with multiple faults (in the same binary for each tcpdump, tcptrace, pdf2svg, mpg321, gif2png) to
utility). The LAVA paper reports results on the evaluation of evaluate the performance of VUzzer. Rebert et al. also eval-
a coverage-based fuzzer (FUZZER), symbolic execution, and uated these programs to report on several bugs [43] and
a SAT-based approach (SES) on these buggy applications. we therefore included these programs in our evaluation for
10comparison purposes. For each of these programs, we use the
TABLEV. PERCENTAGESOFEXPLOITABLEBUGSDISCOVEREDBY
VUZZERASREPORTEDBY!EXPLOITABLETOOL.
vanillareleaseinUbuntu14.04.Weremarkthatby,evaluating
these utilities, we also targeted some well-known libraries, Unknown Exploitable ProbablyNotExploitable
gif2png 100.0 0.0 0.0
such as libpcap, libjpeg, libpoppler, and libpng.
mpg321 100.0 0.0 0.0
Each program is fuzzed for maximum 24 hours. In order pdf2svg 87.5 0.0 12.5
to highlight the performance of VUzzer, we also ran AFL tcpdump 100.0 0.0 0.0
tcptrace 0.0 100.0 0.0
on these applications. Table IV shows the results of running
VUzzerandAFLontheVAdataset,withVUzzersignificantly
outperforming AFL for both number of unique crashes found seemstobeExploitable.Weinvestigatedoneofthecrashesin
and number of inputs required to trigger such crashes. tcptraceandthereisaseeminglyobviouswaytoexploitit:
thevulnerabilityisanout-of-boundswritetoaheapbuffer.The
TABLEIV. VADATASET:PERFORMANCEOFVUZZERVS.AFL.
bound and the data that are written are tainted (i.e., attacker-
VUzzer AFL controlled).
Application
#Uniquecrashes #Inputs #Uniquecrashes #Inputs
mpg321 337 23.6K 19 883K To further analyze the quality of the bugs discovered by
gif2png+libpng 127 43.2K 7 1.84M
VUzzer, we measured the distance between the crash and the
pdf2svg+libpoppler 13 5K 0 923K
tcpdump+libpcap 3 77.8K 0 2.89M library involved (if any). A bug located in a library will likely
tcptrace+libpcap 403 30K 238 3.29M be included in any application that uses that library, hence
djpeg+libjpeg 17 90K 0 35.9M these bugs are of high priority. We need to also keep in mind,
that these are unknown bugs and therefore many of them
Figure 5 details the distribution of crashes over a period
could be zero-day. As we found a large number of unique
of 24 hours. The x-axis of each plot shows the cumulative
crashes, reporting the most important ones early is a priority
sum of crashes, sampled at each 2 hours. As shown in the
andthereforewerelyonanautomatedanalysistoapproximate
figure, for almost every application, VUzzer keeps finding
the severity of a bug. In short, if a crash happens in a library,
crashes during the later iterations of fuzzing, whereas AFL
then it is a serious bug to report. However, sometime a bug
quickly exhausts its efforts after a few initial iterations. This
manifestsitselfintheuserapplication,buttherealcauseofthe
is due to the fact that, at later stages, AFL is not able to find
bugliesinalibraryusedbytheapplication.We,therefore,also
new (deeper) paths, whereas VUzzer is able to learn branch
measure the distance from the last library call, when a crash
constraints as it explores new paths and thus it is able to find
in observed in the application code.
crashes in later stages of fuzzing. Another interesting point to
note in Figure 5 is that, in comparison to AFL, VUzzer in Thedistancebetweenthecrashandalibraryismeasuredby
not only able to find crashes with much fewer inputs, but this twometrics.Firstwecountthenumberofinstructionsexecuted
alsohappensinmuchlesstime(seethepositionofthevertical betweenthecrashandthelastlibrarycall.Theintuitionisthat
line in Figure 5). We want to again remark that we have not the computation (and its side effects) which ultimately caused
optimized VUzzer for fast input execution. We believe that thecrashmightoriginateinalibrarycall.Second,wecountthe
there exist several techniques to enhance the execution speed number of stack frames between the crash and the last library
of VUzzer, for example, using an AFL-like fork-server within call.Asan example,librariesusingoutput functionhooksthat
a single fuzzing iteration or distributing concurrent fuzzing reside in the main application (e.g. tcpdump, tcptrace,
workers across multiple cores or machines. mpg321) are covered by such heuristics. Table VI presents
the results of our analysis.
D. Crash-Triage Analysis
TABLEVI. DISTANCEBETWEENCRASHESANDLIBRARYCALLS.
Fuzzers tend to generate a large number of crashes. Fixing
#Instructions #Stackframes
every bug associated with a crash is a time-consuming but gif2png 20554.00 gif2png(0);libc(5)
lucrativeprocess.Theonlyinformationprovidedtoasoftware mpg321 733.04 libid3tag (0); libmad (3.1); libc (3.9); mpg321
(5.5)
developer is the version number of the application and the
pdf2svg 626.11 libc (1); libpoppler (3); libpoppler-glib (8);
crash itself. Naturally, the bug patching efforts are invested in pdf2svg(9);
the bugs that are more (security) critical. tcpdump 293.50 tcpdump(0);libpcap(5.7)
tcptrace 1134.53 tcptrace(0);libpcap(2);libc(7)
!Exploitable [19], a tool proposed by CERT, is built on
top of GDB and uses heuristics to asses the exploitability of a
Allcrashesinmpg321happenedinsidethe(libid3tag)
crash caused by a bug. The heuristics are based on the crash library. The libid3tag library is heavily patched (patch
location,thememoryoperation(readorwrite),andthesignals level is 10) by the distro maintainers. This shows that this
triggered by the application. While this analysis is not sound, library is known to contain many bugs. gif2png always
it is simple, fast, and provides hints on the severity of a crash. crashed inside the application. This is confirmed by both
We use the !Exploitable tool to rank the crashes found by
metricswithhighfigures.pdf2svgcrashedinlibpoppler
VUzzer on this dataset. Table V presents our results. most of the time. The stack frame distance is 3 because the
signal gets routed from Linux’ vdso through the standard
As shown in the table, most of the cases were marked library. tcpdump and tcptrace use the same (libpcap)
as Unknown due to the simplicity of the !Exploitable tool. librarybut,sincetcpdumpdisplaysthecontentofthenetwork
None of the cases were marked as Probably Exploitable. flow, it has a higher distance from the library.
Finally, every crash discovered by VUzzer in tcptrace
Based on the aforementioned analysis, we believe many
7Nocrash,butinfiniteloopresultinginanout-of-memoryerror. of the crashes reported by VUzzer uncover zero-day vulnera-
114.2 1.5
400 150 20
15
100
200 10
50
100 5
20 10
0 0 0
0 4 8 12 16 20 24 0 4 8 12 16 20 24 0 4 8 12 16 20 24
mpg321 gif2png pdf2svg
11
5 410 10
350
3 250
200 5
100
1
50
0 0 0
0 4 8 12 16 20 24 0 4 8 12 16 20 24 0 4 8 12 16 20 24
tcptdump tcpttrace djpeg
Fig. 5. Distribution of crashes over a time period of 24 hours. X-axis: cummulative sum of creahes. Y-axis: time (over 24 hours). Blue line: VUzzer. Red
dashedline:AFL.Verticalgreenline:TimetakenbyVUzzertofindthesamenumberofcrashesasthosefoundbyAFLduringacompleterun.
bilities and we are currently in the process of performing re- B. Whitebox Fuzzing Approaches
sponsible disclosure to the open-source community. Table VII
Whiteboxfuzzingisoneoftheearliestattemptstoenhance
provides information on some of the bugs that we have
the performance of traditional random fuzzing by considering
analyzed and reported so far.
the properties of the application. There exist a number of
approachestomakefuzzingmoreefficient,forexample,byap-
VI. RELATEDWORK plying symbolic execution and dynamic taint analysis to solve
branch constraints [20]–[24], [26]. Although VUzzer differs
Intheprevioussections,wehavealreadyhighlightedsome
from these approaches in a number of ways, the fundamental
of the major differences between VUzzer and state-of-the-
difference remains the use of symbolic execution. Similar to
art fuzzers like AFL. In this section, we survey additional VUzzer, BuzzFuzz, proposed by Ganesh et.al. [20] makes use
recent research work in the area of fuzzing. This enables us
ofdynamictaintanalysis,butforanentirelydifferentpurpose.
to highlight some of the features and differences with respect
BuzzFuzz is a directed fuzzer and, therefore, it does not try to
to existing work.
learn constraints for every path. It instead uses taint analysis
todetectbytesthatinfluence dangerousspots inthecode,like
A. Search-based Evolutionary Input Generation library call arguments, and mutate these bytes in the input to
trigger exceptional behavior. Most of these approaches also
The use of evolutionary algorithms for input generation require the availability of source code to perform analysis.
purposesisawell-exploredresearchareainsoftwareengineer-
ing [7], [34]. There have been attempts to use evolutionary C. Blackbox/Graybox Fuzzing Approaches
algorithms for input generation to discover vulnerabilities
In spite of being simple and fully application agnos-
in applications [25], [42], [45]. The difference lies in the
tic, blackbox fuzzers, like, Peach [1], Sulley [39], and
fact that these approaches assume a-priori knowledge of the
Radamsa[40]havediscoveredbugsinreal-worldapplications.
applicationtofocusonthepathsleadingtovulnerablepartsof
However, throughout the paper, we have already discussed the
the program. This property makes these approaches closer to
limitations of such fuzzers.
directed fuzzing and, therefore, our fuzzing strategy deviates
from them substantially. Unlike VUzzer, and similar to AFL, Recently, symbolic and concolic execution-based fuzzing
thefeedbackloopusedbytheseapproachesdoesnotattemptto approaches have dominated the area of ”smart” fuzzing [12],
relate application behavior with the input structure to enhance [38], [47], [51]. Mayhem [12], a system from CMU to au-
input generation. tomatically find exploitable bugs in binary code, uses several
12TABLEVII. ANALYSISOFNEWBUGSFOUNDBYVUZZER.
Program BugType Alreadyfixed? Reported?
tcpdump Out-of-boundsRead Yes No
mpg321 Out-of-boundsRead No Yes[2]
mpg321 Doublefree No Yes[3]
pdf2svg Nullpointerderef(write) Seemstobefixedinpoppler0.49 No
pdf2svg Abort Seemstobefixedinpoppler0.49 No
pdf2svg Assertfail(abort) Yes[4] No
tcptrace Out-of-boundsRead No Yes[5]
gif2png Out-of-boundsRead No Yes[6]
program analysis techniques, including symbolic and concolic process. We achieve this by assigning weights to basic blocks
execution, to reason about application behavior for a given and implement a weight-aware fitness strategy for the input.
input. This is similar in spirit to VUzzer. However, since Byusingdynamictaintanalysis,wealsomonitorseveraldata-
the goal of VUzzer differs from that of Mayhem, VUzzer flow features of the application, providing us with the ability
doesnotrequireheavyweightprogramanalysistechniquesand to infer structural properties of the input. For example, this
insteadinfersimportantpropertiesoftheinputjustbyapplying provides us with information on which offsets in the input
heuristics based on lightweight program analysis. Similarly, are used at several branch conditions, what values are used as
Driller [47] uses hybrid concolic execution techniques [33] branchconstraints,etc.Weusethesepropertiesinourfeedback
to assist fuzzing by solving branch constraints for deeper loop to generate new inputs.
path explorations. In [28], Karge´n et.al. propose a different
We have implemented our fuzzing technique in an open-
approachtogeneratefuzzedinputs.Foragivenapplicationthat
source prototype, called VUzzer and evaluated it on several
isbeingtested,theirapproachmodifiesanotherinputproducer
applications. We also compared its performance with that of
application by injecting faults that influence the output. Using
AFL, showing that, in almost every test case, VUzzer was
this strategy, the buggy program generates mutated inputs.
able to find bugs within an order of magnitude fewer inputs
However, it is not clear if these mutated inputs indeed affect
compared to AFL. This concretely demonstrates that inferring
thewayapplicationconsumestheseinputs.TaintScope[49]—a
input properties by analyzing application behavior is a viable
checksum-awarefuzzer—usestaintanalysistoinferchecksum-
and scalable strategy to improve fuzzing performance as well
handling code, which further helps fuzzing bypass checksum
as a promising direction for future research in the area.
checks. VUzzer can also benefit from this (complementary)
techniquewhilefuzzing.Inaveryrecentwork[8](concurrent
to our work), the authors of AFLFAST proposed a markov-
ACKNOWLEDGEMENTS
modelbasedtechniquetoidentifylow-frequencypathstofocus
fuzzing efforts in that direction. The heuristic, also used by We would like to thank the anonymous reviewers for their
VUzzer partially, is to deprioritize paths that are executed by comments. We would also like to thank the LAVA team for
maximum number of inputs. VUzzer’s error-handling basic- sharingtheLAVAcorpusprivatelywithusmuchbeforetheof-
block detection technique is similar to this, albeit much light- ficialpublicrelease.ThisworkwassupportedbytheEuropean
weight. VUzzer applies other data- and control-flow features Commission through project H2020 ICT-32-2014 SHARCS
to speed-up the input generation. under Grant Agreement No. 644571 and by the Netherlands
Organisation for Scientific Research through grants NWO
There have been several other techniques to enhance
639.023.309 VICI Dowsing and NWO 628.001.006 CYBSEC
fuzzing [11], [43], [51]. VUzzer can also benefit from these
OpenSesame.
approaches,inmultipleways.Forexample,Seedselection[43]
can help VUzzer start with a good set of seed inputs.
REFERENCES
VII. CONCLUSIONS [1] “Peachfuzzer,”http://www.peachfuzzer.com/.
[2] 2016,http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=844634.
This paper argues that the key strength of fuzzing is to
[3] 2016,https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=844626.
implement a lightweight, scalable bug finding technique and
[4] 2016,https://bugs.freedesktop.org/show bug.cgi?id=85141.
applying heavyweight and non-scalable techniques, like sym-
bolicexecution-basedapproaches,isnotthedefinitivesolution [5] 2016,https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=844719.
to improve the performance of a coverage-based fuzzer. Af- [6] 2016,https://gitlab.com/esr/gif2png/issues/1.
ter studying several existing general-purpose (black/graybox) [7] W.Afzal,R.Torkar,andR.Feldt,“Asystematicreviewofsearch-based
fuzzers,includingthestate-of-the-artAFLfuzzer,wenotethat testingfornon-functionalsystemproperties,”InformationandSoftware
Technology,vol.51,no.6,pp.957–976,2009.
they tend to be application agnostic, which makes them less
[8] M.Bo¨hme,V.-T.Pham,andA.Roychoudhury,“Coverage-basedgrey-
effectiveindiscoveringdeeplyrootedbugs.Thekeylimitation
boxfuzzingasmarkovchain,”inCCS’16. NewYork,NY,USA:ACM,
of application-agnostic strategies is their inability to generate 2016,pp.1032–1043.
interesting inputs faster. We address this problem by making
[9] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler,
fuzzing an application-aware testing process. “Exe: Automatically generating inputs of death,” in CCS’06. ACM,
2006,pp.322–335.
We leverage control- and data-flow features of the ap-
[10] C.CadarandK.Sen,“Symbolicexecutionforsoftwaretesting:Three
plication to infer several interesting properties of the input. decadeslater,”Commun.ACM,vol.56,no.2,pp.82–90,Feb.2013.
Control-flow features allows us to prioritize and deprioritize
[11] S. K. Cha, M. Woo, and D. Brumley, “Program-adaptive mutational
certain paths, thereby making input generation a controlled fuzzing,”inS&P’15,May2015,pp.725–741.
13[12] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing able: https://www.defcon.org/images/defcon-15/dc15-presentations/
mayhem on binary code,” in IEE S&P’12. Washington, DC, USA: Miller/Whitepaper/dc-15-miller-WP.pdf
IEEEComputerSociety,2012,pp.380–394. [37] D. Molnar, X. C. Li, and D. A. Wagner, “Dynamic test generation to
[13] S. Clark, S. Frei, M. Blaze, and J. Smith, “Familiarity breeds con- find integer bugs in x86 binary linux programs,” in USENIX Sec’09.
tempt:Thehoneymooneffectandtheroleoflegacycodeinzero-day Berkeley,CA,USA:USENIXAssociation,2009,pp.67–82.
vulnerabilities,”inACSAC’10. NewYork,NY,USA:ACM,2010,pp. [38] M.Neugschwandtner,P.MilaniComparetti,I.Haller,andH.Bos,“The
251–260. borg: Nanoprobing binaries for buffer overreads,” in CODASPY ’15.
[14] B. Copos and P. Murthy, “Inputfinder: Reverse engineering closed NewYork,NY,USA:ACM,2015,pp.87–97.
binaries using hardware performance counters,” in PPREW’15. New [39] OpenRCE, “Sulley fuzzing framework,”
York,NY,USA:ACM,2015,pp.2:1–2:12. https://github.com/OpenRCE/sulley.
[15] DARPA CGC, “Darpa cyber grand challenge binaries,” [40] OUSPG,“Radamsafuzzer,”https://github.com/aoh/radamsa.
https://github.com/CyberGrandChallenge.
[41] P. Piwowarski, “A nesting level complexity measure,” SIGPLAN Not.,
[16] B. Dolan-Gavitt, “Fuzzing with afl is an art,” vol.17,no.9,pp.44–50,Sep.1982.
http://moyix.blogspot.nl/2016/07/fuzzing-with-afl-is-an-art.html.
[42] S. Rawat and L. Mounier, “An evolutionary computing approach for
[17] B.Dolan-Gavitt,P.Hulin,E.Kirda,T.Leek,A.Mambretti,W.Robert- huntingbufferoverflowvulnerabilities:Acaseofaimingindimlight,”
son,F.Ulrich,andR.Whelan,“Lava:Large-scaleautomatedvulnera- inEC2ND’10. IEEEComputerSociety,2010.
bilityaddition,”inIEEES&P’16. IEEEPress,2016.
[43] A. Rebert, S. K. Cha, T. Avgerinos, J. Foote, D. Warren, G. Grieco,
[18] Elias Bachaalany, “idapython: Interactive disassembler,” and D. Brumley, “Optimizing seed selection for fuzzing,” in USENIX
https://github.com/idapython. Sec’14. Berkeley,CA,USA:USENIXAssociation,2014,pp.861–875.
[19] J.Foote,“Certtriagetools,”2013. [44] K. Serebryany, “Libfuzzer: A library for coverage-guided fuzz testing
[20] V. Ganesh, T. Leek, and M. Rinard, “Taint-based directed whitebox (withinllvm),”at:http://llvm.org/docs/LibFuzzer.html.
fuzzing,”inICSE’09. IEEEComputerSociety,2009,pp.474–484. [45] S. Sparks, S. Embleton, R. Cunningham, and C. Zou, “Automated
[21] P. Godefroid, “Random testing for security: blackbox vs. whitebox vulnerability analysis: Leveraging control flow for evolutionary input
fuzzing,”inInt.workshoponRandomtesting. NewYork,NY,USA: crafting,”inACSAC’07. IEEE,2007,pp.477–486.
ACM,2007,pp.1–1. [46] M.Stamatogiannakis,P.Groth,andH.Bos,“Lookinginsidetheblack-
box: Capturing data provenance using dynamic instrumentation,” in
[22] P. Godefroid, N. Klarlund, and K. Sen, “Dart: directed automated
IPAW’14. Springer,2015,pp.155–167.
randomtesting,”SIGPLANNot.,vol.40,no.6,pp.213–223,2005.
[47] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
[23] P.Godefroid,M.Y.Levin,andD.Molnar,“Automatedwhiteboxfuzz
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
testing,”inNDSS’08. InternetSociety,2008.
fuzzing through selective symbolic execution,” in NDSS’16. Internet
[24] ——, “Sage: Whitebox fuzzing for security testing,” Queue, vol. 10, Society,2016,pp.1–16.
no.1,pp.20:20–20:27,Jan.2012.
[48] A. Takanen, J. DeMott, and C. Miller, Fuzzing for Software Security
[25] C. D. Grosso, G. Antoniol, E. Merlo, and P. Galinier, “Detecting TestingandQualityAssurance,1sted. Norwood,MA,USA:Artech
buffer overflow via automatic test input data generation,” Computers House,Inc.,2008.
&OperationsResearch,vol.35,no.10,pp.3125–3143,2008.
[49] T.Wang,T.Wei,G.Gu,andW.Zou,“Taintscope:Achecksum-aware
[26] I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos, “Dowsing directedfuzzingtoolforautomaticsoftwarevulnerabilitydetection,”in
for overflows: A guided fuzzer to find buffer boundary violations,” in IEEES&P’10. IEEEComputerSociety,2010.
USENIX SEC’13. Berkeley, CA, USA: USENIX Association, 2013,
[50] X. Wang, L. Zhang, and P. Tanofsky, “Experience report: How is
pp.49–64.
dynamicsymbolicexecutiondifferentfrommanualtesting?astudyon
[27] Hex-Rays, “Ida: Interactive disassembler,” https://www.hex- klee,”inISSTA’15. NewYork,NY,USA:ACM,2015,pp.199–210.
rays.com/products/ida/.
[51] M. Woo, S. K. Cha, S. Gottlieb, and D. Brumley, “Scheduling black-
[28] U. Karge´n and N. Shahmehri, “Turning programs against each other: box mutational fuzzing,” in CCS’13. New York, NY, USA: ACM,
High coverage fuzz-testing using binary-code mutation and dynamic 2013,pp.511–522.
slicing,”inFSE’15. NewYork,NY,USA:ACM,2015,pp.782–792.
[52] M.Zalewski,“Americanfuzzylop,”at:http://lcamtuf.coredump.cx/afl/.
[29] V.P.Kemerlis,G.Portokalidis,K.Jee,andA.D.Keromytis,“Libdft:
Practical dynamic data flow tracking for commodity systems,” in
SIGPLAN/SIGOPSVEE’12. NewYork,NY,USA:ACM,2012,pp.
121–132.
[30] H. Kobayashi, B. L. Mark, and W. Turin, Probability, Random Pro-
cesses,andStatisticalAnalysis:ApplicationstoCommunications,Sig-
nal Processing, Queueing Theory and Mathematical Finance. Cam-
bridgeUniversityPress,Feb.2012.
[31] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S.Wallace,V.J.Reddi,andK.Hazelwood,“Pin:Buildingcustomized
program analysis tools with dynamic instrumentation,” in PLDI’05.
NewYork,NY,USA:ACM,2005,pp.190–200.
[32] ——, “Pin:building customized programanalysis tools withdynamic
instrumentation,”inACMSigplanNotices,vol.40,no.6. ACM,2005,
pp.190–200.
[33] R. Majumdar and K. Sen, “Hybrid concolic testing,” in ICSE’07.
Washington,DC,USA:IEEEComputerSociety,2007,pp.416–426.
[34] T. Mantere and J. T. Alander, “Evolutionary software engineering, a
review,” Applied Soft Computing, vol. 5, no. 3, pp. 315–331, 2005,
applicationReviews.
[35] B. P. Miller, L. Fredriksen, and B. So, “An empirical study of the
reliabilityofunixutilities,”Commun.ACM,vol.33,no.12,pp.32–44,
1990.
[36] C. Miller and Z. N. J. Peterson, “Analysis of muta-
tion and generation-based fuzzing,” 2007. [Online]. Avail-
14