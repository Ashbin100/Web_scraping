A2C: Self Destruc-ng Exploit Execu-ons
via Input Perturba-on
Yonghwi Kwon1, Brendan Saltaformaggio1, I Luk Kim1,
Kyu Hyung Lee2, Xiangyu Zhang1, and Dongyan Xu1
1Department of Computer Science, Purdue University
2Department of Computer Science, University of Georgia
1Observa-on
In most a,acks, a,ackers need to inject
malicious payloads
and they are bri,le
2Our Solu=on: A2C
Observa-on
Malicious Input: ...01010101010...
Malicious Payload: Shellcode/ROP
Shellcode (Payload) Corresponding Instruc=ons
31 c0 31 f6 50 5f 50 b0 66 6a 01 xor eax, eax; xor esi, esi;
5b 53 6a 02 89 e1 cd 80 96 ... push eax; pop edi; push eax; ...
XOR 0xAA
9b 6a 9b 5c fa f5 fa 1a cc c0 ab fwait; push 0xffffff9b; pop esp;
f1 f9 c0 a8 23 4b 67 2a 3c ... cli; cmc; cli; sbb cl, ah; shr ...
Payload is broken!
3Our Solu=on: A2C
Benign execu-on
Input (HTTP request)
POST /index.php HTTP/1.1 ...
-1
Encoded input
ONRS..hmcdw-ogo.GSSO.0-0 ...
Web server Encoded input
ONRS..hmcdw-ogo.GSSO.0-0 ...
Parses/Processes Inputs
POST /index.php HTTP/1.1
Generates Outputs
Output (HTML page)
<html><head><-tle>....</html>
4Our Solu=on: A2C
Idea
Inputs Encoded inputs Program
Encodes
Exploit
Payload is encoded:
A,ack Failed
Decodes
Benign request
Decoded
input
5Our Solu=on: A2C
Why payloads are not decoded?
Decoding based on input processing seman=cs
We sta-cally analyze a program and decode when inputs are
used by the program (as intended data)
Inputs should be data, not code
A2C allows inputs to be accessed as (intended types of) data, but
breaks if they are code (or unintended types of data (e.g., ROP
gadgets))
6Our Solu=on: A2C
Overview
+
Program Analysis
Original Program
Instrumented Run=me
(Constraint Solving +
Program Support
Sta=c Analysis)
7Step 1: Program Analysis
When to encode and decode?
When to encode?
Encode incoming inputs from untrusted sources at
library calls (e.g., recv, read)
When to decode?
Decode when the encoded values are consumed by the
program’s input processing logic
8Program Analysis
When to decode?
Encoded Program Outputs
Inputs
Copy
Read/Compare (Parse)
Conversion (e.g., Charset conversion)
Computa-on
9Program Analysis
When to decode?
Encoded Program Outputs
Inputs
Copy No Decode
Read/Compare (Parse) Decode
Conversion (e.g., Charset conversion)
Computa-on
10Program Analysis
Can an agacker control results?
Opera=on 1
A X
B Y
Malicious Inputs
(Payload)
Conversion (e.g., Charset conversion)
Computa-on
11Program Analysis
Can an agacker control results?
Opera=on 2
A 1
B 1
Malicious Inputs
(Payload)
Conversion (e.g., Charset conversion)
Computa-on
12Program Analysis
Not Sure? Ask Constraint Solver!
// Declara-ons (Data Types)
unsigned int m7[...][...];
unsigned short img[...][...];
unsigned short mpr[...][...];
...
// Transforma-ve Opera-ons
for (int x = 0; ...; x++ )
for (int y = 0; ...; y++ )
m7[x][y] = img[...][...] - mpr[...][...];
13Program Analysis
Not Sure? Ask Constraint Solver!
6. m7/[/x ]D[ye]c l=a rima-go[.n..s] [(.D..a] t-a m Tpyrp[e..s.])[ ...];
1. unsigned int m7[...][...];
; Constraints for Opera-ons (img - mpr)
2. unsigned short img[...][...];
m7[0,1,2,3] = img[0,1,2,3] - mpr[0,1,2,3] /\
3. unsigned short mpr[...][...];
; Constraints for the range of unsigned short
...
0 <= img[0,1,2,3] /\ 0 <= mpr[0,1,2,3] /\
// Transforma-ve Opera-ons
img[0,1,2,3] <= 65535 /\ mpr[0,1,2,3] <= 65535 /\
4. for (int x = 0; ...; x++ )
; Constraints for Payloads (n will select a payload)
5. for (int y = 0; ...; y++ )
m7[0,1,2,3] = payload[n, n+1, n+2, n+3] Large
6. m7[x][y] = img[...][...] - mpr[...][...];
Payload
Pool
(1.4G)
14Program Analysis
Not Sure? Ask Constraint Solver!
ROPgadget
tool
shell-storm.org
Ropper tool
Z3 Solver
Payloads
15Program Analysis
Not Sure? Ask Constraint Solver!
Constraint Solver returns ...
SAT: Agackers can control
TIMEOUT and UNKNOWN: Don’t know è
Agackers might control!
UNSAT
è A,ackers cannot control!
16Decoding Fron=er
Exploitable and Post-Exploitable Space
Encoded Program Outputs
Inputs
Copy No Decode
Conversion (e.g., Charset conversion) No Decode
Simple Computa-on No Decode
Read/Compare (Parse) Decode
Certain Complex Computa-on Decode
17Decoding Fron=er
Exploitable and Post-Exploitable Space
Encoded Program Outputs
Inputs
Encoded Decoded
Copy Read/Compare (Parse)
Conversion (e.g., Certain Complex
Charset conversion) Computa-on
Simple Computa-on
Exploitable Space Post-exploitable Space
Decoding Fron@er
18Step 2: Instrumenta=on
When to encode?
- Encode incoming inputs from untrusted sources at
library calls (e.g., recv, read)
- Encode “constants” that can be wrigen to encoded
buffers (Details in the paper)
When to decode?
- Decode when encoded values are consumed by the
program’s input processing logic
- Decode permanently at decoding fron-er
19Evalua=on
Performance (18 real world apps + SPEC
CPU2006)
18 real world apps SPEC CPU2006
Average: 6.11% Average: 8.13%
Average of all (30 programs):
6.94%
20Evalua=on
Effec-veness
23 different exploits on 18 programs
Tested 100 payloads (50 shellcode/50 ROP) for each program
3 . 6
Avg. # of instr. executed in payloads
Muta-on will break malicious
XOR with 0xAA on malicious payloads. Only 3-4
instruc-ons parae yexloecautdesd aenxde thceuse- aoren m, e aningless.
and it will break early
0 . 1 Avg. # of ROP gadgets executed
Almost no ROP gadgets were executed.
21Discussion
Limita-ons
A,acks in Post-exploitable Space
We use a large pool of payload test cases that models the
distribu-on of valid payloads to determine the DF with strong
probabilis@c guarantees.
Memory Disclosure
We use a different dic-onary (encoding key) for each buffer and
each request. Knowing a previous buffer’s dic-onary does not
help in subsequent agacks.
22Related Works
CFI
Prac-cal CFI (V. van der Veen et al. in CCS’15, B. Niu et al. in CCS’15,
C. Tice et al. in SEC’14, C. Zhang et al. in SP’13, M. Zhang et al. in SEC’13,
V. Pappas et al. in SEC’13, Y. Xia et al. in DSN’12, ...), SafeDispatch (D. Jang et
al. in NDSS’14), Control Flow Locking (T. Bletsch et al. in ACSAC’11), ...
Malicious Payloads Detec=on
Z. Liang et al. in CCS’05, T. Toth et
al. in RAID’02, P. Fogla et al. in SEC’06, M. Polychronakis et al. in RAID’07, K.
Snow et al. in SEC’11, ....
Randomiza=ons
ASLR (R. Wartell et al. in CCS’12, V. Pappas et al. in
SP’12, D. Bigelow et al. in CCS’15, S. Crane et al. in SP’15, J. Hiser et al. in
SP’12), ISA (G. Portokalidis et al. in ACSAC’10, G. S. Kc et al. in CCS’03), Data
Space Randomiza-on (S. Bhatkar et al. in DIMVA’08) ...
Bound Checkers
Address Sani-zer (K. Serebryany et al. in ATC’12),
Cling (P. Akri-dis et al. in SP’08), StackGuard (C. Cowan et al. in SEC’98), ...
23Conclusion
A2C provides a general protec=on
against a wide spectrum of payload injec-on agacks
- Malicious Input: program breaks, and breaks early
- Benign Input: program executes correctly
Key Idea: encodes inputs, decodes depending on the
input processing seman=cs
A2C prevents payload injec=on with low overhead
24Q&A
Thank you
Yonghwi Kwon
PhD student, Purdue University
Contact: yongkwon@purdue.edu
Web: h,p://yongkwon.info
25More Slides
• Backup Slides
26Evalua=on
Decoding fron-er computa-on
More decoding fron=ers
71% of decoding fron-ers turned out
they are indeed decoding fron-ers.
Exploitable-Space is Small
Inputs are quickly parsed and do not
usually propagate deeply into a
program. Exploitable-space is not huge
which is a key reason of our low
overhead.
27Case Study
Preven-ng ROP Agacks
ROP Gadget Instruc=on
void process_font_table (...) {
0x804d820 mov ebx,0x0
ret
...
0x804ec7d mov eax,0x806275c
char name[255];
ret
...
... ...
while (w2) {
XOR 0xAA
tmp = word_string(w2);
if ( tmp && DEC( tmp[0] ) != '\\' )
ROP Gadget Instruc=on
strcat( name, tmp );
0xa2ae728a Invalid address
... 0xa2ae46d7 Invalid address
... ...
28Decoding/Encoding Sets
Sta-c Analysis
Encoding Set: When to encode?
Encode Incoming Untrusted Sources at Library Calls
(e.g., recv, read)
Decoding Set: When to decode?
Decode when encoded values are used
- Decode permanently at decoding fron@er
Finding Decoding/Encoding Sets
Flow-, Context-, Field-sensi@ve Sta@c Analysis
29Decoding/Encoding Sets
Instrumenta-on
recv(..., untrusted_buf, ...);
ENC( untrusted_buf );
...
iiff (( DunECtr( uusntterdu_stbeudf_[b0u] f=[=0 ]‘ C) =’ =) {‘ C’ ) {
...
}
...
int ret = memcmp( uDnEtCr(u usntetrdu_sbteudf,_ b..u. )f; ) , ... );
30Decoding/Encoding Sets
Instrumenta-on
Decoding is not simple
recv(..., untrusted_buf, ...); ENC( untrusted_buf );
...
if ( DEC( untrusted_buf[0] ) == ‘C’ ) {
memcpy( untrusted_buf, “CONSTANT”, ... );
}
...
int ret = memcmp( DEC( untrusted_buf ), ... );
untrusted_buf can be from ‘recv’ and ‘constant’
31Decoding/Encoding Sets
Instrumenta-on
Decoding is not simple
recv(..., untrusted_buf, ...); ENC( untrusted_buf );
...
Decoding untrusted_buf will break
if ( DEC( untrusted_buf[0] ) == ‘C’ ) {
when it holds “CONSTANT”
memcpy( untrusted_buf, “CONSTANT”, ... );
}
Not Decoding untrusted_buf will break
...
when its value is from recv
int ret = memcmp( DEC( untrusted_buf ), ... );
32Decoding/Encoding Sets
Instrumenta-on
Decoding is not simple
recv(..., untrusted_buf, ...); ENC( untrusted_buf );
...
We also encode “CONSTANT”
if ( DEC( untrusted_buf[0] ) == ‘C’ ) {
memcpy( untrusted_buf, “CONSTANT”, ... );
}
Now, decoding untrusted_buf will not
...
break in any context.
int ret = memcmp( DEC( untrusted_buf ), ... );
33Decoding/Encoding Sets
Instrumenta-on
Decoding is not simple
recv(..., untrusted_buf, ...); ENC( untrusted_buf );
...
if ( DEC( untrusted_buf[0] ) == ‘C’ ) {
mmeemmccppyy(( uunnttrruusstteedd__bbuuff,, E“CNOCN(“SCTOANNSTT”A, N...T )”;) , ... );
}
...
int ret = memcmp( DEC( untrusted_buf ), ... );
untrusted_buf is always encoded in any context
34Evalua=on
Different Types of Decoding Fron-ers
1. Compara=ve:
x == y
2. Terminal:
send( x )
3. Type widening:
int y = (char)x;
4. Primi=ve Type
Conversion:
float v = atof(x);
5. Indexing:
1 2 3 4 5
y = array[x];
35Evalua=on
Decoding Fron-er Computa-on
14 = Avg. Constraints
We mostly find that # of
constraints for decoding
fron-er computa-on is not
very large (10-20). This
makes the fast computa-on
possible.
36