([SHULPHQWLQJ(cid:3)ZLWK(cid:3)6KDUHG
*HQHUDWLRQ(cid:3)RI(cid:3)56$(cid:3).H\V
Michael Malkin
Thomas Wu
Dan Boneh
Stanford University
*Supported by DARPAd
CA 1
CA
d
d
2
d
3
The private key is never reconstructed!
F
Who generates the shared key?
2d
1
CA Trusted
Dealer
d
2
d
3
Drawbacks:
• Single point of failure
• May have to destroy dealer afterwards
3Advantages:
• Nobody ever knows the entire key
• No single point of failure
Step 1 Step 2 Step 3
d d
1 2
N
d e
3
4N An n-bit modulus, N = pq
e The encryption (public) key
d The decryption (private) key
Sharing of d : d = d + d + d
1 2 3
F
Can apply key without reconstructing d
d is the secret
fi
p or q d
5(cid:13)
1 3
Biprimality
p p p
1 2 3
q q q Test
1 2 3
p , q are n/2 bit integers
i i
2 4
p p p N p q p q p q
1 2 3 1, 1 2, 2 3, 3
q q q
d d d
1 2 3
1 2 3
N = (p + p + p )·(q + q + q ) = pq
1 2 3 1 2 3
Nobody ever knows p or q!
(*Boneh-Franklin)
6Non-Distributed:
• Pick prime p
• Pick prime q
• Multiply
Distributed:
• Pick N
• Hope N = pq is an RSA modulus
• Can’t test p and q separately
F
’LVWULEXWHG(cid:3)JHQHUDWLRQ(cid:3)WDNHV(cid:3)PRUH(cid:3)LWHUDWLRQV
7Initial time: 2.5 hours
(1024-bit key)
• Distributed Sieving × 10
• Multithreading × 6
• Load Balancing × 1.3
• Parallel Trial Division × 1.3
Final time: 1.5 minutes
8p q
fi
• Bad N probably divisible by 3 or 5 or 7 or …
• Idea: Ensure that N isn’t divisible by any small primes
F
Distributed Sieving
• Can pick p , q so that p, q are not divisible by small primes
i i
… But nobody actually knows p or q!
9fi
• Synchronous algorithm synchronization delays
• Under-utilizing CPU — idle 80% of time
F
Multithreading
• 6 threads optimal for 1024-bit key
• Almost 6 times faster!
(
On 300Mhz Pentium II’s running Solaris 2.6)
10• Biprimality test involves time-consuming calculation
• Idea: Only one server needs to do this
F
Load Balancing
• A different server does test for each iteration
• Probabilistic load balancing
11• What about small primes not covered by sieving?
• Trial division on N by small primes
F
Parallel Trial Division
• Each server does trial division on different small primes
12• Implemented method for small e
• In RSA usually use a small e
• After N is found, generate d , d , and d so:
1 2 3
d + d + d = d
1 2 3
… But do this so that nobody ever knows d
• There is an additional way to share d
• Only a fraction of servers need to be active
13,PSOHPHQWDWLRQ(cid:29)(cid:3)&RQILJ(cid:3))LOH
Num_Servers: 3
Key_Length: Normal
Threads: 2
TrialDiv_End: 10000
Sieve: True
Test_Mode: True
Sequence_Numbers: True
Transport: sslv3
Share_IP_Port_0: 8080
Server_IP_Addr_0: ittc.stanford.edu
Server_Sequence_File_0: com_security/seq0
Server_Cert_0: com_security/cert_s0.pem
Server_Key_0: com_security/key_s0.pem
14• Abstraction layer
• Fault tolerance - non-blocking I/O
• Private, authenticated channels
• Based on SSLeay
• Authenticates share servers using a server certificate:
/C=US/ST=California/O=Stanford University/
OU=ITTC Project/CN=[SERVER 0]
156KDUHG(cid:3).H\(cid:3)6WRUDJH
• Stored as PEM-encoded ASN.1 format
Data Type Field
Integer Version
Integer N
Integer e
Integer k
Integer d
1
M M
Integer d
k
16Primality Network
Key Size Threads Tests Iterations Total Time Traffic
512 bit 2 36 119 0.15 min 0.18 Mb
1024 bit 6 49 130 1.5 min 1.16 Mb
2048 bit 6 234 495 18 min 7.48 Mb
On three 300Mhz Pentium II’s running Solaris 2.6
• Network bandwidth is reasonable
• 1024-bit works well
• 2048-bit is reasonable
17(IIHFW(cid:3)RI(cid:3)1XPEHU(cid:3)RI(cid:3)6HUYHUV
6
5
4
3
2
1
0
18
setuniM
Time to generate a 1024-bit RSA key
3 4 5 WAN 1 CPU
Number of Servers
WAN:
• Two servers at Stanford
• One server at University of Wisconsin at Madison
• Difficult to find PC’s running Solaris1200
1000
800
600
400
200
0
0 2 4 6 8
Threads
19
daerhT
rep
snoitaretI
7
6
5
4
3
2
1
0
0 2 4 6 8
Threads
setuniM
• Synchronization/CPU tradeoff
• Minimize time with 6 threads
*Generating a 1024-bit RSA key(IIHFW(cid:3)RI(cid:3)’LVWULEXWHG(cid:3)6LHYLQJ
12000
10000
8000
6000
4000
2000
0
• Sieve bound is largest prime sieved
fi
• Larger sieve fewer iterations
• Diminishing returns
*Generating a 512-bit RSA key
20
snoitaretI
1200
1000
800
600
400
200
0
0 50 150
Sieve Bound
sdnoceS
0 50 150
Sieve BoundF
Distributed key generation is practical:
• 1.5 minutes for 1024-bit key
F
Several practical improvements to algorithm
• Distributed Sieving
• Multithreading
• Load Balancing
• Parallel Trial Division
F
Optimized cryptographic algorithm
• Requires security proofs
http://theory.stanford.edu/~dabo/ITTC
21