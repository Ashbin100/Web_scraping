Efficient Detection of Split Personalities in Malware
DavideBalzarotti1,MarcoCova3,ChristophKarlberger2
ChristopherKruegel3,EnginKirda2,andGiovanniVigna3
1InstituteEurecom, 2SecureSystemsLab, 3UniversityofCalifornia,
SophiaAntipolis ViennaUniversityofTechnology SantaBarbara
Abstract canefficientlydetectmalwaresamplesthatuseavariety
oftechniquestoidentifyemulatedanalysisenvironments.
Malwareistherootcauseofmanysecuritythreatson
theInternet. Tocopewiththethousandsofnewmalware
samples that are discovered every day, security compa- 1 Introduction
nies and analysts rely on automated tools to extract the
runtimebehaviorofmaliciousprograms.Ofcourse,mal-
ware authors are aware of these tools and increasingly Thesteadygrowthinthenumberofmalwaresamples
trytothwarttheiranalysistechniques. Tothisend,mal- found every day has elicited an increased effort by se-
warecodeisoftenequippedwithchecksthatlookforev- curity vendors and analysts to develop automated mal-
idenceofemulatedorvirtualizedanalysisenvironments. ware analysis tools [1,3–6,8]. These analysis systems
When such evidence is found, the malware program be- typicallyexecuteanunknownprograminarestricteden-
haves differently or crashes, thus showing a different vironment (a sandbox) and monitor the program’s run-
“personality”thanonarealsystem. timebehavior. Basedontheobservedbehavior,analysts
can then assess the severity of the threat posed by the
Recentworkhasintroducedtransparentanalysisplat- malware and develop appropriate countermeasures. Of
forms (such as Ether or Cobra) that make it signif- course,malwareauthorshaveavestedinterestincreating
icantly more difficult for malware programs to detect malicious code that can evade automated screening and
theirpresence.Othershaveproposedtechniquestoiden- analysisprocedures. Thereasonisthat,byremainingin-
tify and bypass checks introduced by malware authors. visibletoautomatedanalysissystems,malwareprograms
Both approaches are often successful in exposing the canoperate(andgeneraterevenue)foralongerperiodof
runtime behavior of malware even when the malicious time.
codeattemptstothwartanalysisefforts. However,these Tothwartautomatedscreening,malwareauthorshave
techniquesinducesignificantperformanceoverhead,es- developed a number of ways to check for the presence
pecially for fine-grained analysis. Unfortunately, this ofmalwareanalysistoolsandpopularsandboxenviron-
makes them unsuitable for the analysis of current high- ments [19,32]. When the malware detects indications
volumemalwarefeeds. that a malware analysis system is present, it typically
suppresses the execution of malicious functionality or
In this paper, we present a technique that efficiently simplyterminates. Thewayinwhichthechecksareim-
detects when a malware program behaves differently in plementeddependsonthetypeofmalwareanalysissys-
an emulated analysis environment and on an uninstru- tem that is targeted. One class of checks leverages in-
mentedreferencehost. Thebasicideaissimple: wejust putfromtheruntimeenvironment(theoperatingsystem)
compare the runtime behavior of a sample in our anal- to determine whether an analysis tool is present. Often,
ysis system and on a reference machine. However, ob- suchcheckslookforfiles,registrykeys,orprocessesthat
tainingarobustandefficientcomparisonisverydifficult. are specific to individual analysis tools. A second class
Inparticular,ourapproachconsistsofrecordingthein- of checks exploits characteristics of the execution envi-
teractions of the malware with the operating system in ronmentthataredifferentbetweenarealhostandanem-
one run and using this information to deterministically ulatedorvirtualizedsystem(whichisfrequentlyusedto
replaytheprograminouranalysisenvironment. Ourex- implementtheanalysissandbox).Forthesechecks,small
perimentsdemonstratethat,byusingourapproach,one variationsinthesemanticsofCPUinstructionsortimingpropertiesareleveragedtodeterminewhetheramalware tion of deviations efficiently, and any deviation must be
processisruninanemulatororavirtualmachine(VM). the result of a malware check and not due to unrelated
differencesbetweentheexecutiontraces. Unfortunately,
Tosolvetheproblemof“analysis-awaremalware”re-
thepreviously-mentionedtool[22]failstoadequatelyad-
searchers have explored two kinds of approaches. One
dress both challenges. First, the tool uses Ether to pro-
classofapproachesfocusesonthedevelopmentofanaly-
duce the reference trace, which causes an unacceptable
sisplatformsthataremoredifficulttodetectbymalicious
performancepenalty. Second,malwaresamplesaresim-
code. Cobra [38] is one of the first systems that intro-
ply executed twice, once on the analysis environment
ducedtheideaofstealth(ortransparent)malwareanaly-
andasecondtimeonthereferencesystem. However,as
sis. Tothisend,thesystemperformsdynamictranslation
our experiments demonstrate, executing the same mal-
ofthemaliciouscodeunderexamination. Thatis,every
wareprogramtwicecanleadtodifferentexecutionruns,
codeblockisdisassembledandinspectedbeforeitisex-
even when no anti-analysis checks are present. Thus, a
ecuted. During this process, each instruction that could
differencebetweentwoexecutiontracesisnotareliable
be used to detect Cobra is replaced with a safe version,
indicatorforthepresenceofanyanti-analysischecksin
calledastealthimplant[37]. Later,researchersproposed
malwaresamples.
Ether [16], a system that leverages hardware virtualiza-
tiontoremaininvisibletomalwarechecks. In this paper, we present a tool that reliably and ef-
Both Cobra and Ether have been shown to be diffi- ficiently detects malware that changes its behavior in-
cult to detect by current malware. However, both sys- sidean(emulated)analysisenvironment,thatis,malware
tems also induce a significant performance penalty, in withsplitpersonality.Toperformthedetection,welever-
particularwhenperformingfine-grainedanalysis.Unfor- agethebasicinsightthat,giventhesameinputs,theex-
tunately,thislevelofanalysisisrequiredforcomprehen- ecutionofaprogramshouldbethesameinouranalysis
sivereportssuchasthoseproducedbyAnubis(ourown environmentandonareferencesystem. Moreprecisely,
malware analysis tool [1,8]) or similar systems [3–6]. wefirstuseakerneldriveronthereferencehosttoeffi-
This is because these systems need, at least, to inspect cientlyrecordatraceofthesystemcalls(andtheirargu-
the arguments of Windows API library functions in ad- ments)thatareexecutedbythemalwareunderanalysis.
dition to system calls, and often track additional infor- Thissystemcalllogcontainsboththeoutputarguments
mation during runtime. The main reason for the perfor- (the values produced by the program and consumed by
manceimpactisthefactthatCobraandEtheroperateon the operating system) and the input arguments (the val-
individualinstructionsorsingle-stepthroughtheprocess ues provided by the operating system and consumed by
execution. Interestingly, the authors of Ether note that the program). In the next step, the malware is executed
their fine-grained analysis “is not meant to be used for intheanalysisenvironment. Ouranalysisenvironmentis
real-timeanalysis,”whiletheauthorsofCobranotethat a modified version of Anubis, which is an extension of
theperformanceoftheirtoolis“withinthelimitsofinter- Qemu,afull-systememulator. Basedonthesystemcall
active analysis.” Given these limitations, these systems log,wecansupplythesameinputargumentsthatthepro-
are not suitable for automated analysis of high-volume grampreviouslyreceivedonthereferencesystem. That
malware feeds. For example, Anubis receives several is, we can perform precise replay of the malware pro-
thousand malware samples every day, and this number cess. This allows us to check whether the system calls
is likely to be significantly larger for commercial anti- (andtheiroutputarguments)thatweobserveintheanal-
malwarecompanies. ysisenvironmentcorrespondtotheonesweexpectfrom
the reference system, given the previously-recorded in-
A second class of approaches to address the prob-
formation.Sincetheinputstotheprocessesarethesame,
lem of analysis-aware malware is to detect the fact that
we expect any deviation to be the result of a check that
a malware sample behaves differently in different envi-
detectedouranalysissystem,andhence,causedthema-
ronments. Recently, researchers have proposed a tool
liciouscodetofollowadifferentexecutionpath.
in which the execution of a malware sample in an em-
ulated(analysis)environmentiscomparedwiththeexe- Our Windows process replay infrastructure, a core
cution trace of this sample on a reference system [22]. component of the analysis environment, is comprehen-
A deviation is considered to be caused by a malware sive and supports features that require special handling,
check that results in the execution of a different pro- suchasmultiplethreads,memory-mappedfiles,andde-
gram path. The basic idea is appealing in theory, be- ferredsystemcalls. Thisisnecessarytohandlethecom-
cause it promises a very general mechanism to detect plex internals of Windows processes and make the sys-
malwarethatbehavesdifferentlyinananalysisenviron- tem work on real malware programs. Our experimental
mentthanitdoesonareferencesystem. However,there resultsshowthattheproposedsystemcanidentifyawide
are a number of problems that must be solved in prac- range of different anti-analysis checks. Moreover, the
tice. In particular, it is important to perform the detec- system can successfully execute (replay) programs thatdonotcontainchecks,andcandetectmalwareinthewild Transparent malware analysis. One could consider
thatimplementsanti-emulatorchecks. directly modifying Anubis or a similar analysis tool to
make it invisible to malware checks. To assess the
Themaincontributionsofthispaperareasfollows:
promise of this approach, it is useful to examine the
different ways in which malware can detect an analy-
• Weproposeareliableandefficientapproachtode- sis environment. Following the terminology introduced
tect malware with split personality. Our approach bytheauthorsofEther[16],atransparent(undetectable)
worksbycomparingthesystemcalltracerecorded malwareanalysissystemhastofulfillfivebasicrequire-
when running a malware program on a reference ments. Wewilldiscusstheserequirementsinthecontext
system with the behavior observed in the analysis ofAnubis,sincethisisthesystemforwhichwehaveim-
environment. plementedthetechniquespresentedinthispaper. How-
ever, the discussion holds in general for all approaches
• We have implemented a comprehensive replay in- thatexecutethemalware(andtheoperatingsystem)inan
frastructure for Windows processes that allows us emulatororavirtualizedenvironment. Therearealterna-
toexecutetheprogramunderanalysiswiththesame tive techniques (such as CWSandbox or Joebox) where
inputsonthereferencesystemandtheanalysisen- partsoftheanalysissystemruninsidethemalwarepro-
vironment. cessorinthesameoperatingsystem. Inthesecases,the
malwareexecutesataprivilegelevelthatissimilartothe
• Wedemonstratethatourtoolissuccessfulindetect- analyzer, and, as a result, the analysis platforms cannot
ingavarietyofchecksusedtoidentifyanalysisen- betransparent[16].
vironments,includingmalwaresamplesinthewild
The first requirement for transparency states that the
thatcontainchecksthatevadeAnubis.
analysis tool has to run in a higher privilege level than
theprogramitanalyzes. Thisrequirementistriviallysat-
2 ProblemStatement isfiedbyapproachesthatrunthetargetinanemulatorora
virtualmachine. Thisisalsotrueforthesecondrequire-
ment,whichstatesthatallside-effectsintroducedbythe
The ultimate goal of an automated malware analysis
analyzer must not be accessible through non-privileged
tool(suchasAnubis)istoobtainanunderstandingofthe
(malware)operations.
runtime behavior of malicious code that is as complete
as possible. In practice, these analysis tools typically The third requirement dictates that the semantics of
followadynamicapproachandsimplyrunanunknown theinstructionsetusedbytheanalyzerhastobethesame
program,monitoringitsruntimebehavior. Thetwomain astheoneusedbyarealhost. Thisconditionisdifficult
issuesthatlimitthecompletenessoftheresultsdelivered tofulfillforanemulator. Anemulatorbasicallyprovides
by a dynamic analysis tool are (a) limited test cover- a software implementation of a complex hardware de-
ageand(b)malwareprogramsthatdetectandevadethe vice(aCPU).Hence,itisalwayspossiblethatthereare
analysisenvironment. Toaddresstheproblemoflimited differences that can be detected. Indeed, previous work
testcoverage,researchershaveproposedextensionsthat haspointedoutCPUsemanticsattacks[16,19,22,27,32]
exploremultipleexecutionpaths[10,30,39]orthatscan based on differences between emulated and real CPUs,
non-executedcoderegionsusingstaticanalysis[13]. andsuchattacksarealsousedactivelybymalwareinthe
wild. The checks used by these attacks exploit undoc-
To address the problem of malware that detects the
umented side-effects of x86 instructions or look for the
analysisenvironment,researchershaveproposedstealthy
presence of CPU-specific mode registers that are typi-
(transparent)analysistools[16,38]thataremoredifficult
callynotpresentontheemulatedprocessor.
toidentify. Asmentionedpreviously, thesetoolsareef-
fective and can gather system call traces in an efficient Thefourthrequirementmandatesthatexceptionhan-
fashion. However, for a more fine-grained analysis that dlingmustbetransparent.Thisalsodemandsthatsystem
includesmorethansystemcalls,thetoolshavetoresort calls(includingsystemcallresults)havetobethesame
toamodeinwhichindividualinstructionsareinspected ontheanalysisplatformandonarealhost. Theauthors
and logged. This is too slow for handling current mal- of Ether state that this requirement can be fulfilled by
warefeeds,whichtypicallycontainmanythousandsam- Anubis and other emulator-based systems “with careful
ples every day. Unfortunately, for a complete and com- design.” However, in practice, there are many ways in
prehensive analysis, Anubis and other tools need to see which the presence of an emulator can be detected by
morethanasystemcalltrace,andhence,requireafine- checking for artifacts in the operating system environ-
grained analysis. For example, Anubis examines Win- ment. This includes specific processes, drivers, or reg-
dowsAPIlibrarycalls,andittracksdataflowdependen- istryvaluesintheguestoperatingsystem. Forexample,
cies. in a typical installation of Windows in VMware Work-station,theregistrycontainsover300occurrencesofthe thattheanalysisfailedtodetectasamplewithasplitper-
stringVMware. Whileitisinprinciplepossibletohide sonality,possiblymissingaseverethreat. Falsepositives
theseartifacts,itisdifficultinpractice. Asaresult,many typically result in a performance loss, because malware
environmentattacks[11]existthatlookforresourcesin sampleswithsplitpersonalitiesinduceadditionalanaly-
theguestoperatingsystemtoidentifyamalwareanalysis siseffort. Withregardstoefficiency,werequirethatthe
environmentortheemulator/virtualmachineusedbythe detector do not add substantial overhead to the current
malwareanalysistool. Anubisanalysisprocess. Currently, theAnubisanalysis
Thefifthrequirementstatesthat,foratransparentmal- environmentcomprisestenQemuworkersontwophys-
ware analysis system, there has to be an identical mea- icalmachines. Althoughthemachinesarefullyutilized,
surement of time. That is, instructions need to take theystilldonotmanagetoprocessourdailysamplefeed.
the same time on the emulator as on the real machine. Thus,anyincreaseinoverheadimmediatelytranslatesto
Clearly, this is not possible, since emulators and virtual alowernumberofsamplesthatcanbeanalyzed.
machines add additional overhead that make the execu-
tion slower than on a native system. Given the large
Handlingmalwarewithsplitpersonalities. Thesec-
number of possible channels through which a process
ond step is to leverage the information collected dur-
can time its execution, timing attacks [32] are very dif-
ing the process of detecting the malware’s split per-
ficulttomitigate. Indeed, systemssuchasEtherexplic-
sonality to improve the analysis results. One possibil-
itlyexcludetimingchecksbasedoninputfromexternal
ity is to rerun malware samples with split personalities
resources (such as an NTP time server on the Internet)
in a transparent but costly analysis framework such as
fromtheirthreatmodel.
Ether. Inthissetup,ourproposedsystemactsasaneffi-
Given the complexity of the analysis system as well
cientandreliablefiltertodetectthosemalwareprograms
as the range of CPU semantics, environment, and tim-
thatrequireadditionalanalysis. Currently,thisapproach
ingattacksthatamalwareauthorhasathis/herdisposal,
wouldbepractical,asthefractionofmalwareprograms
making Anubis invisible to individual checks is clearly
that attempt to detect the analysis environment is quite
anuphillbattle.Similarly,Garfinkeletal.[20]concluded
low. For example, in a previous work [7], we found
that realizing a VMM that is indistinguishable from na-
that less than one percent of the samples in the Anubis
tive hardware is difficult to the point of impracticality.
database execute known checks to detect our analyzer
Thus, we envision a more general approach to address
or are packed with executable protectors (such as Ar-
theproblemofanalysis-awaremalware. Ourapproachis
madillo and tElock) that are known to recognize or fail
atwo-stepprocess.
on Qemu. This is consistent with the findings in a re-
lated study [11], in which the authors show that about
Detecting malware with split personalities. In the 4%ofmalwaresamplesbehavedifferentlywhenrunin-
first step, we detect whether a malware program has a sideavirtualmachine. However,asthefractionofsplit-
splitpersonality.Thisisthefocusofthetoolpresentedin personality malware rises, alternative solutions are re-
thispaper.Thatis,thegoalofthetoolpresentedhereisto quired. A promising venue is to carry out additional
detect malware programs whose runtime behavior in an analysis to identify the root cause for deviating behav-
emulator-based malware analysis system (such as Anu- ior. Once this root cause (likely, the malware check) is
bis) is different from the behavior that these programs found,theanalysisenvironmentcanbeadaptedtoauto-
exhibit on a reference system (a system where the mal- matically bypass such checks. An emulation technique
ware analysis system is not present). Note that we con- for “emulation-resistant” programs, which follows this
sideranemulator(suchasQemu,whichisusedbyAnu- generalapproach,wasdescribedin[22].
bis) to be part of the analysis environment. Thus, our
systemalsorecognizesmalwarethatchecksforthepres-
3 OurApproach
enceofQemu. Thebehaviorofaprogramisdefinedas
thesystemcalls(typesandarguments)thatthisprogram
invokes. Webelievethatthisisareasonableassumption, Inthissection,wediscussourapproachfordetermin-
becausesystemcallsarethemeansthroughwhichapro- ingwhetheragivenmalwareprogramhassplitpersonal-
gram communicates with its environment and by which ities. Asmentionedpreviously,thisapproachisbasedon
itcancausepersistentchangestotheoperatingsystemor thebasicideaofcomparingtheexecutionofthemalware
otherhosts(viathenetwork). on a reference system with the execution on the analy-
It is important that a tool that identifies split- sis system. We will see that for our approach to be ef-
personality malware work reliably and efficiently. We ficient and reliable, we need to extend this basic idea
striveforasystemthathasnofalsenegativesorfalsepos- with a mechanism to log inputs passed to the malware
itives. Falsenegativesaremoresevere,sincetheyimply onthereferencesystem(i.e.,valuesreadfromtheoper-ating system), and to replay those inputs when running and the program used these effects to follow a different
themalwareontheanalysissystem. execution path. The effects can be caused by CPU in-
structionsthateitherhaveadifferentsemanticsordiffer-
3.1 EfficientDetection ent timing properties on the two systems. This is pre-
ciselythecharacterizationofCPUsemanticsandtiming
Claim 1: The runtime behavior of a program can be attacks.
characterized by the sequence of the system calls it ex- Ofcourse,itisnottruethatCPUsemanticsortiming
ecutes. attacks necessarily lead to different behaviors. That is,
itispossiblethatamalwareprogramcontainschecksto
Wejustifythisclaimonthebasisthatsystemcallsare
detectananalysisenvironment,butdecidestoignorethe
themechanismthroughwhicha(user-mode)processin-
resultsofthesechecks. However,inthiscase,theanaly-
fluences its environment (the operating system) as well
sisisabletoobservetheentirebehaviorofthemalware
asexternalhosts(throughthenetwork). Thus,tocapture
binary,andhence,wedonotconsidersuchprogramsas
thekindsofactionsthatamalwareisperformingandthat
split-personality.
itmaybeinterestedinconcealing,wearguethatitissuf-
The astute reader might notice that Claim 2 specifi-
ficienttoinspectthesequenceofsystemcallsthatitexe-
cally focuses on CPU semantics and timing attacks, but
cutes(ofcourse,consideringboththetypesofthesystem
excludesenvironmentattacks.Thereasonisthatenviron-
callsandtheirparametervalues). Thisviewisconsistent
mentattackscannotbedetectedasbehavioraldifferences
with a large body of prior work that uses system calls
when executing a malware binary on two execution-
to model malware behavior or the effect of exploits on
equivalentsystems. Thisisbecauseenvironmentattacks
legitimateprocesses.
analyzeandbranchoninputvaluesthatarereadfromthe
OnthebasisofClaim1,comparingthebehaviorofa
operating system. Since execution-equivalence implies
program on two different systems boils down to check-
that the program receives identical input values on both
ing that its executions produce the same sequence of
systems, the behavior of the program will be the same.
system calls (same types and parameter values). Since
However,aswewillsee,thedesignofoursystemmakes
this comparison requires only coarse-grained analysis,
theanalysisenvironmenttransparenttothesekindsofat-
insteadofmoreprecise,butexpensive,fine-grainedanal-
tacks. Hence, our detection is concerned only with de-
ysisofindividualinstructions, thisanalysiscanbedone
tectingsplit-personalitymalwarethatperformsCPUse-
efficiently.
manticsortimingattacks.
Claim 2 motivates the design of our detection ap-
3.2 ReliableDetection
proach. Thatis,byrunningamalwareprogramonaref-
erencesystemandananalysissystem, anydifferencein
Todiscussreliabledetectionofsplit-personalitymal- the observed behavior allows us to reliably convict this
ware, we first introduce the concept of execution- malwareassplit-personality. Ofcourse,thisisonlytrue
equivalence. We say that two systems are execution- when the reference system and the analysis system are
equivalentifallprogramsthat(a)startfromthesameini- execution-equivalent.
tial state (i.e., memory and registers are initialized with
thesamevalues)andthat(b)receivethesameinputson
3.3 MakingSystemsExecution-Equivalent
bothsystemsexhibitthesameruntimebehavior.
Forthisdefinition,wealsoassumethataprogramhas
Claim 3: To be able to reliably detect split-personality
noracecondition(thatis,theresultsofthecomputation
malware by comparing its behavior on an analysis sys-
areindependentoftheschedulingofindividualthreads).
tem with its behavior on a reference system, these two
Webelievethatthisisareasonableassumptionformost
systemsmustbeexecution-equivalent.
programs. Also, by violating the assumption, a mal-
ware author cannot bypass our detection. Instead, pro- Tomaketwosystems(suchasouranalysisandaref-
gramswithraceconditionsmightbeincorrectlydetected erence system) execution-equivalent, we have to ensure
assplit-personalityprograms. that programs start from the same initial state, and that
their inputs are identical. To provide identical starting
Claim2: Whenthebehaviorofaprogramisdifferenton
states,weusethesameoperatingsystemenvironmentfor
twoexecution-equivalentsystems,thisdiscrepancyisthe
boththeanalysisandthereferencesystem. Thisguaran-
resultofCPUsemanticsortimingattacks.
tees that the operating system components such as the
The fact that the behaviors of the same program on program loader and the runtime libraries (e.g., the Win-
two execution-equivalent systems are different implies dowsAPIfunctions)arethesame. Furthermore,wedis-
thattheexecutionofone(ormore)CPUinstructionson ableanyrandomizationmechanismsthatcouldrearrange
thesesystemsyieldedobservableeffectsfortheprogram, theaddressspacelayoutofaprocessatloadtime.Ensuring that the inputs to both programs are iden- reserved. As a result, the access results in a page fault.
tical is more complicated. While identical OS installa- Thus,thereplaycomponentreplaysvaluesonlyforthose
tions provide identical file system objects, running the systemcallsthatreaddatafromtheenvironment.Thein-
sameprogramindependentlycanleadtodifferentbehav- putchannelsweconsiderarethefilesystem,theregistry,
iorsevenwhentheprogramhasnosplitpersonality. As the network, and time computations. This ensures that
an obvious example, the program could use input from system calls that obtain input values from the environ-
a remote host that returns different results for different ment receive the proper data recorded on the reference
client connections. More subtle examples include pro- system. Othersystemcallsthatareusedformanagement
grams that use the current time and system information purposes (such as system calls for allocating memory,
suchasthecurrentprocessorload.Thus,itisnotpossible spawningthreads,etc.)aremonitoredbutpasseddirectly
to simply execute a malware program on the reference totheunderlyingOS.
systemandontheanalysissystemandexpectthatdiffer-
entbehaviorsarereliableindicatorsfordifferentperson-
3.4 SystemCallMatching
alities.
Oursolutiontoprovideidenticalinputstoaprogram
Assumethatwehaveasystemcalltracethatcaptures
consists of recording the system calls of the program
thebehaviorofamalwareprogramonthereferencesys-
that executes on the reference system, and later replay-
tem. We then execute the malware on the analysis sys-
ingthesesystemcallsontheanalysissystem.Thatis,we
tem. Foreachsystemcallthatisobserved,wecancheck
runthemalwareonthereferencesysteminlogmode. In
whetherthetypeandtheinargumentsofthiscallmatch
this mode, the sequence of system calls and all of its in
theoneinthelog. Ifthisisthecase,wereplaythereturn
andoutparametersarelogged.Then,ontheanalysissys-
value and the out arguments. When the type of the ob-
tem, we run the malware in replay mode. In this mode,
servedsystemcalloritsargumentsaredifferent,wehave
whenever the program invokes a system call, we inter-
identifiedadeviationintheexpectedbehaviorand,thus,
ceptthecallandretrievethecorrespondingcallfromthe
canmarkthemalwareashavingasplitpersonality.
logtrace. Then,insteadoflettingtheOShandlethecall,
Unfortunately, the situation is not that easy in prac-
we simply replay the logged system call, that is, we re-
tice. The reason is that small timing differences can
turncontroltothemalware,aftersettingthereturncode
cause small, temporary deviations in the behavior of a
and all the out parameters to the corresponding values
process that is replayed. For example, a little delay in
observed during the log phase on the reference system.
the delivery of an interrupt can cause a process to issue
Forexample,inourapproach,whenaprogramattempts
additional system calls. More concretely, consider the
toreadafileinreplaymode,itisnotgivenaccesstothe
WaitForSingleObject function, which waits until
actual file storedon thedisk ofthe analysissystem. In-
the specified object is ready to be accessed or until a
stead,theprogramisprovidedwiththecontentofthefile
timeout expires. This function is often called in a loop
asitwasreadinlogmodeonthereferencesystem.
thatspinsuntilanoperatingsystemobjectisready. De-
An important advantage when replaying inputs pending on the time it takes until the object is ready, it
recorded on a reference system is that environment at- ispossiblethattheprogramhasexecutedmore(orless)
tacks are not effective. That is, when the malware at- invocations on the reference system than in the analysis
tempts to access resources on the analysis system that environment. Anotherexamplewouldbethedeliveryof
could reveal its presence, the system replays the re- asignalthatcouldleadtotheexecutionofasystemcall
sourcesthatwerepresentonthereferencesystem. Thus, atslightlydifferentpointsalongtheexecutiontraceofa
during analysis, environments attacks will result in the process.
same behavior as on the reference system, effectively
The previously-outlined deviations result in slightly
makingouranalysistransparenttothisattackvector.
different system call traces. However, these changes do
Unfortunately it is not possible to simply replay all not result in any differences with regards to the actual
system calls that the malware program invokes on the malware behavior. That is, the persistent changes (out-
analysis system. In fact, there are a number of system puts) that the program produces are still identical. To
calls that are not safe to replay. For example, if we re- handle these cases, we have to slightly relax our defini-
playedthereturnvalueofasystemcallthatallocatesnew tionofequalbehavior. Moreprecisely,wedonotrequire
memorybysimplyreturningtheaddressofthememory that the sequences of system calls produced in log and
buffer that was allocated on the references system, the replay mode are exactly the same, but we allow some
program would likely crash when accessing this mem- flexibility to account for small differences. This flexi-
ory. Thereasonisthattheoperatingsystemhasnotcre- ble matching approach is based on the observation that
ated the necessary virtual memory mappings internally, small differences are usually localized in time and tend
while the program assumes that memory was correctly toquicklydisappearastheprogramcontinuesexecution.1 buf_skipped = [] execution. Then, we try to find a match in the log by
2 buf_extra = []
3 def flexible_syscall_match(log, curr_syscall): skippingoveroneormoreofthecallsattheheadoflog
4 # check for deviation (asortoflook-aheadoperation). Ifthisprocedureyields
5 if len(buf_skipped) == L or len(buf_extra) == L:
6 deviation_detected() amatch,thenthosesystemcallsinthelogthatneededto
7 be skipped are added to buf skipped, and the match
8 # expire old entries in the buffers
9 # (if they aren’t "write" operations) isreturnedtoourcorrespondinghandler(lines32–37).
10 expire(buf_skipped) Ifnomatchisfound,i.e.,thecurrentsystemcallwas
11 expire(buf_extra)
notinvokedinlogmode,itisaddedtobuf extraand
12
13 # get the next matching syscall from the log, passedtotheoperatingsystem.
14 # -1 if none
15 pos, candidate_syscall = Our algorithm uses two configurable parameters, L
16 get_next_matching_syscall(log, cur_syscall) and M. L is used to detect deviations in the behavior of
17
18 # the next syscall in the log matches two executions. More precisely, if at any point during
19 if pos == 0: the replay, the number of system calls that have been
20 return candidate_syscall
skipped or added with respect to the log trace reaches
21
22 # if no match or extra syscalls, L, then the algorithm concludes that the current exe-
23 # search a match in the skip buffer
24 if pos == -1 or pos > 0: cution of the application is different than in log mode
25 s_pos, s_candidate_syscall = (lines4–6). Toavoidtheaccumulationofshort-lived,lo-
26 get_next_matching_syscall(buf_skipped,
27 curr_syscall) calized differences, we remove system calls inserted in
28 if s_pos >= 0: thebuf skippedandbuf extraqueuesafterMex-
29 buf_skipped.remove(s_candidate_syscall)
30 return s_candidate_syscall ecutions of the matching algorithm (lines 8–11, we do
31 not show the implementation of the expire function
32 # if found a match in the log
33 # but not in buf_skipped, add to skip buffer forsakeofspace).
34 if pos > 0:
35 for (i = 0; i < pos; i++):
36 buf_skipped.append(log[i]) 4 Implementation
37 return candidate_syscall
38
39 # no match: add to extra bucket
40 buf_extra.append(candidate_syscall) Our approach requires a logging infrastructure that
is capable of recording and replaying Windows system
Listing 1. Flexible matching algorithm calls inside and outside of virtual machines. Here, we
(pseudocode). will describe our implementation of this infrastructure
and a number of interesting, technical challenges that it
requiredtotackle.
The algorithm for performing flexible system call 4.1 LogandReplayInfrastructure
matching in replay mode is simple (refer to Listing 1).
We use two queues to keep track of short-lived differ-
Ourlogandreplayinfrastructureconsistsoftwoparts:
encesintheexecutions. Onequeue,calledbuf extra,
a user-space application and a kernel driver. The user-
records the system calls that have been invoked by the
space application is responsible to load and start the
program but that were not found in the log. The other
driver and to control its operations by sending specific
queue, called buf skipped, holds those system calls
I/Ocontrolcodes. Itisalsoresponsibletostartthepro-
thatwereinthelogtracebutwerenotinvokedinthecur-
cessthathastobeanalyzed,tocommunicatetheprocess
rentexecution.
ID of the sample to the driver, and to receive and store
At each system call invocation, our algorithm com- thedatageneratedduringtheloggingphase.
paresthissystemcall(curr syscall)withtheoneat
Thedriveristhecorepartofoursystem.Itisresponsi-
thecurrentheadofthelog.Ifthealgorithmfindsamatch, bletotrapallthesystemcallsandeitherlogorreplayall
the algorithm returns this system call and advances one theinformationexchangedbetweentheWindowskernel
stepinthelog(line18). andthemonitoredapplication. Thisisachievedbyhook-
If the first entry in the log does not match the cur- ing the System Service Descriptor Table (SSDT). Each
rentsystemcall,thealgorithmfirstsearchesthequeueof entryintheSSDTcontainstheentrypointofaWindows
systemcallsthatwerepreviouslyskipped. Ifamatchis systemcall, sowhenanapplicationinvokessuchacall,
found,itisremovedfromthequeueandisreturnedtothe the SSDT is queried to find the address of the function
correspondinghandler(lines22–30). thatisresponsibletoserveit.
If no match is found at the head of the log or in the When the driver is loaded, every entry in the SSDT
skipbuffer,itmaybethecasethatadditionalsystemcalls that contains a system call address is overwritten with
wereexecutedinlogmodethatwerenotinvokedinthis an address that points to one of our handler functions.However, since it is still necessary to be able to invoke possible deviations, which is done by using the flexible
theoriginal functionalities, theaddresses ofthe original matchingalgorithmdescribedinSection3.
system calls are stored in a backup table (and restored
In the rest of this section, we will describe a number
whenthekernelmoduleisremoved).
ofpracticalaspectsofourlogandreplayinfrastructure.
Itwouldhavebeenextremelyimpracticaltomanually
writeeachofthe283functionhandlersthatwrapallthe
4.2 HandleConsistency
WindowsXPsystemcalls. Inaddition, thefunctionpa-
rametersoftencontaincomplexdatatypessuchaspoint-
InWindows,handlesareopaqueintegersthatareused
erstostructures(thatsometimesrecursivelycontainref-
as an abstraction to provide a uniform interface to ker-
erences to other structures), making a manual approach
nelobjects. Dependingonthecontextinwhichtheyare
evenmorecomplicated.
used,handlesmayrefertofiles,registrykeys,processes,
To address these problems, we implemented a tool
timers, events, communication ports, etc. Since we re-
thatautomaticallygeneratesthesourcecodeforthehan-
play some of the system calls and we let the operating
dler functions. This generator tool receives as input the
systemexecuteothers,inreplayingmode,anapplication
systemcalldeclarationsandthedefinitionofallthesys-
willhavetwokindofhandles: livehandlesthatreferto
tem call arguments (especially, data structures). We ex-
existingobjectsinthekernel, andreplayedhandlesthat
tractedthisinformationfromtheWindowsResearchKer-
wereretrievedfromthelogfileandpassedtotheapplica-
nel. Then, for each system call, our tool creates the
tionbyoneofourreplayingfunctionhandler. Forexam-
source code of two handler functions, one to be used in
ple,iftheapplicationtriestoopenafile,weinterceptthe
logmodeandtheotherinreplaymode.
OpenFile system call and we replay all the outgoing
In log mode, all our system call handlers have the parameters, including the FileHandle, i.e., the refer-
same purpose: To dump all the data that is exchanged encetobeusedbytheprogramforanyfurtheroperations
between the application and the kernel, working like a onthefile. However,sincetheOpenFilesystemcallis
proxy between the user-space program and the original intercepted by our driver and it is never received by the
system call handlers. This is done by recursively log- kernel, the handle we return does not reflect any actual
ging the content of all the parameters before and after objectinkernelmemory.
theoriginalsystemcallisinvoked. Additionally,there- Theproblemarisesbecausecertainsystemcallwrap-
turn value of the system call is also logged. The kernel pers (e.g., the wrapper for Close) can operate on both
drivercontainsabufferthatisusedbythehandlerfunc- kindsofhandles. Tooperatecorrectly,thesesystemcalls
tionstotemporarilystorealltheparametervaluesofthe needtodistinguishiftheyarepassedalivehandle(which
system calls. For performance reasons, the driver does cannot be replayed) or a replayed handle (which cannot
not write the contents of the buffer into a file. Instead, be forwarded to the OS). Therefore, our system main-
theuser-modeprogramcontactsthedriveratgiveninter- tainsalistofallreplayedhandles. Then,whenasystem
vals,copiesthecontentofthebufferintouserspace,and call wrapper receives a handle that is not in the list of
finallystoresitinabinarylogfile. replayedhandles,itsimplyforwardsthecalltotheoper-
Inreplaymode,thedriverhastwomaintasks:Topro- atingsystem.
vide the application with the same input data that was
storedduringtheexecutioninthereferenceenvironment, 4.3 Networking
andtoanalyzetheapplicationbehaviorlookingfordevi-
ationsfromtheexpectedone.
Windows does not have special system calls dedi-
AsexplainedinSection3,itisnotpossibletoblindly cated to networking operations. Instead, most of func-
interceptallthesystemcallsandreplaytheirparameters. tionalitiesareexportedusinganundocumentedinterface
Somefunctionshaveimportantsideeffectsinthekernel through NtDeviceIOControlFile, a generic sys-
(e.g., when the program requires to allocate new mem- tem call that is used by user-space applications to com-
ory) and, therefore, they must be forwarded to the orig- municatewithdevicedrivers.
inal handler to be processed. Other system calls (e.g., NtDeviceIOControlFile has two general-
whentheprogramreadsthevalueofakeyfromthereg- purpose, opaque parameters, called InputBuffer
istry) can instead be safely replayed by substituting all and OutputBuffer, which are used to exchange
the out parameters and the return value with the corre- informationbetweentheapplicationandthedriver. The
spondingvaluesextractedfromthelogfile. Wesaythat specific data and the format of these parameters depend
thehandlerforwardsasystemcallintheformercase,and on the functionality required by the application. To
replaysitinthelatter. correctly implement our network handlers, we had to
Finally, the last task of the driver during the replay reverse engineer the parameters used by the most com-
phaseconsistsofmonitoringtheapplicationbehaviorfor mon network operations and understand their formatsandsemantics. Forinstance,whentheRECVfunctionis ates the impression for the application that certain pa-
invoked, it requires the first word of the input buffer to rameters are indeed deferred (even though they have
be a pointer to a data structure in the process memory already been copied to the application). Therefore,
thatcontains(amongotherdata)apointertoabytearray the application synchronizes its execution using the
thatwillstorethedatareceivedfromthenetworksocket. NtWaitSingleObjection system call, following
In replay mode, the driver analyzes the parameters the same execution path that was followed in the refer-
of the NtDeviceIOControlFile. If the function enceenvironment.
specifiedbyNtDeviceIOControlFileisoneofthe
functions that our tool supports, then the correspond- 4.5 ThreadManagement
ing handler is invoked with the values from the log
file (thus, replaying the network operation that was re- Managing multi-threaded applications poses addi-
quested). Otherwise,thesystemcallissimplyforwarded tional challenges. In particular, in log mode, we need
totheoperatingsystem. Thisavoidsdisruptingservices to ensure that all threads of the process under test are
using the NtDeviceIOControlFile interface that properlyidentifiedsothatwecandistinguishsystemcalls
we have not reverse engineered. We have currently im- madebydifferentthreads. Todothis,ourhandlerforthe
plemented support for TCP sockets. Support for UDP NtCreateThreadsystemcallinitializesanewlogfor
systemcallscouldbeaddedinasimilarway. every new thread. It then simply forwards the system
calltotheOS,andrecordsthethreadIDassignedtothis
newthread. WeusethethreadIDtouniquelyassociatea
4.4 DeferredResults
threadtoitslog. Othercallhandlersthengetthethread
IDofthecurrentlyexecutingthreadanduseittostorethe
An additional issue that arises with logging and re-
executioninformationinthecorrectlog. Logsalsostore
playing network traffic is that networking system calls
therelativeorderinwhichthreadsinvokedsystemcalls.
often return before results are available (e.g., before the
In replay mode, the handler for the
data requested from the network is ready to be sent to NtCreateThread system call lets the OS handle
theuser-spaceprogram). Thisphenomenonisreferredto
the call and associates the newly created threads (their
as deferred results and occurs commonly also with file
thread IDs) to the corresponding logs according to the
system-relatedsystemcalls. order of the NtCreateThread invocations. Other
More precisely, whenever a system call returns a system calls, similarly to what done in log mode, use
STATUS PENDING result, it means that the required the thread ID to retrieve the correct log and replay
action was successfully initiated but the results are not inputs. Absent race conditions between the threads,
yet available to the application. Then, the program this is sufficient to correctly replay multiple threads.
thread has to wait until the operation is completed by While we did not find malware samples that relied on
invoking NtWaitForSingleObject (or the similar race conditions, it would be possible to handle these
NtWaitForMultipleObjects) on the event han- cases, for example, by forcing that multiple threads are
dler that was specified when the operation was initially scheduled in the same relative order, as outlined by the
requested. authorsof[35].
To log deferred results, we follow a two-step strat-
egy. First, when a system call handler has some of its 4.6 MemoryMappedFiles
outputparametersdeferred,itsimplystoresthememory
location of each deferred parameter to an internal De- Memory mapping is a technique used in most mod-
ferredParametersList(DPL).Thesecondstepoccursin ern operating system to map all or part of the content
thehandleroftheNtWaitForSingleObjectsystem of a file to a memory area in the process address space.
call. ThehandlerforwardsthecalltotheOS.Iftheresult Whenafilehasbeenmappedintomemory,theprogram
isSTATUS SUCCESS,itmeansthatthedeferreddatais can freely read and modify its content without invoking
now available. Then, the values for the parameters that any additionalsystem call. This would preventour sys-
weresavedintheDPLcanberetrieved,andtheyarein- tem to load and replay those operations. [29] proposes
sertedintothecorrectpositioninthelog. an interrupt-based technique to intercept the access to a
Replaying deferred results is simple. In fact, when a memory-mappedareaanddumpitscontentwheneverthe
handler needs to replay a system call with deferred re- processmodifiesthisarea.However,wefoundthatinour
sults, it immediately copies all the data (including the case,themostcommonusesofmemorymappingcanbe
values of deferred parameters) into its output param- safelyhandledbysimplyforwardingthememorymapto
eters and returns it to the application. However, to theOS.
prevent changing the application behavior, it also re- InWindows,memorymappingiscommonlyusedby
plays the STATUS PENDING return code. This cre- theprocessloadertoloaddynamiclibraries(DLLs)intomemory. Dynamiclibrariesshouldbeconsideredanin- (and,thus,isnotreadilyaccessiblefromourkernel
put of the application and therefore should be, at least driver), its entropy sources are located in the ker-
in principle, logged and replayed by our system. How- nel[17]. Inthecurrentimplementation,wealready
ever,itismuchmoreefficienttohavethesamecopiesof logandreplaymostofthesources,withtheexcep-
the libraries in the reference and analysis environments tionoftheKSecDDdevicedriver. Byalsologging
and let the application free to load them from disk. For and replaying the data generated by this driver, we
thisreason,whenourkernelmodulereceivesarequestto wouldbeabletoreplayrandomnumbers.
openormemorymapasystemlibrary,itdeactivatesthe
• Inter-process communication and asynchronous
replay for the system call and it forwards the request to
calls: Ourprototypedoesnotreplayanylocalpro-
theoperatingsystem.
cedure call (LPC) communication. All the related
Asecondverycommonuseofmemorymappingthat
systemcallsareforwardedtotheoperatingsystem,
we observed in malicious samples is to create and later
with the risk of causing a deviation in the applica-
execute an executable file. To address this problem, we
tionexecution.
parsethelogfilethathasbeengeneratedinthereference
environment. Everytimewefindafilethatiscreatedby • Complexmemorymapscenario:Asweexplainedin
theprocessandthenmemory-mapped, weremovefrom theprevioussection,oursupportformemorymap-
the log the system calls responsible to open and create ping is not complete and does not support, for ex-
thefile. Then,duringthereplayphase,thematchingal- ample, the use of mapped area as a shared space
gorithmwillbeunabletofindamatchforthesystemcall betweendifferentprocesses.
thatwasremovedfromthelogfile.Therefore,thesystem
callisaddedtoqueueofextrasystemcalls,anditisfor- Some of the previous limitations may seem quite se-
warded to the operating system. As a consequence, the vere. In fact, it is possible for an attacker to exploit
handle for the memory-mapped file is generated by the our limitations to prevent our log/replay infrastructure
operatingsystem(i.e.,itisalivehandle),andothersys- to work properly. However, these attacks would only
temcallsthatoperateonthishandlewillnotbereplayed causeoursystemtodetectadeviationandraiseanalert.
byoursystem. Thepracticaleffectisthattheapplication As a consequence, we would simply incur the perfor-
isgoingtocreatethefileandoperateonitalsoduringthe mancepenaltyofre-runningthesamplewithamorefine-
replaymode. grainedandexpensiveanalyzer,suchasEther.
It is also possible to evade our system when a mal-
4.7 CurrentLimitations ware program delays the checks that aim to detect the
presence of the analysis environment. This is similar to
postponingmaliciousbehaviorforsometime(e.g.,some
Implementing a system to correctly log and replay
minutes)sothattheanalysissystemwillstopmonitoring
systemcallsunderMicrosoftWindowsisaverycomplex
theprocessbeforethesamplestartsanymaliciousactiv-
task. Inmanycases,wehadtorelyonreverseengineer-
ity. Unfortunately,thereisnotasimplesolutionforthis
inginternal,undocumentedWindowsdatastructuresand
problem,withtheexceptionofrunningtheanalysisfora
behaviors.
longertime.
The current prototype supports a large set of func-
Inaddition,itmightbepossibletoevadeourflexible
tionalitiesandcanbeusedtoanalyzerealprogramsand
matching algorithm by dividing the malicious activities
malwaresamples. However,asanyprototype,itstillhas
intoanumberofveryshort(andfarapart)sequencesof
somelimitationsthatwecansummarizeinthefollowing
system calls, so that the localized differences would fly
areas:
undertheradarofourdetectionmechanism.Eventhough
thisispossibleintheory,wedidnotinvestigatehowdif-
• Multiple processes: The current prototype is not
ficult it would be to implement in practice a (malware)
able to log and replay the input if the program is
programinthisway.
composedofmultipleprocesses. Inpractice, ifthe
Finally,anotherlimitationofthecurrentimplementa-
different processes do not communicate with each
tionisthatmalwarethatgainsaccesstokernelstructures
other,wecanstillinstructoursystemtoanalyzeone
(i.e.,rootkits)coulddetectourdrivercomponentandtake
processatatime.
somecountermeasurestoavoiddetection. However, we
• Random numbers: Correctly replaying applica- do not believe that this is a significant problem. First,
tions that rely on random numbers to take non- a previous study of current malware trends showed that
deterministic decisions would require to replay the only3.34%ofsamplesinstallkerneldrivers[7]. Second,
random number generator of the reference system itislikelythatsuchmalwarewouldperformenvironment
on the analysis system. While the random number checks(and,thus,wouldbedetectedbyourtool)before
generatorofWindowsisimplementedinusermode attempting to gain control of the kernel, otherwise, theSyscall Replayed and write data from different channels, i.e., the file sys-
Sample
LogSize (VMware&Qemu) tem, the registry, the system time, and the network. We
SystemTime 123 100% alsocombineddifferentinput/outputoperationstogether
Registry 195 100% in a multi-thread application. Table 1 shows the num-
Network 512 100% ber of system calls that were logged and the fraction of
FileSize 128 100% those that were correctly replayed (or forwarded to the
FileRead 114 100% operating system if no replay was required for that par-
FourThreads 252 100% ticular call) during the replay phase. A value of 100%
means that the system was able to reach the end of the
Table1.SimpleLogandReplaytest. logwithoutdetectinganydeviationfromtheloggedbe-
havior, thus demonstrating the ability of our system to
properlylogandreplaythatinputchannel.
malwareauthorwouldexposesomeoftheprogram’sma-
licious functionality to the analysis system. Finally, we
couldresorttotransparentsolutionstoimplementourlog ExperimentII. Inoursecondexperiment,wewantto
andreplaysystem.Infact,webelievewecouldhaveused showthatourtoolcandetectavarietyofdifferent,real-
Ether,runninginthefastcoarse-grainedmode,forthis. worlddetectionattacks(whichwemanuallyinsertedinto
However, we have not explored this possibility because areal-worldmalware).
Etherwasnotavailablewhenwestartedourproject. WeobtainedthesourcecodeofSDBot,awell-known
botnet application. We first compiled and tested in our
systemavanillaversionofthisbot,whichdidnotinclude
5 Evaluation
anychecktodetectifitisrunninginavirtualmachine.In
Anubis(whichisusedasthereferencesysteminthisex-
Weevaluatedoursystembyconductingfourdifferent periment),theapplicationgeneratedalogfilecontaining
experimentsinvolvinganumberofreal-worldprograms. 1,905systemcalls. Uponinspectingthistrace,wefound
All tests have been run on Microsoft Windows XP Ser- that the 1,524th system call is responsible for spawning
vicePack3, installedinaVMwarevirtualmachineand anewprocess. Sincethecreationofanewprocessisnot
ontheAnubissystem(i.e.,onaQemuimage). Bothsys- currentlysupportedbyourtool,weconsidertwoexecu-
tems were installed from the same CD-ROM and were tionsofSDBotequivalentiftheirbehavioristhesameup
updatedtothesamepatchlevel. to the NtCreateProcess call. For this experiment,
Inourexperiments,weuseinterchangeablyAnubisor wedesignatedVMwareastheanalysissystem.
VMware as the reference system (and the other, as the Wethencreated6differentversionsoftheSDbotpro-
analysissystem). Sinceourtoolisdesignedtodetectdif- gram,eachtimeaddingtothecodeadifferenttesttode-
ferencesinthebehaviorofanapplicationwhenitisrunin tect VMware. We extracted these techniques from sev-
twodifferentenvironments(anytwoenvironments),itis eral publicly available tools such as Red Pill, Scoopy,
notnecessarythatoneisalwaysselectedtobetherefer- VMDetect, and SourPill. Whenever one of these tools
encesystem,northatthereferencesystembeaphysical combined together different approaches, we separated
machine. Of course, if a malware attacks both systems themindifferentprogramstotestthemseparately.
(i.e.,itiscapableofdetectingbothQemuandVMware), We ran each sample in log mode under Anubis and
wemayfailtodetectit. Toavoidthisproblem,itispos- replayeditunderVMware. AsshowninTable2,allthe
sible to use a real machine as the reference system, and samplescontainingaVMwaredetectionattackwerecor-
reset the computer state using hardware devices, e.g., a rectly detected by our tool. It can be seen that under
harddiskwrite-cachecardsuchascoreRestore[2].How- VMware, each sample executed only 460 system calls.
ever,forourexperiments,usingavirtualmachineorem- This is because the application terminated immediately
ulatorasareferencesystemmadeiteasiertorollbackto afterdetectingthepresenceofthevirtualmachine. The
acleanstateaftereachtest. Finally,bothAnubis(Qemu) behaviorunderAnubisandVMwareisclearlydifferent,
andVMwareareactivelytargetedbyreal-worldmalware and,therefore,itwasflaggedbyourtool.
withsplitpersonality.
ExperimentIII. Inthisexperiment, weshowthatour
Experiment I. For the first experiment, we evaluated toolcancorrectlylogandreplayreal-worldmalwarethat
the ability of our system to correctly log and replay all doesnottrytodetectifitisrunninginananalysissystem.
theinputchannelsweidentifiedinSection3. The test suite used in the third experiment consisted
For these experiments, we use VMware as the refer- of10malicioussamplesrandomlychosenfromtheAnu-
encesystemandAnubisastheanalysissystem. Thetest bis database among the malware known not to contain
suiteincludedsixsimpleprogramswedevelopedtoread any virtual machine detection techniques. We first ranSample SyscallLogSize Result
SDBot+CPUIDTimeCheck 460 Detection(deviation)
SDBot+GDTCheck 460 Detection(deviation)
SDBot+LDTRCheck 460 Detection(deviation)
SDBot+RedPillCheck 460 Detection(deviation)
SDBot+VmWarePortCheck 460 Detection(deviation)
SDBot+STRCheck 460 Detection(deviation)
Table2.ExperimentingwithSDBotanddifferentVMdetectiontechniques.
the samples in VMware (reference environment), log- derAnubis[16]. Inallcases, ourtechniquewasableto
gingtheirsystemcalls.Then,weexecutedthesamplesin reporttheattemptsofthesamplestodetectthepresence
Anubis, once without replaying any inputs, and once in oftheanalysissystem.
replay mode. The log collected during the execution of During our test, we also found a sample
thesamplescontainedbetween1,136and30,066system (Heur.Trojan.Generic in Table 4) that worked prop-
calls. erly under Anubis, but immediately terminated in
Table 3 reports the results of the experiments. The VMware, and a sample (Backdoor.Win32.SdBot) that
table contains three columns. The first column reports raised an Internal Error in VMware, but had a normal
thenamethattheKasperskyanti-virusscannerassociates executioninAnubis.
with the malicious sample. The second column shows
theresultoftheexperimentswiththesystemcallreplay
Performance. Theoverheadintroducedbyoursystem
disabled, i.e., with the system configured to pass all the
largely depends on the type of operation performed by
system calls to the operating system. In this case, the
theprogramunderanalysis. Forinstance,writingalarge
kernelmodulewasnotreplayinganyinputdatatotheap-
amountofinformationtoafilerequiresourloggingmod-
plication. The third column shows the results when the
ule to dump and store the full data in the log. How-
system call replay was enabled. In the table, a result of
ever, in our experiments, we noticed that our tool intro-
OKindicatesthattheflexiblematchingalgorithmfound
ducedonaverage1%overheadwhenloggingandreplay-
thebehaviorstobeidentical. Thismeansthatthebehav-
ingmalwaresamples.Whenusedincombinationwithan
ior on the analysis system matched the behavior on the
emulator-basedmalwareanalysissystemsuchasAnubis,
referencesystemuntilthesystemcalllogwasexhausted
thedelaythisaddstotheoverallanalysistimeisnegligi-
(oranunsupportedfunctionalitywasencountered).
ble.
It can be seen that, even with system call replay dis-
Wealsocomparedthetimerequiredtoanalyzeamal-
abled, the behaviors were the same in five cases. The
warewithAnubisandEther. Toperformafaircompar-
mainreasonforthisisthatthetwoWindowsinstallations
ison, we run Anubis with all its analysis enabled, and
areidentical. However,intheremainingfivecases,with
Ether in one of its fine-grained analysis modes. We re-
systemcallreplaydisabled,ourtooldetectedadeviation
port here the result of running one test case that is rep-
intheprogram behavior. Whenthereplay wasenabled,
resentativeofthedifferentperformanceofthesetwosys-
as shown in the last column of the table, the matching
tems.Inparticular,weexecutedthecommand7za.exe
succeeded for all ten samples. This result demonstrates
a test.zip 1KB rand file, which compresses a
the importance of replaying the input in our approach:
1KB-longrandomfile. ItsexecutionunderAnubistook
Withoutthereplay,evenontwoidenticalsystems,thebe-
4.267seconds. InourVMWarereferencemachinewith
haviorofanapplicationcaninfactbedifferentbetween
our kernel module it took 1.640 seconds. The same ex-
thetwoexecutions.
ecutioninEtherrunninginmemwritemodetook77.325
seconds (approximately 20x slower). Therefore, even
Experiment IV. Finally, in this experiment, we show considering that in our experiment we have to run each
that our tool is capable of detecting real-world malware sampletwice,wecanstillanalyzesplit-personalitymal-
thatbehavesdifferentlywhenrunninginsideananalysis wareoneorderofmagnitudefasterthanunderEther.
system.
Topopulatethetestsuite, weextractedrandomsam-
6 RelatedWork
ples from the Anubis database by querying for executa-
bles packed with one of the packers that are known to
either detect or not to work properly under Qemu (e.g., Sincemalwareisasignificantsecuritythreat, alarge
ArmadilloandtElock). Noticethatthesearethepackers body of work exists that presents techniques to analyze
that the authors of Ether found not to be analyzable un- anddetectmaliciouscode. Inthissection,wefirsthigh-Sample SyscallReplayDisabled SyscallReplayEnabled
Email-Worm.Win32.Bagle.fk OK OK
Backdoor.Win32.Rbot.bng FAIL OK
Backdoor.Win32.Agent.eny OK OK
Email-Worm.Win32.Zhelatin.cl FAIL OK
Trojan-Downloader.Win32.Agent.alnx OK OK
Backdoor.Win32.Rbot.ccb FAIL OK
Backdoor.Win32.SdBot.gen FAIL OK
Virus.Win32.Parite.a OK OK
Trojan-Downloader.Win32.Dluca.gen OK OK
Hoax.Win32.Renos.wu FAIL OK
Table3.RealMalwarewithnoVM-checks.
Sample Packer DeviationDetected?
Trojan-Proxy.Win32.Bypass.a tElock YES
Heur.Trojan.Generic PE Patch.UPX YES
Backdoor.Win32.Agobot.aow Armadillo YES
Trojan-Spy.Win32.Banker.pcu tElock YES
Worm.Win32.AutoRun.pga Armadillo YES
Trojan-Spy.Win32.Bancos.zm tElock YES
Trojan-Downloader.Win32.Agent.acrm tElock YES
Backdoor.Win32.SdBot.fme Armadillo YES
Trojan.Win32.KillAV.or Armadillo YES
Net-Worm.Win32.Kolab.ckp Armadillo YES
Table4.RealMalwarewithVMchecks.
lightanumberofsystemsthatusedynamicandstaticap- Currently, the most popular approach for malware
proachesforcombatingmalware. Then,wefocusonthe analysis relies on sandboxes [1,3–6,8]. A sandbox is
differentwaystodetectmalwareanalysisenvironments, aninstrumented executionenvironment that runsan un-
emulators, and virtual machines. Finally, since we pro- known program, recording its interactions with the op-
pose a component to replay malware, we survey related erating system (via system calls) or other hosts (via the
workintheareaofprocessandsystemreplay. network). Often, this execution environment is realized
asasystememulatororavirtualmachine.
Malware analysis and detection. The traditional ap-
Stealthandtransparentanalysis. Sinceemulatorsand
proach to detect malware, as implemented in anti-virus
virtual machines are popular choices for implementing
scanners, isbasedon(string)signaturesthatmatchspe-
dynamic analysis systems, there have been a number of
cific malware binaries [36]. Because code obfuscation
attempts to develop checks (pieces of code) to detect
andruntimepackingcanbeusedtoeasilyevadethistype
them.
of detection, researchers have proposed more sophisti-
Red pill [33] is arguably the most well-known check
catedtechniques,forexample,detectionbasedonmodel
to determine whether code is executed under VMware.
checking [12], recognition of structural similarities be-
MorecheckshavelaterbeendevelopedforVMware[19,
tweenmalwaresamples[24],andsemantics-awareanal-
23,32],butalsoforsystememulatorssuchasBochsand
ysisofcodetemplatesthatimplementspecificfunction-
Qemu[19,31,32]. Tothisend, researchershavelooked
ality[13].
for instructions that behave differently on an emulator
Dynamic detection techniques are complementary to than on a real host, using both manual [19,32] and au-
staticanalysisandtypicallyaimtodetecttheexecutionof tomatedfuzztestingtechniques[31].
maliciouscodebasedonsystemcallpatterns[28]. Tools The increased efforts to detect emulators and virtual
exists to intercept Win32 function calls [21], or to per- machineshavepromptedresearchersandpractitionersto
formtaintanalysisandtrackdatadependenciesbetween lookforwaystohidethepresenceofsuchexecutionen-
system calls and library functions [9,40]. This allows vironments. Initialwork[26]focusedonremovingspe-
onetocapturethebehaviorofmalwareinamoreprecise cificartifactsinVMwarethataretargetedbywell-known
fashionandidentifyoperationsthatarerelated. checks. Later,researchersproposedmorecompletesys-temsthatusevirtualization[16]ordynamictranslationin ExecRecorder[15]isavirtual-machine-basedlogand
combination with stealth implants [38] to remain trans- replay framework for post attack analysis and recovery.
parenttoawiderrangeofmalwarechecks. Whilethese Itcanreplaytheexecutionofanentiresystembycheck-
systemsaresuccessfulinhidingtheirpresence, theyin- pointingthecompletesystemstate(virtualmemoryand
cur a performance penalty that is prohibitive when de- CPU registers, virtual hard disk and memory of all vir-
ployingtheminlarge-scaleautomatedmalwareanalysis tual external devices) and logging all architectural non-
setups. deterministicevents. ExecRecorderisbasedonthesys-
tememulatorBochs[25].AnadvantageofExecRecorder
Inadditiontosystemsthatattempttoremaintranspar- isthatitcanalsorunWindowsinitsvirtualenvironment.
ent to malicious code, researchers have looked at ways However, it also suffers from the drawback that virtual
to detect that a malware sample contains such detection machinedetectingmalwarecannotbeanalyzed.
checks. Toperformthisdetection,thesystemspresented
in [11] and [22] compare the behavior of a sample on a
reference(real)hostwiththebehaviorofthissampleon 7 Conclusions
ananalysis(orvirtual)host. However,bothsystemssim-
ply execute the malware under analysis in two different
Maliciouscodeisoneofthemostsignificantsecurity
environments. Unfortunately, as our experiments have
threats on the Internet. To assess the malicious poten-
demonstrated,re-runningthesamesampletwicecanlead
tial of the thousands of new malware binaries that are
to different behaviors that are not the result of any mal-
discoveredeveryday,dynamicmalwareanalysissystems
ware checks. Hence, this analysis approach is not reli-
(sandboxes)haveproventobevaluabletools. Asareac-
able. Inaddition,thesystempresentedin[22]alsouses
tion,malwareauthorshavestartedtoaddcheckstotheir
a very costly technique (Ether in fine-grained analysis
code that detect the presence of such sandboxes. When
mode)toproduceareferencesystemcalltrace.
a check determines that the malware program is ana-
lyzed,ittypicallyhidesmaliciousfunctionalityorsimply
Process and system replay. A number of systems ex-
crashes. As a result, security analysts might mistakenly
ist that aim at providing deterministic replay of an ap-
classifyabinaryasbenignorunderestimateitsthreat.
plication or of an entire system [14]. For example, Re-
In this paper, we present a technique to reliably and
Virt [18] uses the virtual machine UMLinux to monitor
efficientlyidentifymalwareprogramsthatattempttode-
aprocessandcreatelogsofitsinteractionwiththeguest
tectthepresenceofAnubis(whichisouremulator-based
operating system. The logs are created on the host OS
sandbox) and similar tools. Our technique works by
andcanthenbeusedtoreplaytheentirevirtualmachine.
recording the system call trace of a program when it is
However, ReVirt modifies the host and guest operating
executedonanuninstrumentedreferencesystem. Then,
systemandrequirestheanalyzedprogramstoberunin-
thebinaryisrunontheanalysissystem,replayingthein-
side their virtual environment UMLinux. It is a power-
putsthathavebeenpreviouslyseen. Wheneverthepro-
fulapproachthatallowscomprehensivereplaying,butit
gram shows a different behavior, we conclude that the
cannot analyze a program that contains virtual machine
malwarehasasplitpersonality; thatis,ithasusedCPU
detection checks, since it uses a virtual machine itself.
semantics or timing attacks to identify the presence of
Flashback[35]isadebuggingtoolforLinuxthatallows
our sandbox. In this case, the binary can be forwarded
process replaying. It creates shadow processes at vari-
to a more costly, but fully transparent, analysis system
ous checkpoints that mirror the state of a process at a
for further examination. Our experiments demonstrate
giventime. Inaddition,thesystemtrapssystemcallsto
thatoursystemeffectivelyandefficientlydetectsbinaries
log their parameter values. In contrast to our solution,
with split personalities, while it can successfully replay
Flashback provides its own system calls to enable user
programs that do not contain any checks for Anubis or
programstoprogrammaticallycreatesnapshotsatcertain
theemulator(Qemu).
checkpoints. Forthisreason, it needstomodifythe op-
erating system. Another replaying tool is Jockey [34],
whichinsertstrampolinefunctionsintosystemcallcode
Acknowledgements
todirecttheprogramflowtoitsowncodewheresystem
call parameter values are recorded. These logs are then
usedinreplaymodetoreproducethebehaviorofapro- ThisworkhasbeensupportedbytheAustrianScience
cess. Finally,Tornado[29]enablestoreplaytheapplica- Foundation, (FWF) under grant P18764, Secure Busi-
tioninputbyinterceptingandreplayingthesystemcalls. nessAustria(SBA),andtheWOMBATandFORWARD
Unfortunately,acommondrawbackofallthefourafore- projectsfundedbytheEuropeanCommissioninthe7th
mentioned approaches is that they run on Linux. Thus, Framework. Marco Cova was partially supported by a
theycannotbeusedtoanalyzeWindowsbinaries. SymantecResearchLabsGraduateFellowship.References [17] L.Dorrendorf,Z.Gutterman,andB.Pinkas.Cryptanaly-
sisoftheWindowsRandomNumberGenerator. InPro-
[1] Anubis: Analyzing Unknown Binaries. http:// ceedingsoftheACMConferenceonComputerandCom-
anubis.seclab.tuwien.ac.at,2009. municationsSecurity(CCS),2007.
[18] G. W. Dunlap, S. T. King, S. Cinar, M. A. Basrai, and
[2] Computer Forensic Solutions. http://cfs-llc.
P.M.Chen.ReVirt:EnablingIntrusionAnalysisthrough
net/index.htm,2009.
[3] CWSandbox. http://www.cwsandbox.org/, Virtual-Machine Logging and Replay. SIGOPS Oper.
Syst.Rev.,36(SI):211–224,2002.
2009.
[19] P.Ferrie. AttacksonVirtualMachines. InProceedings
[4] Joebox: A Secure Sandbox Application for Windows.
oftheAssociationofAnti-VirusAsiaResearchersConfer-
http://www.joebox.org/,2009.
[5] Norman Sandbox. http://www.norman.com/ ence,2007.
[20] T. Garfinkel, K. Adams, A. Warfield, and J. Franklin.
technology/norman_sandbox/,2009.
Compatibility is Not Transparency: VMM Detection
[6] ThreatExpert. http://www.threatexpert.
Myths and Realities. In Proceedings of the USENIX
com/,2009.
WorkshoponHotTopicsinOperatingSystems,2007.
[7] U. Bayer, I. Habibi, D. Balzarotti, E. Kirda, and
[21] G. Hunt and D. Brubacher. Detours: Binary Intercep-
C. Kruegel. Insights Into Current Malware Behavior.
tionofWin32Functions. InProceedingsoftheUSENIX
InProceedingsoftheUSENIXWorkshoponLarge-Scale
WindowsNTSymposium,pages135–144,Berkeley,CA,
ExploitsandEmergentThreats(LEET),2009.
USA,1999.USENIXAssociation.
[8] U.Bayer,C.Kruegel,andE.Kirda. TTAnalyze: ATool
[22] M. G. Kang, H. Yin, S. Hanna, S. McCamant, and
forAnalyzingMalware. InProceedingsoftheEuropean
D. Song. Emulating Emulation-Resistant Malware. In
Institute for Computer Antivirus Research Annual Con-
Proceedings of the Workshop on Virtual Machine Secu-
ference(EICAR),2006.
rity(VMSec),2009.
[9] U. Bayer, P. Milani Comparetti, C. Hlauschek,
[23] T. Klein. ScoopyNG – The VMware detection
C.Kruegel,andE.Kirda.Scalable,Behavior-BasedMal-
tool. http://www.trapkit.de/research/
ware Clustering. In Proceedings of the Symposium on
vmm/scoopyng/index.html.
NetworkandDistributedSystemSecurity(NDSS),2009.
[24] C.Kruegel,E.Kirda,D.Mutz,W.Robertson,andG.Vi-
[10] D.Brumley,C.Hartwig,Z.Liang,J.Newsome,D.Song,
gna. PolymorphicWormDetectionUsingStructuralIn-
andH.Yin.AutomaticallyIdentifyingTrigger-basedBe-
formationofExecutables. InSymposiumonRecentAd-
haviorinMalware. InW.Lee,C.Wang,andD.Dagon,
vancesinIntrusionDetection(RAID),2005.
editors,BotnetDetection: CounteringtheLargestSecu-
[25] K. P. Lawton. Bochs: A Portable PC Emulator for
rityThreat.Springer,2007.
Unix/X. LinuxJournal,(29),1996.
[11] X.Chen,J.Andersen,Z.Mao,M.Bailey,andJ.Nazario.
[26] T. Liston and E. Skoudis. On the Cutting
Towards an Understanding of Anti-virtualization and
Edge: Thwarting Virtual Machine Detection.
Anti-debugging Behavior in Modern Malware. In Pro- http://handlers.sans.org/tliston/
ceedingsoftheInternationalConferenceonDependable
ThwartingVMDetection_Liston_Skoudis.
SystemsandNetworks(DSN),2008.
pdf,2006.
[12] M. Christodorescu and S. Jha. Static Analysis of Exe- [27] L.Martignoni,R.Paleari,G.F.Roglia,andD.Bruschi.
cutablestoDetectMaliciousPatterns. InProceedingsof TestingCPUEmulators. InProceedingsoftheInterna-
theUSENIXSecuritySymposium,2003. tionalSymposiumonSoftwareTestingandAnalysis(IS-
[13] M. Christodorescu, S. Jha, S. Seshia, D. Song, and
STA),2009.
R.Bryant. Semantics-awareMalwareDetection. InPro- [28] L. Martignoni, E. Stinson, M. Fredrikson, S. Jha, and
ceedings of the IEEE Symposium on Security and Pri- J. Mitchell. A Layered Architecture for Detecting Ma-
vacy,2005. liciousBehaviors. InProceedingsoftheSymposiumon
[14] F. Cornelis, A. Georges, M. Christiaens, M. Ronsse, RecentAdvancesinIntrusionDetection(RAID),2008.
T. Ghesquiere, and K. D. Bosschere. A Taxonomy of [29] F. C. Michiel, F. Cornelis, M. Ronsse, and K. D. Boss-
Execution Replay Systems. In Proceedings of the In- chere. TORNADO: A Novel Input Replay Tool. In
ternationalConferenceonAdvancesinInfrastructurefor ProceedingsoftheInternationalConferenceonParallel
Electronic Business, Education, Science, Medicine, and andDistributedProcessingTechniquesandApplications
MobileTechnologiesontheInternet,2003. (PDPTA),pages1598–1604,2003.
[15] D.A.S.deOliveira,J.R.Crandall,G.Wassermann,S.F. [30] A.Moser,C.Kruegel,andE.Kirda. ExploringMultiple
Wu,Z.Su,andF.T.Chong. ExecRecorder: VM-Based Execution Paths for Malware Analysis. In Proceedings
Full-SystemReplayforAttackAnalysisandSystemRe- oftheIEEESymposiumonSecurityandPrivacy,2007.
covery. InProceedingsoftheWorkshoponArchitectural [31] R.Paleari,L.Martignoni,G.F.Roglia,andD.Bruschi.A
andSystemSupportforImprovingSoftwareDependabil- FistfulofRed-Pills:HowtoAutomaticallyGeneratePro-
ity (ASID), pages 66–71, New York, NY, USA, 2006. cedurestoDetectCPUEmulators. InProceedingsofthe
ACM. USENIX Workshop on Offensive Technologies (WOOT),
[16] A. Dinaburg, P. Royal, M. Sharif, and W. Lee. Ether: 2009.
Malware Analysis via Hardware Virtualization Exten- [32] T.Raffetseder,C.Kruegel,andE.Kirda. DetectingSys-
sions. InProceedingsoftheACMConferenceonCom- temEmulators. InProceedingsoftheInformationSecu-
puterandCommunicationsSecurity(CCS),2008. rityConference,2007.[33] J. Rutkowska. Red Pill... or how to detect tionsConference(ACSAC),2005.
VMM using (almost) one CPU instruction. [38] A. Vasudevan and R. Yerraballi. Cobra: Fine-grained
http://www.invisiblethings.org/ MalwareAnalysisusingStealthLocalizedExecutions.In
papers/redpill.html,2004. ProceedingsoftheIEEESymposiumonSecurityandPri-
[34] Y.Saito.Jockey:AUser-spaceLibraryforRecord-replay vacy,2006.
Debugging. InProceedingsoftheInternationalSympo- [39] J.WilhelmandT.Chiueh. AForcedSampledExecution
siumonAutomatedAnalysis-drivenDebugging(AADE- Approach toKernel RootkitIdentification. InProceed-
BUG),pages69–76,2005. ingsoftheSymposiumonRecentAdvancesinIntrusion
[35] S.M.Srinivasan,S.Kandula,S.K,C.R.Andrews,and Detection(RAID),2007.
Y.Zhou. Flashback: ALightweightExtensionforRoll- [40] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda.
backandDeterministicReplayforSoftwareDebugging. Panorama:CapturingSystem-wideInformationFlowfor
InProceedingsoftheUSENIXAnnualTechnicalConfer- MalwareDetectionandAnalysis. InProceedingsofthe
ence,pages29–44,2004. ACMConferenceonComputerandCommunicationsSe-
[36] P. Szor. The Art of Computer Virus Research and De- curity(CCS),2007.
fense. AddisonWesley,2005.
[37] A.VasudevanandR.Yerraballi. StealthBreakpoints. In
Proceedings of the Annual Computer Security Applica-