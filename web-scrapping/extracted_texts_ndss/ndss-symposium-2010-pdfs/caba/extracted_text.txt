Binary Code Extraction and Interface Identification
for Security Applications
JuanCaballero§† NoahM.Johnson† StephenMcCamant† DawnSong†
†UCBerkeley §CarnegieMellonUniversity
Abstract 1 Introduction
Oftenasecurityanalystwishestoreuseacodefrag-
Binarycodereuseistheprocessofautomaticallyidenti- ment that is available in a program’s binary, what we
fying the interface and extracting the instructions and callbinarycodereuse. Forexample,apieceofmalware
data dependencies of a code fragment from an exe- may use proprietary compression and encryption algo-
cutableprogram,sothatitisself-containedandcanbe rithmstoencodethedatathatitsendsoverthenetwork
reusedbyexternalcode. Binarycodereuseisusefulfor andasecurityanalystmaybeinterestedinreusingthose
anumberofsecurityapplications,includingreusingthe functionstodecodethenetworkmessages. Further,the
proprietary cryptographic or unpacking functions from analyst may be interested in building a network proxy
a malware sample and for rewriting a network dialog. thatcanmonitorandmodifythemalware’scompressed
Inthispaperweconductthefirstsystematicstudyofau- andencryptedprotocolonthenetwork. Also,fordialog
tomatedbinarycodereuseanditssecurityapplications. rewriting[24,29]ifsomefieldofanetworkprotocolis
changed,otherdependantfieldssuchaslengthorcheck-
The main challenge in binary code reuse is under- sum fields may need to be updated. If those fields use
standing the code fragment’s interface. We propose a proprietary or complex encodings, the encoding func-
novel technique to identify the prototype of an undoc- tionscanbeextractedanddeployedinthenetworkproxy
umented code fragment directly from the program’s bi- sothattherewrittenmessageiscorrectlyformatted.An-
nary,withoutaccesstosourcecodeorsymbolinforma- otherapplicationisthecreationofstaticunpackingtools
tion. Further, we must also extract the code itself from foraclassofmalwaresamples[17]. Currently,creating
thebinarysothatitisself-containedandcanbeeasily astaticunpackerisaslow,manualprocess.Frameworks
reusedinanotherprogram. Wedesignandimplementa haveemergedtospeedtheprocess[15],butafasterap-
toolthatusesacombinationofdynamicandstaticanal- proachwouldbetoextracttheunpackingfunctionfrom
ysis to automatically identify the prototype and extract themalwaresampleandreuseitasastaticunpacker.
theinstructionsofanassemblyfunctionintoaformthat Atthecoreoftheseandothersecurityapplicationsis
can be reused by other C code. The extracted function binarycodereuse,animportantproblemforwhichcur-
can be run independently of the rest of the program’s rentsolutionsarehighlymanual[1,5,6,30]. Inthispa-
functionalityandsharedwithotherusers. per we conduct the first systematic study of automatic
binary code reuse, which can be defined as the pro-
Weapplyourapproachtoscenariosthatincludeex- cess of automatically identifying the interface and ex-
tracting the encryption and decryption routines from tractingtheinstructionsanddatadependenciesofacode
malware samples, and show that these routines can be fragmentfromanexecutableprogram,sothatitisself-
reused by a network proxy to decrypt encrypted traf- containedandcanbereusedbyexternalcode. Reusing
fic on the network. This allows the network proxy to binarycodeisusefulbecauseformanyprograms, such
rewritethemalware’sencryptedtrafficbycombiningthe as commercial-off-the-shelf applications and malware,
extracted encryption and decryption functions with the source code is not available. It is also challenging be-
session keys and the protocol grammar. We also show causebinarycodeisnotdesignedtobereusableevenif
that we can reuse a code fragment from an unpacking thesourcecodeithasbeengeneratedfromis. Themain
functionfortheunpackingroutineforadifferentsample challenge of binary code reuse is to interface with the
of the same family, even if the code fragment is not a codefragmentthatwewanttoreuse.Thecodefragment
completefunction. maynothaveafunctionprototypeavailable,forexample
becauseitwasintendedonlyforinternaluse, oritmaynotevencorrespondtoafunctioninthefirstplace.Iden- cause the function parameters that comprise the proto-
tifyingaprototypeforthebinarycodefragmentenables type are not explicitly defined in the binary code and
reuseofthecodebygeneratingandpassingappropriate also because they need to be expressed using variables
inputs. In addition, we want to extract the code frag- and types, which do not exist in the binary code. Our
ment itself, i.e., its instructions and data dependencies, approach uses dynamic analysis to extract a parame-
so that it is self-contained and can be reused by other ter abstraction at the binary level (an assembly param-
code,independentlyoftherestofthefunctionalityinthe eter)andthentranslatetheassemblyparametersintothe
program. The self-contained code fragment can easily formal parameters in the function’s prototype. To ex-
be shared with other users and can be statically instru- tractassemblyparametersfromagivenexecutiontrace,
mentedorrewritten, forprofilingortoenforceasafety our approach first identifies the inputs and outputs for
policyonitsmemoryaccessesifitisuntrusted. Tosum- eachfunctionrun,splitsthemintoassemblyparameters,
marize,binarycodereuseencompassestwotasks: iden- identifiesimportantattributessuchastheparametertype
tifyingtheinterfaceofthecodefragmentandextracting (input,output,input-output)andtheparameterlocation
theinstructionsanddatadependenciesofthecodefrag- (register, stack, table), and finally combines this infor-
mentsothatitisself-contained. mationacrossmultiplefunctionruns.
To extract the function’s body, i.e., the instructions
Scope. Notallbinarycodecanbereused. Toreuseabi-
thatconstitutetheassemblyfunction,weusetheobser-
nary code fragment, the fragment should have a clean
vationthatforreusingabinarycodefragmentauserof-
interface and be designed to perform a specific well-
ten has no need to understand its inner workings. For
contained task, mostly independent of the remaining
example, a security analyst may want to reuse the pro-
code in the program. In this paper we mostly focus on
prietarycipherusedbysomemalware,togetherwiththe
reusing binary code fragments that correspond to func-
session keys, to decrypt some data, without worrying
tions at the source code level, what we call assembly
about how the proprietary cipher works. For these ap-
functions,becauseinstructuredprogrammingafunction
plications, complex reverse-engineering or decompila-
isthebaseunitofsourcecodereuse. Functionsareusu-
tionmethodsarenotnecessarytorecoverthefunction’s
allydesignedtoperformanindependent,well-contained
bodyassourcecode.Wecanleveragethesupportofcur-
taskandhaveawell-definedinterface,thefunctionpro-
rent C compilers for inline assembly [3,11] and gener-
totype. In addition, we show that a code fragment that
ateafunctionwithaCprototypebutaninlineassembly
does not correspond to a complete assembly function,
body. Toextractthefunction’sbodyweuseacombina-
buthasacleaninterfaceandperformsawell-contained
tionofstaticanddynamicanalysisthatincludeshybrid
task,canalsobereused.
disassembly [41], symbolic execution [35], jump table
Reusing an arbitrary assembly function can be ex-
identification[28],andtypeinferencetechniques.
tremely challenging because the function interface can
Because the extracted binary code runs in the same
be convoluted and the function can have complex side
address space as a program that uses it, the same secu-
effects.Ourapproachhandlescommonsideeffectssuch
rity concerns apply to it as to an untrusted third-party
asanassemblyfunctionmodifyingoneofitsparameters
library: a malicious extracted function might attempt
oraccessingaglobalvariable,andalsohandlescallsto
to call other functions in memory or overwrite the ap-
internalandstandardlibraryfunctions. Butweexclude
plication’s data. If such attacks are a risk, an isolation
functions with a variable-length argument list or func-
mechanism is needed to limit what the extracted code
tions that are passed recursive structures such as trees.
cando. Inthisworkweprocesstheextractedcodewith
We refer the reader to Section 2.3 for a more detailed
asoftware-basedfaultisolation(SFI)tooltoinsertrun-
description of the problem’s scope. An important class
time checks that prevent the extracted code fragment
offunctionsthatweextractinthispaperaretransforma-
fromwritingorjumpingoutsidedesignatedmemoryre-
tionfunctions,whichincludeencryptionanddecryption,
gions (separate from the rest of the program). We use
compressionanddecompression, codepackingandun-
PittSFIeld [39], an SFI implementation for x86 assem-
packing,checksums,andgenerallyanyfunctionthaten-
blycodethatenforcesjumpalignmenttoavoidoverlap-
codes data. Such functions are usually well-contained,
pinginstructionsandincludesaseparatesafetyverifier.
have clean interfaces, limited side effects, are interest-
We design and implement BCR, a tool that extracts
ingformanysecurityapplications,andcanbeidentified
code fragments from program binaries and wraps them
usingpreviouslyproposedtechniques[24,46].
inaCprototype,sotheycanbereusedbyotherCcode.
Approach. The main challenge in assembly function We use BCR to extract the encryption and decryption
reuse is identifying the interface of an assembly func- routinesusedbytwospambotnets:MegaDandKraken.
tion and generating a prototype for it so that it can be We show that these routines, together with appropriate
reused by other source code. This is challenging be- session keys, can be reused by a network proxy to de-cryptencryptedtrafficonthenetwork.Further,weshow • We reuse the encryption and decryption routines
that the network proxy can also rewrite the malware’s used bytwo spambotnets ina networkproxy that
encryptedtrafficbycombiningtheextractedencryption canrewritetheirencryptedC&Ctraffic,whenpro-
and decryption functions with the session keys and the vided with the session keys and the C&C proto-
protocolgrammar. Toshowthatwecanreusecodefrag- col grammar. In addition, we extract the unpack-
mentsthatarenotcompletefunctionsaslongasthecode ingfunctionfromatrojanhorseprogram,andshow
fragmentshaveacleaninterface,wealsoextracttheun- thatacodefragmentbelongingtothatfunctioncan
packing functions from two samples of Zbot, a trojan, be reused by the unpacking function for a differ-
anduseanunpackingfragmentfromonesampleaspart entsamplefromthesamefamily. Finally,weapply
oftheroutinetounpacktheothersample. software-basedfaultisolation[39]totheextracted
functionstopreventthemfromwritingorjumping
Otherapplications. Inadditiontotheapplicationsthat
outsidetheirownisolatedmemoryregions.
weexamineinthispaper,binarycodereuseisusefulfor
many other applications. For example, it can be used
toautomaticallydescribetheinterfaceofundocumented 2 OverviewandProblemDefinition
functions. It often happens that malware uses undoc-
umented functions from the Windows API, which are Inthissectionwegiveanoverviewofthebinarycode
notdescribedinthepublicdocumentation[10]. Projects reuse problem, formally define it, outline the scope of
to manually document such functions [16] could bene- oursolution,andpresentanoverviewofourapproach.
fit from our approach to automatically identify the in-
terface of a binary code fragment. Extracted functions 2.1 Overview
couldalsobeusefulinthedevelopmentofprogramsthat
interoperatewithotherproprietaryinterfacesorfilefor- Binary code reuse comprises two tasks: 1) identify-
mats, by allowing the mixture of code extracted from ing the interface of the code fragment and formatting
previousimplementationswithre-implementedreplace- it as a prototype that can be invoked from other source
ments and new functionality. Another application is to code;and2)extractingtheinstructionsanddatadepen-
determine whether two pieces of binary code are func- denciesofthecodefragmentsothatitisself-contained
tionallyequivalent,forexampletodeterminewhethera and can be reused independently of the rest of the pro-
vulnerability has been fixed in the most recent version. gram’sfunctionality.
Recentworkhasaddressedthisissueatthesourcecode Themainchallengeinbinarycodereuseisidentify-
level by fuzzing both pieces of source code and com- ing the interface of the code fragment, which specifies
paring the input-output pairs [34], but how to interface its inputs and outputs. This is challenging because bi-
withabinarycodefragmenttoperformsuchfuzzingis nary code has memory and registers rather than named
an open problem. Finally, a security analyst may want parameters,andhaslimitedtypeandsemanticinforma-
tofuzzawell-contained, security-sensitivefunction in- tion, which must be converted into a high level proto-
dependentlyoftheprogramstateinwhichitisused. type. It is also challenging because the code fragment
might have been created by any compiler or written by
Contributions.
hand, thusfewassumptionscanbemadeaboutitscall-
• We propose a novel technique to identify the in- ingconvention. Inaddition,theextractedcodefragment
terfaceofabinarycodefragmentdirectlyfromthe needs to be self-contained, which in turn implies that
program’sbinary,withoutaccesstoitssourcecode. we need a recursive process that extracts any function
Theinterfacecapturestheinputsandoutputsofthe calledfrominsidethecodefragmentthatwewanttoex-
codefragmentandprovidesahigherlevelparame- tract(andfrominsidethosecallees),andthatweneedto
terabstractionnotavailableatthebinarylevel. accountforthepossiblesideeffectsfromthecodefrag-
• We design an approach to automatically extract a ment and its callees. For example, we need to identify
code fragment from a program binary so that the and extract the data dependencies such as global vari-
code fragment is self-contained and can be reused ablesandtablesthatthecodefragmentuses.
by an external C program. The extracted code Previous work on binary code reuse is highly man-
fragment can be run independently of the rest of ual[5,6,30]. Asfarasweknowwearethefirstonesto
the program’s functionality, can be easily instru- systematically study automatic binary code reuse. Our
mented, and can be shared with other users. We goal is to automate the whole process, with a focus on
implement BCR, a tool that uses our approach to automaticallyidentifyingthecodefragment’sinterface.
automatically extract an assembly function from a Therearetwodifferentrepresentationsfortheextracted
givenprogrambinary. binarycode: decompiledsourcecode[5,30]andassem-
bly instructions [6,30]. In this work we use inline as-sembly with a C prototype because inline assembly is turninstructions,whichisinsteadpartofthecalledfunc-
the most accurate representation of the code (it repre- tion. Inotherwords,thebodyofafunctionisassumed
sentswhatgetsexecuted)andbecausedecompilationis tocontinuewiththenextinstructionafteracallinstruc-
notneededforbinarycodereuse. Theuseofinlineas- tion. An exit point can be a return or interrupt instruc-
semblylimitsportabilitytothex86architecture,andre- tion. Ourdefinitiondoesnotincludeassemblyfunctions
quirescompilersupport,butthex86architectureisstill with multiple entry points, which we treat as multiple
byfarthemostimportantarchitectureinsecurityappli- (partiallyoverlapping)assemblyfunctions,eachinclud-
cations,andcommonlyusedcompilersincluderichsup- ing all code reachable from one entry point to any exit
portforinlineassembly[3,11]. point.
To reuse a binary code fragment, the code should If one assembly function jumps to another, this def-
haveacleaninterfaceandbedesignedtoperformawell- inition considers the blocks following the jump target
contained task, relatively independent of the remaining to be part of the assembly function to extract. We can
code in the program. Otherwise, if the extracted code further extend our definition of an exit point to include
interface is not clean or the code performs several in- jumpstotheentrypointofanyotherassemblyfunction
tertwinedtasksandtheuserisonlyinterestedinoneof intheprogram’sbinaryorinanexternaldynamiclinked
them, it becomes difficult to separate the relevant code library(DLL).Forthisweneedalistofentrypointsfor
and interface with it. In structured programming, the otherassemblyfunctions,whichcanbegivenorapprox-
above characteristics are usually associated with func- imatedbyconsideringanytargetofacallinstructionto
tions,whicharethebasicunitof(source)codereusein beanentrypoint.
aprogramandreducethedevelopmentandmaintenance Problemdefinition. Theproblemofassemblyfunction
costs of a program by making the code modular. The reuseisdefinedas:giventhebinaryofaprogramandthe
interfaceofafunctioniscapturedbyitsfunctionproto-
entrypointofanassemblyfunctioninthebinary,iden-
type.
tify the interface and extract the instructions and data
The source-level concept of a function may not be dependencies that belong to the assembly function so
directly reflected at the binary code level, since func- thatitisself-containedandcanbereusedbyexternalC
tions at the source level can be inlined, split into non- code. The extracted function consists of both an inline
contiguous binary code fragments, or can exit using assembly function with a C prototype and a header file
jumpsinsteadofreturninstructions(e.g.,duetotail-call containingthefunction’sdatadependencies. Theprob-
optimizations).Despitethisblurring,itispossibletode- lemdefinitionwhenthecodefragmentisnotanassem-
fineanassemblyfunctionabstractionatthebinarylevel
blyfunctionisthesame, exceptthatitrequirestheexit
forwhichanextractedprototypegivesacleaninterface pointstobegiven.
when the underlying functionality is well modularized.
Thus,wefocusonidentifyingtheinterfaceandextract- 2.3 Scope
ingthebodyofsuchfunctionabstractions,thedetailsof
whichweturntonext. Reusinganarbitraryassemblyfunctionisextremely
challenging because the function interface can be con-
2.2 ProblemDefinition
volutedandthefunctioncanhavecomplexsideeffects.
Tolimitthescopeoftheproblemwemakethefollowing
To reuse functions from program binaries, we first assumptionsaboutthefunctiontobeextracted:
need a function abstraction that captures our definition • Thefunctionentrypointisknown. Fortransforma-
ofwhatafunctionisinbinarycode. tionfunctions,weautomaticallydiscoverthemus-
Function abstraction. We define a basic block to be ingapreviouslyproposedtechniquethatflagsfunc-
asequenceofinstructionswithoneentrypointandone tionswithahighratioofarithmeticandbitwiseop-
exit point. Basic blocks are disjoint and partition the erations[24,46].
code in an executable. We define an assembly function • Since our approach uses dynamic analysis, we as-
to be a collection of basic blocks with a single entry sumethatwecanexecutethefunctionatleastonce.
point, which is the target of the instruction that trans- Ifsomespecificinputisneededtoreachthefunc-
fers control from the external code into the assembly tion,weassumeweareprovidedwithsuchinput.
function code, and one or more exit points, which are • The function has a fixed parameter list. Thus, we
instructionsthattransfercontroltoexternalcodenotbe- excludefunctionswithvariable-lengthlistofargu-
longing to the function. All code reachable from the mentssuchasprintf.
entrypointbeforereachinganexitpointconstitutesthe • Thefunctionisnotpassedcomplexrecursivestruc-
body of the assembly function, except code reachable tures such as lists or trees (pointers to single-level
only through call instructions before corresponding re- structuresaresupported).Figure 1. Our assembly function reuse approach. The core of our approach is the function
extractionstepimplementedbyBCR.Thethreedarkgraymodulesinfunctionextractionhave
beenspecificallydesignedforthiswork. Theexecutionmonitor,disassembler,andsemantics
inferencemodule(lightgray)arereusedfromprevioussystems.
• The function does not call system calls directly assemblyapproachbecauseitusesdynamicanalysisto
(e.g.,throughinterruptorsysenterinstructions) complementstaticdisassembly. However, apremiseof
but instead uses system calls only through well- ourapproachisthatwecanobserveasample’sexecution
knownfunctionsthatareavailableinthetargetsys- inouranalysisenvironment(basedonasystememula-
temwherethefunctionisreused(e.g.,thestandard tor). Thus,likeotherdynamicapproaches,ourapproach
Clibrary,ortheWindowsAPIifthetargetsystem can be evaded using techniques that detect virtualized
isWindows-based). or emulated environments [27]. In addition, an adver-
• The function contains no code that explicitly uses sary may make its code hard to reuse, for example, by
itsownlocation. Forexample,thecodeshouldnot mixing unrelated functionality, adding unnecessary pa-
checkifitisloadedataspecificaddressoroffset. rameters, or inlining functions. We have not seen such
Thisrestrictionexcludesmostself-modifyingcode. obfuscationsinourexamples.Weconsiderthemanother
However, the function may still reference global instanceofcodethatishardtoreuseandmayrequireau-
addresses through standard position-independent- tomatedormanualanalysisontopofourtechniques.
code and dynamic linking: relocatable and non-
relocatablecodearebothsupported. 2.4 ApproachandSystemArchitecture
An important class of functions that usually satisfy
these constraints are transformation functions. Trans- Our assembly function reuse approach comprises
formationfunctionsincludeencryptionanddecryption, three steps: dynamic analysis, hybrid disassembly, and
compressionanddecompression, codepackingandun- function extraction. Figure 1 shows the three steps.
packing,checksums,andgenerallyanyfunctionthaten- In the dynamic analysis step the program is run inside
codes given data in a different format. Such functions the execution monitor, which is an emulator based on
are usually well-contained, have clean interfaces, lim- QEMU [13,44] that can produce execution traces con-
ited side effects, and are interesting for many security taining the executed instructions, the contents of the
applications. instructions’ operands and optional taint information.
Handling obfuscation. Our approach can be applied Theexecutionmonitortrackswhenexecutionreachesa
to both benign code and malware. When applying it givenentrypointandwhenitleavestheassemblyfunc-
to malware we need to consider the obfuscation tech- tion via an exit point. When an exit point is reached,
niques that malware often uses. Common obfuscation the execution monitor produces a memory dump, i.e.,
techniquesusedtohamperstaticanalysissuchasbinary a snapshot of the process memory address space. This
packing, adding unnecessary instructions, or replacing step may be repeated to produce multiple execution
calls with indirect jumps do not affect our hybrid dis- tracesandmemorydumps.Inthehybriddisassemblystep,BCRrecoversthein-
structionscomprisingthefunction’sbodyusingacom-
bination of static and dynamic analysis. It first tries
to statically disassemble as much as possible from the
memorydumpstartingatthefunction’sentrypoint,us-
ingtheIDAProcommercialdisassembler[4]. Then, it
usestheinformationfromtheexecutiontracesgenerated
by the dynamic analysis to resolve indirect jumps and
calls, and invokes the static disassembler to disassem-
ble instructions at those locations. If the binary is not
packed,staticdisassemblycanbeperformeddirectlyon
the program binary, otherwise the memory dump pro-
ducedduringthedynamicanalysisstepisused. Thehy-
briddisassemblystepoutputsthedisassembledinstruc-
tionsbelongingtothefunctionbody.
The core of our approach is the function extraction
step. It is implemented by BCR and consists of three
sub-steps. Theinterfaceidentificationmoduleidentifies
thefunction’sparametersandoutputs(i.e.,thefunction
prototype). The body extraction module arranges the
disassembledinstructionsintobasicblocks,andrewrites
addressesinjumpsandtableaccessestouselabels. Fi-
nally, the code generation module takes as input the
functionprototypeandthecontrolflowgraphoftheas-
semblyfunction,andproducesasoutputtheCfileswith
thefunctionandheaderfileswithitsdatadependencies.
The interface identification module, the body extrac-
tionmodule,andthecodegenerationmodulehavebeen
specificallydesignedandimplementedinthiswork.The
executionmonitor[13,44],disassembler[4],andseman-
ticsinferencemodule[24]arepre-existingtools.Wede-
tailtheinterfaceidentificationmoduleinSection3,and
thebodyextractionmoduleandcodegenerationmodule
inSection4.
2.5 RunningExample
Figure 2 shows our running example. At the top is
the source code for the encode function, which reads
lencharactersfrombuffersrc,transformsthemusing
the static table enc tbl, and writes them to the dst
buffer. Below it is the assembly function correspond-
ing to the encode function, extracted by BCR from
theprogrambinary. Thelargeboxesinthefigureshow
theCprototypeproducedbytheinterfaceidentification
module, and the prologue and epilogue introduced by
the code generation module. The smaller boxes show
theadditionalelementsinthebodyofthefunctionthat
have been rewritten or modified to make the function
stand-alone. The rest are the unmodified assembly in-
structionextractedbythebodyextractionmodule. Also Figure 2. Running example. At the top is
produced, but omitted from the figure, is a header file the source code for the encode function
defining a table called tbl 004000000, containing a andbelowtheextractedversionoftheas-
memorydumpoftheoriginalmodule. semblyfunction.3 FunctionPrototypeIdentification ingaddress, recordingthestartingaddressandthe
offset.
3. The parameter length can be either fixed or vari-
The goal of function prototype identification is to
able. Avariablelengthcouldbedeterminedbythe
build a C function prototype for the assembly function
value ofanother length parameter, or the presence
sothat itcan bereusedfrom otherC code. TheC pro-
ofaknowndelimiter(likeanullcharacterforaC-
totype comprises the function’s name and a list of its
stylestring).
formalparameters. However,formalparametersdonot
4. Theparametersemanticsindicateshowitsvalueis
directly appear at the binary code level, so BCR works
used. Parametershavepointerorlengthsemantics
with a binary-level abstraction, which we term an as-
iftheyareusedtoidentifythelocationandsizeof
semblyparameteranddescribenext. Atthesametime,
otherparameters,aspreviouslydescribed. Ourpa-
wecollectsomeadditionalinformation,suchasthepa-
rameterabstractionsupportsanumberofsemantic
rameter length or its semantics. This information does
types related to system operations, such as IP ad-
notdirectlyappearintheprototype,butitisneededfor
dresses,timestamps,andfilenames.An“unknown”
interfacingwiththeextractedcode.
typerepresentsaparameterwhosesemanticshave
Theinterfaceidentificationmoduleidentifiestheas-
notbeendetermined.
sembly parameters using a dynamic analysis that takes
5. TheparametervaluelistgivesthevaluesBCRhas
asinputtheexecutiontracesproducedbytheexecution
observed the parameter to take over all assembly
monitor. Thus, itcanonlyextractparametersthathave
functionexecutions. Thisisespeciallyusefulifthe
beenusedbythefunctionintheexecutionscapturedin
parameter’s semantics are otherwise unknown: a
thegivenexecutiontraces. Toincreasethecoveragein-
usercanjustsupplyavaluethathasbeenusedfre-
side the function white-box exploration techniques that
quentlyinthepast.
workdirectlyonbinariescanbeused[23,31]. Inprac-
tice,wehaveseenthatfewtracesareneededtocapture
Overview.Theinterfaceidentificationmoduleperforms
the full prototype of the function and have not needed
three steps. For each assembly function execution, it
suchexplorationtechniques.
identifies a list of assembly parameters used by the as-
In the remainder of this section we describe how to
semblyfunctioninthatrun(Section3.1). Next,itcom-
identifytheprototypeofanassemblyfunction. Thepro-
bines the assembly parameters from multiple runs to
cessforidentifyingtheprototypeofanarbitrarybinary
identifymissingparametersandgeneralizestheparam-
codefragmentisanalogous.
eter attributes (Section 3.2). Finally, it identifies addi-
Parameter abstraction. An assembly parameter plays tionalsemanticsbyrunningtheassemblyfunctionagain
a role for an assembly function analogous to a formal in the execution monitor using the parameter informa-
parameterforaCfunction,specifyingalocationrepre- tion and a taint tracking analysis (Section 3.3). Later,
senting an input or output value. But instead of being inSection4.2,wewillexplainhowthecodegeneration
referredtobyahuman-writtenname, assemblyparam- moduletranslatestheassemblyparametersproducedby
etersareidentifiedwithalocationinthemachinestate. the interface identification module into the formal pa-
Tobespecific,wedefineassemblyparameterswithfive rametersandoutputstheCfunctionprototype.
attributes:
3.1 IdentifyingtheAssemblyParametersfrom
1. The parameter type captures whether it is only an aFunctionRun
inputtothefunction(IN),onlyanoutputfromthe
function(OUT)orboth(IN-OUT).Anexampleof Foreachfunctionrunintheexecutiontracestheinter-
anIN-OUTparameterisacharacterbufferthatthe face identification module identifies the run’s assembly
assemblyfunctionconvertsin-placetouppercase. parameters. Becausetherearenovariablesatthebinary
2. The parameter location describes how the code level (only registers and memory), this module intro-
finds the parameter in the program’s state. A pa- ducesabstractvariables(sometimescalledA-locs[22])
rametercanbefoundonthestack,inaregister,orat as an abstraction over the machine-level view to rep-
anotherlocationinmemory. Forstackparameters, resent concepts such as buffers and stack parameters.
thelocationrecordsthefixedoffsetfromthevalue Thesevariablesmustbesufficientlygeneraltoallowfor
ofthestackpointerattheentrypoint;foraregister, rewriting: forinstance,theaddressesofglobalvariables
it specifies which register. Memory locations can must be identified if the variable is to be relocated. A
beaccessedusingafixedaddressorpointedbyan- final challenge is that because the code being extracted
otherpointerparameter,perhapswithanadditional might have been created by any compiler or written by
offset.BCRalsospeciallyclassifiesglobalsthatare hand, BCR must make as few assumptions as possible
accessed as tables via indexing from a fixed start- aboutitscallingconventions.In outline, our approach is that the interface identi- Output locations. We define an output location to be
fication module first identifies all the bytes in the pro- a register, memory, or constant location that is written
gram’s state (in registers or memory) that are either an by the extracted function and read by the code that ex-
input or an output of the assembly function, which we ecutesafterthefunctionreturns. Extendingtheanalogy
callinputlocationsandoutputlocations,respectively. It with compiler-style static analysis, this corresponds to
then generalizes over those locations to recognize ab- the intersection of the reaching definitions of the func-
stract locations and assembly parameters. To get the tion’scodewiththelocationsthatareliveinthesubse-
best combination of precision and efficiency, we use quent code. Like static reaching definitions [40], it is
a combination of local detection of instruction idioms, computedinasingleforwardpassthroughthetrace.
andwhole-programdataflowanalysisusingtaintingand Our choice of requiring that values be read later is
symbolicexecution. Intheremainderofthissectionwe motivatedbyminimizingfalsepositives(afalsepositive
refer to an assembly parameter simply as “parameter” outputlocationtranslatesintoanextraparameterinthe
for brevity, and use the term “formal parameter” to re- C function prototype). This requirement can produce
fertotheparametersintheCfunctionprototype. Next, falsenegativesonasinglerun,ifanoutputvalueisnot
wedefineaprogramlocationandwhatinputandoutput used under some circumstances. However, our experi-
locationsare. ence is that such false negatives can be well addressed
by combining multiple function runs, so using a strict
Programlocations. Wedefineaprogramlocationtobe
definitioninthisphasegivesthebestoverallprecision.
aone-byte-longstorageunitintheprogram’sstate. We
Approach. The input and output locations contain
considerfourtypesoflocations: memorylocations,reg-
all locations belonging to the assembly parameters and
isterlocations,immediatelocations,andconstantloca-
globals used by the assembly function, without regard
tions. Eachmemorybyteisamemorylocationindexed
to calling conventions. In addition to identifying them,
byitsaddress. Eachbyteinaregisterisaregisterloca-
theinterfaceidentificationmoduleneedstoclassifythe
tion; for example, the 32-bit register EAX has four lo-
input and output locations into higher level abstrac-
cationsEAX(0)throughEAX(3),twoofwhicharealso
tionsrepresentingparameters. Also,itneedstoidentify
theregistersALandAH.Animmediatelocationcorre-
whetheraparametercorrespondstoastacklocation,to
spondstoabytefromanimmediateinthecodesection
aglobal,orisaccessedusingapointer. Theoverallpa-
ofsomemodule, indexedbytheoffsetofthebytewith
rameter identification process from one function run is
respect to the beginning of the module. Constant loca-
summarizedinTable1anddescribednext.
tionsplayasimilarroletoimmediatelocations,butare
For efficiency, the basic identification of parameters
theresultsofinstructionswhoseoutputsarealwaysthe
isasingleforwardpassthatperformsonlylocalanalysis
same. For example, one common idiom is to XOR a
ofinstructionsinthetrace. Itstartsattheentrypointof
register with itself (e.g., xor %eax, %eax), which sets
one execution of a function, and uses one mode to an-
theregistertozero.
alyze both the function and the functions it calls, with-
Inputlocations.Wedefineaninputlocationtobeareg- outdiscerningbetweenthem(forinstance,alocationis
ister or memory location that is read by the function in counted as an input even if it is only read in a called
the given run before it is written. Identifying the input function),andanothermodetoanalyzetheremainderof
locationsfromanexecutiontraceisadynamicdataflow- thetraceafterthefunctionfinishes.Foreachinstruction,
based counterpart to static live-variables dataflow anal- itidentifiesthelocationstheinstructionreadsandwrites.
ysis[40],whereinputlocationscorrespondtovariables Foreachlocation,itidentifiesthefirstandlasttimesthe
live at function entry. Like the static analysis, the dy- locationisreadandwrittenwithinthefunction,aswell
namicanalysisconceptuallyproceedsbackwards,mark- as the first time it is read or written after the function.
inglocationsasinputsiftheyareread,butmarkingthe Basedonthisinformation, alocationisclassifiedasan
previousvalueofalocationasdeadifitisoverwritten. inputlocationifitisreadinsidethefunctionbeforebe-
(Sinceweareinterestedonlyinlivenessatfunctionen- ingwritteninsidethefunction,andasanoutputlocation
trance,wecanuseaforwardimplementation.) Thedy- if it is written in the function and then read outside the
namicanalysisisalsosimplerbecauseonlyoneexecu- function before being written outside the function; ob-
tion path is considered, and the addresses in the trace servethatalocationcanbebothaninputandanoutput.
canbeuseddirectlyinsteadofconservativealiasanaly- Atthesametime,theanalysisidentifiesstackandta-
sis. Thisbasicdeterminationofinputlocationsisinde- ble accesses by a local matching of machine code id-
pendentofthesemanticsofthelocation,butaswewill ioms. TheESPregisterisalwaysconsideredtopointto
explainlaternotallinputlocationswillbetreatedaspa- thestack. TheEBPregisterisonlyconsideredtopoint
rameters (for instance, a function’s return address will to the stack if the difference between its value and that
beexcluded). ofESPatfunctionentranceisasmallconstant, tosup-Step Description
1 Identifystackandtableaccesses
2 Identifyinputandoutputlocations
3 Removeunnecessarylocations(e.g.,savedregisters,ESP,returnaddress)
4 Identifyinputandinput-outputpointersbyvalue
5 Splitinputlocationsintoparameterinstancesusingpointer,stackandtableaccessinformation
6 Identifyinputparameterpointersbydataflow
7 Splitoutputlocationsintoparameterinstancesusingpointerinformation
8 Identifyoutputparameterpointersbydataflow
Table1.Summaryofparameteridentificationprocessforafunctionrun.
port both code that uses it as a frame pointer and code To detect a pointer by value, BCR simply checks each
thatusesitasageneral-purposeintegerregister. Then,a sequence of four consecutive input locations (pointers
memoryaccessisastackaccessifitusesastackregis- are four bytes on our 32-bit architecture) to see if their
terasastartingaddressandhasaconstantoffset.Onthe valueformsanaddressofanotherinputoroutputloca-
otherhand, amemoryaccessisclassifiedasatableac- tion. However, this simple approach can fail to detect
cessifitsstartingaddressisaconstantandtheoffsetisa somepointers(forinstance,theaddressofabufferthat
non-stackregister.Thestartingaddressandoffsetvalues was only accessed with non-zero indexes), so we also
instackandtableaccessesarerecordedforfutureuse. implementamoresophisticatedapproach.
Toidentifymorepointers,theinterfaceidentification
Excluding unnecessary input locations. The input
module uses a symbolic execution approach using our
locations given by the simple liveness-style definition
Vinesystem[18]toanalyzeanindirectmemoryaccess.
aboveincludeseveralkindsoflocationswithbookkeep-
The input locations to the function are marked as sym-
ing roles in function calls which should not be con-
bolicvariables,andthemodulecomputesaformulafor
sidered parameters, so we next discuss how to exclude
thevalueoftheeffectiveaddressoftheaccessinterms
them. Toexcludethereturnaddress,theinterfaceiden-
ofthem,usingdynamicslicing[21].Itthenperformsal-
tificationmoduleignoresanymemorylocationswritten
gebraic simplifications and constant folding on the for-
byacallinstructionorreadbyareturninstructiondur-
mula, and checks whether it has the form of a 32-bit
ingthefunctionexecution. Toexcludethestackpointer,
inputplusaconstant. Ifso,theinputlocationsarecon-
itignoresanyaccesstoESP.Whencodecallsfunctions
sidered a pointer, and the constant an offset within the
inadynamicallylinkedlibrary, itfetchestherealentry
regionthepointerpointsto. (Thereversesituationofa
point of the function from an export table, but we ex-
constant starting address and a variable offset does not
cludesuchloads.
occur,becauseitwouldalreadyhavebeenclassifiedasa
Mostcomplexisthetreatmentofsavedregisters. For globaltable.)Thoughprecise,thissymbolicexecutionis
instance,wedefineastacklocationtobeusedforsaving relativelyexpensive,sotheinterfaceidentificationmod-
theregisterEBXifthecontentsofEBXarefirstsavedin uleusesitonlywhenneeded,aswewilldescribenext.
that location with a push instruction, and later restored
Identifyingassemblyparametersfrominputandout-
toEBXwithapopinstruction. Butthelocationisnota
put locations. Once the input and output locations
savedregisterlocationifthevalueispoppedtoadiffer-
havebeenidentifiedandunnecessarylocationsremoved,
ent register than it was pushed from, if the stack value
the interface identification module identifies input and
isaccessedbeforethepop,orifafterthepop,thestack
input-outputpointersbyvalueasexplainedabove. Then
valueisreadbeforebeingoverwritten. Conventionally,
itusesthepointers,stack,andtableaccessestoclassify
thestackisusedtosavecertainregistersdesignatedby
theinputandoutputlocationsintoassemblyparameters.
thecallingconventionifacalledfunctionmodifiesthem,
Eachparameterisacontiguousregioninmemory(ora
but our analysis is independent of the calling conven-
register),buttwodistinctparametersmaybeadjacentin
tion’sdesignation: itsimplyexcludesanylocationused
memory, so the key task is separating a contiguous re-
onlyforsavingaregister.
gion into parameters. The module considers a location
Identifyingpointers.Afinalbuildingblockinidentify- to be the start of a new parameter if it is the start of a
ingparametersistoidentifylocationsthatholdpointers. pointer,theaddressaftertheendofapointer,orthelo-
The interface identification module uses a combination cationofapointer,stack,ortableaccess.Withtheinfor-
of two approaches for this task: an inexpensive value- mationfoundsofar, theinterfaceidentificationmodule
based method that can be applied on all locations, and determinestheparametertype,location,andvalue,and
amoreexpensivedataflow-basedmethodthatworksby if the parameter has pointer semantics. The parameter
creating a symbolic formula and is applied selectively. lengthisprovisionallysettothelengthseenonthisrun.Then,theinterfaceidentificationmoduleattemptsto the techniques the interface identification module uses
further classify any parameters that are in memory but toidentifysuchparametersemantics.
are not on the stack and are not known globals by ap- Twokindsofsemanticsthatoccurfrequentlyintrans-
plyingthedataflow-basedpointeridentificationanalysis. formationfunctionsaspartofspecifyingotherinputand
Specifically, it checks whether the access to the start- outputparametersarepointersandlengths.Asdescribed
inglocationoftheparameterwasapointeraccess;ifso, above,theparameteridentificationprocessfindspointer
it updates the type of the pointed-to parameter and the parametersatthesametimeitidentifiestheparameters
semantics of the pointer parameter accordingly. After they point to. To identify length parameters, their tar-
classifyingtheinputlocationsandpointersinthisway, gets, as well as variable-length parameters that use a
themoduleclassifiestheoutputlocationssimilarly,and delimiter to mark the end of the parameter (e.g., null-
toidentifyandclassifyotherpointersthatpointtothem. terminated strings), we leverage previously proposed
protocol reverse engineering techniques [26,47] based
3.2 Combining Assembly Parameters from ontainttracking.
MultipleFunctionRuns The interface identification module also builds on
taint tracking to detect semantics related to system op-
Thesetofassemblyparametersidentifiedfromasin- erations such as IP addresses, timestamps, ports, and
gle run may be incomplete, for instance if a parameter filenames, using a kind of type inference [24]. Certain
is used only in a limited way on a particular execution well-knownfunctionstakeinputsorproduceoutputsof
path, like src and dst in Figure 2. Therefore the in- a particular type, so BCR uses taint tracking to propa-
terfaceidentificationmodulefurtherimprovesitsresults gatethesetypestothetargetfunction(theonebeingex-
by combining the information about parameters identi- tracted)ifanoutputofawell-knownfunctionisusedas
fiedonmultipleruns. aninputtothetargetfunction,oranoutputofthetarget
The final set ofparameters identified is the union of function is an input to a well-known function. For in-
theparametersidentifiedoverallruns,whereparameters stance, the argument to the inet ntoa function is an
areconsideredthesameiftheyhavethesameparameter IPaddress,soanoutputparameterthatisusedtoderive
location. When parameters with the same location dif- thatargumentmustitselfbeanIPaddress. Conversely,
ferinotherattributesbetweenruns, thoseattributesare if an input parameter is based on the return value of
mergedasfollows: RtlGetLastWin32Error,itmustbeanerrorcode.
Currently, BCR supports 20 semantics, the 18 seman-
• Theparametertypegeneralizestoinput-outputifit
tics defined in [24], plus “pointer” and “unknown”. A
wasinputinsomerunsandoutputinothers.
similar approach can be used at the instruction level to
• Theparameterlengthgeneralizestovariable-length
selectamorespecificCtype(suchasfloatratherthan
if it was fixed-length in some runs and variable-
int)[33].
lengthinothers,orifithaddifferinglengthsacross
Taint-tracking-based semantics inference takes ad-
runs.
vantageoftheexecutionmonitor’ssupportforfunction
• The parameter semantics generalizes to any non-
hooks,whichareinstrumentationcodeexecutedjustbe-
unknownvalueifitwasaknownvalueinsomeruns
fore and/or just after the execution of a chosen func-
andunknowninothers(e.g.,aparameterisconsid-
tion. Hooks added after the execution of well-known
eredapointerifitwasidentifiedtobeapointerat
functionsandthetargetfunctiontainttheiroutputs,and
least once, even if it was considered unknown on
hooks before their execution check if their inputs are
runs when it was NULL). On the other hand, the
tainted. Because such hooks can only be added to the
semantics are replaced with unknown if they had
targetfunctionafteritsparametershavebeenidentified,
conflictingnon-unknownvaluesondifferentruns.
semanticsinferencerequiresanextrarunofthefunction
• Theparametervaluelististheunionofalltheob-
intheexecutionmonitor.
servedvalues.
3.3 IdentifyingParameterSemantics 4 Function Body Extraction and C Code
Generation
In addition to the declared type of a parameter in-
cluded in the C prototype, it is also common (e.g., in In this section we first present how the body extrac-
MSDNdocumentation[10])toprovideadditionalinfor- tionmoduleextractstheinstructionsthatformthebody
mation in text or a comment that explains how the pa- ofanassemblyfunction,andthendescribehowthecode
rameter is used; what we refer to as its semantics. For generationmoduleproducesaCfunctionwithaninline-
instance,oneintparametermightholdthelengthofa assembly body from the output of the interface identi-
buffer,whileanotherisanIPaddress. Wenextdescribe fication module and the body extraction module. Thekey challenges are disassembling all relevant instruc- Inpurelydynamicmode,thebodyextractionmodule
tionsfromthepossiblystrippedbinaryandadjustingthe extractsonlyinstructionsbelongingtothefunctionand
extracted code if it uses a calling convention different itsdescendantsthatappearinthegivenexecutiontraces.
from what the C code expects. For brevity, we use “C This mode has low code coverage but has no trouble
function” to refer to a function with a C prototype and dealing with packed executables, or indirect jumps or
aninline-assemblybody. calls.
In hybrid disassembly mode, the body extraction
4.1 FunctionBodyExtraction modulecombinesbothstaticdisassemblywithdynamic
informationfromtheexecutiontracestoobtainthebest
Extracting the function body is a recursive process of both modes. We have found that hybrid disassem-
that starts by extracting the body of the given function bly works best and have set it to be the default mode
and then recursively extracts the body of each of the of operation. For hybrid disassembly, the body extrac-
functions that are descendants of this function in the tion module first uses static disassembly starting at the
function call graph. The body extraction module clas- given function entry point. In the presence of indirec-
sifies descendant functions into two categories: well- tion, the static disassembler may miss instructions be-
known functions that may be available in the system cause it can not resolve the instructions’ targets. Thus,
where the C function is going to be recompiled, e.g., thebodyextractionmodulecollectsthetargetsofallin-
functions in the standard C library or in the Windows direct jumps and calls seen in the execution traces and
Native API, and the rest, which we term internal func- directsthestaticdisassemblertocontinuedisassembling
tions. Thebodyextractionmoduleextractsthebodyof atthoseaddresses. Forexample,inFigure2,thecallto
thegivenfunctionandallinternaldescendantfunctions. thememsetfunctionwasoriginallyadirectcalltoastub
As an optimization, it avoids extracting well-known thatusedanindirectjumpintomemset’sentrypointin
functions. This increases portability: for example if adynamiclibrary. Thebodyextractionmoduleresolves
a function from a Windows executable uses strcpy the target of the jump and uses the information about
from the standard C library, it can be recompiled in a exportedfunctionsprovidedbytheexecutionmonitorto
Linuxsystemmakingacalltothelocalstrcpyfunc- determinethatthefunctionisthestandardmemset. In
tion. In other cases, portability is not possible because addition, the body extraction module uses a dataflow-
the function may not have a direct replacement in the basedapproachtostaticallyidentifythetargetsofjump
target OS (e.g., there is no direct replacement in Linux tables,anotherclassofindirectjumpsoftenusedtoim-
for NtReadFile), so this optimization is not performed. plementswitchstatements[28].
Forinstance,inourrunningexample,showninFigure2, Thereexistsomesituationswherestaticdisassembly
the encode function calls memset; since it is part of maynotbepossibleevenfromamemorydump,forin-
theClibrary,itisskipped. stanceifaprogramre-packsordeletesinstructionsright
afterexecutingthem: thecodemaybegonebythetime
Hybriddisassembly. Thebodyextractionmoduleuses
adumpistaken. Insuchasituationhybriddisassembly
hybrid disassembly that combines static disassembly
smoothly falls back to be equivalent to purely dynamic
from the program binary or a memory dump with dy-
mode. To summarize, hybrid disassembly uses static
namicinformationfromexecutiontraces[41].
disassembly when possible and incorporates additional
In detail, the body extraction module supports three
dynamic information when it encounters indirection or
modes of operation: purely static, purely dynamic, and
packed memory dumps. For each function, hybrid dis-
hybriddisassembly. Inpurelystaticmode,thebodyex-
assembly stores the disassembled basic blocks, and re-
traction module statically disassembles the code start-
coversthecontrolflowgraph.
ing at the given function entry point, using the IDA
Pro[4]commercialdisassembler. Iftheprogrambinary Rewriting call/jumps to use labels. Once the C func-
is not packed, then disassembly is performed directly tionisrecompileditwillalmostcertainlybeplacedata
on the executable. For packed binaries disassembly is different address, so the body extraction module needs
performedonthememorydumptakenbytheexecution to make the code relocatable. To enable this, it inserts
monitorattheexitpointofthefunction. Itisimportant a label at the beginning of each basic block. Then, it
totakethedumpattheendofthefunction’sexecutionto rewrites the targets of jump and call instructions to use
maximizethecodepagespresentinthedump,aspages these labels. If the target of a jump instruction has not
maynotbeloadedintomemorytilltheyareused.Purely been recovered by the hybrid disassembly, it is rewrit-
staticdisassemblyprovidesgoodcodecoveragebutmay ten to use a unique missing block label that exits the
notbeabletodisassemblecodereachablethroughindi- function with a special error condition. Figure 2 uses
rectjumpsorcalls,ormemorydumpsiftheinstructions smallboxestohighlighttheinsertedblocklabelsandthe
arere-packedafterbeingexecuted. rewrittencall/jumpinstructions.Rewritingthecall/jumpinstructionstouselabelsalsoenablesauserorasubse- alsobesufficientforourpurposes. Infact,someofthe
quenttool(liketheSFItooldiscussedinSection5.5)to VisualC/C++features,suchas“naked”inlineassembly
instrumentthefunctionoralteritsbehaviorbyinserting functions, for which the compiler does not generate a
newinstructionsinthebody. prologueorepilogue,couldsimplifyourprocessing.
Rewriting global and table accesses. The extracted
The assembly block contains the assembly instruc-
C function is composed of a C file with the assembly
tionsinAT&Tsyntax,andthelistofinputs,outputs,and
function and a header file. The header file contains
clobbered registers. These are filled using the parame-
a memory dump of the module containing the func-
ter information provided by the interface identification
tion to extract, taken at the function’s exit point on a
module. When GCC compiles the function, it will add
givenrun. Thebodyextractionmodulerewritesinstruc-
prologue and epilogue code that affects the stack lay-
tions that access global variables or tables to point to
out, so even if the extracted function originally used a
the corresponding offsets in the memory dump array.
standard calling convention, it would not find the stack
This way the extracted function can access table off-
parameterswhereitexpects. Toovercomethisproblem,
sets that have not been seen in the execution traces. In
thecodegenerationmoduleinsertswrappercodeatthe
our running example, the header file is not shown for
beginningofthefunctionthatreadstheparametersfrom
brevity, but the array with the contents from the mem-
the C prototype (as inputs to the assembly block), puts
ory dump is called tbl 004000000 and the instruc-
them in the stack or register locations expected by the
tion that accesses enc tbl has been rewritten to use
extracted function, and calls the extracted entry point.
the label 0x3018+tbl 00400000 which is the first
After the call instruction it inserts a jump to the end of
byte of enc tbl in the memory dump. The memory
thefunctionsothattheepilogueinsertedbyGCCisex-
dumpistakenatthefunction’sexitpoint,butiftheinter-
ecuted. ThesecondboxinFigure2showsthiswrapper.
face identification module discovers any input parame-
tersthatareaccessedusingafixedaddressandmodified
TheCprototypecomprisesthefunctionnameandthe
inside the function, e.g., a global table that is updated
formalparametersofthefunction. Thefunctionnameis
by the function, it ensures that the parameter values on
based on its entry point (func 00401000 in the run-
functionentryarecopiedintothedump,sothattheyare
ningexample),andeachparameter’sCtypeisbasedon
correctwhenthefunctionisinvokedagain.
its size and whether it is a pointer. Input and input-
An alternative approach would be to create separate
output parameters located in the stack or registers ap-
Carraysandvariablesforeachglobalparameter,which
pear first, with stack parameters appearing in order of
would reduce the space requirements for the extracted
increasing offset (this means that if the extracted func-
function. Thoughthiswouldworkwellforscalarglobal
tion used the most common C calling convention, their
variables, it would be difficult to infer the correct size
order will match the original source). For each output
fortables, sincethebinarydoesnotcontainboundsfor
parameterreturnedusingaregister,thecodegeneration
individual variables, and code compiled from C often
module adds an additional pointer formal parameter at
doesnotevenhaveboundschecks.(Anintermediateap-
the end of the C prototype and uses the outputs list in
proachwouldbetoestimatethesizeofatablebymulti-
the assembly block to let GCC know that the register
plyingthelargestobservedoffsetbyasafetyfactor;this
needstobecopiedtothepointed-tolocation. Addition-
wouldbeappropriateifitcouldbeassumedthattesting
ally,foroutputglobalortableparametersthecodegen-
coveredatleastauniformfractionoftheentriesineach
eration module adds a C variable corresponding to the
table.)
startaddressoftheglobalortableinthememorydump.
Thismakesthefunction’ssideeffectsavailabletoother
4.2 CCodeGeneration
Ccode.
ThecodegenerationmodulewritestheoutputCfiles Eachformalparameterisalsoannotatedwithacom-
usingtheinformationprovidedbytheinterfaceidentifi- ment that gives information about the attribute values
cation module and the body extraction module. To en- for the corresponding assembly parameter such as the
codethefunctionbodythecodegenerationmoduleuses parameter type and its semantics. These are useful for
GCC’s inline assembly feature [3]. It wraps the func- a user that wants to reuse the function. In addition, it
tionbodyinanassemblyblockandthenputstheassem- prints the most common value seen for each parameter
blyblockinsideafunctiondefinitionwithaCfunction duringthemultipleexecutionsalongwiththepercentage
prototype, as shown in Figure 2. In addition it creates of executions where the parameter showed that value.
a C header file containing the memory dump as an ar- This allows the user to select a value for the parameter
ray.ThoughourcurrentimplementationisjustforGCC, whentheparametersemanticsareunknown. Thefunc-
theinlineassemblyfeaturesofVisualC/C++[11]would tionprototypeisshowninthefirstboxinFigure2.5 Evaluation Thetechniquetoautomaticallydetecttransformation
functions identifies the functions with highest ratio of
arithmetic and bitwise operations, which for block ci-
This section describes the experiments we have per-
phersisusuallythefunctionsthatprocessasingleblock.
formed to demonstrate that our binary code reuse ap-
To encrypt or decrypt an arbitrary message, we would
proach and implementation is effective for security ap-
likeafunctionthatencryptsordecryptsarbitrarylength
plicationssuchasrewritingencryptedmalwarenetwork
data. Thus, when using this technique, after BCR ex-
trafficandstaticunpacking,thatnon-functionfragments
tractsthedetectedtransformationfunctions,weinstruct
can be extracted to give useful functions, and that ex-
it to extract their parent functions as well. Then, we
tracted functions can be used safely even though they
compare the prototype of each detected function with
comefromanuntrustedsource.
theoneoftheparent. Iftheparent’sprototypeissimilar
butacceptsvariable-lengthdata,e.g.,ithasalengthpa-
5.1 RewritingMegaD’sC&CProtocol
rameter,thenwekeeptheparentfunction,otherwisewe
manuallywriteawrapperfortheblockfunction.
MegaD is a prevalent spam botnet that accounted ForMegaD,theparentoftheblockencryptionfunc-
for 35.4% of all spam in the Internet in a December tionhasadditionalparameters,becauseitperformsother
2008study[8],andstillaccountsfor9%asofSeptem- taskssuchassettingupthenetworkandparsingthemes-
ber 2009 [9]. Recent work reverse-engineers MegaD’s sage.Itcontainsnosingleloopthatperformsdecryption
proprietary,encrypted,C&Cprotocol[24],anddemon- of a variable-length buffer; instead, decryption is inter-
strates rewriting messages on the host by modifying a leaved with parsing. Since we are not interested in the
buffer before encryption. In this section we show that parent function’s other functionality, we write our own
ourassemblyfunctionreuseapproachenablesthesame wrapperfortheblockencryptionfunction.
C&C rewriting on a network proxy, by extracting the To verify that the extracted encryption/decryption
bot’skeygenerationandencryptionfunctions. functionworkscorrectly,weaugmentagrammarforthe
Function extraction. MegaD’s C&C protocol is pro- unencrypted MegaD C&C protocol, reported in earlier
tectedusingaproprietaryencryptionalgorithm,andthe work[24],tousetheextracteddecryptionfunction.This
bot contains functions for block encryption, block de- augmentedgrammarservesasinputtotheBinPacparser
cryption,andacommonkeygenerator. Weidentifythe shipped with the Bro intrusion detection system [42].
entrypointsofthethreefunctionsusingpreviouslypro- Usingtheaugmentedgrammar,Brosuccessfullyparses
posedtechniquesthatflagfunctionswithahighratioof all the encrypted MegaD C&C messages found in our
arithmeticandbitwiseoperations[24,46]. networktraces.
First, we use BCR to automatically extract the key Network-based C&C rewriting. To perform network
generationfunction.Theidentifiedprototypeshowsthat rewriting we must deploy the encryption/decryption
thefunctionhastwoparametersandusestwoglobalta- function,aswellasthesessionkeys,inanetworkproxy.
bles.Thefirstparameterpointstoanoutputbufferwhere Suchaproxywillonlybeeffectiveifthefunctionsand
the function writes the generated key. The second pa- keys match those in the bots, so to estimate the rate at
rameter is a pointer to an 8 byte buffer containing the which they change we repeated our analysis with an
seed from which the key is generated. Thus, the func- older MegaD sample. According to malware analysis
tion generates the encryption key from the given seed online services [14,19], our primary sample was first
and the two tables in the binary. Other attributes show seeninthewildinDecember2008,andourolderonein
thatallcallstothekeygenerationfunctionusethesame February2008. Althoughtherearedifferencesbetween
“abcdefgh” seed, and that the two tables are not modi- bothsamples, suchastheoldersampleusingTCPport
fiedbythefunction. 80insteadof443foritsC&C,theparser,usingthede-
Although the entry points for the block encryption cryptionfunctionandkeysextractedfromtheDecember
and decryption functions are different, the first instruc- sample,isabletosuccessfullyparsetheC&Cmessages
tionintheblockdecryptionfunctionjumpstotheentry from the February sample. In addition, we extract the
point of the block encryption function, so here we de- keygenerationandencryptionfunctionsfromtheFebru-
scribe just the encryption function. The prototype ex- ary sample and compare them with the ones from the
tracted by BCR has 3 parameters and uses 6 global ta- December sample. Although there are syntactic differ-
bles. The first parameter points to an input buffer con- ences, theversionsarefunctionallyequivalent, produc-
taining a key (as produced by the key generation func- ing the same outputs on more than a billion randomly
tion). Theothertwoparametersarepointerstothesame generatedinputs. Thusweconcludethattherelevantal-
8byteinput-outputbufferthatonentrycontainstheun- gorithmsandkeys,includingthesessionkey,havebeen
encrypteddataandonexitcontainstheencrypteddata. unchangedduringthetimespanofoursamples.To show how our assembly function reuse approach SimilarlytotheMegaDexperimentdescribedinSec-
enables live rewriting on the network, we build a net- tion 5.1, we build a network proxy that uses the ex-
workproxythatisabletodecrypt,parse,modifyandre- tractedencryption,decryption,andchecksumfunctions,
encrypt MegaD C&C messages that it sees on the net- aswellastheprotocolgrammar, anduseittorewritea
work. To test the proxy we reproduce an experiment C&CmessagetofalsifytheresultofanSMTPcapabil-
from [24], but perform rewriting on the network rather itycheck. Unfortunately(forourpurposes),noneofour
than on the host. The experiment proceeds as follows. KrakensamplesconnectstoaliveC&CserverontheIn-
We run a live MegaD bot in a virtual environment that ternet. Thus,toverifythatthemessagerewritingworks
filtersalloutgoingSMTPconnections, forcontainment we use a previously published Kraken parser [7]. The
purposes. rewritten message parses correctly and has the STMP
To start, suppose that no proxy is in use. The C&C flagcorrectlymodified(settoone).
serversendsacommandtothebotorderingittotestits
abilitytosendspambyconnectingtoatestmailserver. 5.3 ReusingBinaryCodethatisnotanAssem-
Because the virtual environment blocks SMTP, the bot blyFunction
sendsareplytotheC&Cserverindicatingthatitcannot
send spam, and afterwards no more spam-related mes-
Next, we show that our approach enables reusing a
sagesarereceived.
binarycodefragmentthatdoesnotcorrespondtoacom-
Next, we repeat the experiment adding a network
plete assembly function, but has a clean interface and
proxy that acts as a man-in-the-middle on traffic be-
performs an independent task. We extract unpacking
tween the C&C server and the bot. For each message code from two versions of a trojan horse program Zbot
sentbythebot,theproxydecryptsitandchecksifitisa
used primarily to steal banking and financial informa-
messagethatitneedstorewrite. Whenthebotsendsthe
tion[20]. Zbotuses twonestedlayers ofpacking. The
message indicating that it has no SMTP capability, the
samples, provided to us by an external researcher, rep-
proxy,insteadofrelayingittotheC&Cserver,createsa
resent a typical task in the course of malware analysis:
differentmessageindicatingthattheSMTPtestwassuc-
theyhavealreadyhadonelayerofpackingremoved,and
cessful, encrypts it, and sends it to the C&C server in-
we have been provided the entry points for a second,
stead. (Itwouldnotbesufficientfortheproxytoreplay
morecomplex,unpackingroutine.
apreviousencryptedsuccessmessage,becausethemes-
The function prototype extracted by BCR is identi-
sage also includes a nonce value selected by the C&C
cal for both functions. It contains two pointer param-
serveratthebeginningofeachdialog.) Withtheproxy
eters: the ESI register points to an input-output buffer
inplace,thebotkeepsreceivingspam-relatedmessages,
containingpackeddataasinputandacountofthenum-
includingaspamtemplateandlistsofaddressestospam,
berofbytesunpackedasoutput,whiletheEDIregister
thoughitisunabletoactuallysendspam.
pointstoanoutputbufferforunpackeddata. SinceESI
and EDI are not used for parameter passing in any of
5.2 RewritingKraken’sC&CProtocol thestandardx86callingconventions,thissuggeststhese
functionswereoriginallywritteninassemblycode.
KrakenisaspambotnetthatwasdiscoveredonApril Although the prototypes are the same, the unpack-
2008andhasbeenthoroughlyanalyzed[2,5,6,12]. Pre- ing functions are not functionally equivalent; they both
viousanalysisuncoveredthatKraken(versions315and consist of two distinct loops, and we find that extract-
316)usesaproprietaryciphertoencryptitsC&Cproto- ing these loops separately captures more natural func-
colandthattheencryptionkeysarerandomlygenerated tional units. Examining the extracted function bodies,
by each bot and prepended to the encrypted message we find that both consist of two loops that are sepa-
sent over the network [5,12]. Researchers have manu- rated by pusha and popa instructions that save and
allyreverse-engineeredthedecryptionfunctionusedby restore processor state. Each loop makes its own pass
Krakenandprovidedcodetoreplicateit[5]. Inthispa- overthepackeddata,withthefirstpassapplyingasim-
per, we extract Kraken’s decryption function using our plerdecipheringbysubtractingahardcodedkey,andthe
automatic approach and verify that our extracted func- secondpassperformingamorecomplexinstruction-by-
tion is functionally equivalent to the one manually ex- instruction unpacking. After extracting the two loops
tractedinpreviouswork. Specifically,whentestingthe into separate functions, we verify that the differences
manually and automatically extracted function on mil- between the versions are only in the first loop: the ex-
lionsofrandominputs,wefindtheiroutputsarealways tractedversionofthesecondloopcanbereusedacross
thesame. Inaddition,weextractthecorrespondingen- thesampleversions. Thishighlightsthefactthataslong
cryptionfunctionandachecksumfunction,usedbythe asabinarycodefragmenthasacleaninterfaceandper-
bottoverifytheintegrityofthenetworkmessages. forms a well-separated task, it can be reused even if itdoesnotcorrespondtoacompletefunctionintheorigi- extracted function that uses ECX internally, the inter-
nalmachinecode. faceidentificationmoduleincorrectlyidentifiesECXas
a function output. Note that false positive parameters
5.4 Quantitative Summary of Function Ex- are not a serious problem for usability: extra outputs
traction can simply be ignored, and extra inputs do not change
theextractedfunction’sexecution.
Table 2 summarizes the extraction results for all
functionsmentionedinSection5.1throughSection5.3 5.5 Software-basedFaultIsolation
and some additional functions that we extract from the
OpenSSLlibraryforevaluationpurposes. TheGeneral Iftheextractedfunctionsaretobeusedinasecurity-
section of the table shows the number of function runs sensitive application, there is a danger that a malicious
intheexecutiontracesusedasinputtothefunctionex- extracted function could try to hijack or interfere with
traction step, and the total time needed to extract the theoperationoftheapplicationthatcallsit. Toprevent
function. The Code Extraction section has the number this,weusesoftware-basedfaultisolation(SFI)[45]as
of instructions in each extracted function, the number a lightweight mechanism to prevent the extracted code
of missed blocks and the number of indirect call and fromwritingtoorcallinglocationsintherestoftheap-
jumpinstructions. TheParameterIdentificationsection plication. SFIcreatesseparate“sandbox”dataandcode
showsthenumberofparametersintheCfunctionproto- regions for the extracted function, so that it can only
typeandthenumberoffalsepositives(e.g.,unnecessary write to its data region and it can only jump within its
parameters in the prototype) and false negatives (e.g., code region. SFI works by adding checks just before
missingparametersintheprototype). FortheOpenSSL each store or jump instruction, but the extracted code
functions,thefalsepositivesandnegativesaremeasured still runs in the same address space, so calls from the
bycomparisonwiththeoriginalCsourcecode. Forthe applicationarestillsimpleandefficient.
malware samples, no source is available, so we com- Specifically, we postprocess our extracted malware
parewithourbestmanualanalysisand(forKraken)with functionsusingPittSFIeld,animplementationofSFIfor
otherreportedresults. x86 assembly code [39]. PittSFIeld adds new instruc-
Theresultsshowthatasmallnumberofexecutionsis tions for checks, and to enforce additional alignment
enough to extract the complete function without miss- constraints to avoid overlapping instructions. Thus,
ing blocks or parameters. For samples without indi- BCR’s translation of jumps to use labels is necessary
rect jumps or calls, static disassembly recovers all ba- for it to work. PittSFIeld was previously implemented
sic blocks. For the samples with indirection, the dy- for use with the assembly code generated by GCC, so
namic information resolves the indirection and enables inordertoworkwithassemblycodethatcouldbegen-
thestaticdisassemblertofindalltheinstructionsinthe erated by other compilers or hand-written, we general-
function body. The Kraken checksum and MegaD en- ize it to save and restore the temporary register used in
cryptsamplesaresignificantlyslowertoextractthanthe sandboxed operations, and to not assume that EBP is
other samples. This is because they have larger num- alwaysapointertothestack. Wealsomakecorrespond-
ber of invocations of the dataflow-based pointer analy- ingchangestoPittSFIeld’sseparateverificationtool,so
sis technique, which dominates the running time. The ausercancheckthesafetyofanextractedfunctionwith-
parameteridentificationresultsshowthatnoparameters outtrustingthepersonwhoextractedit.
are missed: some runs do not identify all parameters,
but combining multiple executions (Section 3.2) gives
6 RelatedWork
completeresults. ForthefunctionsfromOpenSSL,the
parameters include fields in a context structure that is
Thissectioncomparesourapproachwiththemanual
passed to the functions via a pointer. There are two
processitaimstoreplace,techniquesforrelatedextrac-
false positives in the Kraken functions (i.e., extra pa-
tion problems in other domains, and some other tasks
rameters are identified), both of which are output pa-
thatrequiresimilaralgorithms.
rametersreportedasreturnedintheECXregister.These
arecausedbyacompileroptimization(performedbythe Manualcodeextraction. Codeextractionisacommon
Microsoft compiler, for instance) that replaces the in- activityinmalwareanalysis,butitisusuallyperformed
struction sub $4,%esp to reserve a location on the manually[5,6,30]. Whilethisprocesscangivetheana-
stack with the more compact instruction push %ecx, lystadeepunderstandingofthemaliciousfunctionality,
whichhasthesameeffectonthestackpointerandalso itisalsoverytime-consuming. Simpletoolsupportcan
copies a value from ECX that will later be overwrit- make some of the repetitive tasks more convenient [1],
ten. When this idiom occurs in the code following an but existing approaches still require specialized skills.General CodeExtraction ParameterIdentification
Function #Runs Run #Insn. #Missed #Indirect #Param. FP FN
time(sec) blocks call/jump
MegaDkeygen 4 3 320 0 0 3 0 0
MegaDencrypt 6 257 732 0 0 4 0 0
Krakenencrypt 2 16 66 0 0 7 1 0
Krakendecrypt 1 2 66 0 0 6 0 0
Krakenchecksum 1 179 39 0 0 4 1 0
Zbotv1151 2 15 98 0 0 2 0 0
Zbotv1652 2 17 93 0 0 2 0 0
MD5 Init 6 2 10 0 0 1 0 0
MD5 Update 6 38 110 0 1 3 0 0
MD5 Final 7 31 67 0 3 2 0 0
SHA1 Init 1 8 11 0 0 1 0 0
SHA1 Update 1 36 110 0 1 3 0 0
SHA1 Final 2 36 76 0 3 2 0 0
Table2.Evaluationresults. Atthetoparethefunctionsextractedduringtheend-to-endappli-
cationsandatthebottomsomeadditionalfunctionsextractedfromtheOpenSSLlibrary.
Ourapproachallowsthistasktobeautomated,whenall andstaticanalysistoextractthebodyofthecodefrag-
that is needed is to be able to execute the functionality ment we achieve better coverage than purely dynamic
inanothercontext. techniques.
Input-output relationship extraction. A variant on Otherapplicationsofinterfaceextraction. Jiangand
theextractionproblemisextractingtherelationshipbe- Su [34] investigate the problem of automatic interface
tween some given inputs and outputs of a computa- extractioninCsourcecode,toallowautomatedrandom
tion. To extract such relationships, previous work has testing for fragments with equivalent behavior. Their
usedsymbolicexecution[25,36]ordynamicbinaryslic- task of determining which variables constitute inputs
ing [36,37]. When the functionality to be extracted andoutputsofafragmentisrelatedtotheonewetackle
is sufficiently simple, it can be represented by a sin- inSection3,butmadeeasierbytheavailabilityoftype
gle input-output symbolic formula. For instance, such information. Extractingthecodeitselfisalsoeasierbe-
input-output formulas can be used for protocol dialog causeintheirscenariocodefragmentsarerestrictedby
replay[25],orasamalwaresignature[36]. However,a definitiontocontiguousstatements.
singleformulaisnotapracticalrepresentationformore Independently, Lin et al. [38] extract an interface to
complexfunctionalitythatincludesloopsorothervari- functionalityinabenignprograminordertoaddmali-
antcontrol-flowpaths,orusescomplexdatastructures. ciousfunctionality: forinstance,toturnanemailclient
intoaspam-sendingtrojanhorse. Becausethefunction-
Another alternative representation is a dynamic bi-
alityrunsinitsoriginalcontext,theirinterfaceneednot
nary slice that captures the instructions needed to pro-
cover allthe inputs andoutputs of thecode, only those
duce the output from the inputs in a given execution.
relevanttoaparticularuse. Usingtechniquessimilarto
Dynamic binary slices are usually generated by apply-
ouroutputinference,theyperformaside-effectanalysis
ingmodifiedversionsofdynamicprogramslicingtech-
to determine whether a function’s memory effects can
niques [21] on execution traces. For instance, Lanzi et
berevertedtohideitfromtherestofanexecution.
al. [37] produce dynamic binary slices using a combi-
nation of backwards and forward slicing, and use them Liveness analysis. The analyses that our tool per-
to analyze kernel malware. When it cannot extract an forms to identify input and output variables are the dy-
exactinput-outputsymbolicformula,themalwaremod- namicanaloguesofstaticdata-flowanalysesperformed
elingtoolofKolbitschetal.[36]combinesdynamicbi- bycompilers, suchaslivevariableandreachingdefini-
nary slicing with tainted scopes to capture control de- tionsanalysis[40].Someofthesamechallengesweface
pendencies. There are two main differences between have also been addressed in purely static tools such as
extracting input-output symbolic formulas or dynamic link-timeoptimizersthat,likeourtool,mustoperateon
binaryslicesand binarycodereuse. First, our problem binarycode. Forinstance,link-timeoptimizers[32,43]
ismoredifficultbecausetheinputsandoutputsmustbe must also exclude saves of callee-saved registers from
inferred. Second, by using a combination of dynamic theresultsofnaivelivenessanalysis.Binaryrewriting. Manyofthetechniquesrequiredfor tiallysupportedbytheNationalScienceFoundationun-
binarycodereuseareusedinbinaryrewritingandinstru- der Grants No. 0311808, No. 0448452, No. 0627511,
mentation applications. For instance, purely static dis- andCCF-0424422,bytheAirForceOfficeofScientific
assemblyprovidesinsufficientcoverageforevenbenign Research under Grant No. 22178970-4170, and by the
applicationsonWindows/x86platforms,sostate-of-the ArmyResearchOfficeundergrantDAAD19-02-1-0389.
artrewritingtoolsrequireahybridofstaticanddynamic Any opinions, findings, and conclusions or recommen-
disassembly [41] much as we do. Cifuentes and Van dationsexpressedinthismaterialarethoseoftheauthors
Emmerik [28] introduced the technique we adopt for anddonotnecessarilyreflecttheviewsoftheNational
locating the jump table statements used to implement Science Foundation, the Air Force Office of Scientific
switchstatements. Research,ortheArmyResearchOffice.
7 Conclusion References
Thispaperperformsthefirstsystematicstudyofau- [1] Codesnippetcreator.http://sharemation.com/
servil/idaplugs/csc-bin.zip.
tomatic binary code reuse, which we define as the pro-
[2] Dissecting the Kraken: An analysis of
cess of automatically identifying the interface and ex-
the kraken bonet’s obfuscation techniques.
tractingtheinstructionsanddatadependenciesofacode
http://www.securescience.net/blog/
fragmentfromanexecutableprogram,sothatitisself- kraken paper.pdf.
containedandcanbereusedbyexternalcode. [3] GCC inline assembly HOWTO. http:
We have proposed a novel technique to identify the //www.ibiblio.org/gferg/ldp/
prototype of an undocumented code fragment directly GCC-Inline-Assembly-HOWTO.html.
from the program’s binary, without access to its source [4] The IDA Pro disassembler and debugger. http://
www.hex-rays.com/idapro/.
code. We have designed an approach to automatically
[5] Kraken encryption algorithm. http:
extract a code fragment from a program binary so that
//mnin.blogspot.com/2008/04/
itisself-contained. Theextractedcodefragmentcanbe
kraken-encryption-algorithm.html.
runindependentlyoftherestoftheprogram’sfunction- [6] Kraken is finally cracked. http://
alityinanexternalCprogram,andcanbeeasilytested, blog.threatexpert.com/2008/04/
instrumented,orsharedwithotherusers. kraken-is-finally-cracked.html.
WehaveimplementedBCR,atoolthatusesourap- [7] Kraken wireshark dissector. http://www.mnin.
proach to automatically extract an assembly function
org/data/kraken/cli-dissector.rar.
[8] Marshal8e6 security threats: Email and Web threats.
from a program binary. We have used BCR to reuse
http://www.marshal.com/newsimages/
thecryptographicroutinesusedbytwospambotnetsin
trace/Marshal8e6 TRACE Report Jan2009.
a network proxy that can rewrite the malware’s C&C
pdf.
encryptedtraffic. Inaddition, wehaveextractedanun- [9] Marshal8e6 spam statistics for week ending septem-
packingfunctionfromatrojanhorseprogram,andhave ber 13, 2009. http://www.m86security.com/
shown that a code fragment belonging to that function TRACE/spam statistics.asp.
canbereusedbytheunpackingfunctionforadifferent [10] Microsoft developer network. http://msdn.
samplefromthesamefamily. Finally, wehaveapplied
microsoft.com.
[11] MSDN: Inline assembler. http://msdn.
software-basedfaultisolationtechniques[39]totheex-
microsoft.com/en-us/library/4ks26t93.
tractedfunctionstoensuretheycanbeusedsafelyeven
aspx.
thoughtheycomefromanuntrustedsource.
[12] Owning Kraken zombies, a detailed dissection.
http://dvlabs.tippingpoint.com/blog/
8 Acknowledgements 2008/04/28/owning-kraken-zombies.
[13] TEMU: The Bitblaze dynamic analysis component.
http://bitblaze.cs.berkeley.edu/temu.
We would like to specially thank Fabrice Desclaux html.
for providing us with the unpacking samples and for [14] ThreatExpert. http://threatexpert.com/
all his help with this project. We also thank Cedric reports.aspx.
BlancherandPhilippeBiondifortheirhelp. Finally,we [15] Titanengine. http://www.reversinglabs.
com/products/TitanEngine.php.
aregratefultoRolfRollesforhisvaluablecommentsto
[16] The undocumented functions: Microsoft windows
improvethismanuscript.
nt/2k/xp/2003. http://undocumented.
This work was performed while Juan Caballero was ntinternals.net/.
a visiting student researcher at University of Califor- [17] The unpacker archive. http://www.woodmann.
nia, Berkeley. This material is based upon work par- com/crackz/Tools/Unpckarc.zip.[18] Vine: TheBitblazestaticanalysiscomponent. http: [35] J.King. Symbolicexecutionandprogramtesting. Com-
//bitblaze.cs.berkeley.edu/vine.html. municationsoftheACM,19(7),1976.
[19] Virustotal. http://www.virustotal.com/. [36] C. Kolbitsch, P. M. Comparetti, C. Kruegel, E. Kirda,
[20] Zbot. http://www.f-secure.com/v-descs/ X.Zhou,andX.Wang. Effectiveandefficientmalware
trojan-spy w32 zbot hs.shtml. detectionattheendhost. InUSENIXSecuritySympo-
[21] H.AgrawalandJ.R.Horgan.Dynamicprogramslicing. sium,Montre´al,Canada,August2009.
ACMSIGPLANNotices,25(6),June1990. [37] A.Lanzi, M.Sharif, andW.Lee. K-Tracer: Asystem
[22] G. Balakrishnan and T. Reps. Analyzing memory ac- forextractingkernelmalwarebehavior. InNetworkand
cessesinx86executables. InInternationalConference DistributedSystemSecuritySymposium,SanDiego,CA,
on Compiler Construction, Barcelona, Spain, March February2009.
2004. [38] Z. Lin, X. Zhang, and D. Xu. Reuse-oriented camou-
[23] J. Caballero, S. McCamant, A. Barth, and D. Song. flaging attack: Vulnerability detection and attack con-
Extracting models of security-sensitive operations us- struction. TechnicalReportCERIAS-TR-2009-29,Pur-
ing string-enhanced white-box exploration on binaries. dueUniversity,November2009.
Technical Report UCB/EECS-2009-36, EECS Depart- [39] S. McCamant and G. Morrisett. Evaluating SFI for a
ment,UniversityofCalifornia,Berkeley,March2009. CISC architecture. In USENIX Security Symposium,
[24] J.Caballero, P.Poosankam, C.Kreibich, andD.Song. Vancouver,Canada,July2006.
Dispatcher: Enablingactivebotnetinfiltrationusingau- [40] S.S.Muchnick. AdvancedCompilerDesignandImple-
tomatic protocol reverse-engineering. In ACM Con- mentation. AcademicPress,1997.
ference on Computer and Communications Security, [41] S.Nanda,W.Li,L.-C.Lam,andT.Chiueh. BIRD:Bi-
Chicago,IL,November2009. naryinterpretationusingruntimedisassembly. InInter-
[25] J. Caballero and D. Song. Rosetta: Extracting proto- nationalSymposiumonCodeGenerationandOptimiza-
colsemanticsusingbinaryanalysiswithapplicationsto tion,NY,March2006.
protocol replay and NAT rewriting. Technical Report [42] R.Pang,V.Paxson,R.Sommer,andL.Peterson.binpac:
CMU-CyLab-07-014, Cylab, Carnegie Mellon Univer- Ayaccfor writingapplicationprotocolparsers. InIn-
sity,October2007. ternetMeasurementConference,RiodeJaneiro,Brazil,
[26] J.Caballero,H.Yin,Z.Liang,andD.Song. Polyglot: October2006.
Automaticextractionofprotocolmessageformatusing [43] B.Schwartz,S.Debray,G.Andrews,andM.Legendre.
dynamicbinaryanalysis. InACMConferenceonCom- PLTO:Alink-timeoptimizerfortheIntelIA-32archi-
puter and Communications Security, Alexandria, VA, tecture. InWorkshoponBinaryTranslation,Barcelona,
October2007. Spain,September2001.
[27] X. Chen, J. Andersen, Z. M. Mao, M. Bailey, [44] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager,
and J. Nazario. Towards an understanding of anti- M.G.Kang,Z.Liang,J.Newsome,P.Poosankam,and
virtualization and anti-debugging behavior in modern P.Saxena. BitBlaze: Anewapproachtocomputerse-
malware. In International Conference on Dependable curityviabinaryanalysis. InInternationalConference
SystemsandNetworks,Anchorage,AK,June2008. onInformationSystemsSecurity,Hyderabad,India,De-
[28] C. Cifuentes and M. V. Emmerik. Recovery of jump cember2008. Keynoteinvitedpaper.
tablecasestatementsfrombinarycode. InInternational [45] R.Wahbe,S.Lucco,T.E.Anderson,andS.L.Graham.
WorkshoponProgramComprehension, Pittsburgh, PA, Efficient software-based fault isolation. In Symposium
May1999. onOperatingSystemsPrinciples,Asheville,NC,Octo-
[29] W. Cui, V. Paxson, N. C. Weaver, and R. H. Katz. ber1993.
Protocol-independentadaptivereplayofapplicationdi- [46] Z. Wang, X. Jiang, W. Cui, and X. Wang. ReFormat:
alog. InNetworkandDistributedSystemSecuritySym- Automatic reverse engineering of encrypted messages.
posium,SanDiego,CA,February2006. In European Symposium on Research in Computer Se-
[30] F.DesclauxandK.Kortchinsky. VanillaSkypepart1. curity,Saint-Malo,France,September2009.
InReCon,2006. [47] G. Wondracek, P. M. Comparetti, C. Kruegel, and
[31] P.Godefroid, M.Y.Levin, andD.Molnar. Automated E.Kirda. Automaticnetworkprotocolanalysis. InNet-
whitebox fuzz testing. In Network and Distributed work and Distributed System Security Symposium, San
System Security Symposium, San Diego, CA, February Diego,CA,February2008.
2008.
[32] D.W.Goodwin. Interproceduraldataflowanalysisinan
executableoptimizer. InSIGPLANConferenceonPro-
gramming Language Design and Implementation, Las
Vegas,ND,June1997.
[33] I.Guilfanov. Asimpletypesystemforprogramreengi-
neering. In Working Conference on Reverse Engineer-
ing,Stuttgart,Germany,October2001.
[34] L. Jiang and Z. Su. Automatic mining of functionally
equivalentcodefragmentsviarandomtesting. InInter-
national Symposium on Software Testing and Analysis,
Chicago,IL,July2009.