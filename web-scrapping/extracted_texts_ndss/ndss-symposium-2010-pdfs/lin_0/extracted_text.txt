Automatic Reverse Engineering of Data Structures from Binary Execution
ZhiqiangLin XiangyuZhang DongyanXu
DepartmentofComputerScienceandCERIAS
PurdueUniversity,WestLafayette,IN
{zlin,xyzhang,dxu}@cs.purdue.edu
Abstract will help locate specific information of interest (e.g., IP
addresses)inamemorycoredumpwithoutsymbolicinfor-
With only the binary executable of a program, it is mation; In binary vulnerability discovery, this knowledge
useful to discover the program’s data structures and infer will help construct a meaningful view of in-memory data
theirsyntacticandsemanticdefinitions. Suchknowledgeis structure layout and identify those semantically associated
highlyvaluableinavarietyofsecurityandforensicapplica- withexternalinputforguidedfuzztesting.
tions. Althoughthereexisteffortsinprogramdatastructure Despite the usefulness of automatic data structure re-
inference, the existing solutions are not suitable for our verse engineering, solutions that suit our targeted applica-
targeted application scenarios. In this paper, we propose tion scenarios fall short. First, a large body of work on
a reverse engineering technique to automatically reveal type inference [29, 3, 13, 33, 32, 24] requires program
program data structures from binaries. Our technique, sourcecode. Second,inthebinary-onlyscenario,variables
called REWARDS, is based on dynamic analysis. More are mapped to low-level entities such as registers and
specifically,eachmemorylocationaccessedbytheprogram memory locations with no syntactic information, which
istaggedwithatimestampedtypeattribute. Followingthe makes static analysis difficult. In particular, alias analysis
program’s runtime data flow, this attribute is propagated ishardatbinarylevelwhileitisessentialtotypeinference
to other memory locations and registers that share the – especially semantics inference – because precise data
same type. During the propagation, a variable’s type gets flowcannotbedecidedwithoutaccuratealiasinformation.
resolvedifitisinvolvedinatype-revealingexecutionpoint Variable discovery [5] is a static, binary level technique
or “type sink”. More importantly, besides the forward that recovers syntactic characteristics of variables, such as
type propagation, REWARDS involves a backward type a variable’s offset in its activation record, size, and hier-
resolution procedure where the types of some previously archical structure. This technique relies on alias analysis
accessedvariablesgetrecursivelyresolvedstartingfroma and abstract interpretation at binary level and is hence
typesink. Thisprocedureisconstrainedbythetimestamps heavy-weight. Moreover,duetotheconservativenatureof
ofrelevantmemorylocationstodisambiguatevariablesre- binary alias analysis, the technique does not infer variable
usingthesamememorylocation. Inaddition,REWARDSis semantics. More recently, Laika [16] aims at dynamically
able to reconstruct in-memory data structure layout based discoveringthesyntaxofobservabledatastructuresthrough
on the type information derived. We demonstrate that unsupervisedmachinelearningonprogramexecution. The
REWARDS provides unique benefits to two applications: accuracy of this technique, however, may fall below the
memoryimageforensicsandbinaryfuzzingforvulnerabil- expectation of our applications. It does not consider data
itydiscovery. structure semantics either. The limitations of these efforts
motivate us to develop new techniques for our targeted
applicationscenarios.
1 Introduction In this paper, we propose a reverse engineering scheme
to automatically reveal program data structures from bi-
naries. Our technique, called REWARDS1, is based on
A desirable capability in many security and forensics
dynamic analysis. Given a binary executable, REWARDS
applicationsisautomaticreverseengineeringofdatastruc-
executesthebinary,monitorstheexecution,aggregatesand
tures given only the binary. Such capability is expected to
analyzes runtime information, and finally recovers both
identifyaprogram’sdatastructuresandrevealtheirsyntax
the syntax and semantics of data structures observed in
(e.g., size, structure, offset, and layout) and semantics
the execution. More specifically, each memory location
(e.g.,“thisintegervariablerepresentsaprocessID”).Such
knowledgeaboutprogramdatastructuresishighlyvaluable. 1REWARDSistheacronymforReverseEngineeringWorkforAuto-
For example, in memory-based forensics, this knowledge maticRevelationofDataStructures.accessed by the program is tagged with a timestamped semantic information from the memory dump of a binary
type attribute. Following the program’s runtime data flow, program. In binary fuzzing for vulnerability discovery,
this attribute ispropagated to other memory addresses and REWARDS helps identifying vulnerability “suspects” in a
registers that share the same type in a forward fashion, binaryforguidedfuzzingandconfirmation.
i.e., the execution direction. During the propagation, a
variable’s type gets resolved if it is involved in a type- 2 REWARDSOverview
revealing execution point or “type sink” (e.g., a system
call,astandardlibrarycall,oratype-revealinginstruction).
REWARDS infers both syntax and semantics of data
Besidesleveragingtheforwardtypepropagationtechnique,
structures from binary execution. More precisely, we aim
to expand the coverage of program data structures, RE-
atreverseengineeringthefollowinginformation:
WARDSinvolvesthefollowingkeytechniques:
• Data types. We first aim to infer the primitive data
• Anon-linebackwardtyperesolutionprocedurewhere
types of variables, such as char, short, float,
the types of some previously accessed variables get
and int. In a binary, the variables are located in
recursively resolved starting from a type sink. Since
varioussegmentsofthevirtualaddressspace,suchas
many variables are dynamically created and de-
.stack, .heap, .data, .bss, .got, .rodata,
allocated at runtime, and the same memory location
.ctors, and.dtorssections. (Althoughwefocus
maybere-usedbydifferentvariables,itiscomplicated
on ELF binary on Linux platform, REWARDS can
to track and resolve variable types based on memory
be easily ported to handle PE binary on Windows.)
locations alone. Hence, we constraint the resolution
Hence, our goal is essentially to annotate memory
process by the timestamps of relevant memory loca-
locations in these data sections with types and sizes,
tions such that variables sharing the same memory
following program execution. For our targeted appli-
location in different execution phases can be disam-
cations, REWARDS also infers composite types such
biguated.
assocketaddressstructuresandFILEstructures.
• Anoff-lineresolutionprocedurethatcomplementsthe
• Semantics. Moreover, we aim to infer the semantics
on-lineprocedure. Somevariablescannotberesolved
(meaning) of program variables, which is critical to
during their lifetime by our on-line algorithm. How-
applicationssuchascomputerforensics. Forexample,
ever,theymaylatergetresolvedwhenothervariables
in a memory dump, we want to decide if a 4-byte
havingthesametypeareresolved. Hence,wepropose
integerdenotesanIPaddress.
an off-line backward resolution procedure to resolve
thetypesofsome“dead”variables.
• Abstractrepresentation. Althoughwetypememory
locations, it is undesirable to simply present typed
• A method for typed variable abstraction that maps
memory locations to the user. During program ex-
multiple typed variable instances to the same static
ecution, a memory location may be used by multi-
abstraction. For example, all N nodes in a linked
ple variables at different times; and a variable may
listactuallysharethesametype, insteadofhavingN
have multiple instances. Hence we derive an abstract
distincttypes.
representation for a variable by aggregating the type
• Amethodthatreconstructsthestructuralandsemantic informationatmultiplememorylocationsinstantiated
view of in-memory data, driven by the derived type based on the same variable. For example, we use the
definitions. Once a program’s data structures are offset of a local variable in its activation record as its
identified, it is still not clear exactly how the data abstractrepresentation. Typeinformationcollectedin
structures would be laid out in memory – this is a all activation records of the same function is aggre-
useful piece of knowledge in many application sce- gatedtoderivethetypeofthevariable.
nariossuchasmemoryforensics. Ourmethodcreates
an“organizationchart”thatillustratesthehierarchical Givenonlythebinary, whatcanbeobservedatruntime
layoutofthosedatastructures. from each instruction includes (1) the addresses accessed
and the width of the accesses, (2) the semantics of the in-
WehavedevelopedaprototypeofREWARDSandused struction,and(3)theexecutioncontextsuchastheprogram
it to analyze a number of binaries. Our evaluation results counterandthecallstack. Insomecases,datatypescanbe
show that REWARDS is able to correctly reveal the types partiallyinferredfrominstructions. Forexample,afloating
of a high percentage of variables observed during a pro- pointinstruction(e.g.,FADD)impliesthattheaccessedlo-
gram’sexecution. Furthermore,wedemonstratetheunique cationsmusthavefloatingpointnumbers. Wealsoobserve
benefitsofREWARDStoavarietyofapplicationscenarios: that the parameters and return values of standard library
In memory image forensics, REWARDS helps recovering callsandsystemcallsoftenhavetheirsyntaxandsemantics1 struct { 1 extern foo 1 80480a0: e8 0f 00 00 00 call 0x80480b4
2 unsigned int pid; 2 section .text 2 80480a5: b8 01 00 00 00 mov $0x1,%eax
3 char data[16]; 3 global _start 3 80480aa: bb 00 00 00 00 mov $0x0,%ebx
4 }test; 4 4 80480af: cd 80 int $0x80
5 5 _start: 5 ...
6 void foo(){ 6 call foo 6 80480b4: 55 push %ebp
7 char *p="hello world"; 7 mov eax,1 7 80480b5: 89 e5 mov %esp,%ebp
8 test.pid=my_getpid(); 8 mov ebx,0 8 80480b7: 83 ec 18 sub $0x18,%esp
9 strcpy(test.data,p); 9 int 80h 9 80480ba: c7 45 fc 18 81 04 08 movl $0x8048118,0xfffffffc(%ebp)
10 } 10 80480c1: e8 4a 00 00 00 call 0x8048110
11 80480c6: a3 24 91 04 08 mov %eax,0x8049124
(a) Source code of function foo and the _start assembly code 12 80480cb: 8b 45 fc mov 0xfffffffc(%ebp),%eax
13 80480ce: 89 44 24 04 mov %eax,0x4(%esp)
14 80480d2: c7 04 24 28 91 04 08 movl $0x8049128,(%esp)
[Nr] Name Type Addr Off Size 15 80480d9: e8 02 00 00 00 call 0x80480e0
... 16 80480de: c9 leave
[ 1] .text PROGBITS 080480a0 0000a0 000078 17 80480df: c3 ret
[ 2] .rodata PROGBITS 08048118 000118 00000c 18 80480e0: 55 push %ebp
[ 3] .bss NOBITS 08049124 000124 000014 19 80480e1: 89 e5 mov %esp,%ebp
... 20 80480e3: 53 push %ebx
21 80480e4: 8b 5d 08 mov 0x8(%ebp),%ebx
(c) Section map of the example binary 22 80480e7: 8b 55 0c mov 0xc(%ebp),%edx
23 80480ea: 89 d8 mov %ebx,%eax
24 80480ec: 29 d0 sub %edx,%eax
rodata_0x08048118{ fun_0x08048110{ 25 80480ee: 8d 48 ff lea 0xffffffff(%eax),%ecx
+00: char[12] +00: ret_addr_t 26 80480f1: 0f b6 02 movzbl (%edx),%eax
} } 27 80480f4: 83 c2 01 add $0x1,%edx
bss_0x08049124{ 28 80480f7: 84 c0 test %al,%al
+00: pid_t, fun_0x080480e0{ 29 80480f9: 88 04 0a mov %al,(%edx,%ecx,1)
+04: char[12], -08: unused[4], 30 80480fc: 75 f3 jne 0x80480f1
+16: unused[4] -04: stack_frame_t, 31 80480fe: 89 d8 mov %ebx,%eax
} +00: ret_addr_t, 32 8048100: 5b pop %ebx
fun_0x080480b4{ +04: char*, 33 8048101: 5d pop %ebp
-28: unused[20], +08: char* 34 8048102: c3 ret
-08: char *, } 35 ...
-04: stack_frame_t, 36 8048110: b8 14 00 00 00 mov $0x14,%eax
+00: ret_addr_t 37 8048115: cd 80 int $0x80
} 38 8048117: c3 ret
(d) Output of REWARDS (b) Disassembly code of the example binary
Figure1.AnexampleshowinghowREWARDSworks
welldefinedandpubliclyknown. Hencewedefinethetype world”), ebp-4 can be typed as a pointer, based on the
revealinginstructions,systemcalls,andlibrarycallsastype heuristicsthatinstructionexecutionsusingsimilarimmedi-
sinks.Furthermore,theexecutionofaninstructioncreatesa atevalueswithinacodeordatasectionareconsideredtype
dependencybetweenthevariablesinvolved. Forinstance,if sinks. Note that the type of the pointer is unknown yet.
avariablewitharesolvedtype(fromatypesink)iscopied Atline10,foocalls0x8048110. Insidethebodyofthe
to another variable, the destination variable should have a function invocation (lines 36-38), our algorithm detects a
compatibletype. Assuch,wemodelourproblemasatype getpidsystemcall(atypesink)witheaxbeing0x14at
informationflowproblem. line36. Thereturnvalueofthefunctioncallisresolvedas
pid t type, i.e., register eax at line 11 is typed pid t.
To illustrate how REWARDS works, we use a simple
When eax is copied to address 0x8049124 (a global
program compiled from the source code shown in Figure
variable in .bss section as shown in Figure 1(c)), the
1(a). According to the code snippet, the program has a
algorithmfurtherresolves0x8049124aspid t. Before
global variable test (line 1-4) which consists of an int
the function call 0x80480e0 at line 15 (strcpy), the
and a char array. It contains a function foo (line 6-
parameters are initialized in lines 12-14. As ebp-4 has
10) that calls my getpid and strcpy to initialize the
been typed as a pointer at line 9, the data flow in lines 12
globalvariable. Thefulldisassembledcodeoftheexample
and 13 dictates that location esp+4 at line 13 is a pointer
is shown in Figure 1(b) (a dotted line indicates a “NOP”
aswell. Atline14,as0x8049128isintheglobalvariable
instruction). The address mapping of code and data is
sectionandofaknowntype,locationesphasanunknown
showninFigure1(c).
pointer type. At line 15, upon the call to strcpy (a
Whenfooiscalledduringexecution,itfirstsavesebp type sink), both esp and esp+4 are resolved to char*.
and then allocates 0x18 bytes of memory for the local Through a backward transitive resolution, 0x8049128 is
variables (line 8 in Figure 1(b)), and then initializes one resolvedaschar,ebp-4aschar*,and0x8048118as
localvariable(ataddress0xfffffffc(%ebp)=ebp-4) char.Alsoatline26,insidethefunctionbodyofstrcpy,
with an immediate value 0x8048118 (line 9). Since theinstruction“movzbl (%edx),%eax”canbeusedas
0x8048118 is in the address range of the .rodata anothertypesinkasitmovesbetweencharvariables.
section(itisactuallythestartingaddressofstring“helloWhen the program finishes, we resolve all data types systemcallreturns,REWARDSwilltyperegistereaxand,
(including function arguments, and those implicit vari- fromthere,thosehavingthesametypeaseax. Inourtype
ables such as return address and stack frame pointer) propagation and resolution algorithm (Section 3.2), a type
as shown in Figure 1(d). The derived types for vari- sink will lead to the recursive type resolution of relevant
ables in .rodata, .bss and functions are presented variablesaccessedbeforeandafterthetypesink.
in the figure. Each function is denoted by its entry
Standard library calls. With well-defined API, standard
address. fun 0x080480b4, fun 0x08048110, and
librarycallsareanothercategoryoftypesink. Forexample,
fun 0x080480e0 denote foo(), my getpid(), and
strcpy(), respectively. The number before each de-
thetwoargumentsofstrcpymustbothbeofthechar*
type. By intercepting library function calls and returns,
rived type denotes the offset. Variables are listed in in-
REWARDS will type the registers and memory variables
creasing order of their addresses. Type stack frame t
involved. Standardlibrarycallstendtoproviderichertype
indicates a frame pointer stored at that location. Type
information than system calls – for example, Linux-2.6.15
ret addr t means that the location holds a return ad-
has 289 system calls whereas libc.so.6 contains 2016
dress. Such semantic information is useful in applica-
functions(notesomelibrarycallswrapsystemcalls).
tions such as vulnerability fuzz. Locations that are not
accessedduringexecutionareannotatedwiththeunused
Type-revealing instructions. A number of machine in-
type. In fun 0x080480e0, the two char* below
structionsthatrequireoperands ofspecific types can serve
the ret addr t represent the two actual arguments of
as type sinks. Examples in x86 are as follows: (1)
strcpy(). Although it seems that our example can be
String instructions perform byte-string operations such as
staticallyresolvedduetoitssimplicity,itisverydifficultin
moving/storing (MOVS/B/D/W, STOS/B/D/W), loading
practice to analyze data flows between instructions (espe-
(LOADS/B/D/W),comparison(CMPS/B/D/W),andscan-
cially those involving heap locations) due to the difficulty
ning (SCAS/B/D/W). Note that MOVZBL is also used in
ofbinarypoints-toanalysis.
string movement. (2) Floating-point instructions oper-
ate on floating-point, integer, and binary coded decimal
3 REWARDSDesign operands(e.g. FADD,FABS,andFST).(3)Pointer-related
instructions reveal pointers. For a MOV instruction with
In this section, we describe the design of REWARDS. an indirect memory access operand (e.g., MOV (%edx),
We first identify the type sinks used in REWARDS and %ebx or MOV [mem], %eax), the value held in the
then present the on-line type propagation and resolution source operand must be a pointer. Meanwhile, if the
algorithm,whichwillbeenhancedbyanoff-lineprocedure target address is within the range of data sections such as
thatrecoversmorevariabletypesnotreportedbytheon-line .stack,.heap,.data,.bssor.rodata,thepointer
algorithm.Finally,wepresentamethodtoconstructatyped must be a data pointer; If it is in the range of .text
hierarchicalviewofmemorylayout. (including library code), the pointer must be a function
pointer. Note that the concrete type of such a pointer will
3.1 TypeSinks beresolvedthroughotherconstraints.
A type sink is an execution point of a program where
3.2 Online Type Propagation and Resolution Al
the types (including semantics) of one or more variables
gorithm
can be directly resolved. In REWARDS, we identify three
categories of type sinks: (1) system calls, (2) standard
librarycalls,and(3)type-revealinginstructions. Given a binary program, our algorithm reveals variable
System calls. Most programs request OS services via types,includingbothsyntactictypes(e.g.,intandchar)
systemcalls. Sincesystemcallconventions andsemantics and semantics (e.g., return address), by propagating
are well-defined, the types of arguments of a system call and resolving type information along the data flow during
are known from the system call’s specification. By moni- program execution. Each type sink encountered leads
toringsystemcallinvocationsandreturns,REWARDScan to both direct and transitive type resolution of variables.
determinethetypesofparametersandreturnvalueofeach More specifically, at the binary level, variables exist in
system call at runtime. For example, in Linux, based on eithermemorylocationsorregisterswithouttheirsymbolic
thesystemcallnumberinregistereax,REWARDSwillbe names. Hence, the goal of our algorithm is to type these
abletotypetheparameter-passingregisters(i.e.,ebx,ecx, memory addresses and registers. We attach three shadow
edx, esi, edi, andebp, iftheyareusedforpassingthe variables–asthetypeattribute–toeachmemoryaddress
parameters). From this type sink, REWARDS will further at byte granularity (registers are treated similarly): (1)
type those variables that are determined to have the same Constraint set is a set of other memory addresses that
type as the parameter passing registers. Similarly, when a should have the same type as this address; (2) Type setstores the set of resolved types of the address2, including a set of <address, timestamp> tuples each representing a
both syntactic and semantic types; (3) Timestamp records variable instance that should have the same type as v; its
thebirthtimeofthevariablecurrentlyinthisaddress. For typesetT representstheresolvedtypesforv;andthebirth
v
example, the timestamp of a stack variable is the time timeofthecurrentvariableinstanceisdenotedasts .
v
when its residence method is invoked and the stack frame
1. If the current execution point i is a type sink (line
is allocated. Timestamps are needed because the same
3). The arguments/operands/return value of the sink
memoryaddressmaybereusedbymultiplevariables(e.g.,
willbedirectlytypedaccordingtothesink’sdefinition
the same stack memory being reused by stack frames of
(Get Sink Type() on line 5)3. Type resolution is
different method invocations). More precisely, a variable
then triggered by calling the recursive method Back-
instanceshouldbeuniquelyidentifiedbyatuple<address,
ward Resolve(). The method recursively types all
timestamp>. These shadow variables are updated during
variablesthatshouldhavethesametype(lines32-36):
programexecution,dependingonthesemanticsofexecuted
Ittestsifeachvariablewintheconstraintsetofv has
instructions.
been resolved as type T of v. If not, it recursively
calls itself to type all the variables that should have
Algorithm1On-lineTypePropagationandResolution
the same type as w. Note that at line 34, it checks if
1: /*Sv: constraintsetformemorycell(orregister)v;Tv: typesetofv;tsv:
(birth)timestampofv;MOV(v,w):movingvtow;BINOP(v,w,d):abinary the current birth timestamp of w is equal to the one
operationthatcomputesdfromvandw;GetSinkType(v,i): retrievingthe stored in the constraint set to ensure the memory has
type of argument/operand v from the specification of sink i; ALLOC(v,n):
allocatingamemoryregionstartingfromvwithsizen–thememoryregion not been re-used by a different variable. If w is re-
maybeastackframeoraheapstruct;FREE(v,n):freeingamemoryregion– used (t 6= ts ), the algorithm does not resolve the
thismaybecausedbyeliminatingastackframeorde-allocatingaheapstruct*/ w
2: Instrument(i){ currentw.Instead,theresolutionisdonebyadifferent
3: caseiisaTypeSink: off-line procedure (Section 3.3). Since variable types
4: for eachoperandv
5: T←GetSinkType(v,i) areresolvedaccordingtoconstraintsderivedfromdata
6: BackwardResolve(v,T) flows in the past, we call this step backward type
7: caseihasindirectmemoryaccessoperando
8: To←To∪{pointertypet} resolution.
9: caseiisMOV(v,w):
10: ifwisaregister 2. If i contains an indirect memory access operand o
11 21 :: TS ww ←← TS vv (line 7), either through registers (e.g., using (%eax)
13: else to access the address designated by eax) or memory
14: Unify(v,w)
15: caseiisBINOP(v,w,d): (e.g., using [mem] to indirectly access the memory
16: ifpointertypet∈Tv pointed to by mem), then the corresponding operand
17: Unify(d,v)
18: BackwardResolve(w,{int,pointerindext}) willhaveapointertypetag(pointer type t)asa
19: else newelementinT .
20: Unify3(d,v,w) o
21: caseiisALLOC(v,n): 3. If i is a move instruction (line 9), there are two cases
22: fort=0ton−1
23: tsv+t←currenttimestamp to consider. In particular, if the destination operand
24: Sv+t←φ w is a register, then we just move the properties (i.e.,
25: Tv+t←φ
26: caseiisFREE(v,n): theS v andT v)ofthesourceoperandtothedestination
27: fort=0ton−1
(i.e.,theregister);otherwiseweneedtounifythetypes
28: a←v+t
29: if(Ta)log(a,tsa,Ta) of the source and destination operands because the
30: log(a,tsa,Sa)
destination is now a memory location that may have
31: }
32: BackwardResolve(v,T){ already contained some resolved types. The intuition
33: for<w,t>∈Sv isthatthesourceoperandvshouldhavethesametype
34: if(T 6⊂Twandt≡tsw)BackwardResolve(w,T-Tw)
35: Tv←Tv∪T as the destination operand w if the destination is a
36: } memory address. Hence, the algorithm calls method
37: Unify(v,w){
38: BackwardResolve(v,Tw-Tv) Unify()tounifythetypesofthetwo. InUnify()(lines
39: BackwardResolve(w,Tv-Tw)
37-42),thealgorithmfirstunionsthetwotypesetsby
40: Sv←Sv∪{<w,tsw>}
41: Sw←Sw∪{<v,tsv>} performing backward resolution at lines 38 and 39.
42: } Intuitively,thecallatline38meansthatifthereareany
newtypesinT thatarenotinT (i.e. T -T ),those
w v w v
The algorithm is shown in Algorithm 1. The algorithm new types need tobe propagated tov and transitively
takesappropriateactionstoresolvetypesontheflyaccord- toallvariablesthatsharethesametypeasv,mandated
ingtotheinstructionbeingexecuted. Foramemoryaddress byv’sconstraintset.Suchunificationisnotperformed
oraregisterv, itsconstraintsetisdenotedasS v, whichis ifthewisaregistertoavoidover-aggregation.
2Weneedasettostoretheresolvedtypesbecauseonevariablemay 3The sink’s definition also reveals the semantics of some argu-
havemultiplecompatibletypes. ments/operands,e.g.,aPID.4. If i is a binary operation, the algorithm first tests if 10 matches ts l1, indicating the same variable is still alive.
an operand has been identified as a pointer. If so, it Transitively,thevariablesinS l1,i.e.g1andl2,areresolved
mustbeapointerarithmeticoperation,thedestination tothesametype. Notethatifthebackwardresolutionwas
must have the same type as the pointer operand and not conducted, we would not be able to resolve the type
the other operand must be a pointer index – denoted ofl2becausewhenthemovefroml1tol2(timestamp12)
by a semantic type pointer index t (line 18). occurred,l1wasnottypedandhencel2wasnottyped.
The semantic type is useful in vulnerability fuzz to
overflow buffers. If i is not related to pointers, the 3.3 Off lineTypeResolution
threeoperands shallhave thesametype. Themethod
Unify3() unifies three variables. It is very similar to Most variables accessed during the binary’s execution
Unify()andhencenotshown.Notethatincaseswhere can be resolved by our online algorithm. However, there
the binary operation implicitly casts the type of some arestillsomecasesinwhich,whenamemoryvariablegets
operand (e.g., an addition of a float and an integer), freed (and its information gets emitted to the log file), its
theunificationinducesover-approximation(e.g.,asso- typeisstillunresolved.Werealizethattheremaybeenough
ciating the float point type with the integer variable). information from later phases of the execution to resolve
In practice, we consider such cases reasonable and those variables. We propose an off-line procedure to be
allow multiple types for one variable as long as they performed after the program execution terminates. It is
arecompatible. essentially an off-line version of the Backward Resolve()
method in Algorithm 1. The difference is that it has to
5. Ifiallocatesamemoryregion(line21)–eitherastack
traversethelogfiletoperformtherecursiveresolution.
frameoraheapstruct,thealgorithmupdatesthebirth
Consider the example in Table 2. It shares the same
timestampsofallthebytesintheregion,andresetsthe
execution as the example in Table 1 before timestamp 13.
memoryconstraintset(S )andtypeset(T )toempty.
v v At time instance 13, the execution returns from M, de-
By doing so, we prevent the type information of the allocating the local variables l1 and l2. According to the
old variable instance from interfering with that of the
online algorithm, their constraint sets are emitted to a log
newinstanceatthesameaddress.
file since neither is typed at that point. Later at timestamp
99, another method N is called. Assume it reuses l1 and
6. If i frees a memory region (line 26), the algorithm
l2,namely,N allocatesitslocalvariablesatthelocationsof
traverseseachbyteintheregionandprintsoutthetype
l1 and l2. The birth time of l1 and l2 becomes 99. Their
information. Inparticular,ifthetypesetisnotempty,
type sets and constraint sets are reset. When the sink is
it is emitted. Otherwise, the constraint set is emitted.
encounteredat100,l1andl2arenottypedastheircurrent
Later, the emitted constraints will be used in the off-
lineprocedure(Section3.3)toresolvemorevariables.
birth timestamp is 99, not 10 as in S g1, indicating they
are re-used by other variables. Fortunately, the variable
representedby<l1,10>canbefoundinthelogandhence
Example. Table 1 presents an example of executing our
resolved. Transitively,<l2,10>canberesolvedaswell.
algorithm. The first column shows the instruction trace
withthenumbersdenotingtimestamps. Theothercolumns
3.4 TypedVariableAbstraction
show the type sets and the constraint sets after each in-
struction execution for three sample variables, namely the
global variable g1 and two local variables l1 and l2. For Ouralgorithmisabletoannotatememorylocationswith
syntax and semantics. However, multiple variables may
brevity, we abstract the calling sequence of strcpy to a
occupy the same memory location at different times and
strcpyinstruction. AftertheexecutionentersmethodM
a static variable may have multiple instances at runtime4.
attimestamp10,thelocalvariablesareallocatedandhence
bothl1andl2havethebirthtimeof10. Theglobalvariable Henceitisimportanttoorganizetheinferredtypeinforma-
g1hasthebirthtimeof0.Afterthefirstmovinstruction,the tion according to abstract, location-independent variables
typesetsofg1andl1areunified. Sinceneitherwastyped, other than specific memory locations. In particular, prim-
theunifiedtypesetremainsempty. Moreover, l1, together itive global variables are represented by their offsets to
with its birth time 10, is added to the constraint set of g1 the base of the global sections (e.g., .data and .bss
sections). Stackvariablesareabstractedbytheoffsetsfrom
and vice versa, denoting they should have the same type.
their residence activation record, which is represented by
Similaractions aretakenafterthesecond movinstruction.
Here, the constraint set of l1 has both g1 and l2. The thefunctionname(asshowninFigure1).
strcpy invocation is a type sink and g1 must be of type Forheapvariables,weusetheexecutioncontext,i.e.,the
PC (instruction address) of the allocation point of a heap
char*,thealgorithmperformsthebackwardresolutionby
calling Backward Resolve(). In particular, the variable in 4Alocalvariablehasthesamelifetimeofamethodinvocationanda
S g1, i.e. l1, is typed to char*. Note that the timestamp methodcanbeinvokedmultipletimes,givingrisetomultipleinstances.instruction Tg1 Sg1 tsg1 Tl1 Sl1 tsl1 Tl2 Sl2 tsl2
10.enterM φ φ 0 φ φ 10 φ φ 10
11.movg1,l1 φ {<l1,10>} 0 φ {<g1,0>} 10 φ φ 10
12.movl1,l2 φ {<l1,10>} 0 φ {<g1,0>, <l2,10>} 10 φ {<l1,10>} 10
... ... ... ... ... ... ... ... ... ...
100.strcpy(g1,...) {char*} {<l1,10>} 0 {char*} {<g1,0>, <l2,10>} 10 {char*} {<l1,10>} 10
Table1.Exampleofrunningtheonlinealgorithm. Variableg1isaglobal,l1andl2arelocals.
instruction Tg1 Sg1 tsg1 Tl1 Sl1 tsl1 Tl2 Sl2 tsl2
... ... ... ... ... ... ... ... ... ...
12.movl1,l2 φ {<l1,10>} 0 φ {<g1,0>, <l2,10>} 10 φ {<l1,10>} 10
13.ExitM φ {<l1,10>} 0 φ {<g1,0>, <l2,10>} 10 φ {<l1,10>} 10
... ... ... ... ... ... ... ... ... ...
99.EnterN φ {<l1,10>} 0 φ φ 99 φ φ 99
100.strcpy(g1,...) {char*} {<l1,10>} 0 φ φ 99 φ φ 99
Table2.Exampleofrunningtheoff linetyperesolutionprocedure. Theexecutionbeforetimestamp
12isthesameasTable1. MethodN reusesl1andl2
structureplusthecallstackatthatpoint,astheabstraction corresponding children. If a variable is a pointer, the
of the structure. The intuition is that the heap structure algorithmfurtherrecursivelyconstructsthesub-viewofthe
instancesallocatedfromthesamePCinthesamecallstack datastructurebeingpointedto,leveragingthederivedtype
should have the same type. Fields of the structure are ofthepointer. Forinstance,assumeaglobalpointerpisof
represented by the allocation site and field offsets. As an typeT*,ourmethodcreatesanoderepresentingtheregion
allocated heap region may be an array of a data structure, pointed to by p. The region is typed based on the reverse
weusetherecursiondetectionheuristicsin[9]todetectthe engineereddefinitionofT.Therecursiveprocessterminates
array size. Specifically, the array size is approximated by whennoneofthefieldsofadatastructureisapointer.Stack
themaximumnumberofaccessesbythesamePCtounique is similarly handled: A root node is created to represent
memory locations in the allocated region. The intuition is each activation record. Local variables of the record
that array elements are often accessed through a loop in are denoted as children nodes. Recursive construction is
the source code and the same instruction inside the loop performed until all memory locations through pointers are
bodyoftenaccessesthesamefieldacrossallarrayelements. traversed. Notethatallliveheapstructurescanbereached
Finally,ifheapstructuresallocatedfromdifferentsiteshave (transitively) through a global pointer or a stack pointer.
thesamefieldtypes,wewillheuristicallyclustertheseheap Hence, the above two steps essentially also construct the
structuresintooneabstraction. structuralviewsofliveheapdata.
Our method can also type some of the unreachable
memory regions, which represent “dead” data structures,
3.5 Constructing Hierarchical View of In
e.g., activation records of previous method invocations
MemoryDataStructureLayout
whose space has been freed but not reused. Such dead
data is as important as live data as they disclose what had
An important feature of REWARDS is to construct a
happened in the past. In particular, our method scans the
hierarchicalviewofamemorysnapshot,inwhichtheprim-
stack beyond the current activation record to identify any
itivesyntaxofindividualmemorylocations,aswellastheir
pointers to the code section, which often denote return
semanticsandtheintegratedhierarchicalstructurearevisu-
addressesofmethodinvocations. Withareturnaddress,the
allyrepresented.Thisishighlydesirableinapplicationslike
functioninvocationcanbeidentifiedandwecanfollowthe
memoryforensicsasinterestingqueries,e.g.,“find all
aforementionedstepstotypetheactivationrecord.
IP addresses”, can be easily answered by traversing
the view (examples in Section 5.1). So far, REWARDS 4 ImplementationandEvaluation
is able to reverse engineer the syntax and semantics of
datastructures,representedbytheirabstractions. Next,we WehaveimplementedREWARDSonPIN-2.6[27],with
present how we leverage such information to construct a 12.1K lines (LOC) of C code and 1.2K LOC of Python
hierarchicalview. code. Inthefollowing,wepresentseveralkeyimplementa-
Ourmethodworksasfollows. Itfirsttypesthetoplevel tiondetails.REWARDSisabletorevealvariablesemantics.
global variables. In particular, a root node is created to In our implementation, variable semantics are represented
represent a global section. Individual global variables are asspecialsemantictagscomplementarytoregulartypetags
represented as children of the root. Edges are annotated suchasintandchar.Bothsemantictagsandregulartags
with offset, size, primitive type, and semantics of the are stored in the variable’s type set. Tags are enumeratedto save space. The vast diversity of program semantics 4.1 EvaluationofAccuracy
makes it infeasible to consider them all. Since we are
mainlyinterestedinforensicsandsecurityapplications,we
To evaluate the reverse engineering accuracy of RE-
focusonthefollowingsemantictags:(1)filesystemrelated
WARDS,wecomparethederiveddatastructuretypeswith
(e.g., FILE pointer, file descriptor, file name, file status);
those declared in the program source code. To acquire
(2)networkcommunicationrelated(e.g.,socketdescriptor,
the oracle information, we recompile the programs with
IP address, port, receiving and sending buffer, host info,
debugging information, and then use libdwarf [1] to
msghdr);and(3)operatingsystemsrelated(e.g.,PID,TID,
extracttypeinformationfromthebinaries.Thelibdwarf
UID,systemtime,systemname,anddeviceinfo).
libraryiscapableofpresentingthestackandglobalvariable
Meanwhile, we introduce some of our own semantic mappings after compilation. For instance, global variables
tags, suchasret addr tindicatingthatamemoryloca- scattering in various places in the source code will be
tionisholdingareturnaddress,stack frame tindicat- organizedintoafewdatasections.Thelibraryallowsussee
ingthatamemorylocationisholdingastackframepointer, the organization. In particular, libdwarf extracts stack
format string t indicating that a string is used in variables by presenting the mapping from their offsets in
formatstringargument,andmalloc arg tindicatingan the stack frame and the corresponding types. For global
argumentofmallocfunction(similarly,calloc arg t variables, the output by libdwarf is program virtual
forcallocfunction,etc.). Notethatthesetagsreflectthe addresses and their types. Such information allows us to
propertiesofvariablesatthosespecificlocationsandhence conduct direct and automated comparison. Note that we
donotparticitateinthetypeinformationpropagation. They onlyverifythetypesin.data,.bss,and.rodatasec-
can bring important benefits to our targeted applications tions,otherglobaldatainsectionssuchas.got,.ctors
(Section5). are not verified. For heap variables, since we use the
execution context at allocation sites as the abstract repre-
REWARDSneedstoknowtheprogram’saddressspace
sentation, given an allocation context, we can locate it in
mapping, which will be used to locate the addresses of
thedisassembledbinary,andthencorrelateitwithprogram
global variables and detect pointer types. In particular,
source code to identify the heap data structure definition,
REWARDS checks the target address range when deter-
andfinallycompareitwithREWARDS’soutput. Although
mining if a pointer is a function pointer or a data pointer.
REWARDS extracts variable types for the entire program
Thus, when a binary starts executing with REWARDS,
address space (including libraries), we only compare the
we first extract the coarse-grained address mapping from
resultsforuser-levelcode.
the /proc/pid/maps file, which defines the ranges of
The result for stack variables is presented in Figure
code and data sections including those from libraries, and
2(a). The figure presents the percentage of (1) functions
the ranges of stack and heap (at that time). Then for
that are actually executed, (2) data structures that are used
each detailed address mapping such as .data, .bss and
in the executed functions (over all structures declared in
.rodata for all loaded files (including libraries), we
those functions), and (3) data structures whose types are
extract the mapping using the API provided by PIN when
accuratelyrecoveredbyREWARDS(overthosein(2)). At
thecorrespondingimagefileisloaded.
runtime, it is often the case that even though a buffer is
We have performed two sets of experiments to evaluate
defined in the source code with size n, only part of the
REWARDS: one is to evaluate its correctness, and the
n bytes are used. Consequently, only those used ones are
other is to evaluate its time and space efficiency. All
typed(theothersareconsideredunused).Weconsiderthe
the experiments were conducted on a machine with two
bufferiscorrectlytypedifitsbytesareeithercorrectlytyped
2.13GhzPentiumprocessorsand2GBRAMrunningLinux
or unused. From the figure, we can observe that, due to
kernel2.6.15.
the nature of dynamic analysis, not all functions or data
We select 10 widely used utility programs from the structures in a function are exercised and hence amenable
following packages: procps-3.2.6 (with 19.1K LOC and toREWARDS.Moreimportantly, REWARDSachievesan
containing command ps), iputils-20020927 (with 10.8K average of 97% accuracy (among these benchmarks) for
LOCandcontainingcommandping),net-tools-1.60(with the data structures that get exercised. For heap variables,
16.8K LOC and containing netstat), and coreutils- theresultispresentedinFigure2(b),thebarsaresimilarly
5.93 (with 117.5K LOC and containing the remaining test defined.REWARDS’soutputperfectlymatchesthetypesin
commands such as ls, pwd, and date). The reason theoriginaldefinitionswhentheyareexercised. Notesome
for selecting these programs is that they contain many ofthebenchmarksaremissinginFigure2(b)(e.g., date)
datastructuresrelatedtotheoperatingsystemandnetwork becausetheirexecutionsdonotallocateanyuser-levelheap
communications. We run these utilities without command structures. The result for global variables is presented in
lineoptionexceptping,whichisrunwithalocalhostand Figure2(c),andREWARDSachievesover85%accuracy.
apacketcount4option. ToexplainwhyREWARDScannotachieve100%accu-120
100
80
60
40
20
0
ps ping netstat ls pwd date upti
me
una
me
users hostna
me
egatnecreP
Dynamically Executed Funs
Dynamically Exposed Types
REWARDS Accuracy
Benchmark Program
(a) AccuracyonStackVariables
120
100
80
60
40
20
0
ps ping netstat ls uptime users hostname
egatnecreP
Dynamically Allocated Types
Dynamic Ra Elly W E Ax Re Drc Sis e Ad c cT uy rp ae cys 100
80
60
40
20
0
ps ping netstat ls pwd date uptime uname users hostname
Benchmark Program
(b) AccuracyonHeapVariables
egatnecreP
Dynamically Exercised Types
REWARDS Accuracy
Benchmark Program
(c) AccuracyonGlobalVariables
400
350
300
250
200
150
100
50
0
ps ping netstat ls pwd date uptime uname users hostname
)sdnoces(
emiT
noitucexE
6e+07
REWARDS
MemTrace
Normal Execution
5e+07
4e+07
3e+07
2e+07
1e+07
0
ps ping netstat ls pwd date uptime uname users hostname
Benchmark Program
(d) PerformanceOverhead
)setyb(
noitpmusnoC
yromeM
wodahS
REWARDS
Benchmark Program
(e) SpaceOverhead
Figure2.EvaluationresultsforREWARDSaccuracyandefficiencyracy,wecarefullyexaminedthebenchmarksandidentified 5 ApplicationsofREWARDS
thefollowingtworeasons:
REWARDScanbeappliedtoanumberofapplications.
• Hierarchy loss. If a hierarchical structure becomes
In this section, we demonstrate how REWARDS provides
flat after compilation, we are not able to identify its
unique benefits to (1) memory image forensics and (2)
hierarchy. This happens to structures declared as
binaryvulnerabilityfuzz.
global variables or stack variables. And the binary
never accesses such a variable using the base address
5.1 MemoryImageForensics
plus a local offset. Instead, it directly uses a global
offset(startingfromthebaseaddressoftheglobaldata
section or a stack frame). In other words, multiple Memory image forensics is a process to extract mean-
compositestructuresareflattenedintoonelargestruc- ingful information from a memory dump. Examples of
ture. In contrast, such flattening does not happen to suchinformationareIPaddressesthattheapplicationunder
heapstructures. investigation is talking to and files being accessed. Data
structure definitions play a critical role in the extraction
• Path-sensitive memory reuse. This often happens process. For instance, without data structure information,
to stack variables. In particular, the compiler might it is hard to decide if four consecutive bytes represent an
assign different local variables declared in different IP address or just a regular value. REWARDS enables
program paths to the same memory address. As a analyzing memory dumps for a binary without symbolic
result, the types of these variables are undesirably information. In this subsection, we demonstrate how RE-
unifiedinourcurrentdesign. Amorethoroughdesign WARDS can be used totype reachable memory as wellas
woulduseapath-sensitivelocaloffsettodenoteastack someoftheunreachable(i.e.,dead)memory.
variable.
5.1.1 TypingReachableMemory
Despite the imperfect accuracy, REWARDS still suits
our targeted application scenarios, i.e., memory forensics Inthiscasestudy,wedemonstratehowweuseREWARDS
and vulnerability fuzzing. For example, although RE- to discover IP addresses from a memory dump using the
WARDS outputs a flat layout for all global and stack hierarchical view (Section 3.5). We run a web server
variables,wecanstillconductvulnerabilityfuzzingbecause nullhttpd-0.5.1. A client communicates with this
theabsoluteoffsetsofthesevariablesaresufficient;andwe server through wget (wget-1.10.2). The client has
canstillconstructhierarchicalviewsofmemoryimagesas IP 10.0.0.11 and the server has IP 10.0.0.4. The
pointertypescanbeobtained. memory dump is obtained from the server at the moment
whenasystemcallisinvokedtoclosetheclientconnection.
4.2 EvaluationofEfficiency PartofthememorydumpisshowninFigure3. TheIPsare
underlinedinthefigure. Fromthememorydump,itisvery
We also measured the time and space overhead of hard for human inspectors to identify those IPs without a
REWARDS. We compared it with (1) a standard memory meaningful view of the memory. We use REWARDS to
trace tool, MemTrace (shipped along with PIN-2.6) and derive the data structure definitions for nullhttpd and
(2) the normal execution of the program, to evaluate the then construct a hierarchical view of the memory dump
performanceoverhead. TheresultisshowninFigure2(d). followingthemethoddescribedinSection3.5.
Notethenormalexecutiondataisnearlynotvisibleinthis Therelevantpartofthereconstructedviewispresented
figurebecausetheyareverysmall(roughlyatthe0.01sec- in Figure 4(a). The root represents a pointer variable in
ond level). We can observe that REWARDS causes slow- the global section. The outgoing edge of the root leads
down in the order of ten times compared with MemTrace, to the data structure being pointed to. The edge label
and in the order of thousands (or tens of thousands) times “struct 0x0804dd4f *” denotes that this is a heap
comparedwiththenormalexecution. data structure whose allocation PC (also its abstraction)
For space overhead, we are interested in the space con- is 0x0804dd4f. According to the view construction
sumption by shadow type sets and constraint sets. Hence, method, the memory region being pointed to is typed
we track the peak value of the shadow memory consump- according to the derived definition of the data structure
tion. The result is shown in Figure 2(e). We can observe denotedby0x0804dd4f,resultinginthesecondlayerin
thattheshadowmemoryconsumptionisaround10Mbytes Figure4(a). Thememoryregionstartsat0x08052170is
forthesebenchmarks. Aspecialcaseisping,whichuses denotedbythenodewiththeaddresslabel. Theindividual
muchlessmemory. Thereasonisthatithasfewerfunction child nodes represent the different fields of the structure,
calls and memory allocations, which is also why it runs e.g. the first field is a thread id according to the semantic
muchfasterthantheotherprogramsshowninFigure2(d). tagpthread t,thefourthfield(withoffset+12)denotes...
08052170 b0 5b fe b7 b0 5b fe b7 05 00 00 00 02 00 92 7e 080534a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
08052180 0a 00 00 0b 00 00 00 00 00 00 00 00 c7 b0 af 4a *
08052190 c7 b0 af 4a 00 00 00 00 58 2a 05 08 00 00 00 00 08053910 00 00 00 00 00 00 00 00 57 67 65 74 2f 31 2e 31
080521a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08053920 30 2e 32 00 00 00 00 00 00 00 00 00 00 00 00 00
... 08053930 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
08052a50 00 00 00 00 59 31 01 00 4b 65 65 70 2d 41 6c 69 *
08052a60 76 65 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08053990 00 00 00 00 00 00 00 00 c8 00 00 00 00 00 00 00
08052a70 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 080539a0 00 00 00 00 00 00 00 00 00 00 43 6c 6f 73 65 00
* 080539b0 00 00 00 00 00 00 00 00 00 00 00 00 52 00 00 00
08052ee0 00 00 00 00 00 00 00 00 00 00 00 00 31 30 2e 30 080539c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
08052ef0 2e 30 2e 34 00 00 00 00 00 00 00 00 00 00 00 00 *
08052f00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08053a90 48 54 54 50 2f 31 2e 30 00 00 00 00 00 00 00 00
* 08053aa0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
08052fe0 00 00 00 00 00 00 00 00 00 00 00 00 48 54 54 50 *
08052ff0 2f 31 2e 30 00 00 00 00 00 00 00 00 00 00 00 00 08053b20 74 65 78 74 2f 68 74 6d 6c 00 00 00 00 00 00 00
08053000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08053b30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
* *
08053470 00 00 00 00 00 00 00 00 00 00 00 00 31 30 2e 30 08063ba0 01 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
08053480 2e 30 2e 31 31 00 00 00 00 00 00 00 00 00 00 00 08063bb0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
08053490 47 45 54 00 00 00 00 00 2f 00 00 00 00 00 00 00 *
...
Figure3.Partofamemorydumpfromnull httpd
a sockaddr structure. The last field (with offset +40) correctly identified and its composition bytes are either
denotes another heap structure whose allocation site is correctlytypedorunused.
0x0804ddfb. Transitively, our method reconstructs the
entirehierarchy.
5.1.2 TypingDeadMemory
The extraction of IP addresses is translated into a
traversal over the view to identify those with the IP ad- In this case, we demonstrate how to type dead memory,
dress semantic tags. Along the path 08050260 → i.e., memory regions containing dead variables, using the
08052170 → 7e9200...0 → 0x0b0000a , slapperwormbot-masterprogram. Slapperwormrelieson
a variable with the sin addr type can be identified, P2Pcommunications.Thebot-masterusesaprogramcalled
which stores the client IP. The same IP can also be iden- pudclient to control the P2P botnet, such as launching
tified along the path 08050260 → 08052170 → TCP-flood,UDP-flood,andDNS-floodattacks. Ourgoalis
to extract evidence from a memory dump of pudclient
08052a58 → 10.0.0.11 , with the field offset
fromtheattacker’smachine.
+2596. The field has the ip addr str t tag, which is
Ourexperimenthastwoscenes: theinvestigator’sscene
resolved at the return of a call to inet ntoa(). RE-
andtheattacker’sscene. Morespecifically,
WARDS is able to isolate the server IP 10.0.0.4 as a
string along the path 08050260 → 08051170 →
• SceneI:Inthelab,theinvestigatorrunsthebot-master
10.0.0.4 with the field offset +1172. Interestingly,
program pudclient to communicate with slapper
this field does not have a semantic tag related to an IP
botstoderivethedatastructuresofpudclient.
address. Thereasonisthatthefieldissimplyapartofthe
request string (the host field in HTTP Request Message),
• SceneII:Inthewild,theattackerrunspudclientto
butitisnotusedinanytypesinksthatcanresolveitasanIP.
controlrealslapperbots.
However,isolatingthestringalsoallowsahumaninspector
toextractitasanIP.
In Scene I, we run a number of slapper worm in-
To validate our result, we present in Figure 4(b) the stances in a contained environment (at IP addresses rang-
corresponding symbolic definitions extracted from the ing from 10.0.0.1 - 10.0.1.255). Then we launch
source for comparison. Fields that are underlined are pudclient with REWARDS and issue a series of
used during execution. In particular, struct CONNECTION commands such as listing the compromised hosts, and
corresponds to the abstraction struct 0x0804dd4f launching the UDPFlood, TCPFlood, and DNSFlood at-
(node 08052170 ) and struct CONNDATA corresponds tacks. REWARDSextractsthedatastructuredefinitionsfor
tostruct 0x0804ddfb(node 08052a58 ). Observe pudclient. TheninSceneII,werunpudclientagain
thatallfieldsofCONNECTIONarepreciselyderived,except without REWARDS. Indeed, the attacker’s machine does
thepointerPostData,whichisrepresentedasanunused nothaveanyforensicstoolrunning. Emulatingtheattacker,
arrayintheinferreddefinitionbecausethefieldisnotused weissuesomecommandsandthenhibernatethemachine.
during execution. For the CONNDATA structure, all the Wethengetthememoryimageofpudclientandusethe
exercised fields are extracted and correctly typed. Recall datastructureinformationderivedinSceneItoinvestigate
that we consider a field is correctly typed if its offset is theimage.+0(cid:9)pthread_t
b7fe5bb0
+4(cid:9)int b7fe5bb0 sin_family 0002
+8(cid:9)socket 00000005 sin_port 7e92
+12(cid:9)struct sockaddr 7e920002 0b00000a 0...0 s si in n_ _a zd erd or 0b00000a
08050260 struct _0x0804dd4f * 08052170 +28(cid:9)time_t
4aafb0c7 0...0
+32(cid:9)time_t
+0(cid:9)char [11]
4aafb0c7 Keep−Alive
+36(cid:9)unused [4]
+11(cid:9)unused [1161]
00000000 0...0
+40(cid:9)struct _0x0804ddfb *
+1172(cid:9)char [9]
10.0.0.4
+1181(cid:9)unused [247]
0...0
+1428(cid:9)char [9] 180 typedef struct {
HTTP/1.0 181 pthread_t handle;
182 unsigned long int id;
+1437(cid:9)unused [1159] 183 short int socket;
0...0 184 struct sockaddr_in ClientAddr;
185 time_t ctime; // Creation time
+2596(cid:9)ip_addr_str_t 186 time_t atime; // Last Access time
10.0.0.11 187 char *PostData;
188 CONNDATA *dat;
+2606(cid:9)unused [10] 0...0 189 } CONNECTION;
+2616(cid:9)char [4] GET 206 CONNECTION *conn; //matched the root node
+2620(cid:9)unused [4] 00000000 143 typedef struct {
144 // incoming data
145 char in_Connection[16];
+2624(cid:9)char [2] / 146 int in_ContentLength;
147 char in_ContentType[128];
148 char in_Cookie[1024];
+2626(cid:9)unused [1150] 0...0
149 char in_Host[64];
150 char in_IfModifiedSince[64];
+3776(cid:9)char [12] Wget/1.10.2 151 char in_PathInfo[128];
08052a58 +3788(cid:9)unused [116] 0...0 152 char in_Protocol[16];
+3904(cid:9)short int 153 char in_QueryString[1024];
154 char in_Referer[128];
+3906(cid:9)unused [16] 00c8
155 char in_RemoteAddr[16];
156 int in_RemotePort;
+3922(cid:9)char [6] 0...0
157 char in_RequestMethod[8];
+3928(cid:9)unused [12] Close 158 char in_RequestURI[1024];
159 char in_ScriptName[128];
0...0 160 char in_UserAgent[128];
+3940(cid:9)int
161 // outgoing data
00000052 162 short int out_status;
+3944(cid:9)unused [208] 163 char out_CacheControl[16];
0...0 164 char out_Connection[16];
+4152(cid:9)char [9]
HTTP/1.0 165 int out_ContentLength;
166 char out_Date[64];
+4161(cid:9)unused [135] 167 char out_Expires[64];
0...0 168 char out_LastModified[64];
+4296(cid:9)char [10] 169 char out_Pragma[16];
text/html
+4306(cid:9)unused [65654] 170 char out_Protocol[16];
171 char out_Server[128];
0...0
+69960(cid:9)(cid:9)short int
172 char out_ContentType[128];
0001 173 char out_ReplyData[MAX_REPLYSIZE];
+69962(cid:9)(cid:9)short int
174 short int out_headdone;
0001 175 short int out_bodydone;
+69964(cid:9)(cid:9)short int 176 short int out_flushed;
0001
177 // user data
+69966(cid:9)(cid:9)unused [8192] 178 char envbuf[8192];
0...0 179 } CONNDATA;
(a) HierarchicalviewfromREWARDS (b) Datastructuredefinition
Figure4.ComparisonbetweentheREWARDS derivedhierarchicalviewandsourcecodedefinitionbfffd140 05 00 00 00 6b 00 00 00 69 00 00 00 00 00 00 00 bfffe5d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
bfffd150 00 00 00 00 38 ea ff bf 00 00 00 00 00 00 00 01 bfffe5e0 00 00 00 00 00 00 00 00 00 00 00 00 e0 f5 ff bf
bfffd160 2c 00 00 00 67 45 8b 6b 0e 00 00 00 00 00 00 00 bfffe5f0 a0 2d 05 08 e0 f5 ff bf a0 13 05 08 00 00 00 00
bfffd170 0a 00 00 63 0f 27 00 00 9f 86 01 00 9f 86 01 00 bfffe600 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
bfffd180 1c ea ff bf 10 ea ff bf 6a f2 b2 4a 7a 4a 0e 00 *
bfffd190 22 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 bfffea00 00 00 00 00 00 00 00 00 00 00 00 00 10 ea ff bf
bfffd1a0 6a f2 b2 4a 7a 4a 0e 00 f2 f3 8d 8c 00 00 00 00 bfffea10 01 00 00 00 00 00 00 00 e5 de f2 49 46 00 00 00
bfffd1b0 00 00 00 00 00 00 00 00 01 00 00 00 02 00 00 00 bfffea20 67 45 8b 6b 10 00 00 00 e8 be e6 71 0a 00 00 34
bfffd1c0 64 6e 73 66 6c 6f 6f 64 00 00 00 00 00 00 00 00 bfffea30 0a 00 01 33 0a 00 00 0b 0a 00 00 04 00 00 00 00
bfffd1d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 bfffea40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
* *
bfffd5c0 c0 d1 ff bf 00 00 00 00 02 ca 04 08 00 00 00 00 ...
bfffd5d0 00 00 00 00 00 00 00 00 02 ca 04 08 02 ca 04 08 bffff5c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
bfffd5e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 bffff5d0 01 00 00 00 80 00 00 00 80 00 00 00 ff f7 ff bf
bfffd5f0 00 00 00 00 00 00 00 00 00 00 00 00 04 d6 ff bf bffff5e0 00 00 00 00 00 00 00 00 f3 f7 ff bf 67 45 8b 6b
bfffd600 64 6e 73 66 6c 6f 6f 64 00 00 00 00 00 00 00 00 bffff5f0 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
bfffd610 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 bffff600 01 00 00 00 c0 f6 ff bf 28 f6 ff bf fb c7 04 08
* bffff610 02 00 00 00 dc 3a 1f b6 d4 df 04 08 dc 3a 1f b6
bfffe5b0 00 00 00 00 00 00 00 00 0e 00 00 00 00 00 00 00 bffff620 00 00 00 00 dc 3a 1f b6 88 f6 ff bf a2 de 0d b6
bfffe5c0 00 00 00 00 02 00 4e 34 0a 00 00 0b 00 00 00 00 bffff630 02 00 00 00 b4 f6 ff bf c0 f6 ff bf f6 5b ff b7
Figure5.MemorydumpforSlapperwormcontrolprogramwhenexitingthecontrolinterface
WeconstructthehierarchicalviewandtrytoidentifyIP vulnerability candidate. Vulnerability-specific patterns are
addresses from the view. However, the hierarchical view followed during mutation. One example pattern is to
can only map the memory locations that are alive, namely exponentially expand an input string in the lineage of a
theyarereachablefromglobalandstack(pointer)variables. candidate buffer with the goal of generating an overflow
Here, we take an extra step to type the dead (unreachable) exploit. In that project, we had difficulty finding publicly
data. As described in Section 3.5, our technique scans available, binary-level vulnerability detectors to use as the
the stack space lower than the current (the lowest and frontend. REWARDShelpsaddressthisissuebyderiving
live) activation record and looks for values that are in the both variable syntax and semantics from a subject binary.
range of the code section, as they are very likely return Next, we present our experience of using REWARDS to
addresses. Four such values are identified. One example identify vulnerability suspects and then using our prior
and its memory context is shown in Figure 5. In this system(afuzzer)toconfirmthem.
memory dump snippet, the return address, as underlined, For this study, we design a static vulnerability suspect
islocatedataddress0xbffff62c. Ourtechniquefurther detectorthatreliesonthevariabletypeinformationderived
identifies that the corresponding function invocation is to by REWARDS. The result of the detector is passed to our
0x0804a708. Hence,weusethedatastructuredefinition lineage-basedfuzzertogenerateexploits. Inthefollowing,
of fun 0x0804a708 to type the activation record. The wepresenthowREWARDShelpsidentifyvarioustypesof
definition and the typed values are shown in Table 3. vulnerabilitysuspects.
ObservethatanumberofIPs(fieldswithip addr t)are
• Buffer overflow vulnerability. Buffer overflows
identified. We also spot the bot command “dnsflood”
could happen in three different places: stack, heap,
at-9324and-8236. Notethatthesetwofieldshavethe
and global areas. As such, we define three types of
input t tag as part of their derived definition, indicating
buffer overflow vulnerability patterns. Specifically,
theyholdvaluesfrominput.
for stack overflow, if a stack layout contains a buffer
and its content comes from user input, we consider
5.2 VulnerabilityFuzz
it a suspect. Note that this can be easily facilitated
by REWARDS’s typing algorithm: A semantics tag
It is a challenging task to detect and confirm vulner- input t is defined to indicate that a variable re-
abilities in a given binary without symbolic information. ceives its value from external input. The tag is only
Previously in [26], we have proposed a dynamic analysis susceptible to the forward flow but not the backward
approach that can decide if a vulnerability suspect is true flow. In the stack layout derived by REWARDS, if
positive by generating a concrete exploit. The basic idea a buffer’s type set contains an input t tag, it is
is to first use existing static tools to identify vulnerability consideredvulnerable. Forheapoverflow,weconsider
candidates, which are often of large quantity; then benign two cases: one is to exploit heap management data
executions are mutated to generate exploits. Mutations structure outside the user-allocated heap chunk; and
are directed by dynamic information called input lineage, the other is to exploit user-defined function pointers
which denotes the set of input elements that is used to inside the heap chunk. Detecting the former case is
compute a value at a given execution point, usually a simply to check if a heap structure contains a bufferOffset Type Size MemAddr Content Offset Type Size MemAddr Content
-9432 void* 4 bfffd154 38 ea ff bf -9324 char[9],inputt 9 bfffd1c0 64 6e..64
-9428 char* 4 bfffd158 00 00 00 00 -8300 char* 4 bfffd5c0 c0 d1 ff bf
-9420 int 4 bfffd160 2c 00 00 00 -8236 char[9],inputt 9 bfffd600 64 6e..64
-9416 int 4 bfffd164 67 45 8b 6b -8227 char[28] 28 bfffd609 00 .. 00
-9412 int 4 bfffd168 0e 00 00 00 -4236 void* 4 bfffe5a0 00 00 00 00
-9408 int 4 bfffd16c 00 00 00 00 -4156 struct0x804834e* 4 bfffe5f0 a0 2d 05 08
-9404 ipaddrt 4 bfffd170 0a 00 00 63 -4152 void* 4 bfffe5f4 e0 f5 ff bf
-9300 portt 4 bfffd174 0f 27 00 00 -3104 char* 4 bfffea0c 10 ea ff bf
-9396 int 4 bfffd178 9f 86 01 00 -3088 char[16] 16 bfffea1c 46 00 00 00
-9392 int 4 bfffd17c 9f 86 01 00 -3068 ipaddrt 4 bfffea30 0a 00 01 33
-9388 void* 4 bfffd180 1c ea ff bf -3064 ipaddrt 4 bfffea34 0a 00 00 0b
-9384 void* 4 bfffd184 10 ea ff bf -3058 ipaddrt 4 bfffea38 0a 00 00 04
timeval.tvsec 4 bfffd18c 7a 4a 0e 00 -3054 ipaddrt 4 bfffea3c 0a 00 00 04
-9376 timeval.tvusec 4 bfffd190 22 00 00 00 -0088 int 4 bffff5d4 80 00 00 00
-9368 int 4 bfffd194 00 00 00 00 -0084 int 4 bffff5d8 80 00 00 00
-9352 int 4 bfffd1a4 7a 4a 0e 00 -0080 int 4 bffff5dc ff f7 ff bf
-9348 int 4 bfffd1a8 f2 f3 8d 8c -0004 stackframet 4 bffff628 88 f6 ff bf
-9344 int 4 bfffd1ac 00 00 00 00 +0000 retaddrt 4 bffff62c a2 de 0d b6
-9332 int 4 bfffd1b8 01 00 00 00 +0004 int 4 bffff630 02 00 00 00
-9328 int 4 bfffd1bc 02 00 00 00 +0008 char* 4 bffff634 b4 f6 ff bf
Table3.Resultontheunreachablememorytypeusingtypefun 0x804a708
field that is input-relevant, in a way similar to stack Program #BufferOverflow #IntegerOverflow #FormatString
ncompress-4.2.4 1 0 0
vulnerabilitydetection. Forthelatercase,thedetector
bftpd-1.0.11 3 0 0
scans the derived layout of a heap structure to check gzip-1.2.4 3 0 0
thepresenceofbothaninput-relevantbufferfieldand nullhttpd-0.5.0 5 2 0
xzgv-5.8 3 8 0
a function pointer field. Vulnerabilities in the global gnuPG-1.4.3 0 3 0
memoryregionarehandledsimilarly. ipgrab-0.9.9 0 5 0
cfingerd-1.4.3 4 0 1
ngircd-0.8.2 12 0 1
• Integer overflow vulnerability. Integer overflow oc-
curswhenanintegerexceedsthemaximumvaluethat Table 4. Number of vulnerability suspects
a machine can represent. Integer overflow itself may reportedwithhelpofREWARDS
not be harmful (e.g., gcc actually leverages integer
overflow to manipulate control flow path condition
[38]), but if an integer variable is dependent on user
thedistancebetweenavulnerablestackbufferandareturn
input without any sanity check and it is used as an
argumenttomalloc-familyfunctions,thenaninteger address, i.e., a variable with the ret addr t tag, in
order to construct a stack overflow exploit. Similarly, it
overflow vulnerability is likely. In particular, over-
is important to know the distance between a heap buffer
flowedvaluespassedtomallocfunctionsusuallyresult
andaheapfunctionpointerforcomposingaheapoverflow-
in heap buffers being smaller than they are supposed
based code injection attack. Such information is provided
to be. Consequently, heap overflows occur. For this
byREWARDS.
type of vulnerabilities, our detector checks the actual
arguments to malloc family function invocations: if We applied our REWARDS-based detector to examine
an integer parameter has both malloc arg t and severalprogramsshowninthe1st columnofTable4. The
input t tags, an integer overflow vulnerability sus- detector reported a number of vulnerable suspects based
pectwillbereported. on the aforementioned vulnerability patterns. The total
number of vulnerabilities of each type is presented in the
• Format string vulnerability. The format string vul- remaining columns. Observe that our detector does not
nerability pattern involves a user input flowing into produce many suspects for these programs and hence can
a format string argument. Thus, we introduce a serveasatractablefrontendforourfuzzer. Thefuzzerthen
semantics tag format string t, which is only tries to generate exploits to convict the suspects. Details
resolved at invocations to printf-family functions. of each confirmed vulnerable data structure is shown in
If a variable’s type set contains both input t and the 2nd column of Table 5. The field symbols do not
format string t tags, a format string vulnerabil- representtheirsymbolicnames,whichwedonotknow,but
itysuspectisreported. rather the type tags derived for these fields. For instance,
format string t denotes that the field is essentially
Besides facilitating vulnerability suspect identification, a format string; sockaddr in indicates that the field
the information generated by REWARDS can also help holdsasocketaddress. The3rd columnpresentstheinput
composing exploits. For instance, it is critical to know category that is relevant to the vulnerable data structure.Benchmark SuspiciousDataStructure Input Offset VulnerabilityType
fun0x08048e76{ -1052:char[13],
-1039:unused[1023],...
-0008:char*,
ncompress-4.2.4 -0004:stackframet, argv[1] {0..11} Stackoverflow
+0000:retaddrt,
+0004:char**}
fun0x080494b8{ -0064:char*,
-0060:char[12],
-0048:unused [44],
bftpd-1.0.11 -0004:stackframet, recv {0..3} Stackoverflow
+0000:retaddrt,
+0004:char*}
bss0x08053f80{...
+244128:char[8],
gzip-1.2.4 +244136:unused[1016], argv[1] {0..6} Globaloverflow
+245152:char*,...}
heap0x0804f205{ +0000:char[11],
+0011:unused[5], recv {607,608} Integeroverflow
nullhttpd-0.5.0 +0016:int,...}
heap0x0804c41f{+0000:void[29],
+0029:unused[1024]} recv {661..690} HeapOverflow
bss0x0809ac80{ ...
xzgv-5.8 +91952:int, fread {4..11} Integeroverflow
+91956:int,...}
fun0x080673fc{ ...,
-0176:char[6],unused[2], fread {2..5} Integeroverflow
gnuPG-1.0.5 -0168:int,int,...}
heap0x080afec1{+0000:int,...,
+0036:void[5]} fread {6..10} Heapoverflow
fun0x0804d06b{...,
-0056:int, fread {20..23} Integeroverflow
ipgrab-0.9.9 -0052:int,int,...}
heap0x0805a976{+0000:void[60]} fread {40..100} Heapoverflow
fun0x080496b8{...,
-0440:struct sockaddrin,
cfingerd-1.4.3 -0424:formatstringt[34], read {0..3} FormatString
-0390:unused[174],
-0216:char[4],,...}
fun0x0805f9a5{...,
-0284:formatstringt[76]
ngircd-0.8.2 -0208:unused[204], recv {12..15} FormatString
-0004:stackframet,
+0000:retaddrt,...}
Table5.ResultfromourvulnerabilityfuzzerwithhelpofREWARDS
For example, the char[12] buffer in bftpd denotes a 6 Discussion
packet received from outside (the recv category). Note
that the input categories are conveniently implemented as REWARDS has a number of limitations: (1) As a dy-
semantics tags in REWARDS. The 4th column offset namicanalysis-basedapproach,REWARDScannotachieve
represents the input offsets reported by our fuzzer. They full coverage of data structures defined in a program.
represent the places that are mutated to generate the real Instead, the coverage of REWARDS relies on those data
exploits. TheREWARDS-basedvulnerabilitydetectoralso structures that are actually created and accessed during a
emits vulnerability types (shown in the 5th column) based particularrunofthebinary. (2)REWARDSisnotfullyon-
on the vulnerability patterns matched. Consider the first line as our timestamp-based on-line algorithm may leave
benchmark ncompress: Its entry in the table indicates somevariablesunresolvedbythetimetheyarede-allocated,
that the char[13] buffer inside a function starting with and thus the off-line companion procedure is needed to
PC 0x08048e76 is vulnerable to stack buffer overflow. make the system sound. A fully on-line type resolution
The buffer receives values from the second command line algorithmisourfuturework.(3)BasedonPIN,REWARDS
option (argv[1]). Our data lineage fuzzer mutates the doesnotsupportthereverseengineeringofkernel-leveldata
lineage of the buffer, which are the first 12 input items structures. (4) REWARDS does not work with obfuscated
(offset 0 to 11) to generate the exploit. From the data code. Thus it is possible that an adversary can write an
structure in the 2nd column, the exploit has to contain a obfuscated program to dodge REWARDS – for example,
byte string longer than 1052 bytes to overwrite the return byavoidingtouchingthetypesinkswedefine. (5)Besides
addressatthebottom.Othervulnerabilitiescanbesimilarly the general data structures, REWARDS has yet to support
apprehended. the extraction of other data types, such as the format of a
specifictypeoffiles(e.g.,ELFfiles,multimediafiles),andbrowser-related data types (e.g., URL, cookie). Moreover, involves reconstructing variable types [31, 19]. By using
REWARDSdoesnotdistinguishbetweensignandunsigned unification,Mycroft[31]extendstheHindley-Milneralgo-
integersinourcurrentimplementation. rithm [29] and delays unification until all constraints are
available. Recently, Dolgova and Chernov [19] present an
7 RelatedWork iterativealgorithmthatusesalatticeoverthepropertiesof
datatypesforreconstruction.
Allthesetechniquesarestaticandhencesharethesame
Typeinference. Someprogramminglanguages,suchas
limitations of static type inference and they only derive
ML, do not explicitly declare types. Instead, types are in-
simple syntactic structures. Moreover, they aim to get
ferredfromprograms. Typingconstraintsarederivedfrom
an execution-equivalent code and do not pay attention to
program statements statically and programs are typed by
whethertherecoveredtypesreflecttheoriginaldeclarations
solvingtheseconstraints.Notabletypeinferencealgorithms
andhavethesamestructures.
include Hindley-Milner algorithm [29], Cartesian Product
Protocolformatreverseengineering. Recenteffortsin
algorithm [3], iterative type analysis [13], object oriented
protocolreverseengineeringinvolveusingdynamicbinary
type inference [33], and aggregate structure identification
analysis (in particular input data taint analysis) to reveal
[35].
the format of protocol messages, facilitated by instruction
These techniques, like REWARDS, rely on type uni-
semantics (e.g., Polyglot [9]) or execution context (e.g.,
fication, namely, variables connected by operators shall
AutoFormat [25]). Recently, it has been shown that the
have the same type. However, these techniques assume
BNF structure of a given protocol with multiple messages
program source code and they are static, that is, typing
can be derived [40, 17, 28]; and the format of out-going
constraintsaregeneratedfromsourcecodeatcompiletime.
messages as well as encrypted messages can be revealed
ForREWARDS,weonlyassumebinarieswithoutsymbolic
[8,39].Inparticular,REWARDSsharesthesameinsightas
information, in which high level language artifacts are all
Dispatcher[8]fortypeinferenceandsemanticsextraction.
broken down to machine level entities, such as registers,
ThedifferenceisthatDispatcherandotherprotocolreverse
memory addresses, and instructions. REWARDS relies
engineering techniques mainly focus on live input and
on type sinks to obtain the initial type and semantics
output messages, whereas we strive to reveal general data
information. Variables are then typed through unification
structures in a program. Meanwhile, we care more about
withtypesinksduringexecution.
the detailed in-memory layout of program data, motivated
Lately, Balakrishnan et al. [4, 5, 36] showed that
byourdifferenttargetedapplicationscenarios.
analyzing executables alone can largely discover syntactic
Memory forensics and vulnerability discovery.
structures of variables, such as sizes, field offsets, and
FATKit [34] is a toolkit to facilitate the extraction,
simplestructures. Theirtechniqueentailspoints-toanalysis
analysis, aggregation, and visualization of forensic data.
andabstractinterpretationatbinarylevel. Theycannothan-
Their technique is based on pre-defined data structures
dle obfuscated binaries and dynamically loaded libraries.
extracted from program source code to type memory
Furthermore, the inaccuracy of binary points-to analysis
dumps. This is also the case for other similar systems
makes it hard to type heap variables. In comparison, our
(e.g., [12, 30, 2]). KOP [11] is an effective system that
technique is relatively simple, with the major hindrances
can map dynamic kernel objects with nearly complete
to static analysis (e.g., points-to relations and dynamically
coverage and perfect accuracy. It also relies on program
loadedlibraries)addressedviadynamicanalysis.
sourcecodeandusesaninter-proceduralpoints-toanalysis
Abstract type inference. Abstract type inference [32]
to compute all possible types for generic pointers. There
is to group typed variables according to their semantics.
are several other efforts [37, 18] that use data structure
For example, variables that are meant to store money, zip
signaturestoscanandtypememory. Complementingthese
codes, ages, etc., are clustered based on their intention’s,
efforts, REWARDS extracts data structure definitions and
even though they may have the same integer type. Such
reconstructshierarchicalin-memorylayoutsfrombinaries.
anintentioniscalledanabstracttype. Thetechniquerelies
There is a large body of research in vulnerability dis-
ontheHindley-Milnertypeinferencealgorithm. Recently,
covery such as Archer [41], EXE [10], Bouncer [15],
dynamic abstract type inference is proposed [24] to infer
BitScope[7],DART[22],andSAGE[23,21]. REWARDS
abstract types from execution. Regarding the goal of
complementsthesetechniquesbyenablingidentificationof
performing semantics-aware typing, these techniques and
vulnerabilitysuspectsdirectlyfrombinaries.
ours are similar. However, they work at the source code
levelwhereasoursworksatthebinarylevel. Ourtechnique
8 Conclusion
furtherderivessyntactictypestructures.
Decompilation. Decompilation is a process of recon-
structing program source code from lower-level languages We have presented the REWARDS reverse engineering
(e.g., assembly or machine code) [14, 20, 6]. It usually system that automatically reveals data structures in a bi-nary based on dynamic execution. REWARDS involves [9] J. Caballero and D. Song. Polyglot: Automatic extraction
an algorithm that performs data flow-based type attribute of protocol format using dynamic binary analysis. In
forward propagation and backward resolution. Driven by Proceedingsofthe14thACMConferenceonComputerand
the type information derived, REWARDS is also capable and Communications Security (CCS’07), pages 317–329,
Alexandria,Virginia,USA,2007.
of reconstructing the structural and semantic view of in-
memorydatalayout.Ourevaluationusinganumberofreal- [10] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and
world programs indicates that REWARDS achieves high D.R.Engler. Exe:automaticallygeneratinginputsofdeath.
accuracy in revealing data structures accessed during an In Proceedings of the 13th ACM conference on Computer
and communications security (CCS’06), pages 322–335,
execution. Furthermore, we demonstrate the benefits of
Alexandria,Virginia,USA,2006.ACM.
REWARDS to two application scenarios: memory image
forensicsandbinaryvulnerabilitydiscovery. [11] M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and
X. Jiang. Mapping kernel objects to enable systematic in-
tegritychecking.InThe16thACMConferenceonComputer
9 Acknowledgment
and Communications Security (CCS’09), pages 555–565,
Chicago,IL,USA,2009.
We would like to thank the anonymous reviewers for
[12] A. Case, A. Cristina, L. Marziale, G. G. Richard, and
theirinsightfulcomments. WearegratefultoXuxianJiang
V. Roussev. Face: Automated digital evidence discovery
and Heng Yin for earlier discussions and help on this and
andcorrelation. DigitalInvestigation,5(Supplement1):S65
relatedproblems. Thisresearchissupported,inpart,bythe
–S75,2008.TheProceedingsoftheEighthAnnualDFRWS
OfficeofNavalResearch(ONR)undergrantN00014-09-1-
Conference.
0776andbytheNationalScienceFoundation(NSF)under
[13] C. Chambers and D. Ungar. Iterative type analysis and
grant0720516. Anyopinions,findings,andconclusionsor
extended message splitting: Optimizing dynamically-typed
recommendationsinthispaperarethoseoftheauthorsand
object-orientedprograms. InProceedingsoftheSIGPLAN
donotnecessarilyreflecttheviewsoftheONRorNSF.
Conference on Programming Language Design and Imple-
mentation,pages150–164,1990.
References
[14] C.Cifuentes. ReverseCompilationTechniques. PhDthesis,
QueenslandUniversityofTechnology,1994.
[1] Libdwarf. http://reality.sgiweb.org/davea/dwarf.html.
[15] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado.
[2] Mission critical linux. In Memory Core Dump, Bouncer: securingsoftwarebyblockingbadinput. InPro-
http://oss.missioncriticallinux.com/projects/mcore/. ceedingsofthe21stACMSIGOPSsymposiumonOperating
[3] O. Agesen. The cartesian product algorithm: Simple and systems principles (SOSP’07), pages 117–130, Stevenson,
precise type inference of parametric polymorphism. In Washington,USA,2007.ACM.
Proceedings of the 9th European Conference on Object-
[16] A. Cozzie, F. Stratton, H. Xue, and S. T. King. Digging
OrientedProgramming(ECOOP’95),pages2–26,London,
for data structures. In Proceeding of 8th Symposium on
UK,1995.Springer-Verlag.
Operating System Design and Implementation (OSDI’08),
[4] G.Balakrishnan,,G.Balakrishnan,andT.Reps. Analyzing pages231–244,SanDiego,CA,December,2008.
memoryaccessesinx86executables. InProceedingsofIn-
[17] W. Cui, M. Peinado, K. Chen, H. J. Wang, and L. Irun-
ternationalConferenceonCompilerConstruction(CC’04),
Briz.Tupni:Automaticreverseengineeringofinputformats.
pages5–23.Springer-Verlag,2004.
In Proceedings of the 15th ACM Conference on Computer
[5] G.BalakrishnanandT.Reps. Divine:Discoveringvariables and Communications Security (CCS’08), pages 391–402,
in executables. In Proceedings of International Conf. on Alexandria,Virginia,USA,October2008.
Verification Model Checking and Abstract Interpretation
[18] B.Dolan-Gavitt,A.Srivastava,P.Traynor,andJ.Giffin.Ro-
(VMCAI’07),Nice,France,2007.ACMPress.
bustsignaturesforkerneldatastructures. InProceedingsof
[6] P.T.BreuerandJ.P.Bowen. Decompilation: theenumer-
the16thACMconferenceonComputerandcommunications
ationoftypesandgrammars. ACMTrans.Program.Lang.
security(CCS’09),pages566–577,Chicago,Illinois,USA,
Syst.,16(5):1613–1647,1994.
2009.ACM.
[7] D.Brumley,C.Hartwig,M.G.Kang,Z.Liang,J.Newsome,
[19] E.N.DolgovaandA.V.Chernov. Automaticreconstruction
P.Poosankam,D.Song,andH.Yin.Bitscope:Automatically
of data types in the decompilation problem. Program.
dissectingmaliciousbinaries,2007.TechnicalReportCMU-
Comput.Softw.,35(2):105–119,2009.
CS-07-133,CarnegieMellonUniversity.
[20] M. V. Emmerik and T. Waddington. Using a decompiler
[8] J.Caballero,P.Poosankam,C.Kreibich,andD.Song. Dis-
for real-world source recovery. In Proceedings ofthe 11th
patcher: Enablingactivebotnetinfiltrationusingautomatic
WorkingConferenceonReverseEngineering,pages27–36,
protocol reverse-engineering. In Proceedings of the 16th
2004.
ACM Conference on Computer and and Communications
Security(CCS’09),pages621–634,Chicago,Illinois,USA, [21] P.Godefroid,A.Kiezun,andM.Y.Levin. Grammar-based
2009. whitebox fuzzing. In Proceedings of the ACM SIGPLANConference on Programming Language Design and Imple- [33] J. Palsberg and M. I. Schwartzbach. Object-oriented type
mentation (PLDI’08), pages 206–215, Tucson, AZ, USA, inference. In OOPSLA ’91: Conference proceedings on
2008.ACM. Object-oriented programming systems, languages, and ap-
plications,pages146–161,Phoenix,Arizona,UnitedStates,
[22] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed
1991.ACM.
automatedrandomtesting. InProceedingsofthe2005ACM
SIGPLANconferenceonProgramminglanguagedesignand [34] N.L.Petroni,Jr.,A.Walters,T.Fraser,andW.A.Arbaugh.
implementation (PLDI’05), pages 213–223, Chicago, IL, Fatkit: A framework for the extraction and analysis of
USA,2005.ACM. digitalforensicdatafromvolatilesystemmemory. Digital
Investigation,3(4):197–210,2006.
[23] P.Godefroid,M.Levin,andD.Molnar.Automatedwhitebox
[35] G. Ramalingam, J. Field, and F. Tip. Aggregate structure
fuzz testing. In Proceedings of the 15th Annual Network
identification and its application to program analysis. In
andDistributedSystemSecuritySymposium(NDSS’08),San
Proceedingsofthe26thACMSIGPLAN-SIGACTsymposium
Diego,CA,February2008.
onPrinciplesofprogramminglanguages(POPL’99),pages
[24] P. J. Guo, J. H. Perkins, S. McCamant, and M. D. Ernst. 119–132,SanAntonio,Texas,1999.ACM.
Dynamic inference of abstract types. In Proceedings of
[36] T.W.RepsandG.Balakrishnan. Improvedmemory-access
the 2006 international symposium on Software testing and
analysisforx86executables.InProceedingsofInternational
analysis(ISSTA’06),pages255–265,Portland,Maine,USA,
Conference on Compiler Construction (CC’08), pages 16–
2006.ACM.
35,2008.
[25] Z.Lin,X.Jiang,D.Xu,andX.Zhang. Automaticprotocol
[37] A. Schuster. Searching for processes and threads in mi-
formatreverseengineeringthroughcontext-awaremonitored
crosoft windows memory dumps. Digital Investigation,
execution. In Proceedings of the 15th Annual Network
3(Supplement-1):10–16,2006.
andDistributedSystemSecuritySymposium(NDSS’08),San
Diego,CA,February2008. [38] T. Wang, T. Wei, Z. Lin, and W. Zou. Intscope: Au-
tomatically detecting integer overflow vulnerability in x86
[26] Z. Lin, X. Zhang, and D. Xu. Convicting exploitable
binaryusingsymbolicexecution. InProceedingsofthe16th
softwarevulnerabilities:Anefficientinputprovenancebased
AnnualNetworkandDistributedSystemSecuritySymposium
approach. In Proceedings of the 38th Annual IEEE/IFIP
(NDSS’09),SanDiego,CA,February2009.
International Conference on Dependable Systems and Net-
[39] Z.Wang,X.Jiang,W.Cui,X.Wang,andM.Grace. Refor-
works(DSN’08),Anchorage,Alaska,USA,June2008.
mat: Automaticreverseengineeringofencryptedmessages.
[27] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, In Proceedings of 14th European Symposium on Research
G.Lowney,S.Wallace,V.J.Reddi,andK.Hazelwood. Pin: in Computer Security (ESORICS’09), Saint Malo, France,
building customized program analysis tools with dynamic September2009.LNCS.
instrumentation. InProceedingsofACMSIGPLANConfer-
[40] G.Wondracek, P.Milani, C.Kruegel, andE.Kirda. Auto-
enceonProgrammingLanguageDesignandImplementation
maticnetworkprotocolanalysis. InProceedingsofthe15th
(PLDI’05),pages190–200,Chicago,IL,USA,2005.
AnnualNetworkandDistributedSystemSecuritySymposium
[28] P. Milani Comparetti, G. Wondracek, C. Kruegel, and (NDSS’08),SanDiego,CA,February2008.
E. Kirda. Prospex: Protocol Specification Extraction. In
[41] Y. Xie, A. Chou, and D. Engler. Archer: using sym-
IEEE Symposium on Security & Privacy, pages 110–125,
bolic,path-sensitiveanalysistodetectmemoryaccesserrors.
Oakland,CA,2009.
In Proceedings of the 9th European software engineering
[29] R.Milner. Atheoryoftypepolymorphisminprogramming. conference held jointly with 10th ACM SIGSOFT interna-
Journal of Computer and System Sciences, 17:348–375, tional symposium on Foundations of software engineering
1978. (ESEC/FSE-10),pages327–336,Helsinki,Finland,2003.
[30] P. Movall, W. Nelson, and S. Wetzstein. Linux physical
memory analysis. In Proceedings of the USENIX Annual
Technical Conference, pages 39–39, Anaheim, CA, 2005.
USENIXAssociation.
[31] A.Mycroft. Type-baseddecompilation(orprogramrecon-
struction via type reconstruction). In Proceedings of the
8thEuropeanSymposiumonProgrammingLanguagesand
Systems (ESOP’99), pages 208–223, London, UK, 1999.
Springer-Verlag.
[32] R.O’CallahanandD.Jackson. Lackwit: aprogramunder-
standing tool based on type inference. In Proceedings of
the 19th international conference on Softwareengineering,
pages338–348,Boston,Massachusetts,UnitedStates,1997.
ACM.