A First Step Towards Automated Detection of Buffer Overrun Vulnerabilities
(cid:0)
DavidWagner JeffreyS.Foster Eric A. Brewer AlexanderAiken
Universityof California,Berkeley
Abstract
We describe a newtechnique for finding potential buffer
overrunvulnerabilitiesinsecurity-criticalCcode. Thekey
to success is to use static analysis: we formulate detec-
tion of buffer overruns as an integer range analysis prob-
lem. One major advantage of static analysis is that secu-
rity bugs can be eliminated before code is deployed. We
haveimplementedourdesignandusedourprototypetofind
new remotely-exploitable vulnerabilities in a large, widely
deployed software package. An earlier hand audit missed
thesebugs.
1. Introduction
Buffer overrun vulnerabilities have plagued security ar-
chitects for at least a decade. In November 1988, the in-
famous Internet worm infected thousands or tens of thou-
sandsofnetwork-connectedhostsandfragmentedmuchof
theknownnet[17]. Oneoftheprimaryreplicationmecha-
nisms was exploitation of a bufferoverrunvulnerability in
thefingerddaemon.
Sincethen,bufferoverrunshavebeenaserious,continu-
ingmenacetosystemsecurity.Ifanything,theincidenceof
bufferoverrunattackshasbeenincreasing. SeeFigure1for
data extracted from CERT advisories over the last decade.
Figure1showsthatbufferoverrunsaccountforupto50%
oftoday’svulnerabilities,andthisratioseemstobeincreas-
ingovertime. A partialexamination ofother sources sug-
gests that this estimate is probably not too far off: buffer
overrunsaccountfor 27%(55of207)oftheentriesinone
vulnerability database [29] and for 23%(43 of 189)in an-
otherdatabase[33]. Finally,adetailedexaminationofthree
monthsofthebugtraqarchives(JanuarytoMarch,1998)
shows that 29% (34 of 117) of the vulnerabilities reported
areduetobufferoverrunbugs[7].
Buffer overruns are so common because C is inherently
unsafe. Array andpointerreferencesarenotautomatically
bounds-checked, so it is up to the programmer to do the
(cid:1)
checks herself. More importantly, many of the string op-
erationssupportedbythestandardClibrary—strcpy(),
strcat(), sprintf(), gets(), and so on—are un-
safe.Theprogrammerisresponsibleforcheckingthatthese
operationscannotoverflowbuffers,andprogrammersoften
getthosecheckswrongoromitthemaltogether.
Asaresult,weareleftwithmanylegacyapplicationsthat
usetheunsafestringprimitivesunsafely. Programswritten
today still use unsafe operations such as strcpy() be-
cause they are familiar. Even sophisticated programmers
sometimes combine the unsafe primitives with some ad-
hoc checks, or use unsafe primitives when they somehow
“know” that the operation is safe or that the source string
cannotcomeunderadversarialcontrol.
Unfortunately,programsthatusejustthe“safe”subsetof
theCstringAPIarenotnecessarilysafe,becausethe“safe”
stringprimitiveshavetheirownpitfalls[43]:
ThisresearchwassupportedinpartbytheNationalScienceFounda-
tionYoungInvestigatorAwardNo. CCR-9457812,NASAContractNo.
NAG2-1210,andanNDSEGfellowship.
(cid:2)
Thestrn*()callsbehavedissimilarly. Forinstance,
strncpy(dst, src, sizeof dst) is correct
but strncat(dst, src, sizeof dst) is
wrong. Inconsistencymakesitharderfortheprogram-
mer to remember how to use the “safe” primitives
safely.
(cid:2)
strncpy()mayleavethetargetbufferunterminated.
In comparison, strncat() and snprintf() al-
ways append a terminating ’\0’ byte, which is an-
otherexampleofdissimilarity.
(cid:2) Usingstrncpy()hasperformanceimplications,be-
cause it zero-fills all the available space in the tar-
get buffer after the ’\0’ terminator. For example,
a strncpy() of a 13-byte buffer into a 2048-byte
bufferoverwritestheentire2048-bytebuffer.
(cid:2)
strncpy() and strncat() encourage off-by-
one bugs. For example, strncat(dst, src,
sizeof dst - strlen(dst) - 1) is correct,
butdon’tforgetthe-1!
(cid:2)
snprintf()isperhapsthebestofthe“safe”primi-
tives:ithasintuitiverules,anditisverygeneral.How-
ever, until recently it was not available on many sys-
tems,soportableprogramscouldnotrelyonit.
130 60%
25 50%
20 40%
15 30%
10 20%
5 10%
0 0%
1988 1990 1992 1994 1996 1998 1988 1990 1992 1994 1996 1998
Figure 1. Frequency of buffer overrun vulnerabilities, derived from a classification of CERT advisories. The
left-handchartshows,foreach year,thetotalnumberofCERT-reportedvulnerabilitiesandthenumberthat
can be blamed primarily on buffer overruns. The right-handchart graphs the percentage of CERT-reported
vulnerabilitiesthatwereduetobufferoverrunsforeachyear.
Inallcases, theprogrammermuststillkeeptrackofbuffer manyvulnerabilities. Considerthefollowingexample:
lengths accurately, which introduces another opportunity
if (strlen(src) > sizeof dst)
formistakes.
break;
In short, today’s C environments make it easy to do the
strcpy(dst, src);
wrongthing,and,worsestill,hardtodotherightthingwith
buffers. This suggests that an automated tool to help de- Note that off-by-one errors in buffer management, such
tect this class of security-relevantcoding errors may be of as the one shown above, have been exploited in the past
considerablebenefit. [36,48]. Thefundamentalproblemwithdynamictestingis
thatthecodepathsofgreatestinteresttoasecurityauditor—
1.1.Overview
theoneswhich areneverfollowedinordinaryoperation—
are also the ones that are the hardest to analyze with dy-
Thispaperdescribesatoolwedevelopedtodetectbuffer
namictechniques.Therefore,inthisworkwefocusonstatic
overruns in C source code. Though this is only a first
analysis.
prototype, early results look promising. For example, the
A theme in this work is the trade-off between precision
tool found several serious new vulnerabilities in one large
andscalability. Ifscalabilityisnotaddressedfromthestart,
security-criticalapplication,eventhoughithadbeenhand-
program analyses often have trouble handling large appli-
auditedpreviously.
cations. Since we wish to analyzelargeprograms, such as
This work involves a synthesis of ideas from several
sendmail(tensofthousandsoflinesofcode),weexplicitly
fields, including programanalysis, theory, and systems se-
aim for scalability even if it comes at some cost in preci-
curity. The main idea is to apply standard static analy-
sion. Thismotivatesouruseofseveralheuristicsthattrade
sis techniques from the programming languages literature
offprecisionforscalability.
to the task of detecting potential security holes. We focus
As a result of imprecision, our analysis may miss some
specificallyon staticanalysis so that vulnerabilitiescan be
vulnerabilities (false negatives) and produce many false
proactively identified and fixed before they are exploited.
alarms (false positives), but it is still a useful tool. In our
We formulate the buffer overrun detection problem as an
experience, even though our relatively imprecise analysis
integerconstraintproblem,andweusesomesimplegraph-
generates manyfalse alarms, it still reduces the number of
theoretic techniques to construct an efficient algorithm for
unsafestringoperationstobecheckedbyhandbyanorder
solving the integer constraints. Finally, security knowl-
ofmagnitudeormore;seeSection5.5.
edgeisusedtoformulateheuristicsthatcapturetheclassof
Weintroducetwofundamental,newinsightsinthispaper:
security-relevantbugsthattendtooccurinrealprograms.
Others have applied runtime code-testing techniques to 1. We treat C strings as an abstract data type. In C,
theproblem,using,e.g., black-boxtesting[41,42]orsoft- pointers are the bane of program analysis, and any
warefaultinjection[21]tofindbufferoverrunsinreal-world code fragments that manipulate buffers using pointer
applications. However,runtimetestingseemslikelytomiss operations are very difficult to analyze. However,
2integer constraint
source C parser constraint solver warnings
generation
Figure2.Thearchitectureofthebufferoverflowdetectionprototype.
mostCbufferoverrunsareinstringbuffers,andmost theproofsforallofourtheoreticalresults,andAppendixB
stringoperationsuse thestandardClibraryfunctions. expandsonmoredetailsoftheconstraintsolver.
This suggests modelling C strings as an abstract data
type with operations like strcpy() (copy strings), 2. Theconstraint language
strcat() (concatenate strings), and so on. Any
Inthissectionwedescribethelanguageofconstraintswe
buffer overruns caused by manipulating strings using
usetomodelstringoperations.
primitive pointer operations cannot be detected, but
Let
suchcodewon’totherwiseinterferewiththeanalysis.
2. Wemodelbuffersaspairsofintegerranges. Rather
than tracking the contents of each string variable di-
rectly, we summarize each string with two integer
quantities: thenumberofbytesallocatedforthestring
buffer(itsallocatedsize),andthenumberofbytescur-
rentlyinuse(itslength). ThestandardClibraryfunc-
tionscanbemodelledbywhattheydototheallocated
sizeandlengthofstringswithoutregardtothestrings’
contents.
We formulate the problem of detecting buffer over-
flowsintermsofintegerrangetracking.Anyalgorithm
forintegerrangeanalysiswillwork: wejustcheck,for
eachstringbuffer,whetheritsinferredallocatedsizeis
atleastaslargeasitsinferredmaximumlength.
Thesetwoideasprovideaconceptualframeworkforbuffer
overrunanalysis.
Our formulation of the problem suggests a natural divi-
sion of labor for the implementation: a front end models
stringoperationsasintegerrangeconstraints, whileaback
endsolvestheresultingconstraintsystem. SeeFigure2for
adiagramofthesystemorganization.
Asecondarycontributionofthisresearchisascalableand
very fast integer range analysis. One novel feature of this
analysis is the ability to handle cyclic data dependencies
without loss of precision by invoking a fixpoint theorem.
However,wecouldeasilyreplacethisalgorithmwithsome
othertechniqueforintegerrangeanalysis.
Theorganizationofthefirsthalfofthispaperparallelsthe
structure of our implementation. First, we need to define
a constraint language (see Section 2). Given this mathe-
maticalfoundation,wegenerateconstraintsfromthesource
code (see Section 3), solve the resulting constraint system
(seeSection4),andcheckallofthestringvariablesforover-
flow.
The second half of this paper focuses on analysis of our
approach, including our initial experience with the proto-
type(Section5),areviewofrelatedwork(Section6),anda
fewconcluding remarks (Section7). AppendixA presents
(cid:3)
denote the set of integers and write
(cid:11)(cid:13) (cid:12)(cid:15) (cid:14)(cid:17) (cid:16)(cid:19) (cid:18)(cid:20) (cid:14)(cid:22) (cid:21)
(cid:3)(cid:5) (cid:4)(cid:7) (cid:6)(cid:8) (cid:3)(cid:10) (cid:9)
for the extendedintegers. Thesubsets of
(cid:3)(cid:15) (cid:4)
formacompletelatticewith (cid:23) asthepartialorder.
We restrict our attention to integer ranges. However,
many of the comments here also apply more generally to
arbitrary subsets of
(cid:3)(cid:5) (cid:4)
. A range is a set (cid:24)(cid:25) (cid:23)
(cid:3)(cid:5) (cid:4)
of
the form (cid:26)(cid:27)
(cid:16)(cid:29) (cid:28)(cid:31) (cid:30) (cid:6) (cid:11)! # " (cid:3) (cid:4)% $
(cid:27) & &
(cid:28)’ (cid:21)
. When
(
is a subset of
(cid:3)(cid:15) (cid:4)
, we write )+*- ,
(
and .0 /2 1
(
for the
minimum and maximum element (with respect to & ) of
(
; in particular, for ranges we have )+*- ,! (cid:26)(cid:27)
(cid:16)0 (cid:28)(cid:31) (cid:30) (cid:6)
(cid:27) and
.0 /2 13 (cid:26)(cid:27)
(cid:16)0 (cid:28)(cid:31) (cid:30) (cid:6) (cid:28)
. The range closure of any set
(
(cid:23)
(cid:3)4 (cid:4)
is
theminimalrange (cid:24) (withrespectto (cid:23) )containing
(
,i.e.,
(cid:24)
(cid:6)
(cid:26))+*- ,
( (cid:16)
.0 /2 1
( (cid:30)
. For example, the set
( (cid:6) (cid:11)5 (cid:12)(cid:20) 67 (cid:16)9 82 (cid:16)0 :2 (cid:21)
hasrangeclosure
(cid:12)(cid:20)
(cid:26)
67 (cid:16)(cid:29) :7 (cid:30)
,since )+*- ,
( (cid:6) (cid:12)(cid:20) 6
and .(cid:29) /; 1
( (cid:6) :
;
notethattherangenotation
(cid:12)(cid:20)
(cid:26)
65 (cid:16)(cid:29) :< (cid:30)
isshorthandfortheset
(cid:11)(cid:13) (cid:12)(cid:20) 67 (cid:16)0 8; (cid:16)= 65 (cid:16)9 >- (cid:16)9 ?2 (cid:16)0 :2 (cid:21)
(cid:23)
(cid:3)(cid:5) (cid:4)
.
We extend the usual arithmetic operators to act on sets
( (cid:16)0 @
(cid:23)
(cid:3)(cid:15) (cid:4)
inthenaturalway:
(
(
(N
(cid:18)A
(cid:12)J
M
@
@
@
(cid:6)
(cid:6)
(cid:6)
(cid:11)C
(cid:11)C
(cid:11)C
BD
BK
B
(cid:18)F
(cid:12)L
M
E
E
E
$
$
$
BG
BG
BG
"
"
"
(
(
(
(cid:16)0
(cid:16)0
(cid:16)0
EH
EH
EH
"I
"I
"I
@(cid:20)
@(cid:20)
@(cid:20)
(cid:21)
(cid:21)
(cid:21)
For notational convenience we often write
(cid:28)
as shorthand
forthesingletonset
(cid:11)O (cid:28)’ (cid:21)
,when
(cid:28)A " (cid:3)(cid:5) (cid:4)
. Thus,theexpres-
sion
>P @
acquiresitsnaturalinterpretation
(cid:11)P >P E $ EH "R @(cid:20) (cid:21)
>P @ (cid:6) (cid:11)P >Q (cid:21) M @ (cid:6)
.
When the result of an operation is not a range, we take
its range closure. When this rule is followed, the ex-
tended arithmetical operators obey most of the usual alge-
braic laws. For instance,
( (cid:18)S @ (cid:6) @T (cid:18) (
,
( (cid:18)S 8 (cid:6) (
,
( (cid:18) ( (cid:6) > (
,
(U M @ (cid:6) @ MA (
,
8 M# ( (cid:6) 8
, and so on.
However,thedistributiveruledoesnothold(ingeneralwe
onlyhave
(V MX W @Y (cid:18)V ZG [
(cid:23)
(V M @\ (cid:18) (V M Z
;see[32])andthe
rulefor subtraction introducesa slightlyuglyfeaturesince
ingeneral
( (cid:12) (^ ](cid:6) 8
.
Inpractice, itis useful to extendthe constraintlanguage
toinclude _‘ )+* and _b aP c operators:
_‘
_b
)+*
aP c
Wd
Wd
(
(
(cid:16)0
(cid:16)0
@(cid:15)
@(cid:15)
[
[
(cid:6)
(cid:6)
(cid:11)
(cid:11)
_‘
_b
)e*
aP c
B5W
B5W
(cid:16)(cid:29) E(cid:29) [
(cid:16)(cid:29) E(cid:29) [
$
$
BG
B(cid:20)
"
"
(
(
(cid:16)(cid:29) ED
(cid:16)(cid:29) ED
"R
"R
@G
@(cid:20)
(cid:21)
(cid:21)
3Ccode Interpretation
char s[n];
(cid:28)
(cid:23) alloc
W
s
[
strlen(s) len
W
s
[f (cid:12)N 6
strcpy(dst,src); len
W
src
[
(cid:23) len
W
dst
[
strncpy(dst,src,n); _‘ )e*
W
len
W
src
[(cid:19) (cid:16)(cid:29) (cid:28)3 [
(cid:23) len
W
dst
[
s = "foo";
:
(cid:23) len
W
s
[(cid:19) (cid:16)(cid:25) :
(cid:23) alloc
W
s
[
p = malloc(n);
(cid:28)
(cid:23) alloc
W
p
[
p = strdup(s); len
W
s
[
(cid:23) len
W
p
[(cid:19) (cid:16)
alloc
W
s
[
(cid:23) alloc
W
p
[
strcat(s,suffix); len
W
s
[g (cid:18)
len
W
suffix
[h (cid:12)N 6
(cid:23) len
W
s
[
strncat(s,suffix,n); len
W
s
[g (cid:18)
_‘ )+*
W
len
W
suffix
[’ (cid:12)(cid:10) 67 (cid:16)(cid:29) (cid:28)3 [
(cid:23) len
W
s
[
p = getenv(...);
65
(cid:26)
(cid:16)i (cid:14)F (cid:30)
(cid:23) len
W
p
[j (cid:16) 65
(cid:26)
(cid:16)i (cid:14)F (cid:30)
(cid:23) alloc
W
p
[
gets(s);
65
(cid:26)
(cid:16)i (cid:14)F (cid:30)
(cid:23) len
W
s
[
fgets(s,n,...);
65
(cid:26)
(cid:16)(cid:29) (cid:28)(cid:31) (cid:30)
(cid:23) len
W
s
[
sprintf(dst,"%s",src); len
W
src
[
(cid:23) len
W
dst
[
sprintf(dst,"%d",n);
65
(cid:26)
(cid:16)9 >7 8P (cid:30)
(cid:23) len
W
dst
[
snprintf(dst,n,"%s",src); _‘ )e*
W
len
W
src
[(cid:19) (cid:16)(cid:29) (cid:28)3 [
(cid:23) len
W
dst
[
p[n] = ’\0’; _‘ )e*
W
len
W
p
[(cid:19) (cid:16)(cid:29) (cid:28)k (cid:18)^ 6! [
(cid:23) len
W
p
[
p = strchr(s,c); p = s+n;
82
(cid:26)
(cid:16)
len
W
s
[l (cid:30)
(cid:23)
(cid:28)
h = gethostbyname(...);
65
(cid:26)
(cid:16)i (cid:14)F (cid:30)
(cid:23) len
W
h->h name
(cid:12)(cid:15)
(cid:26)
(cid:14)^ (cid:16)i (cid:14)F (cid:30)
(cid:23)
[(cid:19) (cid:16)
h->h_length
Table1.Modellingtheeffectsofstringoperations: someexamples.
For example, when
( (cid:6) (cid:11)(cid:13) 67 (cid:16)9 >2 (cid:16)0 ?; (cid:16)(cid:29) :2 (cid:21) (cid:6) 65
(cid:26)
(cid:16)(cid:29) :7 (cid:30)
and
(cid:11)! ?; (cid:16)(cid:29) :m (cid:16)9 n- (cid:16)9 o- (cid:21) (cid:6) ?;
(cid:26)
(cid:16)0 o< (cid:30)
@ (cid:6)
, then )e*- ,
@ (cid:6) ?
, _‘ )+*
Wd ( (cid:16)0 @(cid:15) [ (cid:6) 67
(cid:26)
(cid:16)0 :< (cid:30)
,
and
( (cid:12)J @ (cid:6) (cid:12)(cid:5)
(cid:26)
n2 (cid:16)= 6= (cid:30)
.
Wedefineanintegerrangeexpression p as
p
$e$(cid:6)(cid:17) qR r
r
(cid:28)
_b
r
aP
(cid:28)
c
W
M
p
(cid:16)=
qX
sO s=
r
st
p
(cid:16)
(cid:18)
[
p
p
r
_u
r
p
)+*
(cid:12)
W
p
p
(cid:16)= s= sO st (cid:16)
p
[
where
(cid:28)v " (cid:3)
and
q "
Vars, a set of range variables. An
integer range constraint has the form p^ (cid:23)
q
. Notice we
requiretheright-handsidetobeavariable.
Notethatequalityconstraints oftheform
q (cid:18)(cid:22) (cid:28) (cid:6)x w
fit
within this framework, since they can be equivalently ex-
pressedasthepairofsimultaneousconstraints
q (cid:18)N (cid:28)
(cid:23)
w
,
w (cid:12)(cid:17) (cid:28)
(cid:23)
q
. Equality constraints are useful for unifying
variablesthatarediscovered(duringconstraintgeneration)
torefertothesamememorylocation.
An assignment y
$ qU z{
y
W q [
(cid:23)
(cid:3)(cid:5) (cid:4)
satisfies a sys-
temofconstraintsifalloftheconstraintassertionsaretrue
whentheformalvariablenames
q
arereplacedbythecorre-
spondingvalues y
W q [
. Forassignments y and | ,wesaythat
y} (cid:23)v | if y
W q [
(cid:23)U |
W q [
holds for allvariables
q
. Theleast
solutiontoaconstraintsystemisthesmallestassignment y
thatsatisfiesthesystem,i.e.,asatisfyingassignment y such
thatanyothersatisfyingassignment | obeys yA (cid:23)N |
3. Constraint generation
The first step is to parse the source code; we use the
BANEtoolkit [2]. Ouranalysisproceedsbytraversingthe
parsetreefortheinputCsourcecodeandgeneratingasys-
temofintegerrangeconstraints. Witheachintegerprogram
variablevweassociatearangevariable
.
Theorem1. Everyconstraintsystemhasauniqueleastso-
lution.
Proof. SeetheAppendixAfortheproof.
Infact,asweshallseelater,theseconstraintsystemsusu-
allycanbesolvedefficiently.
q
. Asdiscussedbe-
fore,witheachstringvariablesweassociatetwovariables,
itsallocatedsize(thenumberofbytesallocatedfors),de-
notedalloc(s),anditslength(thenumberofbytescurrently
inuse),denotedlen(s). We modeleachstringoperationin
termsofitseffectonthesetwoquantities.
For convenience, the length of a string is defined to in-
cludetheterminator’\0’. Thus,thesafetypropertytobe
verifiedis
len
W
s
[
& alloc
W
s
[
forallstringvariabless.
For each statement in the input program, we generate
an integer range constraint. Integer expressions and inte-
ger variables are modelled by corresponding range opera-
tions.Foranassignmentv = e,wegeneratetheconstraint
p(cid:20) (cid:23)
q
. Forexample,fortheassignmenti = i+j,wegen-
eratetheconstraint
3 (cid:18)(cid:127) ~
(cid:23) . Weignoreassignmentswith
dereferencedpointersontheleft;seebelowforadiscussion.
Forstringoperations,wepattern-matchtodeterminewhat
kindofconstrainttogenerate. Somesampleconstraintsare
summarizedinTable1. TheleftcolumnshowstheCcode
forastringoperationofinterest,andtherightcolumnshows
thegeneratedconstraints.Forexample,thesecondlinesays
that the return value of the strlen() library call is the
lengthof thestringpassed asits firstargument, minus one
4(for the string terminator). The third line in the table says
that the effect of the strcpy() operation is to overwrite
the first argument with the second argument, and thus af-
terthestrcpy()thelengthofthefirstargumentisequal
to the length of the second argument. Note that although
strncpy()may leaveitstargetunterminated, wedonot
modelthisbehavior.
Forscalabilityandsimplicityofimplementation,weusea
flow-insensitiveanalysis,i.e.,weignoreallcontrolflowand
disregard the order of statements. Flow-insensitive analy-
ses sacrifice some precision for significant improvements
in scalability, efficiency, and ease of implementation. We
donotclaimthatflow-insensitiveanalysisisnecessarilythe
best approachfor a production-qualitybufferoverruntool;
instead,wemerelyobservethatitsadvantages(easeofim-
plementation, scalability) mapped well to our initial goals
(constructionofaproof-of-conceptprototypethatcanana-
lyzelarge,real-worldapplications).
Note that the strcat() operation is difficult to model
accuratelyinaflow-insensitivemodel,becausewemustas-
sume that it can execute arbitrarily often (for instance, in-
sidealoop). Asaresult,inaflow-insensitiveanalysisevery
non-trivial strcat() operation is flagged as a potential
bufferoverrun. Thisisapricewehavetopayforthebetter
performanceofflow-insensitiveanalyses.Fortunately,most
of the C library string operations are idempotent, which
means that they do not present any intrinsic problems for
aflow-insensitiveanalysis.
Finally, we model function calls monomorphically, i.e.,
we merge information for all call sites of the same func-
tion. Let f() be a function defined with the formal in-
teger parameter formal. We add a variable f_return
to denote the return value of f(). A return statement
in f() is treated as an assignment to f_return. Each
function call b = f(a) is treated as an assignment of
the actuals to the formals (i.e., formal = a) followed
byanassignmentthatcarriesthereturnvalueoff()(i.e.,
b = f\_return).Notethatthebodyofeachfunctionis
processedonlyonce,sothisstrategyissimpleandefficient,
butnotnecessarilyprecise.
Afterthepossiblerangesofallvariablesareinferred,we
may check the safety property for each string s. Suppose
theanalysisdiscoversthatlen
W
s
[
andalloc
W
s
[
takeonval-
ues only in (cid:26)(cid:128)
(cid:16)9 (cid:129)9 (cid:30)
and (cid:26)(cid:130)
(cid:16)9 (cid:131)< (cid:30)
, respectively. There are three
possibilities:
1. If
(cid:129)
&(cid:10) (cid:130) ,wemayconcludethatthestringsneverover-
flowsitsbuffer.
2. If (cid:128)# (cid:132)
(cid:131)
char s[20], *p, t[10];
strcpy(s, "Hello");
p = s + 5;
strcpy(p, " world!");
strcpy(t, s);
Figure3.Abufferoverrunthattheanalysiswould
notfindduetothepointeraliasing. Inthisexam-
ple, a 13-byte string is copied into the 10-byte
bufferttt.
conservativelyconcludethatthereisthepotentialfora
bufferoverrunvulnerabilityins.
3.1.Handlingpointers
Ideally,wewouldliketheconstraintgenerationalgorithm
tobesound:if
, then a buffer overrun always occurs in any
executionthatusess.
3. Ifthetworangesoverlap,then wecannotruleoutthe
possibilityofaviolationofthesafetyproperty,andwe
y isasatisfyingassignmentfortheconstraint
systemgeneratedbythisalgorithmonsomeprogram,then
y
W q [
should contain every possible value that the integer
programvariablevcantakeonduringtheexecutionofthe
program. Ouralgorithmis,however,unsafeinthepresence
ofpointersoraliasing.
Table 1 is deliberately vague about pointer operations.
This is because, in the simplistic model used in the pro-
totype, pointeraliasing effects are largelyignored, and the
rules for dealing with pointer expressions are highly ad-
hoc. Forexample,thestatementq = p+j;isinterpreted
as alloc
W
p
[(cid:15) (cid:12)N ~
(cid:23) alloc
W
q
[
, len
W
p
[(cid:5) (cid:12)N ~
(cid:23) len
W
q
[
. This
interpretation iscorrect in the absence ofwrites to *p and
*q,butduetotheimplicitaliasingofpandqawritetoone
stringisnotreflectedwhentheotherstringisreadinsome
subsequent program statement. Figure 3 givesan example
ofacodesegmentwithastaticbufferoverrunthatisunde-
tected by the analysis. Thus, ignoring pointer aliasing can
cause the analysis to miss some vulnerabilities and, as we
shallseelater,canoccasionallycausefalsealarms.
Doubly-indirected pointers (e.g., char **) are hard to
handlecorrectlywithourheuristicsandthusareignoredin
ourtool. Arraysofpointerspresentthesameproblemsand
are treated similarly. As an unfortunate result, command-
line arguments (char *argv[]) are not treated in any
systematicway.
Function pointers are currently ignored. We also ignore
union types. These simplifications are allunsound in gen-
eral,butstillusefulforalargenumberofrealprograms.
It seems that one can retain some benefits of static
analysis despite (largely) ignoring pointers and aliasing.
Nonetheless, in practice there is one related C idiom that
cannotbeignored: useofCstruct’s.Structuresformes-
sentiallytheonlymechanismforabstractionorconstruction
ofdatastructures,soitisnotsurprisingthattheyarewidely
used. Experience suggests that modelling structures prop-
erlyiscrucialtoobtaininggoodresults: anearlieranalysis
5tool that ignored structures was mostly useless for under-
standing realprograms of anynon-trivialcomplexity. One
aspect that complicates analysis of structures is that they
arecommonlyusedinconjunctionwithpointers(forexam-
ple, we might want to know whether p->left->right
referstothesameobjectasq->right->right),yetone
ofthegoalsoftheprototypewastoavoidtheimplementa-
tioncomplexityassociatedwithafulltreatmentofpointers,
ifpossible.
Thisseemingparadoxisresolvedwithasimpletrickfor
modellingstructures: allstructureobjectswiththesame(or
compatible)Ctypeareassumedtobepotentiallyaliasedand
are modelled with a single variable in the constraint sys-
tem (see also [16]). In addition, structure field references
arefurtherdisambiguatedusinglexicalfieldnames,sothat
hp->h_lengthisnotconsideredthesamememoryloca-
tion as hp->h_addr. This technique can introduce false
alarms(butdoesn’tmissrealvulnerabilities,unlessthepro-
gramusescastsinunusualways),yetitseemstoworkwell
enoughinpractice,inlieuofafullpointeranalysis.
4. Solvinginteger rangeconstraints
Thedesignoftheconstraintlanguageismotivatedbythe
following intuition. Suppose we are analyzing a program
with (cid:133) variables. Consider the statespace
(cid:3)(cid:5) (cid:134)
whose -th
component records the value of the -th program variable.
We may consider an execution of the program as a path
throughthestatespace. Withthisperspective,ourgoalisto
findaminimalboundingboxthatenclosesallofthedynam-
icallypossiblepathsthroughthe (cid:133) -dimensionalstatespace.
In this section, we give an efficient algorithm for find-
ing a bounding box solution to a system of constraints. In
practice, our algorithm scales linearly on our benchmarks.
Notice that the solution to the constraint system gives us
bounds on the ranges of each program variable standing
alone, but cannot give us any information on relationships
that hold between multiple program variables. As an al-
ternative, we could imagine computing a minimal convex
polyhedronthatenclosesalltheexecutionpaths(using,e.g.,
the simplex method). This would return more precise re-
sults, but it would probably also scale up very poorly to
the large problem instances encountered when analyzing
real-worldprograms. Forinstance,sendmailcontainsabout
32knon-comment,non-blanklinesofCcode,andityields
a constraint system with about 9k variables and 29k con-
straints. The simplification to bounding boxes is what al-
lowstheconstraintsolvertorunveryefficiently.
Wedevelopaboundingboxalgorithmbybeginningwith
thesimplestcase: assumethatarithmeticandmin/maxex-
pressions are omitted, so that each constraint has the form
(cid:135)’ W q< (cid:136) [
(cid:23)
q! (cid:137)
,where
(cid:3)(cid:5) (cid:4) (cid:21)
(cid:135) "F (cid:138)(cid:20) (cid:139) (cid:6) (cid:11)! (cid:140) z{
(cid:128)
(cid:140)b (cid:18)(cid:22) (cid:129) $
(cid:128)
" (cid:3) (cid:16)9 (cid:129)(cid:5) "
is an affine function on
(cid:3)(cid:15) (cid:4)
extended to operate on
rangesinthenaturalway, i.e.,
(cid:135)’ W
(cid:24)
[ (cid:6) (cid:11) (cid:135)’ W(cid:142) (cid:141) [ $ (cid:141) "
(cid:24)
(cid:21)
(cid:23)
(cid:3)(cid:5) (cid:4)
.
We form a directed graph whose vertices are the vari-
ables
q< (cid:136)
. For each constraint
(cid:135)’ W q< (cid:136) [
(cid:23)
q! (cid:137)
we add the la-
beled directed edge
q (cid:136)(cid:144) (cid:143){ q (cid:137)
. Each vertex
q (cid:136)
is marked
with a range y
W q (cid:136) [
giving the current estimate of the so-
lution. All ranges are initially set to y
W q (cid:136) [ $(cid:6)(cid:146) (cid:145)
. Then
constraints of the form
(cid:28)
(cid:23)
q
are processed by setting
y
W q< (cid:136) [ $(cid:6)
RANGE-CLOSURE
W
y
W q< (cid:136) [ (cid:9) (cid:11)O (cid:28)’ (cid:21)C [
and the solver
iscalled.
The solver works by propagating information in this
graph. We say that an edge
q (cid:136) (cid:143){ q (cid:137)
is active if
(cid:135)’ W
y
W q< (cid:136) [0 [ ]
(cid:23)(cid:147) y
W q! (cid:137) [
. To propagate information along such
anactiveedge(alsoknownasrelaxation),weset y
W q! (cid:137) [ $(cid:6)
RANGE-CLOSURE
W
y
W q! (cid:137) [ (cid:9) (cid:135)’ W
y
W q< (cid:136) [(cid:29) [0 [
. Anaugmentingpath
is one containing only active edges. (This wording is in
deliberateanalogytostandardalgorithmsforshortest-paths
and network flow problems.) The goal of the algorithm is
to find augmenting paths and propagate information along
thembyrelaxingtheupperboundsonthesolution.
Iftheresultingdirectedgraphisacyclic,wecantrivially
solvetheconstraintsysteminlineartime: wetopologically
sortthegraphandpropagateinformationalongeachedgein
sortedorder.Graphswithcyclesarehardertohandle.
The approach given above can be rephrased in the per-
hapsmorefamiliarlanguageoffixpointsoverlattices. Each
constraint
(cid:135)’ W q< (cid:136) [
(cid:23)
q! (cid:137)
induces a continuous function (cid:148) on
assignmentsgivenby
W
(cid:148)
W
y
[(cid:29) [ W q
(cid:134)
[ (cid:6)(cid:150) (cid:149) y
W q (cid:137) [ (cid:9) (cid:135)’ W
y
W q (cid:136) [0 [
if
y
W q
(cid:134)
[
~ (cid:6)
(cid:133)
otherwise
(cid:16)
andinthiswaytheconstraintsystemgivesusasetofsuch
functions
(cid:11)
(cid:148)
(cid:21)
. Now note that a satisfying assignment for
the constraint system forms a fixpoint for all the (cid:148) ’s, and
vice versa. Therefore, we are seeking the least fixpoint of
the functions
(cid:11)
(cid:148)
(cid:21)
, because it will be the least solution to
theconstraintsystem.
Wecouldsearchforthefixpointusingastandardworklist
algorithmthatvisitsalltheaugmentingpathsinbreadth-first
orderandpropagatesinformationalongthembyrelaxation.
However,thebasicworklistalgorithmwouldexhibitserious
problems: inthepresenceofcycles,itmightnotterminate!
Forinstance, considertheconstraintsystemcontainingthe
two constraints
n
(cid:23)
q
and
q (cid:18)U 6
(cid:23)
q
. A naive algorithm
wouldloopforever,revisingitsinitialestimate y
W q [ (cid:6) n2
(cid:26)
(cid:16)9 nC (cid:30)
to
n-
(cid:26)
(cid:16)9 oP (cid:30)
,
n2
(cid:26)
(cid:16)i (cid:151)! (cid:30)
,
n-
(cid:26)
(cid:16)9 (cid:152)P (cid:30)
,etc. This“countingtoinfinity”behav-
iorarisesbecausethelatticeofrangeshasinfiniteascending
chains, andthus themonotonicity of
(cid:11)
(cid:148)
(cid:21)
isnotenoughto
ensuretermination.
Atthispoint,wehavethreeoptionsforrestoringtermina-
tion.
1. We could restrict attention to those programs that in-
duceacyclicconstraintsystems.
62. We could introduce a widening operator that raises
variables involved in cycles to the trivial solution
(cid:12)(cid:15)
(cid:26)
(cid:14)(cid:17) (cid:16)(cid:19) (cid:14)(cid:127) (cid:30)
, as pioneered in [10] and [11]. This avoids
infiniteascendingchains.
3. Wecoulddirectlysolvetheconstraintsubsystemasso-
ciatedwitheachcycle,usingdomain-specificinforma-
tionabouttheconstraintlanguage.
The first is not very attractive, because real programs of-
ten involve cycles, such as those created by loops and re-
cursion. Even worse, cycles are almost unavoidable for a
flow-insensitive analysis: for example, the C assignment
i = i1+willalwaysinduceacycleintheformofacon-
straint
(cid:153) (cid:18)U 6
(cid:23) . One disadvantage of the second option
isthatitintroducesimprecision,i.e.,itwillonlyprovidean
approximate solution (an upper bound onthe least satisfy-
ingassignment).
This paper follows the third option. We show how to
avoid divergent behavior, without introducing any impre-
cision,bydirectlysolvingforthefixpointoftheconstraint
subsystemassociatedwitheachcycle.
Atypicalcyclelookslike
(cid:135)7 (cid:154)P W q (cid:154) [
(cid:23)
q< (cid:155) (cid:16)(cid:20) sO s= st (cid:16) (cid:135)P (cid:156)- (cid:157)t (cid:154)P W q (cid:156)Q (cid:157)t (cid:154) [
(cid:23)
q (cid:156) (cid:16) (cid:135)< (cid:156)t W q (cid:156) [
(cid:23)
q (cid:154) s
Transitivelyexpandingthis cycle,we findthat
(cid:135)’ W q (cid:154) [
(cid:23)
q (cid:154)
where
(cid:135) (cid:6) (cid:135)P (cid:156)Y (cid:158)R (cid:159)O (cid:159)= (cid:159)t (cid:158)‘ (cid:135)7 (cid:154)
. (We may view
(cid:135)
loosely as
Shostak’sloopresidue[56]forthecycle.) Thecomposition
ofaffinefunctionsisaffine,so
(cid:135)
isaffine. Theobservation
is that we can precisely solve this cyclic constraint system
without anydivergencewhatsoever,byusing a simple fact
onthefixpointsofaffinefunctions.
Lemma1. Let
(cid:135)’ W (cid:140)(cid:31) [ (cid:6)
(cid:128)
(cid:140)‘ (cid:18)N (cid:129)
beanaffinefunctionin
(cid:138)(cid:20) (cid:139)
with (cid:128)(cid:150) (cid:132)
8
, let (cid:24) be a range, and let
(
(cid:23)
(cid:3)(cid:15) (cid:4)
be the
minimalrangesatisfying (cid:24)(cid:160) (cid:23)
(
and
(cid:135)’ W¡ ( [
(cid:23)
(
. Then(1)
.0 /2 1
( (cid:6) (cid:14)
if .0 /2 1
(cid:135)’ W
(cid:24)
[
(cid:132)¢ .0 /2 1K (cid:24) ; also, (2) )e*2 ,
( (cid:6) (cid:12)(cid:15) (cid:14)
if )+*- ,
(cid:135)’ W
(cid:24)
[Y £
)+*- ,m (cid:24) . If neither clause (1) nor clause (2)
applies, we have
( (cid:6)
(cid:24) . If both clauses apply, we have
( (cid:6) (cid:12)(cid:15)
(cid:26)
(cid:14)(cid:17) (cid:16)(cid:19) (cid:14)(cid:127) (cid:30)
CONSTRAINT-SOLVER
1. Set
.
Theorem2. Wecansolvetheconstraintsubsystemassoci-
atedwithacycleinlineartime.
Torestatethetheoremintuitively: ifweeverfindanaug-
menting path that traverses an entire cycle, the theorem
shows us how to immediately apply a widening operator
without any loss of precision whatsoever. This provides a
simplewaytoavoidthe“countingtoinfinity”behaviorthat
arisesfromtraversingacyclemultipletimes. Thus,thereal
contribution of Theorem 2 is that it shows how to find the
fixpointofthesystempreciselyandefficiently;sinceweare
workinginalatticewithinfiniteascendingchains,standard
techniquescannotprovidethis.
Figure 4 presents an algorithm that uses these ideas to
handle cycles efficiently. This time, we use a depth-first
y
W q (cid:136) [ $(cid:6)S (cid:145)
forall ,andsetdone
$(cid:6)
false.
2. Foreachconstraintoftheform
(cid:28)
(cid:23)
w
,do
3. Set y
W w [ $(cid:6)
RANGE-CLOSURE
W
y
W w [ (cid:9) (cid:11)O (cid:28)’ (cid:21)P [
.
4. Whiledone
](cid:6)
true,callONE-ITERATION.
ONE-ITERATION
1. Set ⁄
W q (cid:136) [ $(cid:6)
whiteforall andsetdone
$(cid:6)
true.
2. Foreachvariable
q
,do
3. If ⁄
W q [ (cid:6)
white,do
4. Setprev
W q [ $(cid:6)
nullandcallVISIT(
q
).
VISIT(
q
)
1. Set ⁄
W q [ $(cid:6)
gray.
2. Foreachconstraintoftheform
(cid:135)’ W q [
(cid:23)
w
,do
3. If
(cid:135)’ W
y
W q [(cid:29) [ ]
(cid:23)(cid:22) y
W w [
,do
4. Set y
W w [ $(cid:6)
RANGE-CLOSURE
W
y
W w [ (cid:9) (cid:135)’ W
y
W q [(cid:29) [(cid:29) [
.
5. Setdone
$(cid:6)
false.
6. If ⁄
W w [ (cid:6)
gray,callHANDLE-CYCLE(
q
,
w
,prev).
7. If ⁄
W w [ (cid:6)
white,do
8. Setprev
W w [ $(cid:6)^ q
andcallVISIT(
w
).
9. Set ⁄
W q [ $(cid:6)
black.
RANGE-CLOSURE(
(
)
1. Returntherange (cid:26))+*- ,
( (cid:16)
.(cid:29) /; 1
( (cid:30)
.
Figure4.Analgorithmthatefficientlysolvessys-
temsofintegerrangeconstraints.
search so that we can recover the edges participating in
the cycle as soon as we see a back-edge. The HANDLE-
CYCLE procedure(leftunspecifiedhere,forspacereasons)
retracesthecyclediscoveredinthedepth-firstsearchusing
the predecessor pointers and then processes that cycle us-
ing the algorithm sketched in the proof of Theorem 2 (see
AppendixA).
Intheory,this solutionprocesscouldtake ¥
W(cid:29) W (cid:28)Y (cid:18)
(cid:27)
[
(cid:133)
[
timeintheworstcase,where (cid:133) countsthenumberofcycles
inthegraph. Inpractice,though, (cid:133) seemstobesmall, and
thealgorithmusuallyrunsinlineartime,probablybecause
of sparsity and locality in the constraint systems that arise
duringtheanalysisoftypicalprograms.
This concludes our treatment of constraint solving for
simpleconstraints. Wehaveextendedthealgorithmtohan-
dlethefullconstraintlanguage,includingmulti-variableex-
pressionsand min/maxoperators. See Appendix B for the
details.
5. Earlyexperience withthe prototype
This section details some early experience with the cur-
rentversionoftheoverrundetectiontool.
Theexperimentalmethodologywassimple. Thetoolwas
appliedtoseveralpopularsoftwarepackages.Thetooltypi-
callyproducedanumberofwarningsaboutpotentialbuffer
7overruns, and one of us examined the source by hand to seemexploitableinpracticebecausetherelevantinputsare
screen out the false alarms. Some sample output is shown not under adversarial control. Nonetheless, the new bugs
inFigure5. identifieddodemonstratethepotentialtofindsubtlecoding
We appliedthetooltoaboutadozensoftwarepackages. errorsinrealcodeusingautomatedanalysistechniques.
Duetolackofspace,weomitthecaseswherethetoolfound The most important bug identified by the tool was a
nothingofinterest. complex off-by-one error in the management of string
buffers. This bug is hinted at by the warning about
5.1.Linuxnettools ‘dfname@collect()’: the tool discovered that 20
bytes were allocated for a buffer called dfname (defined
Thebestsuccessstorysofararosefromananalysisofthe
inthecollect()procedure),andthatastringcontaining
Linuxnettoolspackage,whichcontainssourceforstan-
possiblyasmanyas257bytesmightbecopiedintothe20-
dard networking utilities such as netstat, ifconfig,
bytebuffer. Thisisapotentialviolationofthesafetyprop-
route, and so on. The programs themselves total about
erty. In this case, the tool suggests that the lengthy string
3.5k lines of code, with another 3.5k devoted to a support
camefromthereturnvalueofqueuename(),butwasnot
library1.
abletoidentifyanyfurtherdependenciesofinterest.
This package had already been audited by hand once
Upon further investigation, using other diagnostics from
in 1996 after several buffer overruns were found in the
the tool, we found that a complexsequence of invocations
code [31], so it came as somewhat of a surprise when the
can cause queuename() to return a 21-byte string (in-
tool discovered several serious and completely new buffer
cluding the terminating ’\0’). (The 257-byte figure is
overrun vulnerabilities. One library routine trusts DNS
a result of imprecision in the analysis.) The troublesome
responses and blindly copies the result of a DNS lookup
sequence is: orderq() reads a file from the queue di-
into a fixed-length buffer, trusting both the hp->h_name
rectory, and copies its filename (possibly as many as 21
and hp->h_length values returned. In both cases, this
byteslong,includingthe’\0’)intod->d_nameandthen
trust is misplaced. Another routine blindly copies the
into w->w_name; then runqueue() calls dowork(w-
result of a getnetbyname() lookup into a fixed-size
>w_name+2,...), and dowork() stores its first argu-
buffer. At first glance, this may appear harmless; how-
ment (which can be as long as 19 bytes) into e->e_id;
ever, getnetbyname()may issuea NIS networkquery
next queuename() concatenates "qf" and e->e_id,
in some cases, and thus its response should notbe trusted.
returning the result, which is copied into dfname; but
Severalotherplacesalsoperformuncheckedstrcpy()’s
queuename()’sreturnvaluemightbeaslongas19+2=21
into fixed-size buffers on the stack that can apparently be
bytes long (including the ’\0’), which will overflow the
overrunbyspoofingDNSorNISresultsorbysimplyregis-
20-bytedfnamebuffer.
teringahostwithanunexpectedlylongname.
This minor bug is the result of a common off-by-one
These vulnerabilities seem likely to be remotely ex-
error: the programmer apparently forgot to include the
ploitable2. Itisworthstressingthattheseholeswereprevi-
stringterminator’\0’whencountingthenumberofbytes
ouslyunknown,despiteanearliermanualauditofthecode.
neededtostorethereturnvaluefromqueuename(). The
5.2.Sendmail8.9.3 very complexcalling pattern needed to trigger this pattern
illustrates why this type of bug is so difficult for humans
Thelatestversionofsendmail(about32klinesofCcode) to find on their own and why automated tools are so well
wasone ofthe firstprogramsanalyzed. Somesampleout- suitedforthistask.
put is shown in Figure 5, which shows (for example) that Wenotethatthiscodingerrorsurvivedatleastoneman-
solving the constraint system took less than two seconds; ual audit (the bug predates version 8.7.5, and survived an
also,Section5.5presentsamoredetailedstudyofthewarn- extensive sweep of the code apparently inspired by CERT
ings fromthe tool. Sendmail makesanespeciallyinterest- advisoryCA-96.20).
ingtest,becauseithasbeenextensivelyauditedbyhandfor For completeness, we explain some of the other
bufferoverrunsandothervulnerabilities. Also,wefeelthat warning messages in Figure 5. The warning about
itmakesforaverythoroughtestoftheapplicabilityofthe ‘from@savemail()’ is caused by imprecision in the
tooltolarge,complexapplications. analysis. Therelevantcodelookssomethinglikethis:
Thetestingsessiondidnotuncoveranysecurityvulnera-
bilitiesinsendmail-8.9.3. Afewsmallbugswereidentified if (sizeof from
thatcouldintheoryleadtobufferoverruns,buttheydonot < strlen(e->e_from.q_paddr) + 1)
break;
1Throughoutthispaper,weexcludecommentsandblanklinesfromour
strcpy(from, e->e_from.q_paddr);
countsofcodesizes.
2Wehaven’twrittenexploitcodetoconfirmthis,butexaminationofthe
Ahumanwouldrealizethatthestrcpy()isnotreached
sourcesuggeststhatstandardattacksarelikelytowork.
8Warning: function pointers; analysis is unsafe...
1.74user 0.07system 0:01.99elapsed 90%CPU
Probable buffer overflow in ‘dfname@collect()’:
20..20 bytes allocated, -Infinity..257 bytes used.
<- siz(dfname@collect())
<- len(dfname@collect()) <- len(@queuename_return)
Probable buffer overflow in ‘from@savemail()’:
512..512 bytes allocated, -Infinity..+Infinity bytes used.
<- siz(from@savemail())
<- len(from@savemail()) <- len((unnamed field q_paddr))
Slight chance of a buffer overflow in ‘action@errbody()’:
7..36 bytes allocated, 7..36 bytes used.
<- siz(action@errbody())
<- len(action@errbody())
...
Figure5.Someexampleoutputfromtheanalysistool. Thisexampleisasmallsampleofsomeofthemore
interestingoutputfromananalysisrunofsendmail8.9.3.
unlessitissafetoexecute.Thetooldoesnotfindthisproof
ofsafetybecausetherangeanalysisisflow-insensitiveand
thusblindtotheifstatement.
The warning about ‘action@errbody()’ (another
falsealarm)isalsoinstructive.Therelevantsectionofcode
hasthefollowingform:
char *action;
if (bitset(QBADADDR, q->q_flags))
action = "failed";
else if (bitset(QDELAYED, q->q_flags))
action = "delayed";
Wecanreadilyseethatalloc
W
action
[ (cid:6)
len
W
action
[
al-
waysholdsforthiscodesegment,sothereisnosafetyprob-
lem. However,the“boundingbox”rangeanalysisisfunda-
mentallyunabletodetectinvariantsdescribingthepossible
relationshipsbetweenvaluesofprogramvariables—another
form of imprecision—so it is unable to detect and exploit
thisinvarianttoprovethecodesafe.
Inthis case, the analysiscan only assumethat the string
action may have as few as 7 bytes allocated for it but
as many as 8 bytes copied into it. This happens fairly of-
ten: whenapointercanrefertomultiplestringsofdifferent
lengths,theanalysisusuallyreportsthatitssizeandlength
bothhavethesamerange
(cid:131)m
(cid:26)
(cid:16)
p
(cid:30)
,andwhen pƒ (cid:132)
(cid:131)
completedthetaskmorequickly,butitwouldstillundoubt-
edlybeatime-consumingprocess.
5.3.Sendmail8.7.5
Findingnewsecurityvulnerabilitiesisacompellingway
tovalidatetheeffectivenessofthetool,butitrequirescon-
siderable time with no guarantee of positive results. As a
time-savingalternative,weappliedthetooltooldsoftware
known to contain serious vulnerabilities to see if the bugs
couldhavebeendetected. Sendmailisoneoftheclassicex-
amplesofanapplicationthathasbeenvulnerabletobuffer
overrunsinthepast. SinceCERTreportedseveraloverruns
in sendmail 8.7.5 (see CA-96.20), and since the next ver-
sionwasauditedbyhandtotrytoeliminatesuchbugs,we
decidedtousethisasatestplatform.
Thetoolfoundmanypotentialsecurityexposuresinsend-
mail8.7.5:
thereisno
way to rule out the possibility of a problem. We use sev-
eralheuristicstotrytodetectthisclassoffalsealarmsand
prioritizeallwarnings: thisclassofviolationsofthesafety
propertyislabelled“Slightchanceofabufferoverrun.”
OneaspectofthistrialthatisnotapparentfromFigure5
is the large number of false alarms encountered (see Sec-
tion5.5). Weedingthroughthefalsealarmstookafullday
of staring at warning messages and source code. A devel-
oper already experienced in sendmail internals might have
(cid:2)
Anuncheckedsprintf()fromtheresultsofaDNS
lookuptoa200-bytestack-residentbuffer;exploitable
from remote hosts with long DNS records. (Fixed in
sendmail8.7.6.)
(cid:2)
An unchecked sprintf() to a 5-byte buffer from
a command-line argument (indirectly, via several
other variables); exploitable by local users with
“sendmail -h65534 ...”. (Fixedin8.7.6.)
(cid:2)
An unchecked strcpy() to a 64-byte buffer when
parsingstdin;locallyexploitableby“echo /canon
aaaaa... | sendmail -bt”. (Fixedin8.7.6)
(cid:2)
Anuncheckedcopyintoa512-bytebufferfromstdin;
try“echo /parse aaaaa... | sendmail
-bt”. (Fixedin8.8.6.)
9Improvedanalysis Falsealarmsthatcouldbeeliminated
flow-sensitive
6! §(cid:13) ¤P :5 8(cid:20) '(cid:17) :(cid:13) (cid:152)(cid:13) “
flow-sens. withpointeranalysis
>5 n5 ¤P :5 8(cid:20) '^ o5 ?(cid:13) “
flow-andcontext-sens.,withlinearinvariants
>7 (cid:152)(cid:13) ¤P :5 8(cid:20) 'S (cid:151)< 8(cid:13) “
flow-andcontext-sens.,withpointeranalysisandinv.
?5 (cid:152)(cid:13) ¤P :5 8(cid:20) '^ §(cid:13) n5 “
Table2.Expectedreductioninfalsealarmsfromseveralpotentialimprovementstotheanalysis.
(cid:2)
Anuncheckedsprintf()toa257-bytebufferfrom
a filename; probably not easily exploitable. (Fixed in
8.7.6.)
(cid:2)
A call to bcopy() could create an unterminated
string,becausetheprogrammerforgottoexplicitlyadd
a’\0’;probablynotexploitable. (Fixedby8.8.6.)
(cid:2)
An unchecked strcpy() in a very frequently used
utilityfunction. (Fixedin8.7.6.)
(cid:2)
Anuncheckedstrcpy()toa(static)514-bytebuffer
from a DNS lookup; possibly remotely exploitable
with long DNSrecords, butthe bufferdoesn’tliveon
the stack, so the simplest attacks probably wouldn’t
work. Also,thereisatleastoneotherplacewherethe
result of a DNS lookup is blindly copied into a static
fixed-sizebuffer.(Fixedin8.7.6.)
(cid:2)
importantpropertyofthesystemisthatitscalesupreadily
tofairlylargeapplications3.
5.5.Limitations
Themainlimitationoftheprototypeisthelargenumber
offalsealarmsitproduces,duetoimprecisionintherange
analysis. Asaconsequence,ahumanmuststilldevotesig-
nificanttimetocheckingeachpotentialbufferoverrun.
Our tool generates 44 warnings marked Probable for
sendmail 8.9.3. Four of these were real off-by-one bugs,
whichleaves40falsealarms. Despitethehighsuccessrate
(1in10warningsindicatedrealbugs),eliminatingthefalse
alarmsbyhandstillrequiresanon-negligiblelevelofhuman
effort.
One way to reduce the number of false alarms requir-
ing human attention is to trade off time for precision in
theintegeranalysis. Forexample,wecouldenvisionmov-
Several places where the results of a NIS network ing to a flow-sensitive or context-sensitive analysis. This
query is blindly copied into a fixed-sizebuffer on the obviously raises the question of which improvements are
stack; probably remotely exploitable with long NIS worth the effort and at what cost. To estimate the poten-
records. (Fixedin8.7.6and8.8.6.) tialbenefitsofvariouspossibleimprovementstotheanaly-
sis,weclassified—byhand—thecausesofeachfalsealarm
Mostofthesecodingerrorsbecameathreatonlybecauseof
in sendmail 8.9.3. See Table 2 for the results. (A linear
subtleinteractionsbetweenmanypiecesoftheprogram,so
invariant is a simple, linear relationship between program
thebugswouldnotbeapparentfromlocalizedspot-checks
variables—suchasx
ofthesource. Thisseemstobeagooddemonstrationofthe
potentialforfindingrealvulnerabilitiesinrealsoftware.
To our knowledge, none of the vulnerabilities found in
sendmail8.7.5byourtoolhavebeendescribedpubliclybe-
fore.
5.4.Performance
Inourexperience,theperformanceofthecurrentimple-
mentation is sub-optimal but is usable. For example, the
analysisofsendmail(about32klinesofCcode)tookabout
15 minutes of computation on a fast Pentium III worksta-
tion: a few minutes to parse the source, the rest for con-
straintgeneration, anda fewsecondstosolvetheresulting
constraintsystem.
Theprototypegenerates extensivedebuggingoutputand
hasnotbeenoptimized,soweexpectthattheanalysistime
couldbereducedwithadditionaleffort. Ontheotherhand,
thetimerequiredtoexamineallthewarningsbyhandcur-
rently dwarfs the CPU time needed by the tool, so better
performanceisnotanimmediatepriority.Fornow,themost
(cid:18)
y
£(cid:17) n
oralloc
W
buf
[D «
buflen—
thatholdsinallprogramexecutions.)
These figures suggest that, in retrospect, it might have
been better to use a more precise but slower analysis. We
expectthatstandardanalysistechniques(suchasSSAform
[13], Pratt’s method [49] or Shostak’s loop residues [56],
and a points-to analysis) could be used to improve on our
currentprototypebyanorderofmagnitudeormore. How-
ever, significant engineering effort is probably required to
getthere.
Despite the unwieldy number of false alarms produced
byourtool,ourapproachisstillasubstantialimprovement
over the alternative: in a typical code review, one would
identifyallthepotentiallyunsafestringoperations(perhaps
usinggrep),tracebackallexecutionpathsleadingtothose
unsafe operations, and manually verify that none of them
lead to exploitable overruns. For comparison, there are
about 695 call sites to potentially unsafe string operations
3Wehave noexperiencewithverylarge applications, e.g., programs
withhundredsofthousandsoflinesofcode,soitremainsunknownhow
ourtechniquesscaleuptosuchprogramsizes.
10inthesendmail8.9.3sourcewhichwouldneed tobeman-
ually checked in a typical code audit—
6C n M
more than the
number that must be examined with our tool—so we con-
cludethatourtoolisasignificantstepforward.
Oneimportantgapinourunderstandingoftheprototype’s
limitations is that it is difficult to rigorously measure the
false negative rate. As a first approximation, we may ex-
amine all the buffer overruns in sendmail that have been
fixed in the three years since the release of version 8.7.5;
anysuchbugnotreportedbythetoolisafalsenegative.To
ourknowledge,theonlypublicly-reportedoverruninsend-
mail8.7.5isthechfnvulnerability[44],wherealocaluser
canoverflowa257-bytebufferbychangingtheirgecosfield
in /etc/passwd. Due to pointer aliasing and primitive
pointer operations, our tool does not find the chfn bug,
although a better pointer analysis would have revealed the
problem.Adetailedmanualexaminationofthesourcecode
revision history shows that a number of other buffer over-
runs insendmail8.7.5havebeen quietlyfixedwithout any
public announcements4. As far as we know, our tool finds
all of those vulnerabilities (see Section 5.3 for examples).
Thisevidencesuggeststhatourtool’sfalsenegativerateis
non-negligiblebutstillacceptable.
A final problem with the tool is that it does not provide
asmuchinformationabouteachpotentialbufferoverrunas
we might like. As can be seen from Figure 5, the output
shows only which buffer overflowed, not which statement
wasatfault.Thisambiguityisarguablyanunfortunatecon-
sequence of the constraint-based formulation. To improve
the situation somewhat, we extended the constraint solver
toreportwhich variable(s)contributedtoeachviolationof
thesafetyproperty.Thisheuristicisnotalwaysreliable,but
itdoeshelp.
6. Relatedwork
LINEARPROGRAMMING. Manypapershavesuggestedus-
inglinearprogrammingtechniquestodiscoverprogramin-
variants, including the simplex method, Fourier-Motzkin
variableelimination[53],theOmegamethod[50],theSUP-
INF method [5, 55], Shostak’s loop residues [56], and al-
gorithms for special classes of linear systems [30, 9, 38].
Typically,onecombineslinearprogramming withabstract
interpretationoversomesimpledomain(convexpolyhedra,
octagons,etc.) [10,11,23,25,26,24,52]. Inthiscontext,
linear programming algorithms provide a tool for manipu-
latingsubsets of
(cid:3)(cid:5) (cid:134)
, with operations such as
(cid:9)
, ‹
simplex method. Although the simplex-based techniques
offermoreprecisionthanourrangeanalysis,itisnotclear
howwelltheyscale.
PARALLELIZING COMPILERS. One important application
forarrayreferenceanalysisisindiscoveringimplicitparal-
lelisminsequentialFortranprograms[40,4,50];however,
those techniquesdo not seem to help with the bufferover-
runproblembecausetheyfocustoonarrowlyonthespecial
caseofloopoptimization.
ARRAY BOUNDS CHECKING. One way to avoid buffer
overruns is to use runtime array bounds checks. There
are several implementations of array bounds checking for
C, including SCC [3], gcc extensions [35], Purify [51],
and BoundsChecker [46]. However, many of these tools
impose a large performance overhead (instrumented pro-
gramsaretypically2–3
, projec-
tion, widening, and testing for feasibility. See especially
[11]foranearlyexampleofatoolthatinferslinearinvari-
antsofsmallprogramsusingabstractinterpretationandthe
4We do not know whether these bugs were known to the sendmail
developers, or whether they were fortuitously eliminated by the more-
defensiveprogrammingstyleinitiatedinversions8.7.6and8.8.0.
M
slowerthantheoriginalversions
[3, 35, 8, 22]). As a result, the tools areusually usedonly
fordebugging,notforproductionsystems.
Toreducethehighcostofruntimeboundschecking,sev-
eral researchers have studied optimization techniques for
eliminating redundant checks [22, 39, 57]. However, they
typicallyfocusonmovingboundscheckstolessfrequently
executed locations, rather than on eliminating all bounds
checks. For example, hoisting bounds checks out of loops
using loop invariants greatly reduces the performance im-
pact of the bounds checks but cannot reduce the number
of checks in the program’s source code. Therefore, these
optimization techniques are not well suited for proactively
findingbufferoverruns.
Otherworkshaveconcentratedoneliminatingallbounds
checksforsometype-safelanguages. Forexample,Necula
andLeedevelopacertifyingcompilerforatype-safesubset
of C that eliminates most bounds checks using Shostak’s
loopresidues[45].Also,XiandPfenningproposeamethod
to eliminate runtime array bounds checking for ML with
the help of some assertions added by the programmer to
capturecertainprograminvariants[60,61].Ofcourse,none
ofthesetoolscaneliminatebufferoverrunsinlargelegacy
applicationswritteninC.
RANGE ANALYSIS. Ourapproachto rangeanalysis builds
on much prior work in the literature, including early work
on abstract interpretation [10] and range propagation [27]
as well as more mature work on systems for static debug-
ging[6],generalizedconstantpropagation[59],andbranch
prediction[47];however,ouremphasisonanalysisoflarge
programsspurredustodevelopnewtechniqueswithbetter
scalingbehavior.
CONSTRAINT-BASED ANALYSES. Philosophically, our
analysis may be viewed as a constraint-based analysis [1];
however,itisunusualtoincorporatearithmeticexpressions
inthesetconstraintlanguageandsolver(butsee[28]foran
importantpartialexception).
11Note also that techniques for solving integer constraint
systemsmaybefoundintheartificialintelligenceliterature
[14, 32, 37, 58]; however, their algorithms typically stress
generalityforsmallproblems(“hundredsofnodesandcon-
straints”[14])overscalabilityandthusarenotdirectlyap-
plicablehere.
LINT-LIKE TOOLS. Severalcommonly used tools [34, 18,
19] use static analysis and some heuristics to detect com-
mon programming errors (such as type errors, abstraction
violations,andmemorymanagementbugs),butthesetools
don’tdetectbufferoverruns.
Many practitioners have noted that grep can be a use-
fulifcrudetestforfindingbufferoverrunsbysearchingfor
all uses of unsafe string operations; however,a substantial
timeinvestmentisoftenrequiredtodealwiththeverylarge
number of false alarms. Our results demonstrate an
6C n M
lemintermsofintegerrangetrackingallowsustobuildon
techniquesfromprogramanalysis.
We conclude that this provides a powerful and success-
ful new approach to finding buffer overrun vulnerabilities.
Weattributeitssuccesstothenewmethodologyintroduced,
where we apply static analysis to security problems. One
major advantage of static analysis is that it allows us to
proactivelyeliminatesecuritybugsbeforecodeisdeployed.
Ideally,wewouldlikeatoolthatcouldcatcheverybuffer
overrun. Although our tool does not detect all exploitable
overruns, it still finds more than humans do, which shows
thatwehavemaderealprogresstowardthisgreatergoal.
8. Acknowledgements
Wearegratefultoanumberofreaderswhosecomments
have substantially improved the paper, including Crispin
improvementovergrepforthecaseofsendmail8.9.3(see
Cowan,GeorgeNecula,AdrianPerrig,JohnViega,andthe
Section5.5).
anonymousreviewers.ThanksespeciallytoStevenBellovin
PROGRAM VERIFICATION. ESC is an automated program (for bringing our attention to some of the limitations of
checkerforModula-3andJavathatcatchesmanyprogram- dynamic testing in security applications) and to Manuel
ming errors at compile-time, using program verification Fa¨hndrich (for early discussions on the basic approach to
techniques[15]. OnedisadvantageofESCisthatitrequires modellingstringbuffers).
coderstoannotatemoduleinterfaceswithinformationabout
expectedpre-andpost-conditions,butitcanusethisinfor- References
mationtofindaverylargeclassofpotentialbugs.
[1] A.Aiken, “Setconstraints: results, applications, andfuture
STACKGUARD. Stackguardisaruntimetoolwhichdetects
directions,”PPCP’94:PrinciplesandPracticeofConstraint
buffer overruns on the stack before they cause harm [12]. Programming,Springer-Verlag,pp.326–335.
Stackguard imposes very little performance overhead and
[2] A. Aiken, M. Fa¨hndrich, J.S. Foster, Z. Su, “A toolkit
has been applied to large suites of applications, including
for constructing type- and constraint-based program analy-
anentireLinux distribution. Stackguardis apowerfultool
ses,”TIC’98: TypesinCompilation,Springer-Verlag,1998,
that can serve as a strong deterrent against many existing pp.78–96.
bufferoverrunattacks;however,itdoesnotstopalloverrun
[3] T.M.Austin,S.E.Breach,G.S.Sohi,“EfficientDetectionof
attacks,andthusshouldnotberelieduponastheonlyline
AllPointerandArrayAccessErrors,”PLDI’94,ACM.
ofdefense.
[4] U. Banerjee, Dependence analysis for supercomputing,
KluwerAcademicPublishers,Norwell,MA,1988.
7. Conclusion
[5] W.W. Bledsoe, “The SUP-INF method in Presburger arith-
This paper introduces a simple technique for the auto- metic,”,MemoATP-18,MathDept.,U.TexasAustin,Dec.
mated detection of buffer overrun vulnerabilities. Of par- 1974.
ticular significance is its ability to analyze large, complex [6] F.Bourdoncle,“Abstractdebuggingofhigher-orderimpera-
programs. Because we trade off precision for scalability, tivelanguages,”PLDI’93,ACM.
ourtoolgeneratesarelativelylargenumberoffalsealarms, [7] Thebugtraqmailinglist,
butitseemslikelythatamoresophisticatedanalysiscould http://www.securityfocus.com/.
reducethefrequencyoffalsealarms.Wealsodemonstrated [8] F. Chow, “A portable machine-independent global
thatourprototypeimplementationcanfindevenverysubtle optimizer—Design and measurements,” Tech. report
bugs that elude human auditors. Although the tool is cer- 83-254,PhDthesis,ComputerSystemsLab,StanfordUniv.,
tainlynosubstitutefordefensiveprogrammingoracareful 1983.
codereview,ourexperiencesuggeststhatitcancomplement [9] E.Cohen,N.Megiddo, “Improvedalgorithmsforlinearin-
andreducetheburdenoftheseapproaches. equalitieswithtwovariablesperinequality,”SIAMJ.Com-
Ourimplementationhingesontwokeydesignconsidera- puting,vol.23no.6,pp.1313–1347,Dec.1994.
tions. First, treating strings asan abstractdatatype allows [10] P.Cousot,R.Cousot,“Staticdeterminationofdynamicprop-
us to recognize natural abstraction boundaries that are ob- ertiesofprograms,”Proc.2ndIntl.Symp.onProgramming,
scuredbytheCstringlibrary.Second,formulatingtheprob- Paris,Apr.1976.
12[11] P. Cousot, N. Halbwachs, “Automatic Discovery of Linear [29] G.Helmer,“IncompletelistofUnixvulnerabilities,”
RestraintsamongVariablesofaProgram,”5thACMPOPL, http://www.cs.iastate.edu/˜ghelmer/
1978,pp.84–97. unixsecurity/unix_vuln.html.
[12] C. Cowan, C. Pu, D. Maier, H. Hinton, P. Bakke, S. Beat- [30] D.S.Hochbaum,J.S.Naor,“Simpleandfastalgorithmsfor
tie,A.Grier,P.Wagle,Q.Zhang, “StackGuard: Automatic linearandintegerprogramswithtwovariablesperinequal-
Adaptive Detection and Prevention of Buffer-Overflow At- ity,”SIAMJ.Computing, vol.23no.6,Dec.1994,pp.1179–
tacks,”Proc.7thUSENIXSecurityConf.,Jan.1998. 1192.
[13] R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, F.K. [31] D. Holland, http://www.hcs.harvard.edu/
Zadeck, “An Efficient Method of Computing Static Single ˜dholland/computers/netkit.html.
AssignmentForm,”POPL’89.
[32] E. Hyvo¨nen, “Constraint reasoning based on interval arith-
[14] E.Davis,“Constraintpropagationwithintervallabels,”Arti- metic:thetolerancepropagationapproach,”ArtificialIntelli-
ficialIntelligence,vol.32no.3,July1987,pp.281–331. gence,vol.58,1992,pp.71–112.
[15] D.L.Detlefs,K.R.M.Leino,G.Nelson,J.B.Saxe,“Extended [33] http://www.infilsec.com/vulnerabilities/.
StaticChecking,”CompaqSRCResearchReport159,1998.
[34] S.C. Johnson, “Lint, aC programchecker,” Computer Sci-
[16] A.Diwan,K.McKinley,E.Moss,“Type-BasedAliasAnal- enceTech.report65,BellLaboratories,1978.
ysis,”PLDI’98.
[35] R.Jones,P.Kelly,“BoundsCheckingforC,”
[17] M.W.Eichin,J.A.Rochlis,“Withmicroscopeandtweezers: http://www-ala.doc.ic.ac.uk/˜phjk/
ananalysis oftheInternetvirusof Nov. 1988,” 1989IEEE BoundsChecking.html.
Symp.SecurityandPrivacy.
[36] O.Kirch,“ThepoisonedNULbyte,”posttothebugtraq
[18] D.Evans,J.Guttag,J.Horning,Y.M.Tan,“LCLint: atool mailinglist,Oct.1998.
forusingspecificationstocheckcode,”SIGSOFTSymp.on
[37] O. Lhomme, “Consistency techniques for numeric CSPs,”
FoundationsofSoftwareEngineering,Dec.1994.
IJCN’93: 13th Intl. Joint Conf. on Artificial Intelligence,
[19] D. Evans, “Static detection of dynamic memory errors,” vol.1,1993.
PLDI’96.
[38] G.Lueker,N.Megiddo,V.Ramachandran,“Linearprogram-
[20] R.Ghiya,L.J.Hendren,“Puttingpointeranalysistowork,” ming with two variables per inequality in poly-log time,”
POPL’98. SIAMJ.Computing,vol.19no.6,Dec.1990,pp.1000–1010.
[21] A.K.Ghosh, T.O’Connor, G.McGraw, “Anautomatedap- [39] V.Markstein,J.Cocke,P.Markstein,“Optimizationofrange
proachforidentifyingpotentialvulnerabilitiesinsoftware,” checking,” SIGPLAN Notices, vol.17 no.6, Proc. Symp. on
Proc. IEEE Symp. on Security and Privacy, May 1998, CompilerConstruction,June1982,p.114–119.
pp.104–114.
[40] D.E.Maydan,J.L.Hennessy,M.S.Lam,“EfficientandExact
[22] R.Gupta,“Optimizingarrayboundchecksusingflowanaly- DataDependenceAnalysis,”PLDI’91.
sis,”ACMLettersonProgrammingLanguagesandSystems,
[41] B.P.Miller,L.Fredricksen,B.So,“Anempiricalstudyofthe
vol.2no.1–4,Mar.–Dec.1993,pp.135–150.
reliabilityofUnixutilities,”CACM,vol.33no.12,Dec.1990,
[23] N.Halbwachs,Y.-E.Proy,P.Raymond,“Verificationoflin- pp.32–44.
ear hybrid systems by means of convex approximations,”
[42] B.P.Miller,D.Koski,C.P.Lee,V.Maganty, R.Murphy,A.
SAS’94: Static Analysis Symp., Springer-Verlag, 1994,
Natarajan,J.Steidl,“Fuzzrevisited:are-examinationofthe
pp.223–237.
reliability of Unix utilities and services,” Tech. report CS-
[24] N. Halbwachs, Y.-E. Proy, P. Roumanoff, “Verification of TR-95-1268,U.Wisconsin,Apr.1995.
real-time systems using linear relation analysis,” CAV’93:
[43] T.C. Miller, T. de Raadt, “strlcpy and strlcat—Consistent,
ComputerAidedVerification, PublishedinFormalMethods
Safe, String Copy and Concatenation,” FREENIX’99,
inSystemDesign,vol.11no.2,Aug.1997,KluwerAcademic
USENIXAssoc.,Berkeley,CA.
Publishers,pp.157–185.
[44] Mudge, “Sendmail 8.7.5 vulnerability,” post to the
[25] M. Handjieva, “Abstract interpretation of constraint
bugtraqmailinglist,Sep.1996.
logic programs using convex polyhedra,” Tech. report
[45] G.C.Necula, P.Lee, “TheDesignandImplementationofa
LIX/RR/96/06,LIX,EcolePolytechnique,May1996.
CertifyingCompiler,”PLDI’98.
[26] M.Handjieva, “STAN: A static analyzerforCLP(R) based
[46] NuMegaBoundsChecker,http://www.numega.com/
onabstractinterpretation,”SAS’96:StaticAnalysisSymp.
products/aed/vc_more.shtml.
[27] W.H. Harrison, “Compiler analysis of the value ranges
[47] J. Patterson. “Accurate Static Branch Prediction by Value
forvariables,”IEEETrans.SoftwareEngineering, vol.SE-3
RangePropagation”.PLDI’95,pp.67–78.
no.3,May1977,pp.243–250.
[48] Phrack Magazine, “The Frame Pointer Overwrite,” Sep.
[28] N.Heintze,“Setbasedanalysisandarithmetic,”Tech.report
1999,vol.9no.55.
CS-93-221,CarnegieMellonUniv.
13[49] V.R.Pratt, “Twoeasytheorieswhosecombinationishard,”
unpublishedmanuscript,Sep.1977.
[50] W.Pugh,D.Wonnacott,“Eliminatingfalsedatadependences
usingtheOmegatest,”PLDI’92,pp.140–151.
[51] PureAtriaPurify,http://www.rational.com/
products/purify_unix/index.jtmpl.
[52] P.Raymond, X. Nicollin, N.Halbwachs, D. Weber, “Auto-
matic testing of reactive systems,” Proc. 19th IEEE Real-
TimeSystemsSymp.,1998,pp.200-209.
[53] A.Schrijver,Theoryoflinearandintegerprogramming,Se-
riesinDiscreteMathematics,JohnWiley&Sons,1986.
[54] M.Shapiro,S.Horwitz,“Theeffectsofprecisionofpointer
analysis,” SAS’97: Static Analysis Symp., Springer-Verlag,
pp.16–34.
[55] R.Shostak,“OntheSUP-INFmethodforprovingPresburger
formulas,”J.ACM,vol.24no.4,Oct.1977,pp.529–543.
[56] R.Shostak,“Decidinglinearinequalitiesbycomputingloop
residues,”J.ACM,vol.28no.4,Oct.1981,pp.769–779.
[57] N. Sosuki, K. Ishihata, “Implementation of array bound
checker,”POPL’77,pp.132–143.
[58] P.VanHentenryck,H.Simonis,M.Dincbas,“Constraintsat-
isfactionusingconstraintlogicprogramming,”ArtificialIn-
telligence,vol.58,1992,pp.113–159.
[59] C. Verbrugge, P. Co, L.J. Hendren, “Generalized constant
propagation:AstudyinC,”CompilerConstruction,6thIntl.
Conf.,LNCS1060,Apr.1996,pp.74–90.
[60] H. Xi, F. Pfenning, “Eliminating array bound checking
throughdependenttypes,”PLDI’98,pp.249–257.
[61] H.Xi,F.Pfenning,“DependentTypesinPracticalProgram-
ming,”POPL’99.
A. Proofs ofthe theorems
Theorem1. Everyconstraintsystemhasauniqueleastso-
lution.
Proof. There is a natural intersection operator on assign-
ments, defined by
W
yJ ‹L |
[ W q [ (cid:6)
y
W q [
‹V |
W q [
. The inter-
section of two satisfying assignments is also a satisfying
assignment, since if y
W
p
[
(cid:23)(cid:144) y
W q [
and |
W
p
[
(cid:23)(cid:144) |
W q [
, then
W
yL ‹Y |
[ W
p
[
(cid:23)
W
yV ‹V |
[ W q [
. This means that if a constraint
systemhasaleastsolution,itisunique:supposingthereare
twominimalsatisfyingassignments y
](cid:6)
| ,then yH ‹H | isan-
other, smallersatisfying assignment, which contradicts the
assumptionofnon-uniqueness.Toshowthataleastsolution
exists,let y betheintersectionofallsatisfyingassignments.
Thisintersectionisnon-empty,sincethetrivialassignment
q^ z{ (cid:12)(cid:15)
(cid:26)
(cid:14)(cid:17) (cid:16)(cid:19) (cid:14)(cid:127) (cid:30)
satisfies every constraint system. Clearly,
if | satisfies the system, then y(cid:147) (cid:23)› | . Therefore, y is a
satisfyingassignment,anditistheleastsuch.
Lemma1. Let
(cid:135)’ W (cid:140)(cid:31) [ (cid:6)
(cid:128)
(cid:140)‘ (cid:18)N (cid:129)
beanaffinefunctionin
(cid:138)(cid:20) (cid:139)
with (cid:128)(cid:150) (cid:132)
8
, let (cid:24) be a range, and let
(
(cid:23)
(cid:3)(cid:15) (cid:4)
minimalrangesatisfying
be the
(cid:24)fi (cid:23)
(
and
(cid:135)’ W¡ ( [
(cid:23)
(
. Then(1)
.0 /2 1
( (cid:6) (cid:14)
if .(cid:29) /2 1
(cid:135)’ W
(cid:24)
[
(cid:132)(cid:150) .0 /2 1K (cid:24) ; also, (2) )+*- ,
( (cid:6) (cid:12)(cid:15) (cid:14)
if )+*- ,
(cid:135)’ W
(cid:24)
[Y £
)+*- ,m (cid:24) . If neither clause (1) nor clause (2)
applies, we have
( (cid:6)
(cid:24) . If both clauses apply, we have ( (cid:6) (cid:12)(cid:15)
(cid:26)
(cid:14)^ (cid:16)i (cid:14)F (cid:30)
.
Proof. Let (cid:24)
(cid:6) (cid:131)m
(cid:26)
(cid:16)
p
(cid:30)
, so that .0 /2 1
(cid:135)’ W
(cid:24)
[ (cid:6) (cid:135)’ W
p
[
(since
(cid:135)
is monotone and (cid:128)
«fl 6
). If
(cid:135)’ W
p
[
(cid:132)x p , then
(cid:135)’ W (cid:140)(cid:176) [
(cid:132)
(cid:140)
for
all
(cid:140)(cid:144) «
p (since (cid:128)
«(cid:7) 6
), so that
(cid:135)’ Wd (cid:135)’ W
p
[0 [
(cid:132)
(cid:135)’ W
p
[
(cid:132)– p ,
etc., and (1) is provedby induction. (2) follows similarly.
Finally, if neither clause applies, then
(cid:135)’ W
(cid:24)
[
(cid:23)† (cid:24) , and by
theminimalityof
(
wehave
( (cid:6)
(cid:24) .
Theorem2. Wecansolvetheconstraintsubsystemassoci-
atedwithacycleinlineartime.
Proof. Let
(cid:135)’ W (cid:140)(cid:31) [ (cid:6)
(cid:128)
(cid:140)b (cid:18)# (cid:129)
betheaffinefunctionassociated
withthecycle. Itsufficestoshowthattheclaimistruefor
(cid:128)F (cid:132)
8
. (If (cid:128)
(cid:6) 8
, the theoremis trivial; if (cid:128)
£‡ 8
, we tra-
versethecycletwiceand consider
(cid:135)k (cid:158)(cid:5) (cid:135)
.) We showthatit
suffices to simply compute
(cid:135)’ W
y
W q (cid:154) [0 [
and compare the re-
sultwith y
W q (cid:154) [
. If
(cid:135)’ W
y
W q (cid:154) [(cid:29) [
(cid:23)U y
W q (cid:154) [
, theleastsolutionis
y
W q (cid:154) [
,andwecanstoptraversingthecycle.Otherwise,one
or both of the clauses of the lemma apply. If both apply,
we are done: set y
W q (cid:154) [ $(cid:6) (cid:12)(cid:15)
(cid:26)
(cid:14)^ (cid:16)i (cid:14)F (cid:30)
, and let the work-
list algorithm trace out the implications for the
q (cid:137)
. If just
one applies—say, clause (1)—we simply apply the lemma
(a second time) to (cid:24)(cid:181) ·
(cid:6)
(cid:26))+*- ,m (cid:24)
(cid:16)i (cid:14)F (cid:30)
, and we will be done
after this second application. Computing
(cid:135)
requires time
linearinthelengthofthecycle,andpropagatingtheresult
oftheanalysisaroundthecyclealsorequireslineartime,so
thewholeprocessrunsinlineartime.
B.Moreonconstraint solving
In this section, we extend the basic algorithm presented
inSection4tohandlemoregeneralconstraints. Letusfirst
review how far we have come. We have an efficient algo-
rithmthathandlessimpleconstraints,i.e.,constraintsofthe
form (cid:128)
q (cid:136) (cid:18)R (cid:129)
(cid:23)
q (cid:137)
.Wehaveprecisetechniquesforhandling
cycles. But the algorithms presented so far cannot handle
arithmetic ormin/maxexpressions ontheleft hand side of
theconstraint. Suchconstraintsarerelativelyrare: fortypi-
calprogramanalysistasks,onlyabout2%oftheconstraints
usecomplexarithmeticalexpressions,andlessthan1%use
min/maxexpressions. Nonetheless,theyarestillimportant
enough that they cannot be ignored: consider, e.g., the C
statement sprintf(dst, "foo: %s %s", s, t)
to see why we need complex arithmetical expressions;
also,modellingthestandardlibraryfunctionsstrncpy(),
snprintf(), etc., clearly requires support for min/max
expressions. Wenowdescribehowtoextendthealgorithm
tohandlethesemoregeneraltypesofconstraints.
14Let ¶ be a constraint system consisting of a system of
simpleconstraints ¶t · alongwiththecomplexconstraint
(cid:128)
(cid:154) q (cid:154) (cid:18) (cid:159)= (cid:159)O (cid:159) (cid:18)
(cid:128)
(cid:156) q (cid:156) (cid:18)N (cid:129)
(cid:23)
w s
(1)
We show how to construct a reduced constraint system
(cid:24)(cid:181) •
W
¶
[
containing only simple constraints, where the least
solution to (cid:24)4 •
W
¶
[
givesa useful lower bound on the solu-
tion to ¶ . The idea is to note that, for each
~
, (1) implies
(cid:128)
(cid:137) q (cid:137) (cid:18)# (cid:129) (cid:137)
(cid:23)
w
,wherethe
(cid:129) (cid:137)
’saregivenby
(cid:129) (cid:137)(cid:5) (cid:6) (cid:129)f (cid:18)
(cid:136)e„ (cid:154)(cid:19)
‚
”…»…»…»‰ ”(cid:156)5 (cid:190) (cid:136)l ¿„(cid:176) (cid:137) (cid:128)
(cid:136)
y
W q< (cid:136) [
and y isanylowerboundontheleastsatisfyingassignment
to ¶ . Thuswe may take
~ (cid:6) 65 (cid:16)= sO s= st (cid:16)(cid:29) (cid:28)’ (cid:21) (cid:9) (cid:11)
y
W q (cid:137) [
(cid:24)4
(cid:23)
•
W
¶
(cid:137)kq
[
$
(cid:6)
~
¶
(cid:6)
·
(cid:9)
67 (cid:16)=
(cid:11)
sO
(cid:128)
s=
(cid:137)
st
q
(cid:16)0
(cid:137)
(cid:28)’
(cid:18)(cid:17)
(cid:21)
(cid:129) (cid:137)
(cid:23)
w $
,wherethe
constants
(cid:129) (cid:137)
are defined in terms of y as above. By con-
struction, any satisfying assignment for ¶ will then satisfy
(cid:24)(cid:181) •
W
¶
[
.
In principle, this immediately yields an algorithm for
solvingaconstraintsystem ¶ containingcomplexarithmeti-
cal expressions: compute the least solution | to (cid:24) •
W
⁄
[
(using the algorithm in Figure 4) and set y
$(cid:6)
y
(cid:9)
| , re-
peating these two steps iteratively until convergence. Ter-
minationisguaranteedsincea cyclein ¶ willinduceacy-
cle in (cid:24)(cid:181) •
W
¶
[
and thus will be processed efficiently by the
HANDLE-CYCLEprocedure.
Inpractice, our implementationexploitsa moreefficient
approach, where we update the reduced system (cid:24)(cid:181) •
W
⁄
[
in
place as y is updated. In the optimized algorithm, each
change to y
W q (cid:136) [
in the algorithm of Figure 4 immediately
forces an update to (cid:24)4 •
W
⁄
[
whenever
q (cid:136)
participates in the
left-hand side of somecomplexconstraint. This technique
seemstoworkverywellforourpurposes,probablybecause
complexconstraintsarerelativelyrare.
The approach used to handle to min/max constraints is
currentlyverysimplistic:thecurrentimplementationpropa-
gatesinformationthroughmin/maxconstraintsbutdoesnot
attempttohandlecyclescontainingmin/maxconstraints.In
principle,thiscouldintroduce“countingtoinfinity”,butwe
haveyettoencounterthisbehavior. Thissimplificationre-
flectsimplementationconsiderationsmorethan anyfunda-
mental difficulty with handling this type of constraints. If
weeverencountercyclescontainingminormaxoperations,
we willimplementthefollowingextensionofLemma1 to
min/maxconstraints:
Lemma2. Let
(cid:135)’ W (cid:140)(cid:31) [ (cid:6)
_‘ )e*
(cid:11)= (cid:192) (cid:154)C W (cid:140)(cid:176) [j (cid:16)= s= sO s3 (cid:16)(cid:29) (cid:192) (cid:156)(cid:176) W (cid:140)(cid:176) [j (cid:16)
(cid:130)
(cid:21)
for
(cid:192) (cid:154) (cid:16)O s= sO st (cid:16)‰ (cid:192) (cid:156) "‡ (cid:138)G (cid:139)
and (cid:130)
" (cid:3)(cid:15) (cid:4)
, where each
(cid:192) (cid:137)
is of the
form
(cid:192) (cid:137) W (cid:140)(cid:31) [ (cid:6)
(cid:128)
(cid:137) (cid:140)k (cid:18)(cid:22) (cid:129) (cid:137)
for (cid:128)
(cid:137)
(cid:132)
8
. Let (cid:24) bearange,and
let
(
(cid:23)
(cid:3)(cid:15) (cid:4)
be the minimal range satisfying (cid:24)` (cid:23)
(
and
(cid:135)’ Wd ( [
(cid:23)
(
. Then (1) )e*2 ,
( (cid:6) (cid:12)(cid:15) (cid:14)
if )+*- ,
(cid:135)’ W
(cid:24)
[\ £
)+*- ,m (cid:24) ;
also,(2) .0 /2 1
( (cid:6)
(cid:130) if .0 /2 1
(cid:135)’ W
(cid:24)
[
(cid:132)T .0 /2 1K (cid:24) . Ifneitherclause
(1)norclause(2)applies,wehave
( (cid:6)
(cid:24) . Ifbothclauses
apply,wehave
( (cid:6) (cid:12)(cid:15)
(cid:26)
(cid:14)^ (cid:16)i (cid:14)F (cid:30)
Proof. Clause (1) is an immediate consequence of
Lemma 1: if
.
)e*- ,
(cid:192) (cid:137) W
(cid:24)
[(cid:22) £
)e*- ,(cid:176) (cid:24) , then
(cid:12)(cid:15) (cid:14) " (
, since
)+*- ,
(cid:135)’ W¡ ( [
&fl )e*- ,
(cid:192) (cid:137) W¡ ( [
for all
(
. To prove clause (2), note
that .(cid:29) /; 1
(
&(cid:146) (cid:130) , so it suffices to prove that .0 /2 1
( «
(cid:130) .
Suppose not, i.e., that .0 /2 1
( £
(cid:130) . Let p
(cid:6)
.(cid:29) /; 1K (cid:24) . Since
.0 /2 1
(cid:135)’ W
(cid:24)
[
(cid:132)v .(cid:29) /2 1K (cid:24) , we have
(cid:192) (cid:137) W
p
[
(cid:132)‡ p for all
~
. Also, by
Lemma 1,
(cid:192) (cid:137) W (cid:140)(cid:31) [
(cid:132)
(cid:140)
for all
(cid:140)^ «
p and for each
~
. Since
(cid:135)’ W¡ ( [
(cid:23)
(
, we must have
.0 /2 1
(
_‘ )e*
(cid:11)= (cid:192) (cid:154)C W¡ ( [(cid:19) (cid:16)O s= sO s´ (cid:16)‰ (cid:192) (cid:156)(cid:31) Wd ( [(cid:19) (cid:16)
(cid:130)
(cid:21)
&
, and so
(cid:192) (cid:137) W
.(cid:29) /; 1
( [
&ˆ .0 /2 1
(
for all
~
. At the same
time, (cid:24)fi (cid:23)
(
implies .(cid:29) /2 1
( «
p , so
(cid:192) (cid:137) W
.(cid:29) /; 1
( [
(cid:132)v .0 /2 1
(
, a
contradiction, which establishes clause (2). Finally, if nei-
therclauseapplies,then
(cid:135)’ W
(cid:24)
[
(cid:23)S (cid:24) ,andbytheminimality
of
(
wehave
( (cid:6)
(cid:24) .
The algorithm could be further improved with slightly
moresophisticatedtechniques.Forexample,wecouldcom-
putetheacycliccomponentgraph(whereeachstronglycon-
nected component is shrunk down to one vertex) and then
iteratively process each strongly connected component in
topologicallysortedorder,usingadepth-firstsearchtodis-
coverthecycleswithineachstronglyconnectedcomponent.
However,wehavenotexploredthesepossibilitiesforopti-
mization,becausetheexistingsolverisalreadymuchfaster
thannecessary.
15