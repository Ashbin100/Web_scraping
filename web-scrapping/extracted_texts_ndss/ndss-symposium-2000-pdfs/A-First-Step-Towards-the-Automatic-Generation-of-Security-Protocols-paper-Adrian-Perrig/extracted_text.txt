On a First Step to the Automatic Generation of Security Protocols
(cid:0)
AdrianPerrig Dawn Song
perrig@cs.berkeley.edu dawnsong@cs.berkeley.edu
ComputerScience Department
Universityof California, Berkeley
Abstract
This paper describes automatic protocol genera-
tion (APG for short), a novel mechanism to gen-
erate security protocols automatically. With APG,
theprotocoldesignerinputsthespecificationofthe
desired security properties andthesystemrequire-
ments. The system requirements include a metric
function which specifies the cost or overhead of
protocolprimitives,whichdefinesanorderingover
protocolswithrespecttothemetricfunction. Based
on this ordering, APG explores the protocol space
andoutputsthecorrectprotocolwhichhasminimal
cost with respect to the metric function, as well as
satisfiesthesecuritypropertiesandsystemrequire-
ments.
TheAPGapproach hasseveral advantages over
thecurrentprotocoldesignprocess. Itisfullyauto-
matic,andhence,moreefficientthanamanualpro-
cess. Theprotocolsgenerated byAPGofferhigher
confidence, becausetheyareverifiedbyapowerful
protocol analyzer. Another significant advantage
is that, because APG search through the protocol
spaceintheorderofincreasingcostwithrespectto
the metric function, APG generates correct proto-
colswithminimalcostwhichideallysuitthesystem
requirements. Furthermore, APG is flexible in the
sensethatitcanhandledifferentsecurityproperties
(cid:1)
anddifferentsystemrequirements.
To gain experience with APG, we conduct a
case study on the automatic generation of two-
party, mutual authentication protocols. In one
experiment, APG generates authentication proto-
cols that are simpler than the standard protocols
documented in the literature (i.e., ISO standards
[Int93]). In another experiment, the automatic
protocol generation generates different protocols
with minimal cost for varying requirements, hence
demonstrating its capability to produce high qual-
ityprotocols.
1 Introduction
The exponential growth of the Internet and elec-
tronic commerce brings not only prosperity, but
also vulnerability. Numerous attacks pose a real
challenge to different aspects of security mecha-
nisms. Among these security mechanisms, secu-
rityprotocolsplayanessentialrole. Theyusecryp-
tographic primitives as building blocks to achieve
security goals such as authentication, confidential-
ity, and integrity. New applications and systems
eagerly demand security protocolssuitable to their
system requirements. Unfortunately, designing se-
curity protocols is a delicate task and experience
shows that security protocols are notoriously hard
ThisresearchwasdonewhiletheauthorswereatCarnegie togetright[BAN89,Low96]. Thisnaturallyraises
MellonUniversity. Thispublicationwassupportedinpartby the question whether the current security protocol
Contract Number 102590-98-C-3513 from the United States
design process is satisfactory. If the answer is no,
PostalService. Thecontentsofthispublicationaresolelythe
howcanweimproveit?
responsibilityoftheauthoranddonotnecessarilyreflectthe
officialviewsoftheUnitedStatesPostalService. The current process of finding a solution is usu-ally ad-hoc and involves little formalism, and al-
mostnomechanicalassistance. Suchadesignpro-
cessisnotsatisfactoryforthefollowingreasons:
(cid:2)
Error-prone. Security protocols are intricate
andattackersarepowerful.
– If the designer has limited experience,
it is likely that the security protocol is
flawed. Evidence shows that even when
securityprotocolsaredesignedwithcare
and examined intensely (even over time
ofyears),theycanstillbefundamentally
flawed.
– Due to the lack of formalism and me-
chanical assistance, manually designed
protocols often suffer from the fact
thattheycontainundocumentedassump-
tions. Since the implementation might
notrespecttheseassumptionstheresult-
ingprotocolsmightbeinsecure/flawed.
– Without proofs, these protocols cannot
give any guarantee on satisfying the de-
sired security properties, and hence de-
gradethelevelofconfidence.
(cid:2)
Non-optimal. Such designed protocols may
contain unnecessary operations. Simply be-
causethedesignercannotsearchalargenum-
berofcandidates,shemaynotfindtheoptimal
protocol for the given system requirements.
Moreover, conservative designers might put
unnecessaryoperationsjusttoplaysafe.
(cid:2)
bandwidth. A protocol generator then generates
candidate security protocolswhich satisfythesys-
tem requirements. In the final step, a protocol
screener analyzesthecandidateprotocols,discards
theflawedprotocols,andoutputsthecorrectproto-
colsthatsatisfythedesiredsecurityproperties.
Ourapproachprovidesseveraladvantages:
Inefficient andExpensive. Thecurrentdesign
process is often slow. It can be a serious bot-
tleneckoftheprojectandseverelydelayprod-
uct development. If the protocol is flawed,
highcostsmightincur,duetoforcedredesign,
updateplans,orliabilityclaims.
Inthispaper,wepresentautomaticprotocolgen-
eration, APG for short, a mechanism which ad-
dressestheseshortcomings. Withautomaticproto-
col generation, the protocol designer specifies the
desired security properties, such as authentication
and secrecy, and system requirements, i.e., sym-
metric or asymmetric encryption/decryption, low
(cid:2)
Automatic. The protocol designer specifies
thesecuritypropertiesandthesystemrequire-
ments. The remaining process is fully auto-
matic.
(cid:2)
High Confidence. Since the input specifica-
tions are written in a well-defined specifica-
tionlanguageandtheautomaticprotocolgen-
eration is fully mechanical, there are no hid-
denassumptions,incontrasttothemanualde-
signprocess. Theprotocolscreenerhasapow-
erfulenginewhichcanautomaticallygenerate
aproofifaprotocoliscorrect,oracounterex-
ampleotherwise.
(cid:2)
High Quality. The user-defined system re-
quirements includes a metric function which
specifies the cost or overhead of a protocol.
APG tries to generate correct protocols with
minimal cost with respect to the metric func-
tion hence suits the system requirements the
best.
(cid:2) Flexible. Theapproachworksfordifferentse-
curityproperties,systemrequirements,andat-
tackermodels.
The remainder of this paper is organized as fol-
lows. We begin with an overview of the general
framework and requirements of APG. Next, we
presentacasestudyofautomaticgenerationofau-
thentication protocols. In our case study, we show
how we deal with the arising difficulties to make
APG feasible. Following the case study, we dis-
cusssomeofthelimitationsofAPG,aswellasthe
insights andresultsof thecasestudyandtheinter-
esting directions for further research. Finally, we
summarizethecontributions ofthispaper.2 General Framework and Re-
quirements for APG
In this section, we first give an overview of the
general framework of APG. Then, we state the re-
quirements of each component and give more de-
tails aboutourdesign andimplementation of these
components.
2.1 Overview
At a high level, APG is, as Figure 1 shows, a
pipelinecomposedofanautomaticprotocolgener-
atorandanautomaticprotocolscreener. Ingeneral,
the process of APG has four stages. First, the pro-
tocol designer specifies the desired security prop-
erties and system requirements as input. Second,
the protocol generator searches through the pro-
tocol space and generates candidate protocols that
satisfythesystemrequirements. Third,theprotocol
screener analyzes the candidate protocols. Finally,
the flawed protocols are discarded and the correct
ones thatsatisfy thedesired security propertiesare
output.
(cid:3)(cid:5)
(cid:11)(cid:13)
(cid:4)(cid:6)(cid:8) (cid:7)(cid:6)(cid:8)
(cid:12)(cid:8) (cid:14)(cid:15) (cid:12)
(cid:9)(cid:8) (cid:6)(cid:8) (cid:10)
(cid:4)(cid:16)(cid:17) (cid:7)(cid:6)(cid:8) (cid:4)
(cid:19)(cid:21) (cid:20)(cid:23) (cid:22)(cid:25)(cid:24)(cid:27) (cid:26)(cid:24)(cid:23) (cid:20)(cid:29) (cid:28)(cid:30)
(cid:28)(cid:31)(cid:25) ! !# "(cid:29) !# $%
(cid:3)(cid:5) (cid:4)(cid:6)(cid:8) (cid:7)(cid:6)(cid:8)
(cid:18) (cid:12)(cid:8) (cid:12)(cid:8)(cid:9)(cid:8) (cid:4)
(cid:9)(cid:8)
(cid:14)(cid:15)
(cid:6)(cid:8)
(cid:12)
(cid:10)
(cid:4)
Figure1: APGoverview
2.2 InputSpecification
Our specification language defines the security
properties, including authentication, secrecy and
other properties related to electronic commerce.
The system requirements are specified as a metric
functionandaspecificationoftheinitialsetup. The
E2 2 2 H- ’ /,(F . /) G /(,
> :8:A B6 789:;
C 78= D<= > ;8:? > @
E H 2 2 K 2 2F ( * J ’ ,/ * 3 H(
& ’ () * + (,-
. /) () - ) 0
1 2 3 2 3/+ (,)
1 54& .
I 2) //
. /) () -
-
)
(
H0
initial system configuration defines which crypto-
graphic primitives are available to the principals
and what keys each principal possesses. For ex-
ample, in a PKI environment, all protocol parties
know their own private key and the public keys of
the other principals, whereas in a symmetric-key
environmenttheprincipalshavesharedsecretkeys.
Hybridsystemsarealsopossible.
The metric function corresponds to the cost or
overhead of the protocol. An example for metric
designistomakethemetriccorrespondtothetime
overhead of the protocol. In a system such as a
smart-card, encryption can be fast while the band-
widthbetweenthecardandthecardreadermaybe
low, in which case the metric function specifies a
low cost for encryption, whereas the cost of send-
ingandreceivingmessagesishigh.
The metric function is required to be monoton-
ically increasing as the protocol complexity is in-
creasing. This requirement is necessary during the
protocol generation phase, where all the protocols
uptoamaximumcostthresholdaregenerated.
The metric function defines an ordering among
theprotocolsgenerated. Thescreener analyzesthe
protocols in the order of increasing cost,1 hence
the first correct protocol has a minimal cost-value
with respect to the metric function. Given a spec-
ification of security properties and system require-
ments,wesaythataprotocolisoptimalifithasthe
lowest cost-value with respect to the metric func-
tionamongprotocolsthatsatisfythesecurityprop-
ertiesandthesystemrequirements.
2.3 Notation
Weusethefollowingnotationtodescribeprotocols
inthispaper.
Figure2: APGdataflow
LN MP O
aretheprincipals
QS R
isanoncegeneratedby
TU R
L
denotes
L
’spublickey
TW VYR X
denotes
L
’sprivatekey
1Allprotocolsaresortedafterthegenerationstep,sincethe
generationmightnotgeneratetheminstrictlyincreasingorderTZ R\ [
denotes the secret (symmetric) key
whichissharedbetween
L
and
]_ ^a ‘_ bd c
O
istheencryptionofmessage
^
with
O
’spublickey
2.4 Protocol Representation
Aprotocoldefinesasequenceofactionsofthepar-
ticipating parties. The actions include sending and
receiving messages. Messages are defined by the
followinggrammar. Thegrammarcanbeeasilyex-
tendedifneeded.
^f
Lq
e_ g_
p(cid:21)
g_
rt
h(cid:13)
sv
ij
u(cid:5)
el
w
kmkon
kmkon
Lq
xt
p(cid:21)
(cid:132)(cid:133)
rt sv
rt |}
u(cid:5)
w
wy
h
x{
ep
zN
|
|}
h
w(cid:127) ~t
e{p
(cid:128)_
(cid:131)
(cid:129)(cid:130) p e{ (cid:131)
Principalname
x
Nonce
zN |} w(cid:134) ~(cid:135) (cid:128)_ (cid:129)(cid:130) p e{ (cid:131)(cid:136) kmkon(cid:138) (cid:137)(cid:139) ^(cid:138) e(cid:140) gt g(cid:140) h(cid:13) ij e M
x T e (cid:128)
Key
T e (cid:128) kmkon
(cid:141)
PublicKey
x
PrivateKey
x
SymmetricKey
(cid:132)(cid:133)
^(cid:138)
rt |}
e(cid:140) gt
hw
g_ h(cid:145)
ep
ij
|
e(cid:146)
h
(cid:143)
e{p
gu
(cid:131)(cid:136)
p
kmkon(cid:142)
kmkon(cid:142)
^(cid:138)
^(cid:138)
x ^f
e(cid:140)
e(cid:140)
gt
gt
e_
g(cid:140)
g(cid:140)
g_
h(cid:13)
h(cid:13)
g_
ij
ij
h(cid:13)
e(cid:144)
e
ij
(cid:143)
e M
u g
^f
p
e_ g_ g_ h(cid:13) ij e(cid:147) (cid:143) u g p
Each message can be represented as a tree with
the atomic messages as leaves and operations as
intermediate nodes. Figure 3 shows an example
for the message:
LN MP O(cid:148) M ] LS MP O ‘ b c
Concat
A B Encr
Concat Kb
A B
Figure 3: Example of a message tree for the mes-
sage:
. We define the
depth of a message as the depth of the tree repre-
sentingthatmessage. Forexample,inFigure3the
depthofthemessagetreeis4.
2.5 TheProtocol Generator
Thepurposeoftheprotocolgeneratoristogenerate
candidate protocols that satisfy the specified sys-
temrequirements. Intuitively, theprotocolspaceis
infinite. Hence,weneedawaytolimitthenumber
ofcandidateprotocolsgeneratedwhilenotomitting
anypotentialoptimalprotocols.
Our primary method to solve this problem is
to use iterative deepening, a standard search tech-
nique [RN95]. In each iteration, we set a cost
threshold ofprotocols. Wethensearchthroughthe
protocol space to generate all the protocols below
LS MP O(cid:148) M ] LN MP O ‘ b c
the given cost threshold. After sorting the proto-
cols,theprotocolscreenerteststhemintheorderof
increasingcost. Ifoneprotocolsatisfiesthedesired
properties, it is minimal with respect to the cost
metric and the generation process can stop. Oth-
erwise,weincreasethecostthresholdandgenerate
moreprotocols.
Itisintuitiveandourexperimentsconfirmedthat
thenumberofprotocolsgeneratedisexponentialin
the value of the cost threshold. Hence, the proto-
col generator can easily generate millions of pro-
tocols. Since elaborate protocol verification takes
on the order of 1 second per protocol, it would
be impractical for the protocol screener to analyze
all of these protocols. To make APG practical we
use efficient reduction techniques and heuristics to
prune invalid candidate protocols early to reduce
the number of candidate protocols passed to the
protocol screener. Most of the generatedprotocols
containseveresecurityflawswhichcanbedetected
with a simple and more efficient verification algo-
rithm. Each security property that is supported by
the system is therefore accompanied by a pruning
algorithm(whichefficientlydiscardsmostseverely
flawed protocols) and a verification condition for
the screener. We give more detail about the prun-
ingalgorithmsinthecasestudyinSection3.2.6 TheProtocol Screener
Theautomaticprotocolscreenerneedstobesound
andefficient. Givenacandidateprotocol,theproto-
colscreenerhastobeabletoexaminetheprotocol
and tell whether it is correct or not. The protocol
screener is sound if when it claims that a protocol
satisfiescertainsecurityproperties,itistruethatthe
protocolreally does satisfy these properties. Since
the protocol generator generates thousands of can-
didate protocols, the protocol screener needs to be
highlyefficienttofindtheoptimalprotocolinarea-
sonableamountoftime.
There are several existing tools for semi-
automatic and automatic protocol analysis, such
as the NRL Analyzer [Mea94], the Interrogator
Model [Mil95], FDR [Low96], Mur (cid:149) [MMS97],
and Brutus [CJM98]. Athena is a recently
introduced checker for security protocol analy-
sis[Son99]. Comparingtootherexistingautomatic
tools, Athena has the following two main advan-
tages:
(cid:2)
Athenahastheabilitytoanalyzeprotocolexe-
cutionswithanyarbitraryconfiguration. Most
ofotherexistingautomatictoolscanonlyrea-
son about finite state space, which implies
thattheycanonlyanalyzeprotocolexecutions
with certain configurations, such as two ini-
tiators and two responders. In contrast, when
Athena terminates, it provides a proof that a
protocol satisfies its specified property under
anyarbitraryprotocolconfiguration,oritgen-
erates a counterexample if the property does
nothold.
(cid:2)
proposed Strand Space Model [THG98] to repre-
sentprotocolexecution. Athenaincorporatesanew
logic that can express security properties includ-
ing authentication, secrecy and properties related
to electronic commerce. An automatic procedure
enables Athena to evaluate well-formed formulae
in this logic. For a well-formed formula, if the
evaluation procedure terminates, it will generate a
counterexample if the formula is false, or provide
a proof if the formula is true. Even when the pro-
ceduredoesnotterminatewhenweallowanyarbi-
trary configurations of the protocol execution, (for
example,anynumberofinitiatorsandresponders),
termination couldbe forcedby bounding thenum-
ber of concurrent protocol runs and the length of
messages, as is done in most existing automatic
tools.
Athena also exploits several state space reduc-
tion techniques. Powered with techniques such
as backward search and symbolic representation,
Athena naturally avoids the state space explosion
problem commonly caused by asynchronous com-
position and symmetry redundancy. Athena also
has the advantage that it can easily incorporate re-
sults from theorem proving through unreachability
theorems. Byusingtheunreachabilitytheorems,it
can prune the state space at an early stage, hence,
furtherreducethestatespaceexploredandincrease
the likely-hood of termination. These techniques
dramaticallyreducethestatespacethatneedstobe
explored.
3 Case Study: Automatic Genera-
tion of Authentication Protocols
Athena exploits many state space reduction
techniques which result in a highly reduced In order to gainpreliminaryexperience withAPG,
statespace. we perform a case study with automatic gener-
ation of two-party mutual authentication proto-
For these reasons, we choose to use Athena as cols. Authenticationprotocolsareamongthemost
the protocol screener. During this project, Athena widely used and intensely studied security proto-
hasverified tens of thousands of protocols andhas cols. Theircomplexityissuitableforaninitialcase
established itself as a highly efficient and robust study, and they are known to be notoriously diffi-
toolforautomaticprotocolanalysis. culttodesigncorrectlyandhenceagoodchallenge
ThefollowingisabriefoverviewofhowAthena [BAN89,Low96].
works. Athena uses an extension of the recently We use the agreement properties proposedby Gavin Lowe for authentication protocols as
the formal definition of the authentication prop-
erty [Low97]. A protocol guarantees a participant
O
agreement for a certain binding
(cid:151)
(cid:150) if each time
a principal
O
completes a run of the protocol as a
responderusing
(cid:151)
(cid:150) ,supposedlywith
L
,thenthereis
auniquerunoftheprotocolwiththeprincipal
L
as
initiatorusing
(cid:151)
(cid:150) ,supposedlywith
O
.
In this section, we first discuss the assumptions
we make in the case study. Then, we explain the
difficulties we encountered in the case study and
describe our enhancement techniques to overcome
the difficulties. Finally, we summarize the experi-
mentresultsandourfindings.
3.1 Assumptions
We initially analyzed how many first messages
the initiator
L
can send, with a given depth
of the message tree. Subsequently, we refer
to the two protocol principals as the initiator
L
and the responder
O
. Initially the initiator
knows the following atomic message components:
LS MP OZ M T R M T VYR X M T [ M Q R
. With a message depth
of 4 the initiator can generate about one thousand
messages; and with a depth of 6, it can generate
about8millionmessages. Ifatwo-partymutualau-
thenticationprotocolusesthreerounds,considering
1000possiblemessagesineachroundwouldleave
us with (cid:152)(cid:154) (cid:153)(cid:156) (cid:155) protocols. A protocol screener which
analyzes 20 protocols per second, would take over
1year.
Aftertheinitialestimate,wedecidetomakecer-
tain assumptions to keep the protocol space small.
Wedonotintendtoprovethattheseassumptionsdo
not eliminate the potential optimal protocol. But
we believe these assumptions are intuitively rea-
sonable. We list all the assumptions we make in
thecasestudyasthefollowing:
(cid:2) Message components are typed. This allows
any participant to distinguish a nonce from a
principalname,forexample.
(cid:2)
Inany concatenated message, there arenore-
dundantmessagecomponents,i.e.,
Q R M Q R
.
(cid:2)
No initial keys are sent in a message, since it
doesnotmakesensetosendaprivatekey,and
weassumeeveryprincipalknows allthepub-
lic keys. Session keys generated during the
protocol run do not fall into this category of
authenticationprotocols.
(cid:2) We assume that the initiator’s name needs to
be in the first message in a understandable
format to the responder, so that the respon-
der knows who to reply to. (This assumption
mightnot be necessarywhen theinitiator and
the responder have a link between them that
isonlyused tocommunicatebetween thetwo
parties, although this case is not very general
sowedonotconsiderithere.)
(cid:2)
We do not consider permutations of the mes-
sagecomponentsofaconcatenatedmessage.
Thelastpointreducestheprotocolspacetremen-
dously. Unfortunately, this optimization might re-
sult in missing a correct protocol. This case can
occur if the generated protocol is vulnerable to a
specific replay attack, where a message of round
u
can be replayed for another message of round (cid:157)
(
u(cid:159) n(cid:158)
(cid:157) ). In our current implementation of APG,
the protocol is rejected and no permutation of the
message components is considered. In the future,
however,wecoulddetectthiscaseandtrytorepair
theprotocolthroughamessagereordering.
3.2 Adding the Pruning Algorithm to the
ProtocolGenerator
As we mentioned before, a na¨ıve approach gener-
atesalargenumberofuninterestingcandidatepro-
tocols. InTable1weshow thatthena¨ıve approach
generates tens of thousands of candidate protocols
intherealexperiments. Generatingalargenumber
of flawed candidate protocols risks to render APG
impractical, since the running time of the protocol
screener would be prohibitive. To deal with this
problem, we define a pruning algorithm for each
security property, which efficiently prunes the ma-
jority of the flawed protocols. This pruning algo-
rithm can either operate on the message level oron the protocol level. A secrecy property, for in-
stance, can be verified on the message level, since
the secret value cannot be disclosed publically in
any message. In the case of the authentication
property, however, thepruningalgorithmworkson
the protocol level, since it is difficult to define a
message-level pruning algorithm which does not
violate completeness (i.e. preserves correct proto-
cols). Toquicklydiscardflawedauthenticationpro-
tocols,weuseanintrudermodulewhichchecksfor
impersonation and simple replay attacks. As Ta-
ble1shows, these twomechanismsreduce98 per-
centofthecandidateprotocolsinrealexperiments.
Impersonationattempt
We use two intruders to attack each protocol. The
intruder (cid:160)(cid:154) ¡ triestoimpersonatetheinitiator
L
,and
the other intruder (cid:160){ ¢ attempts to impersonate the
responder
O
. Bothintrudershavethepublickeysof
alltheprincipalsintheirinitialinformation. Ifsym-
metricencryptionisused,theintruderscertainlydo
not obtain any of the secret keys. Then, (cid:160)(cid:154) ¡ tries to
startasessionwith
O
impersonatingas
L
. If (cid:160)(cid:154) ¡ can
get
O
to finish hissession believing it is talking to
L
,thentheprotocolissimplybroken. Similarlywe
cancheckwhether (cid:160) ¢ canimpersonateas
O
tofin-
ishasessionwith
L
. Thepurposeforthisattackis
simply to checkwhether correctand necessaryen-
cryptions are used. It does not involve any replay
attack and multiple protocol run and hence is very
efficient.
Preventingsimplereplayattacks
Nowwelookatasimplereplayattack. Afterapro-
tocol session of an initiator
L
and a responder
O
,
anintruder (cid:160) storesallthemessagessentintheses-
sion. Then, (cid:160) tries to re-send the packets to
O
to
impersonateas
L
. If (cid:160) cantrick
O
tofinishitsses-
sion believing it is talking to
L
, then the protocol
is flawed and is discarded. Similarly, (cid:160) can launch
thesimplereplayattackto
L
messagesandhenceisveryefficient.
3.3 Testing and Improving the Protocol
Screener
There are two main challenges for the protocol
screener. First, the protocol screener needs to be
sound. If the protocol screener outputs a flawed
protocol, the automatic protocol generation is not
trustworthy. Second,theprotocolscreenerhastobe
efficient becausepotentiallytheprotocolgenerator
couldgeneratethousandsofcandidateprotocols.
Hence, one point worth mentioning is that this
research also serves a second purpose: a real test
for Athena. As far as shown in previous litera-
ture, mostof theautomatictoolsforprotocolanal-
ysis have only been tested with a handful testing
protocols and the testing protocols are mainly ex-
isting human-designed protocols. The candidate
protocols generated by the protocol generator are
purely machine-generated from a large protocol
space, and hence, could potentially contain more
misbehavioranddifficulterrors. Therefore,thisisa
good testforthesoundnessofboth designandim-
plementation of Athena. During the experiments,
the protocol generator generates thousands of can-
didate protocols. Therefore, this is also a good
test for the performance of Athena. As a sanity
check, we also manually analyzed the protocols
whichAthena proved correct. Wewere notableto
find errors in these protocols. On average, Athena
verifies around 5 protocols per second, based on a
400MHzPentiumIILinuxworkstation.
3.4 Summaryof the ExperimentResults
EffectivenessoftheReductionTechniques
In this experiment, we use a simple, linear met-
ric function. Each operation has a unit-cost.
The cost value of a protocol is the sum of the
costs of all the protocol operations and compo-
nents. We choose UNIT ELEMENT COST
aswell. Thepurpose
for this attack is just to check whether nonces are
used in a correct way. The intruder does not try to
encrypt or decrypt messages or alter the received
n
(cid:152)
(cost to send a nonce or a principal name),
and NEW NONCE COST
n
(cid:152) (cost to
generate a new nonce). For symmetric-key
protocols SYM ENCRYPTION COST
n £(cost to encrypt a message with a symmet-
ric key), and for asymmetric-key protocols
ASYM ENCRYPTION COST
n £
(cost to
encryptamessagewithanasymmetrickey).
Table1showsthestatisticsfortheprotocolgen-
eration. Thecostthresholdis10forsymmetric-key
authenticationprotocolsand14forasymmetric-key
protocols. The columnlabeled “Generated”shows
how many protocols were initially generated with
the corresponding cost threshold without applying
the intruder reduction. The table depicts the ef-
fectiveness of theimpersonator and replayattacks.
The column marked “I.A.” shows the number of
protocols that are eliminated by the impersonation
attack. Similarly, the “R.A.” column depicts the
number of protocols that are vulnerable to the re-
play attack. The combination of the two attacks
is quite efficient (shown in the “Combined” col-
umn) and leaves about 2% of candidate protocols
forthesymmetriccase and0.2%fortheasymmet-
ric case (shown in the “Candidate” column). The
running time for the protocol generation is on the
order of 1 second for every 2000 protocols gen-
erated which includes the pruning algorithm (this
number is based on our Java implementation, exe-
cutedbytheJVMoftheSunJDK1.1.7,runningon
a400MHzPentiumIILinuxworkstation).
OurFindingsoftheProtocols
Continuing the experiment from the previous sub-
section, Athena analyzed the remaining candidate
protocols and output 2 correct symmetric-key pro-
tocols, which have the minimum cost 10. Among
the110asymmetric-keyprotocols,only1iscorrect
and has the minimal cost 14. The three protocols
arelistedbelow:
(cid:2)
Symmetric-key mutual authentication proto-
cols.
⁄ƒ ¥# §(cid:135) ¤(cid:21) §j '(cid:154) §« “ k L›
Oa
L›
‹fi
‹fi
‹fi
O
L
O
k
k«
k
Q
]
Q
QS
R
[
MP
R
L
M Qfl [ MP L ‘ b– (cid:176) c
⁄† ¥(cid:23) §(cid:135) ¤(cid:21) §j '(cid:154) §« “ k L‡
O(cid:181)
L‡
‹·
‹·
‹·
O
L
O
k
k¶
k
Qfl
]
Q•
Qfl
R
[
MP
R
L
M Q• [ MP O ‘ b– (cid:176) c
The standard symmetric key mutual authen-
tication protocol using random numbers is
documented in ISO/IEC 9798 [Int93] as ISO
Symmetric-Key Three-Pass Mutual Authenti-
cationProtocol:
⁄† ¥(cid:23) §(cid:135) ¤(cid:21) §j '(cid:154) §« “ k L‡
O(cid:181)
L‡
‹·
‹·
‹·
O
L
O
k
k¶
k¶
Qfl
]
]
Qfl
Q
R MP
R
R
L
M
M
Q•
Q
[
[
MP
‘_
O
b
‘
(cid:176)
b–
c
(cid:176) c
Our automatically-generated protocols are
clearlysimplerthantheonelistedasISOstan-
dardwithrespectofservingthesamepurpose
asmutualauthenticationprotocol.
(cid:2)
Asymmetric-key mutualauthenticationproto-
cols.
⁄† ¥# §(cid:135) ¤‚ §j '(cid:154) §« “ k L›
Oa
L›
‹fi
‹fi
‹fi
O
L
O
k«
k«
k
]
]
Q•
Qfl
Q
[
R
R
MP
M
L
Q
‘
[
b
MP
c
O ‘_ b (cid:176)
This protocol happens to be the same as the
fixed version of Needham-Schroeder proto-
col [Low96], except for that the last message
is not encrypted. This is because we do not
have the secrecy requirement in the security
propertyspecification.
Although intuitive, another interesting result from
the statistics is that the number of correct proto-
colscomparingtotheprotocolsthathave thesame
cost is very low. For example, in this case study,
theratioofgeneratedprotocolstocorrectprotocols
is around (cid:152)(cid:154) (cid:153)
V” „
. This ratio decreases when we in-
creasethecostthreshold.
OptimalProtocols
In this experiment, we experiment with two ex-
treme cases of the metric function to see how we
canbenefitfromtheautomaticprotocolgeneration
togenerateoptimalprotocols.Type MaxCost Generated I.A. R.A. Combined Candidates Correct
Symmetric 10 19856 12098 18770 19449 407 2
Asymmetric 14 46518 46378 40687 46408 110 1
Table 1: Experiment Statistics for protocol generation. I.A. stands for impersonation attack and R.A. for
replayattack
In the first case, we consider a smart-card,
which has a built-in cryptographic accelerator and
hence, can perform fast encryption/decryption op-
erations. But the smart-card has a slow link to
the card reader. In this case, we set the cost of
encryption much lower than the bandwidth cost
(UNIT ELEMENT COST in the specification).
With this metric function, we find one symmetric-
keyauthenticationprotocolwithminimumcost:
⁄† ¥# §(cid:135) ¤‚ §j '(cid:154) §« “ k L»
O(cid:181)
L»
‹fi
‹·
‹fi
O
L
O
k¶
k¶
k
]
]
Q
Qfl
Qfl
[
R
R
MP
M
L
Q•
‘
[
b–
‘
(cid:176)
b–
c
(cid:176) c
In the second case, we consider a slow machine
withafastlink,wherethecryptographicoperations
are the bottleneck. In this case, we set the band-
width cost much lower than the encryption cost in
the metric function. Hence, we get the following
twooptimalsymmetric-key protocols.
⁄†
⁄ƒ
¥(cid:23) §(cid:135)
¥# §(cid:135)
¤(cid:21)
¤‚
§j
§‰
'(cid:154)
'(cid:154)
§«
§«
“
“
k
k
L»
O…
L»
L‡
Oa
L‡
‹·
‹·
‹·
‹fi
‹fi
‹fi
O
L
O
O
L
O
k
k«
k
k
k¶
k
Qfl
]
Q•
Qfl
]
Q•
Qfl
Qfl
R
[
R
[
MP
R
MP
R
L
M
L
M
Qfl
Q•
[
[
MP
MP
L
O
‘
‘
b–
b–
(cid:176)
(cid:176)
c
c
protocolastheoptimalprotocol. Theresultingpro-
tocol is the same as the asymmetric-key protocol
listedintheprevioussubsection.
4 Discussion and Future Work
The approach of automatic protocol generation
sounds attractive, but it isinitially unclearwhether
it is feasible to generate meaningful and correct
protocols automatically. One goal of this research
is to try to answer this question. During the
case study, we were able to generate correct au-
thentication protocols automatically and some of
them were documented beforeandare currentlyin
use. Theautomaticprotocolgenerationprocessfor
authentication protocols is efficient, usually only
takesmatterofsecondsofrunningtime. Thisillus-
trates that theapproachof automatic protocolgen-
erationisfeasible.
The case study is a proof of concept and shows
that automatic protocol generation can accomplish
simple tasks, but it says little about whether this
approach will scale up to more complicated pro-
tocols. Since the protocol space grows exponen-
tially with the number of parties and the number
of messages, we expect that the number of candi-
dateprotocols,generatedbytheprotocolgenerator
inmorecomplicatedcases,canbeordersofmagni-
tudes larger than the numbers that appeared in the
experiments. It is an interesting research direction
It is interesting to notice that the two protocols in to explore more powerful reduction techniques to
thefirstcaseuseonemoreencryptionthanthetwo makethisapproachscale.
protocols in the second case, while the messages The case study mainly covers the authentication
are shorter. We can see a clear benefit from auto- securityproperty. Therearemanyotherinteresting
maticprotocolgeneration,sincetheprotocolsgen- security properties including properties related to
eratedsuitthesystemrequirementsideally. electronic commerce, such as atomicity. We need
For the asymmetric-key protocol, in both cases, toextendoursystemtohandletheseproperties. For
the automatic protocol generation finds the same example, new reduction techniques are needed fortheprotocolgenerator. Athenaterminatedandsuc-
cessfully analyzed all the candidate protocols gen-
erated in the case study for authentication proto-
cols. But for protocols requiring other properties,
wemightneedtoaddnewunreachabilitytheorems
toenhanceAthena.
Currently, in the protocol analysis, we assume
perfect encryption. The perfect-encryption as-
sumption states that a ciphertext can only be de-
crypted if the decryption key is present, and simi-
larly, a ciphertext can only be produced if the en-
cryption key is present. Researchers have been
exploring protocols which are resistant against
stronger attacks, such as dictionary attacks. It is
also interesting to try to strengthen the attacker
model in the current approach to produce stronger
protocols.
5 Conclusion
Themainpointsofthepaperarethefollowing:
(cid:2)
We present the novel approach of automatic
generation of security protocols. With a
user-defined specification of security proper-
ties and the system requirements, including a
system metric function, APG generates min-
imal protocols that satisfy the specified secu-
rity properties andsystem requirements, min-
imal with respect to themetric function. This
approachisasignificantimprovementoverthe
current protocol design process, because it is
more reliable, efficient, and produces proto-
cols that suit the given system requirements
ideally.
(cid:2)
6 Acknowledgments
We would like to thank Doug Tygar for his valu-
able help and support during this project. We also
thankGeorgeNeculaandSeanSmithfortheiruse-
fulsuggestionsanddiscussions. Wearealsogreat-
ful to the anonymous reviewers for their feedback
andsuggestions.
References
[BAN89] M. Burrows, M. Abadi, and R. Need-
ham. Alogicofauthentication. Techni-
cal Report 39, DEC Systems Research
Center, February1989.
[CGP99] Edmund Clarke, Orna Grumberg, and
Doron Peled. Model Checking. MIT
Press,1999.
[CJM98] E.M. Clarke, S. Jha, and W. Marrero.
Usingstatespaceexplorationandanat-
ural deductionstyle messagederivation
enginetoverifysecurityprotocols.InIn
Proceedings of the IFIP Working Con-
ference on Programming Concepts and
Methods(PROCOMET),1998.
[DY89] D. Dolev and A. Yao. On the se-
curity of public key protocols. IEEE
Transactions on Information Theory,
29(2):198–208,March1989.
[HT96] N.HeintzeandJ.Tygar.Amodelforse-
cure protocols and their compositions.
IEEE Transactions on Software Engi-
neering, 22(1):16–30,January1996.
We perform a case study on the automatic
[Int93] International Standards Organization.
generation of two-party mutual authentica-
InformationTechnology-Securitytech-
tion protocols for proof of concept and to
niques — Entity Authentication Mech-
gain experience with APG. During the case
anisms Part 3: Entity authentica-
study, APGautomaticallygeneratesprotocols
tion using symmetric techniques, 1993.
thataresimplerthanthedocumentedstandard
ISO/IEC9798.
ones. In two examples from the real world,
APGisalsoabletogeneratedifferentoptimal [Low96] G. Lowe. Breaking and fixing the
protocolswithrespecttovaryingmetricfunc- Needham-Schroeder public-key proto-
tions,andhence,demonstrateitsbenefit. col using FDR. In Tools and Algo-rithms for the Construction and Analy-
sis of Systems, volume 1055 of Lecture
NotesinComputerScience, pages147–
166.Springer-Verlag,1996.
[Low97] G. Lowe. A hierarchy of authentica-
tion specifications. In Proceedings of
the 1997 IEEE Computer Society Sym-
posiumonResearchinSecurityandPri-
vacy,pages31–43,1997.
[Mea94] C. Meadows. A model of computation
for the NRL protocol analyzer. In Pro-
ceedings of the 1994 Computer Secu-
rityFoundationsWorkshop.IEEECom-
puterSocietyPress,June1994.
[Mea95] C. Meadows. Formal verification of
cryptographic protocols: A survey. In
Advances in Cryptology - Asiacrypt
’94, volume 917 of Lecture Notes
in Computer Science, pages 133–150.
Springer-Verlag,1995.
[Mil95] J. Millen. The Interrogator model.
In Proceedings of the 1995 IEEE
Symposium on Security and Privacy,
pages 251–260. IEEE Computer Soci-
etyPress,1995.
[MMS97] J. C. Mitchell, M. Mitchell, and
U.Stern. Automatedanalysisofcrypto-
graphic protocols using mur (cid:149)
Why is a security protocol correct? In
Proceedings of 1998 IEEE Symposium
onSecurityandPrivacy,1998.
[WL93] T.Y.C.WooandS.S.Lam. Asemantic
model for authentication protocols. In
ProceedingsoftheIEEESymposiumon
ResearchinSecurityandPrivacy,1993.
. In Pro-
ceedings of the 1997 IEEE Symposium
on Security and Privacy. IEEE Com-
puterSocietyPress,1997.
[RN95] Stuart Russell andPeter Norvig. Artifi-
cial Intelligence: A Modern Approach.
PrenticeHallSeriesinArtificialIntelli-
gence,1995.
[Son99] Dawn Song. Athena: An automatic
checker for security protocol analysis.
In Proceedings of the 12th Computer
ScienceFoundationWorkshop, 1999.
[THG98] F.Javier Thayer, Jonathan C. Herzog,
andJoshuaD.Guttman. Strandspaces: