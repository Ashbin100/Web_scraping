Analysis of
a Fair Exchange Protocol
Vitaly Shmatikov John Mitchell
Stanford UniversityAgreement in Hostile Environment
Cannot trust the communication channel

Cannot trust the other party in the protocol

Trusted third party may exist

Last resort: use only if something goes wrong
Contract Signing
Immunity
deal
Both parties want to sign the contract

Neither wants to commit first
Fairness
If A cannot obtain a contract,
then B should not be able to
obtain a contract, either
(and vice versa)
Example (Alice buys a house from Bob)
If Alice cannot obtain a deed for the property,
Bob should not be able to collect Alice’s moneyAccountability
If trusted party T misbehaves,
then honest party should be
able to prove T’s misbehavior
Example (Alice buys a house from Bob)
If escrow service gives Bob Alice’s money without
giving Alice the deed, Alice should be able to prove
to a judge that escrow service is cheatingFormal Protocol Analysis
Informal
Formal Intruder
Protocol
Protocol Model
Description
Gee whiz.
Analysis
Looks OK
Tool
to me.Murj
[Dill et al.]
Describe finite-state system

State variables with initial values

Transition rules

Communication by shared variables

Scalable: choose system size parameters

Specify correctness condition

Automatic exhaustive state enumeration

Hash table to avoid repeating states

Success with research, industrial protocol verificationOptimistic Contract Signing
[Asokan, Shoup, Waidner]
m = sig (PK , PK , T, text, hash(R ))
1 A A B A
m = sig (m , hash(R ))
2 B 1 B
A
B
m = R
3 A
m = R
4 B
m , R , m , R
1 A 2 BSeveral Forms of Contract
Contract from normal execution

m , R , m , R
1 A 2 B
Contract issued by third party

sig (m , m )
T 1 2
Abort token issued by third party

sig (abort, a )
T 1Role of Trusted Third Party
T can issue an abort token

Promise not to resolve the protocol in the future
T can issue a replacement contract

Proof that both parties are committed
T decides whether to abort or resolve on

the first-come-first-serve basis
T only gets involved if requested by A or B
Abort Subprotocol
m = sig (… hash(R ))
1 A A
A B
Network
???
a =sig (abort,m )
1 A 1
a
2
T
sig (m , m ) resolved?
T 1 2
Yes: a = sig (m , m )
2 T 1 2
OR
No: aborted := true
a = sig (abort, a )
sig (abort, a ) 2 T 1
T 1Resolve Subprotocol
m = sig (… hash(R ))
1 A A
m = sig (… hash(R ))
Net 2 B B B
A
m = R ???
3 A
r = m , m
1 1 2
r
2
T
sig (m , m )
T 1 2 aborted?
Yes: r = sig (abort, a )
OR 2 T 1
No: resolved := true
sig (abort, a )
r = sig (m , m )
T 1
2 T 1 2Race Condition
m = sig (PK , PK , T, text, hash(R ))
1 A A B B
m = sig (m , hash(R ))
2 B 1 B
A
B
a = sig (abort, m )
r = m , m
1 A 1
1 1 2
TAttack
m = sig (... hash(R ))
1 A A
m = sig (m , hash(R ))
2 B 1 B
A
secret Q , m
B 2
m = R
3 A
r = m , m
1 1 2
T
contracts are
r = sig (m , m )
inconsistent!
2 T 1 2
sig (m , m ) m , R , m , Q
T 1 2 1 A 2 BReplay Attack
sig (… hash(R ))
A A
Intruder causes B
A sig (... hash(R )) B
B B
to commit to old
R
A
R contract with A
B
Later ...
sig (PK , PK , T, text, hash(R ))
A A A A
sig (m , hash(Q ))
B 1 B
B
R
A
Q
BRepairing the Protocol
m = sig (PK , PK , T, text, hash(R ))
1 A A B A
m = sig (m , hash(R ))
2 B 1 B
A
B
m = s i g ( R , hash(R ))
3 A A B
m = R
4 B
m , R , m , R
1 A 2 BAnother Property: Abuse-Freeness
No party should be able to prove
that it can solely determine
the outcome of the protocol
Example (Alice buys a house from Bob)
Bob should not be able to show Alice’s offer to
Cynthia so that he can convince Cynthia to pay moreConclusions
Fair exchange protocols are subtle

Correctness conditions are hard to formalize

Unusual constraints on communication channels

Several interdependent subprotocols

Many cases and interleavings

Finite-state tools are useful for case analysis
