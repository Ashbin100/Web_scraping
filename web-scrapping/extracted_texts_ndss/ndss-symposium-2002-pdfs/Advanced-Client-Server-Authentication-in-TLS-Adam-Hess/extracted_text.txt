Advanced Client/Server Authentication in TLS
Adam Hess, Jared Jacobson, Hyrum Mills, Ryan Wamsley, Kent E. Seamons, Bryan Smith
Computer Science Department
Brigham Young University
Provo, Utah, USA 84602
seamons@cs.byu.edu
ABSTRACT When a server conducts a secure on-line transaction
Many business transactions on the Internet occur with a stranger, two common security problems must be
between strangers, that is, between entities with no prior addressed: first, the details of the transaction must remain
relationship and no common security domain. Traditional confidential; second, the server must authenticate the client
security approaches based on identity or capabilities do according to a pre-existing policy that specifies who is to
not solve the problem of establishing trust between be considered trustworthy for the given transaction. In our
strangers. New approaches to trust establishment are model, authentication of the client is not based on identity
required that are secure, scalable, and portable. One new but rather on attribute values encoded in digital
approach to mutual trust establishment is trust negotiation, credentials—the online analogues of today’s paper
the bilateral exchange of digital credentials to establish credentials.
trust gradually. This paper describes the Trust Transport Layer Security (TLS) [4], the IETF
Negotiation in TLS (TNT) protocol, an extension to the adaptation of Netscape’s SSL V3.0 [5] protocol, can
TLS handshake protocol that incorporates recent advances provide confidentiality. TLS also provides client and
in trust negotiation into TLS to provide advanced server authentication. However, TLS authentication is not
client/server authentication in TLS. In this paper we suitable for strangers trying to conduct business
describe the current limitations in TLS client/server transactions. For example, a business may be interested in
authentication with respect to trust establishment, and providing a service to residents of a given state. The
show how the TNT protocol overcomes them. We also identity of the client accessing the service is irrelevant to
describe our implementation of TNT, built using PureTLS, this decision; the client only needs to establish proof of
a Java TLS package that is freely available. This residency. As discussed further in section 3, TLS does
implementation is the first to provide confidential trust not provide this form of authentication.
negotiation, verification of private keys during trust Clients may have their own criteria for trusting servers.
negotiation, and a single trust negotiation protocol For example, before the client discloses a credential he or
supporting interoperable trust negotiation strategies. she considers to be sensitive, such as a credit card number
and expiration date, the client may first require a credential
from the server stating that the server will handle the
client’s private information properly. Without this
1. Introduction
assurance, customers who do not want their sensitive
information disclosed to others will go elsewhere.
Many interactions on the Internet occur between
An interesting case to consider occurs when the server
strangers, that is, between entities with no prior
must authenticate the client in order to provide a service,
relationship and no common security domain. Traditional
but the client considers those credentials sensitive. The
security approaches based on identity or capabilities do not
client therefore wants to authenticate the server before
solve the problem of authentication between strangers,
disclosing them. In such a case, a strictly one-way model
because strangers do not share a common security domain.
of authentication will not suffice; mutual authentication is
New approaches are required that are secure, scalable, and
necessary.
portable.Our approach to mutual trust establishment is called protocol. Section 5 describes an implementation of TNT,
trust negotiation, the bilateral exchange of digital and Section 6 discusses related work. Section 7 contains
credentials to establish trust gradually [10][13][14][15]. conclusions and future work plans.
Digital credentials contain digitally signed assertions by a
credential issuer about a credential owner. A credential 2. Trust negotiation
uses name/value pairs to describe one or more attributes of
the owner. Each credential also contains the public key of
In our approach to automated trust establishment, trust is
the credential owner and is signed using the issuer's private
established incrementally by exchanging credentials and
key. The owner can answer challenges and otherwise
requests for credentials, an iterative process known as trust
demonstrate ownership of the credentials. Credentials are
negotiation [10][13][14][15]. While a trust negotiation
a more general name for certificates, such as X.509v3
protocol defines the ordering of messages and the type of
certificates [8].
information messages will contain, a trust negotiation
As an example of trust negotiation, an on-line bookstore
strategy controls the exact content of the messages, i.e.,
may offer discounts to students at accredited universities.
which credentials to disclose, when to disclose them, and
When a first-time customer requests a student discount, he
when to terminate a negotiation.
or she will not have prior knowledge of the bookstore’s
Figure 1 introduces our TrustBuilder architecture for
requirements for proof of student status. One approach is
trust negotiation. A security agent mediates access to local
for the server to transmit a policy to the client. Such a
protected resources: services, access control policies, and
policy could specify that the customer must submit a
credentials. We say a credential or access control policy is
student ID and a credit card number in order to make an
disclosed if it has been sent to the other party in the
on-line purchase and receive a student discount. The
negotiation, and that a service is disclosed if the other
customer (for example, a female student) is only willing to
party is given access to it. Disclosure of protected
disclose her credit card number to a business that is a
resources is governed by access control policies.
member of the Better Business Bureau (BBB). In
The architecture in figure 1 supports a single protocol
accordance with her policy, her trust negotiation agent
for establishing trust. The architecture is designed to
discloses her student ID and requests that the server return
support customized negotiation strategies. All trust
a BBB member credential to the client. The server then
negotiation strategies share the goal of building trust
sends the client a BBB member credential. Finally, the
through an exchange of digital credentials. The purpose of
client submits a valid digital credit card number and
this exchange is obtaining access to a protected resource.
receives the student discount.
Once the access control policy for a particular credential
Since digital credentials can often contain sensitive
has been satisfied, a local negotiation strategy must
information, associating an access control policy with each
determine whether the credential is relevant to the current
credential controls credential disclosure. As in the
stage of the negotiation. If so, it will be disclosed.
example above, a credential is disclosed only when its
Different negotiation strategies will use different
access control policy has been met. For a trust negotiation
definitions of relevance, involving tradeoffs between
to be successful, some credentials must be freely available
computational costs, the length of the negotiation, and the
on at least one side of the negotiation.
number of disclosures.
This paper describes the Trust Negotiation in TLS
From the handful of trust negotiation strategies
(TNT) protocol, an extension to the TLS handshake
proposed so far in the literature [10][13][14][15], it is clear
protocol that incorporates trust negotiation to provide
that there are endless variations in how to negotiate trust.
advanced client/server authentication in TLS. The TNT
It is unlikely that a single strategy will meet the needs of
protocol is based on recent advances in trust negotiation
all users. The TrustBuilder architecture is designed to
and provides a solution for confidential trust negotiations
support a strategy-independent, policy-language-
and for verifying credential ownership. The details of
independent trust negotiation protocol that ensures
these issues have so far not been addressed in past trust
interoperability within a family of negotiation strategies
negotiation protocol proposals. This paper also describes
[15].
our implementation of TNT, which extends PureTLS, a
Access control policies for local resources specify
freely available Java implementation of SSL/TLS (See
credentials that the other negotiation participant must
http://www.rtfm.com/puretls/ for more details). Section 2
disclose in order to obtain access to those resources.
discusses recent advances in the area of trust negotiation.
During a negotiation, the security agent invokes a local
Section 3 describes the TLS handshake protocol and
compliance checker in two ways. First, the security agent
identifies current limitations in TLS client/server
receives credentials from the other participant and checks
authentication with regard to mutual authentication
to see if the relevant local access control policies are
between strangers. Section 4 contains the description of
satisfied by the remote credentials before disclosing a local
the TNT protocol that extends the TLS handshake
protected resource. Second, the agent may also receiveLocal Site Security Agent Remote Site Security Agent
Negotiation Access Access Negotiation
Manager control control Manager
policies policies
Negotiation Negotiation
Protocol Protocol
Strategy Engine API Protected Protected Strategy Engine API
Resources Resources
S Et nra gt ie ng ey crs ee dr evi nc te ias l,
s ,
Disclosures
crs ee dr evi nc te ias l,
s ,
S
E
tr na gt ie ng ey
policies policies
Figure 1. The TrustBuilder architecture for automated trust negotiation. A security agent who
manages local protected resources and their associated access control policies represents each
negotiation participant. TrustBuilder provides the necessary middleware support for security
agents to enable negotiation strategy interoperability.
remote access control policies that serve as requests for credentials during trust negotiation have not been
local credentials. The agent checks to see whether any addressed previously. To date, no implementation of the
local credentials satisfy the remote access control policy. negotiation protocol or negotiation strategies exists.
If so, the agent uses the negotiation strategy to determine if
and when those local credentials should be disclosed to the 3. Transport Layer Security (TLS)
other party to advance negotiation toward the goal of
granting access to the protected resource.
TLS is a connection-oriented protocol that provides a
When an access control policy P contains sensitive
secure channel between a client and a server. TLS
information, then P itself requires protection in the form of
supports confidentiality, data integrity, and client/server
an access control policy for access to P. Earlier work in
authentication. The TLS handshake protocol provides a
trust negotiation introduced support for sensitive policies
means for authentication and the negotiation of security
using policy graphs [10]. The presence of sensitive
parameters, such as the encryption algorithms, encryption
policies requires that trust be established gradually. For
keys, MAC keys, etc., that are used to transmit data
example, suppose a client begins an interaction with an
securely. The TLS record protocol specifies how
unfamiliar web server. Before sending a sensitive request
application data is actually transmitted between two
for credentials to the server that would reveal information
communicating hosts so that confidentiality and data
regarding the nature of the client’s business, the client may
integrity are provided.
request credentials attesting to how the server handles
The focus of the research described in this paper is
private information and whether or not the server conforms
authentication. Client/server authentication in TLS is
to certified security practices. Once the client has
handled in the handshake protocol. In this section, we
established this initial level of trust, the client can continue
describe the TLS handshake protocol for client/server
by sending the sensitive request for further credentials
authentication and identify the limitations in the protocol
from the server.
for authenticating strangers on the Internet.
The previous work in trust negotiation has focused on
The general TLS handshake protocol is illustrated in
support for sensitive credentials and access control
Figure 2, with optional messages shaded. The exact
policies, the definition and interoperability of trust
sequence of messages in a given handshake between a
negotiation strategies, and a trust negotiation protocol. In
client and server will vary depending on the key exchange
[15], a trust negotiation protocol was presented, along with
method selected by the client and server during the
the Disclosure Tree Strategy (DTS) family. It was proved
handshake. The TLS handshake has four phases. In the
that if two participants each choose a strategy from the
first phase, the client and server exchange hello messages
DTS family, they will be able to negotiate trust just as well
that are used to establish security parameters used in the
as if they had both adopted the same strategy. The issues
TLS session and settings used during the handshake, such
of confidentiality and verifying ownership of submitted
as the key exchange algorithm. During the second phase,Client Server Client Server
ClientHello ClientHello
ServerHello ServerHello
Certificate Certificate
CertificateRequest
ServerKeyExchange
ServerHelloDone
CertificateRequest
ServerHelloDone
Certificate
Certificate ClientKeyExchange
ClientKeyExchange
CertificateVerify
CertificateVerify
ChangeCipherSpec
ChangeCipherSpec Finished
Finished
ChangeCipherSpec
ChangeCipherSpec
Finished
Finished
Figure 3. The TLS handshake protocol for
Figure 2. The general TLS handshake client and server authentication using the
protocol with optional messages shaded. RSA key exchange method.
the server sends a Certificate message to the client
3.1. TLS client/server authentication
that may include a server certificate when an RSA key
exchange is used, or Diffie-Hellman parameters when a
This section describes the specific form of a TLS
Diffie-Hellman key exchange is used. The server may also
handshake that supports client and server authentication
request a certificate from the client using the
using the RSA key exchange method, shown in Figure 3.
CertificateRequest message. During the third
Using this method, the client and server exchange
phase of the handshake, the client may send its certificate
certificates with one another for mutual authentication.
to the server in a Certificate message along with a
The client initiates the handshake by sending a
CertificateVerify message so that the server can
ClientHello message to the server. The server
verify certificate ownership, if the server requested a client
responds with a ServerHello message. These
certificate during the second phase. The client must send
messages contain the necessary information to establish
either a pre-master secret encrypted using the server’s
the security parameters for the TLS session. Although the
public key, or public Diffie-Hellman parameters, in the
messages contain the same parameter types, they have a
ClientKeyExchange message so that the client and
slightly different meaning. Table 1 lists the parameters of
server can compute a shared master secret. In the fourth
these two hello messages and describes their meaning.
phase of the handshake, the client and server finish the
The cipher suite parameter is a 4-tuple specifying the
handshake so that they may begin exchanging application
cryptographic algorithms to use in the TLS session. These
data.
include the server authentication algorithm, key exchange
The full range of handshake variants is beyond the
algorithm, bulk encryption algorithm, and digest algorithm
scope of this paper. Interested readers are referred to
for message integrity.
[4][9][12] for a full treatment of the TLS handshake.Parameters ClientHello ServerHello
Version Highest SSL/TLS version supported by client Lower of the client-suggested version and
highest server-supported version
Random Client-generated random structure, used as a nonce Server-generated random structure
SessionID Variable-length session identifier. A zero value If client sends a zero value, server returns
indicates a new session. A non-zero value refers to an a new session ID, otherwise returns the
earlier session the client wishes to resume. old session ID supplied by the client.
CipherSuite List of cryptographic algorithm combinations the client Single cipher suite selected from the list
supports, in decreasing order of preference. supplied by the client.
Compression List of the compression methods supported by the Compression method selected by the
Method client server.
Table 1. A description of the parameters contained in the TLS ClientHello and ServerHello messages.
The server continues the handshake by sending a message using the public key contained in the client
Certificate message containing an X.509 certificate certificate and compares the result to a hash of all the
or certificate chain. Next, the server sends a previous messages exchanged during the handshake. This
CertificateRequest message, communicating the message serves as an implicit challenge for the client to
following three items of information to the client: first, that prove ownership of the private key associated with the
the server requires a client certificate for authentication client certificate.
purposes; second, a list of certificate types the server is The handshake now enters the final phase. The client
willing to accept; and third, a list of X.500 distinguished sends a ChangeCipherSpec message, indicating that
names of the certificate authorities that the server trusts. the client will now begin encrypting its communications
For the kind of handshake being described, the server using the new cryptographic keys that were just computed.
specifies the certificate type as RSA. The list of trusted Then the client sends a Finished message to the server
certificate authorities assists the client in selecting a containing a hash of all the preceding messages exchanged
certificate or certificate chain to submit that is signed by a during the handshake. The server follows suit by sending
root CA that the server trusts. Finally, the server sends a its own ChangeCipherSpec and Finished messages
ServerHelloDone message indicating that it is now to the client. Upon completion of the handshake,
the client’s turn to continue the handshake. application data begins to flow through the secure channel.
The third phase of the handshake protocol consists of Note that no application data, such as an HTTP request,
messages sent from the client to the server. First, the flows from the client to the server until after the encrypted
client sends a Certificate message to the server session is established.
containing an X.509 certificate or certificate chain.
Next, a ClientKeyExchange message is sent 3.2. Limitations in TLS authentication
containing a client-generated, pre-master secret to be used
for key generation. The client encrypts the pre-master The following are limitations to authenticating strangers
secret using the public key contained in the server’s on the Internet using TLS client/server authentication:
certificate that was received earlier in the handshake. The 1. Certificates are exchanged in plain text during the
only way for the server to decrypt the message initial TLS handshake. This does not present a danger
successfully and obtain the pre-master secret is if the that an eavesdropper can intercept the certificate and
server possesses the private key associated with the misuse it. An attacker who intercepts a certificate is
certificate the server previously sent to the client. Thus, unable to pose as the owner of the certificate without
the ClientKeyExchange serves as an implicit obtaining possession of the associated private key,
challenge for the server to prove ownership of the private assuming due diligence on the part of authentication
key. If the server successfully decrypts the pre-master services to challenge for possession of the associated
secret, the server can generate the correct keys to be used private key appropriately whenever a certificate is
during the TLS session. presented. However, exchanging certificates in the
The third phase of the handshake concludes when the clear does introduce privacy risks whenever certificate
client sends a CertificateVerify message to prove contents are sufficiently sensitive that disclosing the
certificate to anyone unauthorized to receive it is
ownership of the private key associated with the certificate
undesirable.
the client just disclosed to the server. The message
2. The client and the server are limited to disclosing a
consists of a signed hash of all previous messages
single certificate chain to each other. In certain
exchanged during the handshake. The server decrypts thecircumstances, disclosing multiple certificate chains messages added to TNT that are not already included in
provides a greater level of trust compared to a single TLS is given using the syntax from the TLS protocol
certificate chain, especially when several attributes are specification.
of interest in determining trust and different
certification authorities are trusted to issue certificates 4.1. TLS rehandshake
containing those attributes. Requiring multiple
certificate chains for authentication may also mean that Once a TLS connection is established using the
multiple private keys must be compromised in order for handshake protocol described in the previous section, it is
an imposter to successfully breach the system. possible to conduct a TLS rehandshake. The rehandshake
3. The server specifies a list of distinguished names of is simply the TLS handshake performed over an existing,
certifying authorities that the server trusts when it and likely encrypted, TLS connection. (Although not
requests a client certificate. In contrast, the client has common, it is possible for a TLS session to provide
no such opportunity. message integrity, but not encryption.) Either the client or
4. The server discloses its certificate before the client server can initiate a rehandshake.
discloses a certificate, forcing the server to always A client initiates a rehandshake by sending a new
make the disclosure to a complete stranger. ClientHello message to the server after a previous
5. The client always receives a certificate from the server handshake has finished. A server can initiate a
before it is required to disclose its own certificate to the rehandshake by sending a ServerHelloRequest
server. Although the client is able to verify the validity message to a client. The client responds with a
of the certificate contents, at the moment the client ClientHello message, and the handshake continues as
discloses a certificate to the server, the client has no usual. Either party has the option of ignoring a request for
proof that the server owns the certificate that it a rehandshake, but that is rarely done.
disclosed. Thus, the client cannot rely on the server The three purposes of a rehandshake in SSL/TLS are:
certificate to determine conclusively whether or not to 1) client authentication, 2) cipher suite upgrading, and 3)
trust the server enough to disclose a sensitive client replenishment of keying material. Suppose a server is
certificate. configured to enforce different security requirements
6. If the certificate chain received by either the client or according to the specific data or service being accessed.
the server does not completely satisfy their Until the server receives the client’s request, there is no
authentication requirements, there is no facility in the basis for client authentication. In this case, it is not
protocol for requesting additional certificates to meet possible to authenticate the client during the initial TLS
all the authentication requirements. The typical handshake at the beginning of a connection, because the
approach is for the client to authenticate the server if a server has not yet received any application data from the
trusted root CA known to the client signs the root client. Only after receiving application data, such as an
certificate in the chain. Web clients typically HTTP request, can the server authenticate the client based
authenticate the server if the distinguished name in the on the access control policy of the requested service.
certificate matches the DNS name for the web server The rehandshake is used to upgrade the strength of the
host machine. Most often, if servers authenticate cipher suite in Netscape's Step-Up methodology—similar
clients at all, they simply verify that the client possesses to Microsoft's Server Gated Cryptography, or SGC [9].
the private key associated with the public key presented Before the United States’ export regulations were relaxed,
certificate. an exception was granted for the use of strong encryption
during certain financial transactions. For example, a client
4. Trust negotiation in TLS using only 40-bit encryption could automatically switch to
stronger encryption when the client determined it had
The Trust Negotiation in TLS (TNT) protocol is an connected to a web server that was granted an exception to
extension to the TLS handshake protocol that is designed use strong cryptography, such as a financial institution
to use trust negotiation to establish trust between strangers. outside the United States. For example, suppose a client
TNT provides advanced client/server authentication in connects to a bank in Paraguay and indicates that it is an
TLS by overcoming the limitations of TLS client/server exportable client who is only able to support 40-bit
authentication presented in the previous section. This encryption. The bank's server can send back a special
section describes the TLS rehandshake and session certificate in the TLS handshake indicating that it is
resumption procedures and details how TNT leverages allowed to use strong cryptography with exportable clients.
those procedures to support confidential trust negotiations. After receiving this certificate, the client can initiate a
This section also describes the TNT protocol for rehandshake to negotiate a TLS session with stronger
conducting trust negotiation between a TLS client and encryption.
server during a rehandshake. Finally, the definition of newUsing Netscape’s Step-Up methodology, a web browser resumption, an abbreviated handshake occurs as follows.
initiates a re-handshake at the conclusion of the The client sends a ClientHello message to a server
handshake. Microsoft’s SGC methodology is and includes the sessionID from a previous session
implemented to allow the browser to interrupt the current with the server. If the server is willing to resume the
handshake and begin a rehandshake. Although this is session, the server replies by returning the same
arguably more efficient, it does violate the SSL/TLS sessionID in the ServerHello message. In order to
specification, which does not allow for a rehandshake to resume a session, the client and server reuse the master
begin in the middle of a handshake. secret from the prior session to compute new keying
A rehandshake is also used to replenish keying material, thus avoiding the expensive public-key
material. This is done to prevent cryptographic attacks on operations of a normal handshake. After the
long-lived sessions. In TLS, the keying material can ServerHello message they simply exchange
consist of up to six different values, depending on the
ChangeCipherSpec and Finished messages, with
cipher suite being used. This includes an encryption key,
the server proceeding first.
MAC key, and an initialization vector (IV) for both the
The TNT protocol presented in the next section
client and server. Keys may also need to be replenished to
leverages TLS session resumption in order to avoid the
prevent CBC rollover when large amounts of data are
overhead of needlessly generating a new master secret.
being transmitted using a block cipher in CBC mode.
Once the client and server successfully negotiate trust, an
When two data blocks i and j encrypt to the same value c,
abbreviated handshake takes place, similar to session
if blocks i+1 and j+1 are equal, they will also encrypt to
resumption. Instead of completing the full handshake, the
the same value, revealing patterns in the data to a
client and server compute new keying material by reusing
cryptanalyst.
the master secret from the current TLS session and
Since trust negotiations involve sensitive certificates,
conclude by sending ChangeCipherSpec and
negotiations must be confidential. During TLS
Finished messages to one another, with the server
client/server authentication, certificates are exchanged in
proceeding first.
plain text in an initial TLS handshake. To overcome this
limitation, TNT is intended for use only during a
4.3. TNT protocol
rehandshake initiated during an encrypted TLS session, to
keep the trust negotiation confidential.
The TNT protocol, shown in figure 4, is designed to
This paper assumes the server initiates the rehandshake,
support trust negotiation between a TLS client and server
to establish trust in a client according to the access control
whenever a TLS client has requested access to a sensitive
policy associated with the sensitive resource that the client
service and the access control policy associated with the
has requested to access. In the future, TNT will also
service is not satisfied. A TLS server desiring to negotiate
permit a client to establish trust in a server prior to any
trust with a client initiates a rehandshake by sending a
application data being passed through the secure channel,
HelloNegotiationRequest message to the client.
known as client-initiated trust establishment [1].
The client responds with a ClientHello message,
Single-round trust negotiations do not involve sensitive
followed by the server sending a ServerHello
certificates, and therefore do not require confidentiality.
Although not addressed in this paper, this simple case message. The sessionID included in the hello
could be supported in the normal TLS handshake. A messages is the sessionID associated with the current
simple negotiation occurs, for example, when a server session, to allow for streamlined session resumption
requests a certificate from the client and the client following a successful trust negotiation.
immediately discloses the certificate. TNT is designed to In order to conduct a successful trust negotiation, the
protect sensitive certificates in more complex negotiations. negotiation participants must first agree on a trust
negotiation strategy family. Once they agree on a strategy
4.2. TLS session resumption family, each party is free to independently select a
negotiation strategy from that strategy family, with the
The performance bottleneck in TLS handshakes is the guarantee that trust will be successfully negotiated
public key cryptographic operations [9]. In particular, the whenever possible [15]. Two design choices for adding
encryption and decryption required to confidentially information on the negotiation strategy family into TLS
exchange a pre-master secret is expensive. One of the are: 1) include the strategy family in the hello messages, or
reasons the client must verify the server’s certificate is to 2) incorporate the strategy family into the TLS cipher
use the server’s public key to encrypt the pre-master secret suite. A current IETF Internet draft specifies extensions
in the key exchange. to the ClientHello and ServerHello messages that
TLS supports session resumption in order to avoid the can be used to communicate support for new capabilities
overhead of a full TLS handshake. With sessionClient Server
until the negotiation succeeds or is terminated. During the
server’s turn, the server first discloses zero or more
HelloNegotiationRequest certificates using a combination of TLS Certificate
and CertificateVerify messages. Immediately
ClientHello
following each Certificate message, the server
ServerHello
demonstrates ownership of a private key using the
CertificateVerify message, unless the server has
previously demonstrated possession of the private key
Certificate earlier in the negotiation. The CertificateVerify
message is encrypted using the server’s private key
* CertificateVerify
associated with the certificate the server just disclosed. It
is sent to prove to the client that the server is the owner of
Policy
the certificate. Next, the server discloses zero or more
*
ServerTurnDone Policy messages. Policies are disclosed to provide hints
to the client regarding the certificates the client can
+ disclose to advance the negotiation. Finally, the server
Certificate sends a ServerTurnDone message indicating that the
server has nothing further to disclose during this round of
CertificateVerify * the negotiation.
Next, the client takes a turn disclosing information to
Policy advance the negotiation, following the same general
* pattern as the server. The client first discloses zero or
ClientTurnDone
more certificates using a combination of Certificate
and CertificateVerify messages. Immediately
following each Certificate message, the client
NegotiationDone demonstrates ownership of a private key using the
CertificateVerify message, unless the client has
ChangeCipherSpec
previously demonstrated possession of the private key
Finished earlier in the negotiation. Next, the client discloses zero or
more policies to provide hints to the server regarding the
ChangeCipherSpec
certificates the server can disclose to advance the
negotiation. The client concludes its turn during the
Finished
current round of negotiation by sending a
ClientTurnDone message.
The negotiation continues for a number of rounds until
the server’s policy governing the resource is satisfied or
Figure 4. The TNT handshake protocol for
the negotiation is terminated. The server checks to see
negotiating trust during an encrypted TLS
whether the policy is satisfied after each round of the
rehandshake, with optional messages shaded.
negotiation. Once the policy is satisfied, the server
successfully concludes the negotiation by sending the
in a TLS client or server [2]. The draft is work in NegotiationDone message.
progress. Either party may terminate the negotiation at any time
Anticipating that extensibility in the hello messages using the facilities for terminating any other TLS
will be available in TLS in the future, TNT extends the handshake. The decision to terminate is dependent on the
ClientHello and ServerHello messages to include negotiation strategy. Previous work on trust negotiation
the TrustNegotiationStrategyFamily field. characterizes important properties of negotiation strategies,
Using that field in the ClientHello message, a TNT including termination [10][13][14][15]. A production
client includes a list of the negotiation strategy families implementation of TNT could use these previous results to
that the client supports. The server selects a strategy place practical limits on the number of rounds of
family from the list presented by the client and returns it in negotiation to insure a negotiation does not continue
the ServerHello message. indefinitely.
Following the exchange of hello messages, the TNT The final phase of the TNT protocol is very similar to
protocol enters the negotiation phase, in which the server the conclusion of the abbreviated TLS handshake. The
and client take turns disclosing policies and certificates server sends a ChangeCipherSpec message and aFinished message. Once the client replies with the 4.4. Overcoming TLS authentication limitations
same two types of messages, the rehandshake is complete.
The following is an example trust negotiation between a The TNT protocol overcomes the limitations of TLS
client and server using TNT. Suppose a web browser and client/server authentication described in section 3.2, as
server support TNT. The user is a student purchasing a described in the following list corresponding to each of the
book from an online bookstore that offers discounts to limitations given previously.
students at accredited universities. Suppose the user 1. The TNT protocol is conducted within the scope of a
requests a student discount while purchasing a book in the rehandshake during an encrypted TLS session.
context of a TLS session. For this example, assume the Sensitive certificates are not exchanged in plain text.
client and server are initially unfamiliar with one another. 2. The client and the server can exchange multiple
The server initiates a TLS rehandshake in order to certificates during each round of a negotiation.
authenticate the client as a valid student by sending a Requiring multiple certificates from different certifying
HelloNegotiationRequest message to the client. authorities can reduce the risk associated with a single
The client responds with a ClientHello message, private key compromise. This is the electronic
followed by a ServerHello message from the server. equivalent of requiring multiple forms of ID.
These messages permit the client and server to select a 3. The TNT protocol allows the server to go first.
trust negotiation strategy family and the RSA key However, the server is not obligated to disclose all of
exchange method. its certificates before the client discloses any. The
server can save more sensitive certificates for
Next, the server sends a Policy message to the client
disclosure during later rounds of the negotiation.
that describes the certificates the client must submit in
Another approach that could be explored is to have the
order to receive the discount service. In this case, the
participants negotiate who goes first. The decision of
server requires a valid student ID certificate and a credit
who proceeds first is related to the negotiation strategy;
card certificate. For this example, we ignore the details of
so further work in this area is warranted.
the valid certificate chains that are required in practice.
4. The client and server have equal opportunity to disclose
The server then sends a ServerTurnDone message.
policies to one another to specify their trust
Suppose the client has the necessary certificates to obtain a
requirements.
discount, but considers them to be sensitive. In order to
5. The client and server both send verification messages to
establish trust in the server, the client sends a Policy
one another after disclosing a certificate that they own.
message requesting certificates from the server that
This verifies ownership of associated private keys. It is
demonstrate the server is a member of the Better Business
necessary to prove this immediately in TNT so that the
Bureau and is certified by TRUSTe to follow its privacy
certificate can be reliably used to gain access to
practices to not share private information with any outside
sensitive certificates of a negotiation counterpart.
party. The client then sends a ClientTurnDone
6. The TNT protocol permits clients and servers who are
message, indicating it is done with this stage of the
strangers to inform each other regarding their
negotiation.
requirements for establishing trust through the use of
Next, assume the server possesses the certificates that
Policy messages. Even a negotiation strategy that does
satisfy the client’s request. The server sends a
not make use of policy messages could allow a client
Certificate message and a CertificateVerify
or server the ability to begin disclosing less sensitive
message for each of the certificate chains associated with
certificates and only disclose more sensitive certificates
its BBB and TRUSTe certificates, followed by a
when absolutely necessary. TNT is more flexible than
ServerTurnDone message. Now that the server is
the one-time disclosure currently available in TLS.
authorized to receive the client’s certificates, the client
continues the negotiation by sending a Certificate
4.5. TNT message syntax
message and a CertificateVerify message for the
two certificates requested earlier by the server, the student
The majority of the message types in the TNT protocol
ID and credit card. The client then sends a
are standard TLS message types. The semantics of these
ClientTurnDone message. messages remain the same in TNT as they are in TLS. The
Once the client has satisfied the server’s requirements TNT protocol introduces five new message types. The
for the discount service, the server sends a following syntax describes four new message types in
NegotiationDone message. Finally, the handshake TNT that are simply for control flow purposes.
completes according to the abbreviated approach used Struct {} HelloNegotiationRequest
during session resumption, with the server and client Struct {} ServerTurnDone
sending a ChangeCipherSpec message and a Struct {} ClientTurnDone
Finished message to one another. Struct {} NegotiationDoneTNT
d,e
TrustBuilder
b,c
The following syntax describes the TNT Policy message. In our implementation, the client and server each rely
Struct {Policy policy;} on a TrustBuilder component to manage certificates,
opaque Policy<2^24-1> policies, and services. TrustBuilder implements the
The syntax and semantics of the Policy message is negotiation strategy and handles all decision-making
not specified in the TNT protocol. It is dependent on the aspects of a negotiation. Once the client and server
TNT implementation. Section 5 discusses the policy receive remote certificates and policies during a
representation in our implementation of TNT. negotiation, they submit them to TrustBuilder for
evaluation. TrustBuilder determines which local
5. Implementation certificates and policies to disclose, and when to disclose
them.
In our research, we utilize the IBM Trust Establishment
There are two approaches to supporting confidential
(TE) system [6] to create X.509v3 certificates and XML
trust negotiation using TLS: build an application level
role-based access control policies that govern access to
protocol above TLS, or integrate trust negotiation into TLS
sensitive services and certificates. Additionally, the TE
client/server authentication. The TNT protocol is an
runtime system has a compliance checker that
example of the latter approach. In our research, we are
TrustBuilder uses to verify whether a set of certificates
exploring both approaches through the design and
satisfies an access control policy. Note that the TLS client
development of TrustBuilder, trust negotiation middleware
and server each rely on the compliance checker during
consisting of reusable trust negotiation components.
trust negotiation to verify 1) whether the remote
An advantage of integrating trust negotiation into TLS is
certificates received during the negotiation satisfy the local
the opportunity to leverage capabilities already available in
policies governing access to local services or certificates,
a TLS implementation, including verifying certificate
and 2) whether local certificates satisfy remote policies
contents and both verifying and proving certificate
received during the negotiation.
ownership. An application-level protocol for trust
The typical usage model for a compliance checker in
negotiation requires a custom solution providing similar
trust management systems is to input a set of certificates
capabilities.
and a policy to a Boolean decision function. Our trust
We have implemented a research prototype supporting
negotiation prototype requires an extended usage model
the TNT protocol described earlier. The implementation
whenever policies are disclosed during trust negotiation.
architecture is illustrated in Figure 5. Our implementation
For example, when a TLS client receives a policy from the
extends PureTLS, a free Java-only implementation of the
TLS server, the client is able to search for local certificates
SSL V3.0 and TLS V1.0 protocols. PureTLS was
that satisfy the server’s policy, so it can submit those
developed by Eric Rescorla and is distributed by RFTM at
certificates to the server. This allows the negotiation to
http://www.rtfm.com/puretls/.
focus on only those certificates that can advance the
negotiation to a successful conclusion. However, this
IMR
PureTLS
Client
a d
TrustBuilder
d b,c
IBM Trust
Establishment Certificates Policies Services
Module
IMR
PureTLS Key
Server ( a ) Remote Certificates / Policies
( b ) Remote Certificates / Local Policies
( c ) Local Certificates / Remote Policies
( d ) Unlocked Local Certificates / Policies
a ( e ) Authorization Decision
d,e
IBM Trust
Establishment
Module
Figure 5. The implementation architecture for a trust negotiation prototype supporting the TNT
protocol, an extension to the TLS handshake protocol. The implementation extends PureTLS, a
freely available Java implementation of TLS. The architecture includes XML role-based access
control policies and a compliance checker from the IBM Trust Establishment system.requires that the compliance checker accept a set of local as well as keep some private certificate contents
certificates and a remote policy and return not only a completely confidential.
Boolean result indicating whether or not the policy is A recent IETF Internet draft from the TLS Working
satisfied, but also the set of certificates that satisfy the Group [2] discusses work in progress to define extensible
policy so that they can be disclosed to the other party. The hello messages in the TLS handshake protocol.
TE system developers provided an API to their compliance Extensibility will allow a TLS client and server to
checker that supports the extended usage model, prompted negotiate additional features. One example taken from the
by our requirements for trust negotiation. draft document illustrating the use of extensions is to allow
In our implementation, the TrustBuilder trust TLS clients to indicate to TLS servers which CA root keys
negotiation manager and compliance checker run in a they possess in the hello message. This example is one
separate process, providing a flexible architecture for TLS way to overcome a limitation to TLS authentication
clients and servers. For instance, multiple TLS servers presented earlier in the paper in which a TLS client cannot
operating in a high-performance web server environment inform a TLS server regarding the CAs they trust. The
can share the compliance checker, permitting all private negotiation strategy family field added to the hello
key operations to be encapsulated within a separate messages in TNT is another example of an item that could
process that can be isolated on a secure server with a be included in an extensible hello message.
cryptographic coprocessor. Dean et al. [3] describe an extension to TLS that uses
Our experience demonstrates that the protocol client puzzles to prevent denial of service attacks on TLS
extensions to TLS outlined in this paper can be readily servers. An imbalance in the computational requirements
incorporated into existing TLS implementations while still of TLS places an undue burden on the server. An attacker
providing backward compatibility with existing TLS can exploit this to launch a successful denial of service
implementations. The TNT implementation provides a attack. The use of client puzzles places additional
trust negotiation protocol supporting interoperable trust computational demands on the client that tends to balance
negotiation strategies [15] and provides the first the load enough to discourage and prevent successful
implementation of confidential trust negotiation. A denial of service attacks. This paper introduces trust
research prototype implementation of TNT is available negotiation into TLS, potentially increasing the
from BYU’s Internet Security Research Lab requirements on TLS servers. Adopting the use of client
(http://isrl.cs.byu.edu/). puzzles into our work has the potential to prevent denial of
service attacks against TNT.
6. Related work
7. Conclusions and future work
Yu et al. [15] introduce the notion of a family of trust
negotiation strategies guaranteed to interoperate. They This paper presents TNT, an extension to the TLS
also introduce the idea of a trust negotiation protocol handshake protocol supporting advanced client/server
supporting a variety of negotiation strategies. Our work authentication in TLS. TNT incorporates recent advances
represents the design and implementation of those ideas in in trust negotiation from TrustBuilder [15] into TLS
TNT, an extension of the TLS handshake protocol. client/server authentication. This integration overcomes
Previous trust negotiation prototypes [13] [11] focused on the existing limitations in TLS client/server authentication
languages for trust negotiation and negotiation strategies. for establishing trust between strangers.
The trust negotiation protocols were implemented at the By integrating trust negotiation into TLS, the strengths
application layer. Our work extends these earlier efforts of the TLS protocol are leveraged to provide confidential
by providing confidential trust negotiation and the trust negotiation and the verification of private keys
verification of private keys associated with certificates associated with certificates disclosed during a trust
disclosed during a trust negotiation. The TNT protocol is negotiation. TNT exploits the rehandshake facility of TLS
designed to support negotiation strategy interoperability. to enable a TLS server to “pull” certificates from the client
Persiano et al. [7] introduce the SPSL protocol to as needed, according to the access control policies of a
extend TLS so that a portion of a disclosed certificate sensitive resource accessed by a TLS client.
remains private from the party to which the certificate was An implementation of TNT has been built that extends
disclosed. This is desirable when an attribute certificate PureTLS, a Java TLS package that is freely available.
contains some sensitive attributes that need not be This implementation is the first to provide confidential
disclosed in order to establish trust. Our work on trust trust negotiation, the verification of private keys during
negotiation focuses on establishing trust in another party in trust negotiation, and a trust negotiation protocol designed
order to disclose a certificate to them. The two approaches to support interoperable trust negotiation strategies [15].
complement one another and could be combined in order In the future, we will explore alternative trust
to authenticate another party prior to certificate disclosure negotiation strategies to insure that the current protocol issufficiently general to support all useful negotiation 9. References
strategy families. Also, policy languages for trust
negotiation is an active area of research, and requirements [1] T. Barlow, A. Hess, and K. E. Seamons. Trust Negotiation
for a trust negotiation policy language are emerging. We in Electronic Markets. Eighth Research Symposium on
believe it unlikely that a single policy language will be Emerging Electronic Markets, Maastricht, Netherlands,
universally adopted. We intend to examine current policy September 2001.
languages in terms of ease of use, expressiveness, and [2] S. Blake-Wilson, M. Nystrom, D. Hopwood, J. Mikkelsen,
and T. Wright. TLS Extensions. Internet Draft, TLS
efficiency for use during trust negotiation. This
Working Group, June 20, 2001. Work in progress available
exploration will help identify any needed extensions to
at http://www.ietf.org/internet-drafts/draft-ietf-tls-extensions-00.txt.
TNT to support policy language interoperability, including
[3] D. Dean and A. Stubblefield. Using Client Puzzles to
additional negotiation parameters TLS handshake hello Protect TLS. Proceedings of the 10th USENIX Security
messages, such as certificate format and policy language. Symposium, Washington D.C., August 2001.
Trust negotiation places greater computational demands [4] T. Dierks and C. Allen. The TLS protocol version 1.0. RFC
on TLS servers, requiring further study of performance 2246, January 1999.
optimizations and scalable security architectures for TNT. [5] A. Frier, P. Karlton, and P. C. Kocher. The SSL 3.0
Our research to date has not addressed performance. The Protocol. Netscape Communications Corp., Nov. 18, 1996.
current TNT prototype consists of non-optimized Java [6] A. Herzberg, J. Mihaeli, Y. Mass, D. Naor, and Y. Ravid.
Access Control Meets Public Key Infrastructure, Or:
code.
Assigning Roles to Strangers. IEEE Symposium on Security
At times, a client may want to authenticate a server
and Privacy, Oakland, May 2000.
prior to sending a sensitive service request, known as
[7] P. Persiano and I Visconti. User Privacy Issues Regarding
client-initiated trust establishment [1]. To illustrate when Certificates and the TLS Protocol. 7th ACM Conference of
this might occur, suppose a client refuses to send personal Computer and Communications Security, Athens, Greece,
information gathered by the service until the server November 2000.
discloses a TRUSTe certificate declaring that the server [8] Recommendation X.509--Information Technology—Open
handles private information appropriately, such as not Systems Interconnection--The Directory: Authentication
Framework. International Telecommunication Union, Aug.
disclosing it to a third party unless the client provides
1997.
explicit authorization. Since TLS allows a client to initiate
[9] E. Rescorla. SSL and TLS: Designing and Building Secure
a rehandshake, the client could establish trust in the server
Systems. Addison-Wesley, 2001.
before any sensitive application data is transmitted, using a
[10] K. E. Seamons, M. Winslett, and T. Yu. Limiting the
similar approach to the server-initiated rehandshake Disclosure of Access Control Policies During Automated
approach adopted by TNT in this paper. Trust Negotiation. Symposium on Network and Distributed
This paper considered trust negotiations involving System Security, San Diego, Feb. 2001.
sensitive certificates, requiring that trust negotiations be [11] K. E. Seamons, W. Winsborough, and M. Winslett. Internet
confidential. This made it necessary that a trust Credential Acceptance Policies. Proceedings of the
Workshop on Logic Programming for Internet Applications,
negotiation always occur in the context of an encrypted
Leuven, Belgium, July 1997
TLS rehandshake. In the future, we will consider
[12] S. Thomas. SSL and TLS essentials: Securing the Web.
extending TLS to support the simplest negotiations not
Wiley Computer Publishing, 2000.
involving sensitive certificates. Simple negotiations could
[13] W. Winsborough, K. E. Seamons, and V. Jones. Automated
occur frequently in practice, for example, during client- Trust Negotiation. DARPA Information Survivability
initiated trust establishment when the client verifies that a Conference and Exposition, Hilton Head, SC, Jan. 2000.
TLS server satisfies a general, well-known security [14] T. Yu, X. Ma, and M. Winslett. PRUNES: An Efficient and
requirement that need not be kept confidential. These trust Complete Strategy for Automated Trust Negotiation over
negotiations could be conducted during the initial TLS the Internet. 7th ACM Conference on Computer and
handshake, since they do not require confidentiality. Communications Security, Athens, Greece, November 2000.
[15] T. Yu, M. Winslett, and K. E. Seamons. Interoperable
Strategies in Automated Trust Negotiation. 8th ACM
8. Acknowledgements
Conference on Computer and Communications Security,
Philadelphia, Pennsylvania, November 2001.
This research was supported by DARPA through AFRL
contract number F33615-01-C-0336 and the Space and
Naval Warfare Systems Center San Diego grant number
N66001-01-18908. The authors express thanks to
Marianne Winslett for her helpful feedback and
discussions on an earlier version of this paper and to Ryan
Jarvis for his help preparing the final submission. They
also thank the anonymous reviewers for their comments.