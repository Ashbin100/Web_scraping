DIRA: Automatic Detection, Identification, and Repair of Control-Hijacking
Attacks
AlexeySmirnov Tzi-ckerChiueh
ComputerScience Department
StateUniversityofNewYorkatStonyBrook
StonyBrook,NY11794-4400
{alexey,chiueh}@cs.sunysb.edu
Abstract 1. Introduction
A control-hijackingattackoverwritessomedata struc-
turesinavictimprogramthataffectits controlflow,and
Bufferoverflowattacksareknowntobethemostcom-
eventuallyhijacksthecontroloftheprogramandpossibly
mon type of attacks that allow attackers to hijack a re-
theunderlyingsystem.Adatastructurethatcanaffectthe
mote system by sending a specially crafted packet to a
controlflowofaprogramiscalledacontrol-sensitivedata
vulnerablenetworkapplicationrunningonit. Acompre-
structure,examplesofwhichincludereturnaddress,func-
hensive defense strategy against such attacks should in-
tionpointer,globaloffsettable/importtable, C++ virtual
clude (1) an attack detectioncomponentthat determines
functionstable pointer,etc. Once anattacker grabscon-
thefactthataprogramis compromisedandpreventsthe
trol ofthevictimprogram,shecaninvokeanyoperation
attackfrom furtherpropagation,(2)anattack identifica-
to which the victim program’s effective user is entitled.
tion componentthat identifies attack packets so that one
Control-hijackingattacksareconsideredthemostdanger-
can block such packets in the future, and (3) an attack
oustypeofattacksbecausetheyexploitsoftwarebugsdi-
repaircomponentthatrestoresthecompromisedapplica-
rectlywithoutrequiringanyuseractions,andbecausema-
tion’sstatetothatbeforetheattackandallowsittocon-
liciouscomputerwormsusethemasbasicbuildingblocks
tinuerunningnormally.Overthelastdecade,asignificant
topropagatethemselvesfromonemachinetoanother.
amount of research has been vested in the systems that
Over the last decade, a significant amount of research
candetectbufferoverflowattackseitherstaticallyatcom-
hasbeeninvestedinthedetectionofcontrol-hijackingat-
piletimeordynamicallyatruntime. However,notmuch
tacks. Some are based on program analysis techniques
effort is spent on automated attack packet identification
[38, 12,19, 26,32, 37] thatstatically determinewhether
or attackrepair. Inthis paperwe presenta unifiedsolu-
a given program contains buffer overflow vulnerability.
tion to the three problems mentioned above. We imple-
Othersuseprogramtransformationtechniques[8,11,10,
mentedthissolutionasaGCCcompilerextensioncalled
14,36,9]toconvertapplicationsintoaformthatcanei-
DIRA that transforms a program’s source code so that
therdetectcontrol-hijackingattacks[8,10,14,9]orpre-
theresultingprogramcanautomaticallydetectanybuffer
ventcontrol-sensitivedatastructuresfrombeingmodified
overflowattackagainstit,repairthememorydamageleft
at run time [11]. Still others develop operating system
bytheattack,andidentifytheactualattackpacket(s). We
mechanisms that ensure that it is not possible to execute
used DIRAtocompileseveralnetworkapplicationswith
codeinjectedintothevictimprogram[34,27].Regardless
knownvulnerabilitiesandtested DIRA’seffectivenessby
oftheirapproach,mostifnotalloftheseeffortscouldonly
attacking the transformed programs with publicly avail-
determinewhetheraprogramisunderacontrol-hijacking
able exploit code. The DIRA-compiled programs were
attack,butcouldnotactivelyrepairavictimprogramaf-
alwaysabletodetecttheattacks,identifytheattackpack-
terithasbeencompromised.Typically,upondetectingan
ets and most often repair themselves to continue normal
attack, theysimply terminatethe victim application, and
execution. The average run-time performance overhead
restartanotherinstanceifnecessary. Whileterminatinga
forattackdetectionandattackrepair/identificationis4%
compromised application helps prevent further propaga-
and25%respectively.
tion of the attack, it may lead to a denial of service at-
tack. Fornetworkapplicationswithasubstantialamount
ofstatesuchasaDNSsever,ittakessometimeforthemD I R corruptedcontrol-sensitivedatastructureneedstobefirst
Stackguard[10],RAD[8] + - - computedandthenintersectedwiththeincomingpackets.
Buttercup[29],Autograph[21] - + - DIRA takes an application’ssourcecode, andinserts ad-
Flashback[33],IGOR[13] - - + ditionalloggingcodesothattheresultingapplicationcan
DIRA + + + detect, identify, and recover from any control-hijacking
attacksinawaythatiscompletelyindependentoftheun-
Table1.Previousworkaddressingproblems derlyingoperatingsystemandhardware.
of attack (D)etection, (I)dentification, and The restofthis paperis organizedas follows. Section
(R)epair. 2 reviews previous research on detection and prevention
methodsforcontrol-hijackingattacks, as well as onpro-
gramrollback.Section3describestheloggingalgorithms
tore-acquirethenecessarystateatstart-upinordertopro- anddatastructuresusedinthe DIRAcompiler.InSection
videthefullservice. Fortheseapplications,abrupttermi- 4wediscusstheimplementationdetailsofthe DIRAcom-
nationisnotanacceptableattackrecoverystrategy.More- piler. Section 5 presents the performancemeasurements
over, because existing control-hijacking attack detection ofafullyoperational DIRAprototypeandtheiranalysis.
systemscannotpreventthesameattacksfromtakingplace Section6concludesthispaperwitha summaryofmajor
again,vulnerableapplicationsmayberepeatedlyvictim- researchcontributionsandabriefoutlineoftheon-going
izedandre-startedinthepresenceofrecurringattacksas work.
inthecaseofworms.Inthemeantime,theseapplications
cannotrenderanyusefulservicetotheirintendedusers. 2. RelatedWork
Toaddressthelimitationsofexistingsystemsthatfocus
Our work is based upon previous work in three broad
onlyondetectionofcontrol-hijackingattacks,thisproject
areasofsystemsresearch: bufferoverflowattacksdetec-
aims to developa program transformationsystem called
tion,maliciouscodeidentification,andprogramrollback
DIRAthatcanautomaticallytransformanarbitraryappli-
andreplay.
cationintoaformthat
Approachestodetectbufferoverflowattackscanbedi-
• Can detect a control-hijacking attack when the vided into two groups: static techniques that detect po-
control-sensitivedatastructureittamperswithisac- tential buffer overruns by examining program’s source
tivated, codeanddynamictechniquesthatprotectprogramsatrun-
time. Wilanderet. al. [39, 40] presenta comprehensive
• Can identify the network packets that lead to the overview of tools of both types. Greiner [16] gives an
control-hijacking attack, and send these packets to overviewofmanualcodeauditingtechniquesthathelpde-
a front-endcontent filter to preventthe same attack tectpotentialvulnerabilities.
fromcompromisingtheapplicationagain,and Therealcauseofbufferoverflowsisuncheckedpointer
• Canrepairitselfbyerasingallthesideeffectsofthe orarrayaccess.JonesandKelly[20]andAustinet.al.[3]
proposetocheckeachpointeraccessatruntimetosolve
attackpacketsasifitneverreceivedthem.
thisproblem. Thisrequiresaugmentationofthestandard
To the best of our knowledge, attack detection, repair pointer representation with additional fields such as the
and identification have never been considered together extent of the memoryregionthat the pointer is referring
previously. Table 1 puts in perspective related projects to. Both systems are implementedas C compiler exten-
in each of these three areas. The main contribution of sions that instrument the source code of the program in
this paper is the developmentof a unified solution to all suchawaythatthemodifiedprogramcheckseachpointer
threeproblems. Eventhoughonthesurfaceattackdetec- access it performs at run-time. Purify [18] is a similar
tion,identification,andrecoveryappeartobecompletely toolthatinstrumentsprogram’sobjectcodeandtherefore
orthogonal functions, a careful examination reveals that does not require access to its source code. However, all
theycanactuallybeunifiedintoasingleimplementation thesetoolssufferfromasignificantperformanceoverhead
framework that is based on memory update logging. To whichcanbemorethan500%insomecases. CRED[31]
repair a program’s memory state, all updates to its ad- is a project that aims to provide a comprehensivemem-
dress space should be logged so that these updates can oryaccessboundscheckingat areasonablecost. Unlike
bereversed. Todetectacontrol-hijackingattack, thebe- otherboundscheckingprojects,CREDcheckstheaccess
foreimageofacontrol-sensitivedatastructureshouldbe correctnessforpointerstocharacterstringsonlyassuming
storedaway,andcheckedatthe timeofactivationtosee thatimproperstringmanipulationisresponsibleformost
ifanytamperingtookplace. Totracebackthepacketsre- bufferoverflowattacks. ThereportedoverheadofCRED
sponsibleforadetectedattack,thebackwardsliceofthe isless than26%. Suchamoderatelyhighoverheadindi-catesaneedformorelightweightandinexpensiveprotec- agation of the recent worms, it is hopeless to rely on a
tionmechanisms. human-basedmethodsforsignaturegenerationas bythe
Thereturnaddressisthemostcommontargetofbuffer timethepropersignatureiscreatedanddistributedamong
overflow attacks. Stackguard [10] is a system that pro- computerusers, the wormis likelytoinfecta significant
tects thereturnaddressby placinga canaryword onthe numberofcomputersystems. Autograph[21]isasystem
stackbeforethereturnaddress.Itisbasedontheassump- that generates worm signatures automatically by detect-
tionthatoverwritingthereturnaddressrequiresoverwrit- ingcommonbytesequencesinsuspiciousnetworkflows.
ingthepartofthestackimmediatelyprecedingit. Ifthe In this system, a network flow is considered suspicious
canary word is found modified upon the function return if it comes from a host that is believed to perform port
thenanattackhastakenplace. RAD[8]takesadifferent scanning. Toth and Kruegel [35] propose a system that
approach. It copies the return address to a buffer called detectsmaliciouscodeinpacketpayloadsbyperforming
thereturnaddressrepositorywhichisprotectedfromboth abstractexecutionofthe payloaddata. Buttercup[29]is
sidesbyapplyingmprotect()systemcall. Similarly,it a system aimed at preventing polymorphic worms with
compares the return address on the stack with the saved known signatures from entering the system. It identifies
value and raises the red flag if the two values are differ- the ranges of possible return addresses for existing vul-
ent. StackShield [36], ProPolice [11], and StackGhost nerabilitiesandcheckswhetheranetworkpacketcontains
[14] are similar systems that protect other code pointers suchaddresses.
suchasfunctionpointersandstackframeregisterinaddi- Another approach to identifying malicious code is to
tiontothereturnaddress.FormatGuard[9]providesaset analyze the execution trace of a compromised program.
ofwrapperfunctionsthatprotecta programfromformat Given the address of the compromised control-sensitive
stringattacks. data structure, one can use dynamic slicing techniques
Anotherapproachtobufferoverflowpreventionispre- [24,22,23]tofindoutallstatementsoftheprogramthat
sented by Baratloo et. al. [4]. They developa dynamic affectedthevalueofthisdatastructure.Thisallowsoneto
librarycalledLibsafethatprovideswrappersforcommon tracebacktheoriginofthemaliciousdatathatwaswritten
libc functions that are prone to buffer overflows. This tothisdatastructuretothepointwhereitfirstappearedin
library is transparently inserted at run-time between the the program. Therefore, one can completely restore the
application being protected and libc using LD_PRELOAD compromisingnetworkpacketoruserinput.Agrawaland
environmentvariable.Theprotectionmechanismisbased Horgan[2]discussseveralapproachesforcomputingdy-
onestimatingtheboundariesofthestackframeofthecall- namicslicesandintroducethenotionofadynamicdepen-
ingfunctionandassumingthatnofunctioncanwritebe- dencegraph.
lowthatboundary. Finally, yet another approach to malicious input iden-
A typical buffer overflow attack executes the injected tificationit tousea techniquesimilartoPerltaint mode.
code on the stack. Therefore, making stack non- The idea is to assign differenttags to all user inputs and
executablewillpreventanystack-basedattack. PaX[34] propagatethesetagsalongthroughallmemoryoperations.
andOpenwall[27]aretwoLinuxkernelpatchesthatim- Upondiscoveringacompromiseddatastructure,onecan
plement non-executablestacks. This approachhas some identifytheoriginofthemaliciousdatabylookingatthe
limitations, however. First, attacks that inject their code tagcurrentlyassociatedwiththatmemorylocation.
into data segment as well as return-into-libcattacks will Systemsupportforrollbackandreverseexecutionisan-
stillwork. Second,Linuxsignalhandlersandsomefunc- other related area of systems research. Althoughnot re-
tionallanguagessuchasLISPrequirethestacktobeexe- lated directly to post-attack recovery, these mechanisms
cutable. can be readily adapted to rollback a program to a pre-
Essentially, theproblemofdetectingabufferoverflow attackstate. Systems thathavea rollbackcapabilityrely
attackreliesonamechanismtomonitoraparticularmem- on one of the followingtechniques: they either keepthe
orylocation(suchasareturnaddress).Asimilarproblem execution history [1] or do periodic state checkpointing
existsinsoftwaredebugginginwhichcaseadynamically [13,28,33].Forexample,Igor[13]isasystemthatsaves
monitoredmemorylocationis called a watch-point. Ex- modifiedmemorypagesateachcheckpoint.RECAP[28]
isting solutions of this problem can be divided into run- andFlashback[33]usecopy-on-writefork()systemcall
timedynamiccheckingtechniques[17,18]andhardware- tocheckpointtheirexecutionstate. Spyder[1]isbasedon
basedtechniques[25,30,41]. thenotionofexecutionhistory. Duringitsnormalexecu-
The problem of automatic identification of malicious tion,Spyderrecordstheprogramcounterandtheoldval-
codebecameincreasinglyimportantinthepastfewyears uesofallvariablesthatthecurrentinstructionwillchange.
sincewormsepidemicsstartedtohappenmoreandmore Allthesesystemsrequirespecificsupportfromtheunder-
frequentlyandathigherspeeds. Giventhespeedofprop- lyingOS.An alternativewayofbringinga compromisedsystem control-hijackingattacksatruntime,the DIRAcompiler
to the normalstate is a completerestart. Canderaet. al. maintains the original image of every control-sensitive
[7,6]developtheconceptofmicro-reboots.Accordingto datastructure,andatthetimeofcontroltransfercompares
this concept,acomplexsystemcomprisedofmanyindi- the current value of the associated control-sensitivedata
vidual components(such as a large Internetservice) can structure with its original image to determine whether it
be efficiently repaired in case of a fault or an attack by has been modified via buffer overflowing. Current ver-
performing a micro reboot of a single failed component sionofthe DIRAcompilerprotectsonlyreturnaddresses
ratherthanthatofthewholesystem.Iftheproblemcannot andfunctionpointersastheyarethemostcommonattack
be fixedbymicro-rebootingthenit is deferredtohuman targets. Inparticular,the DIRAcompilerinstrumentsan
operators. inputprogramasfollows:
• Atthefunctionprologue,thereturnaddressisstored
3. Attack Detection, Identification, and Re-
inthereturnaddressbuffer.Atthefunctionepilogue,
pair
thereturnaddressonthestackiscomparedwiththe
storedvalueinthereturnaddressbuffer. Ifthereisa
DIRA makes programs capable of attack detection,
mismatch,thereturnaddresshasbeentamperedwith
identificationandrepairbyusingacombinationofstatic
andacontrol-hijackingattackisdetected.
anddynamictechniques.Atcompiletime,the DIRAcom-
pilerinstrumentsthesourcecodeofaprograminanum- • Everytimeafunctionpointerismodifiedinthepro-
berofways. First,itinsertspropermemoryupdateslog- gram,itsnewestvalueisstoredinanexistingornew
gingcodethatallowstheprogramtokeeptrackofevery entryofthefunctionpointerbuffer.Thisincludesthe
memoryupdateitperforms. Second,the DIRAcompiler casewhenafunctionpointerispassedasaninputar-
inserts the code that checks every control-sensitive data gumentintoafunction. Therearealsootherwaysto
structure before it is used. Finally, a number of special modifyafunctionpointer,forexamplebyoverwrit-
functionsthat allowthe programto identifyattackpack- ingitusingmemcpy()function.Thecurrentversion
ets and repair itself are added to the program. At run of the DIRA compiler supports only simplest kind
time, the instrumentedprogramgenerates a memoryup- of function pointer modification when it is updated
dateslogwhichcanbeusedtoidentifyattackpacketsand throughadirectassignment. Eachentryofthefunc-
repairtheprogramonceanattackisdetected.Thelogged tionpointerbuffercontainstwofields:theaddressof
informationisalsousedtocheckthecontrol-sensitivedata afunctionpointervariableanditsvalue. Everytime
structuresatruntimewhentheyareabouttobeused.Ifa a function pointer is about to be used in a function
control-sensitivedatastructureisfoundcompromised,the call,itscurrentvalueischeckedagainstthefunction
attackidentificationandrepairfunctionsarecalled. pointer’sstoredvalue. Themismatchofthetwoval-
Theamountoflogginginformationaswellasthetype uesistheindicationofanattacktakingplace.
of informationstored in the log dependson the mode in
Becausethereturnaddressbufferandthefunctionpointer
which DIRA operates. There are three modes of oper-
buffer are supposed to contain the ground truth, they
ation: compilation to support attack detection only (D-
should be well protected such that tampering via buffer
mode),compilationtosupportdetectionandidentification
overflowingis impossible. Otherwise, if an attacker can
(DI-mode) and finally compilation to support detection,
overflowbothacontrol-sensitivedatastructureanditsas-
identification, and repair (DIR-mode). Each successive
sociatedduplicatebuffer,shecandefeatthisattackdetec-
moderequiresmoreinformationtobelogged.Inthissec-
tion method. Towards this end, both the return address
tionwedescribehowmemoryupdateloggingworksand
bufferandthefunctionpointerbufferaresandwichedin-
how the logged information is used in attack detection,
side a pair of read-only pages. Any attempts to modify
identification,andrepair.
thesetwobuffersviaoverflowingwillresultinprotection
faults. An attacker might try to compromise the system
3.1. AttackDetection
byguessingtheaddressofsuchabufferandwritingtoit
Most of the control-hijacking attacks modify some directlywithouthavingtogothroughtheprotectedpages.
control-sensitive data structures in the victim program, In order to reduce significantly the likelihood of a suc-
suchasareturnaddress,afunctionpointer,orajumpta- cessfulattack,suchabuffercanbeallocatedatarandom
ble, throughbuffer overflowing. Once the compromised memorylocation. Thistechniqueisnotimplementedyet
datastructureisusedinacontroltransfer,theattackerhi- inthecurrentversionof DIRA.
jacksthecontroloftheapplication. In theory, the DIRA compiler can also protect jump
The approach to attack detection used by DIRA is tables in the same way as function pointers. However,
similar to that developed in RAD project [8]. To detect becausetherehaveneverbeenanyrealcontrol-hijackingattacks that tamper with jump tables, for simplicity we address of the left-hand-side variable being modified, in
chosetoignorejumptableprotectioninthecurrentproto- this case X’s address. The length field is the size of the
type. modifiedvariable,sizeofXinthiscase. Thedatafieldis
notusedwhen DIRAoperatesinDI-mode.InDIR-mode,
3.2. MemoryUpdatesLogging thisfieldstoresthepre-imageofX,thevariablebeingwrit-
ten to. It is not always possible to uniquelyidentify the
The purposeof memoryupdates logging is to make it
read address, for instance if Y is a complex expression
possibletotracebackincomingpacketsthatareresponsi-
containinganumberofvariablesorafunctioncall.Inthis
bleforthedetectedattack, andtorestorethevictimpro-
case the read address is set to “-1,” which indicates that
grambacktothestate beforetheattackpacketswerere-
thedataoriginofthisassignmentisunknown.
ceived. Keepinga copyofa control-sensitivedatastruc-
Thesecondsourceofmemoryimagechangesarestan-
tureforattackdetectioncanbeseenasaspecialformof
dard library calls such as memcpy(). DIRA proxies
memoryupdateslogging. Toassociatecorruptedcontrol-
several libc functions that can change program’s mem-
sensitive datastructureswith incomingpackets, foreach
ory state. Whenever a functionthat is proxiedis called,
incomingpacketit is necessaryto computeall datavari-
the correspondingproxy function also produces a mem-
ables that directly or indirectly depend on the incoming
oryupdateslogrecordthatsummarizesthesideeffectsof
packet. If a corrupted control-sensitive data structure is
thefunctioncall.Thefieldsofthememoryupdateslogen-
data-dependentonanincomingpacket,thepacketiscon-
tryaresetdifferentlyfordifferentproxiedfunctions. We
sideredanattackpacketanditscontentswillbeusedfor
willdiscussallthefunctionsproxiedby DIRAbelow.
contentfiltering.
Some programsprovidean alternative implementation
To allow a program to be rolled back to the state it
of standard libc functions. Such functions will be com-
was in before receiving an attack packet, a snapshot of
piledbyDIRAthusprovidingnecessarysupportforattack
the program’s state should be checkpointed every time
detection,identificationandrepairas longas thesefunc-
it receives a packet. However, the performance over-
tionsarewritteninstandardC.If, however,thenewlibc
headofthis approachis toohightobefeasible. Instead,
functionsareimplementedusinginlineassembly(forper-
DIRAusesafine-grainedasynchronouscheckpointingap-
formance reasons, for example), then DIRA will not be
proach, which logs updates only to global or static vari-
abletoinstrumentthem.
ables,andperformstheseloggingoperationsinanincre-
The above memory update logging algorithm imple-
mental fashion rather than in one batch. When choos-
ments both state checkpointing and data dependency
ing this approach, DIRA assumes that during the inter-
tracking. Moreover, the DIRA compiler inserts logging
val between when a control-hijacking attack is detected
codeforeachassignmentoperationoftheformspecified
andwhenthecorrespondingattackpacketisreceived,the
abovewithoutperforminganysophisticateddata orcon-
programwillnotbeabletoundoanyfileornetworkI/O
trol flow analysis. As a result, the implementationcom-
operations. Therefore,memoryupdatesloggingcanonly
plexityofthe DIRAcompilerisgreatlysimplified.
eraseattack’ssideeffectsonthememorystateofthepro-
To reduce memory updates logging overhead,
gram,butnotonitsfilesystemstate.
DIRA tries to avoid unnecessary logging operations.
Eachrecordofthe memoryupdatelog hasfourfields:
In its default mode, DIRA does not log updates of the
read_addr, write_addr,len, anddata. We will de-
formX=YifXisalocalvariablereferenceddirectly. The
scribethemeaningofeachfieldbelow.
reason behind this is the assumption that local variables
Mostifnotallcontrol-hijackingattacksuseoneormul-
referenceddirectlyareusuallyusedastempvariables(for
tiplenetworkpacketstooverrunabufferinthevictimpro-
example, as loop variables) and do not contain any data
gramandeventuallyoverwritesomecontrol-sensitivedata
coming from external sources. Although in general this
structures.Therefore,thecontentofthecorruptedcontrol-
approachcanmiss certaindependencies,itturnsoutthat
sensitivedatastructureisderivedfromtheattackpackets
quite often enough information is logged to identify the
throughaseriesofmemorycopyingoperations. Memory
maliciousinput.
imageofaprogramcanbechangedbyeithertheprogram
Figure1showstheabbreviatedsourcecodeofasimpli-
itselforbyalibraryfunctioncallmadebytheprogram.To
fiednetworkserviceapplicationcontainingabufferover-
handletheupdatesoftheformertype, DIRAlogstheef-
flow vulnerability. To ensurethat omittinglocal updates
fectsofassignmentstatementsofthefollowingform:X =
logging is usually harmless, let us consider the logging
Y,whereX andY aredirectlyreferencedvariables,array
operations performed by the program compiled in DIR-
references (e.g., a[i]) or de-referenced variables (e.g.,
mode anddeterminethat this informationis sufficientto
*(a+1)). Thereadaddressfieldcontainstheaddressof
identifythe attack packet. Function do_packet() calls
the right-hand-sidevariableof the assignmentoperation,
functionget_packet(),whichreceivesapacketbycall-
inthiscaseY’saddress. Thewriteaddressfieldholdstheing recv(). This is one of the functions proxied by Let MA(modifiedaddress)betheaddressofa corrupted
DIRA. The corresponding proxy function logs the pre- control-sensitivedatastructure,i.e.,areturnaddressora
image of buf by setting the write_addr field to the functionpointer. Inmostcases,itwastamperedwithasa
valueofbuf.Thenthecontrolflowgoesbacktofunction resultofanuncheckedarray-to-arraycopyoperationsuch
do_packet(). The assignmentof the returnedvalue to asstrcpy().Eachofsuchmodificationsleavesarecord
variablelastisnotloggedbecauselastisalocalvari- inthememoryupdateslog. Therefore,thetracingbegins
able referenced directly. Function process_packet() with the most recent memory updates log entry whose
is callednexttakinglast as its onlyargument. The as- write address is equal to MA, and uses the read address
signmentofbuf topacket is notloggedeitherbecause fieldofthisentryasakeytosearchthememoryupdates
packetisalsoalocalvariablereferenceddirectly. Next logtofindthemostrecentlogentrywhosewriteaddress
thereisacalltofunctionstrcpy()whichisalsoproxied matches it, etc. This process continues iteratively until
by DIRA. This functioncopiessome data frompacket reachingamemoryupdateslogentrywhosereadaddress
into a limited-space buffer name without checking the issettooneofthespecialvaluesdescribedbelow,which
length of packet->name, and thus represents an attack meansthatthedatawrittentothewriteaddressofthaten-
target. The read_addr field of the corresponding log trycomesfromanexternalsource. Theabovetrace-back
recordissettotheaddressofpacket->name.Tosumma- algorithmisformallydescribedinFigure2.
rize,thememoryupdatelogcontainstwoentriesrelevant To support attack identification, the following classes
to the packet beingprocessed. None of the intermediate of libc functions need to be “proxied”: copy-
assignmentoperationsarelogged. Nevertheless,itisstill ing/concatenationfunctionssuchasstrcpy(),network
possibletoidentifythepacketthatshouldbeheldrespon- I/Ofunctionssuchasrecv(),fileI/Ofunctionssuchas
siblewhenanattackisdetected.Indeed,variablepacket read() (which can also read data from network), and
of function process_packet() contains the same ad- format string functions such as sprintf(). The com-
dressasvariablebufoffunctionget_packet().Allin- plete list of functions proxied by DIRA including those
termediate assignments transfer the value of the pointer requiredforpost-attackrecoveryonlyispresentedinTa-
thatpointstothebuffercontainingtheattackpacket. ble2.
Memory updates log contains additional information Copying/concatenationFunctions. Eachproxyfunc-
when DIRAworksintheDIR-mode. Thismoderequires tionfromthisgroupgeneratesalogrecord. Forinstance,
storing additional information in the log such as marks a log recordfor a strcpy(a, b) functioncall contains
that indicate function boundaries and potential restart the address of b in its read_addr field, the address of
points. Wecallsuchrecordstags. Thereareseveraltypes ainits write_addrfield,strlen(b)initslenfield.
of tags. The tag type is stored in the field read_addr. Thedata fieldisset toNULLasnodatais requiredfor
Theremainingfieldsareuseddifferentlyforeachtag.We thetracebackalgorithm.Aftergeneratingalogrecordthe
willdescribeeachtagtypeonebyoneinSection3.4. proxy functioncalls the correspondinglibc functionand
returnsitsresult.
3.3. AttackIdentification Network I/O and File I/O Functions. These proxy
functionsalsogenerateonelogrecordeachtimetheyare
Upon detecting a control-hijackingattack, we assume
called. The read_addr field ofthese recordsis set to a
thatthecorruptedcontrol-sensitivedatastructureiscom-
specialvalueindicatingtheexternalsourceofthedatabe-
promisedbysomedatathatmighthavebeenreadfromthe
inglogged.Inaddition,theymakeuseofdatafieldofthe
consolebya gets() callorfromanetworksocketbya
log record. This field stores thepost-imageofthe mem-
recv()call. Inthesecases,itisimportanttoidentifythe
orybuffer,thatis,thedatathatwasactuallyreadfromthe
sourceofcorruptionandtakepropermeasurestoprevent
network or a file. This data is the malicious network or
the samecompromisefromhappeningagain. Of course,
filedatathatcanleadtoabufferoverflowattack.Itispre-
itis alsopossiblethatthecontrol-sensitivedatastructure
sentedastheresultofthetracebackalgorithmifabuffer
wasactuallyoverwrittenduetoamistakeintheprogram’s
overflow attack is detected. This data can be sent to a
internallogic.Inthiscase,theprogramshouldbejustter-
front-endintrusion-detectionsystem, whichcanthenuse
minated since no automatic repairing can stop the same
ittopreventthesameattackfromreachinginternalhosts
compromisefromrecurring.
again. This automatic attack packets extraction capabil-
To identify the data item read from the network or a
ity protects an enterprise from worm-like attacks, where
file that is responsible for the corruption of a control-
attacking or compromised hosts tend to send out attack
sensitivedatastructure,weneedtotracebackthedepen-
packetsthatarelargelythesame.
dencygraph,startingfromthecorruptedcontrol-sensitive
datastructure. Thistracingreliesonthereadaddressand
write address fields of the memory updates log entries.void do_packet() { packet_t *get_packet() { void process_packet(char *buf) {
packet_t *last; char *buf=malloc(PACKSZ); char name[10];
last=get_packet(); recv(sock, buf, PACKSZ, 0); packet_t *packet;
process_packet(last); return buf; packet=(packet_t*)buf;
} } strcpy(name, packet->name);
}
Figure1.Anexampleofaprogramvulnerabletoabufferoverflowattack.
cur_addr=MA;
while(more_log_entries&&cur_addr(cid:1)=0)
ent=get_prev_log_entry();
ifent.write_addr≤cur_addr&&ent.write_addr+ent.len>cur_addr
thencur_addr=ent.read_addr+(cur_addr-ent.write_addr);
end;
if(cur_addr(cid:1)=0)
{printf(“Can’tfindsourceofattack\n”);exit(0);}
/*entistherequiredlogentry*/
Figure2.Thetraceback algorithmusedtolocatethesourceofabufferoverflowattackbasedon
acorruptedcontrol-sensitivedatastructure.
3.4. AttackRepair do not track any local variable updates we will not be
abletobringtheprogrambacktoaconsistentstateolder
Although DIRA’sattackdetectionmechanismcansuc-
thanthestateinwhichitwasrightbeforef_restartwas
cessfully prevent a control-hijacking attack from taking
called. Thereis anexceptionfromthisrule, however. If
overavictimapplication,theapplicationitselfmayneed
therearenolocalvariableupdatesinf_restartbetween
to be terminatedas a result ofsuch an attack. This “ter-
thepointafterf_readreturnsandbeforef_attackbe-
minate and restart” approach to recover from a control-
gins,wecansafelyrestarttheexecutionfromf_readin-
hijackingattackisnotalwaysdesirable. Instead,itisbet-
steadoff_restart.
ter if the victim application can simply erase the effects
Sometimes, it is still possible that the whole pro-
of theattack packets as if these packets neverhappened.
gram will need to be restarted. Indeed, this happens if
Therearetwoissuesinvolvedinthisprogramstaterepair
f_restartturnsouttobefunctionmain()andthereare
process: (1) From which state should a victim program
somelocalvariableupdatesmadebetweenwhenf_read
restart? (2)Howtorestartavictimprogramwithoutspe-
returnsandf_attackbegins.Whileevaluating DIRAwe
cialOSsupport?
have encountered one such program. One way to avoid
Because DIRA logs only updatesto globaland array-
thisproblemistotrackallvariableupdatesincludinglo-
like variables, it canonly restart a programfromthe en-
calones,butthatmaysignificantlyincreasetherun-time
trypointofa function. Theproperfunctionf_restart
overhead. If the repair algorithm finds that the program
turnsouttobetheleastcommonancestorofthefunction
needs to be restarted fromthe beginning,the programis
inwhichtheattackwasdetectedandthefunctioninwhich
simplyterminatedandrestartedafterwards.
themaliciousexternaldatawasreadin. We will callthe
Identifyingthefunctionthatreadsinthemaliciousex-
functioncalledfromf_restart,whicheventuallyledto
ternal data is a part of attack identification process and
malicious data read operation f_read and the function
thereforedoesnotincuranyextrarun-timeoverheadwhile
that eventuallyled to the attack f_attack (both can be
theprogramisrunningnormally. Figure3illustrateshow
the same functionor even f_restart). The reason be-
the restart point is chosen with a typical bufferoverflow
hindchoosingf_restartthewaywedescribeditabove
attackscenario. Inthiscase,eitherf2()orf1()canbe
is the fact that the stack frame of the dynamic parent of
chosenasthenewrestartpoint. Thedecisiondependson
f_restarthasnotchangedbetweenthepointwhenthe
whetherthereareanylocalvariableupdatesinf1()after
malicious data was read in and the pointwhen an attack
returnfromf2()untilthecalltof4().
was detectedwhereasthe stack frameofanyotherfunc-
DIRAdoesnotrequireanysystemsupportforprogram
tioncalledafterf_restartaswellasf_restartitself
restart. Instead, it uses inter-procedural jump functions
mighthavechangedbetweenthetwomoments. Sincewesetjmp()andlongjmp()toimplementthisfunctional- tags are functionentry tag, functionexit tag, jump buffer
ity. tag, andfirst local updatetag. Uponenteringa function
Figure4showsthealgorithmthat DIRAusestofindthe DIRAinsertsafunctionentrytagintothememoryupdates
leastcommondynamicancestorbetweenthefunctionthat log. Similarly, when the functionreturns a functionexit
detectsanattackoracorruptionofsomecontrol-sensitive tag is inserted. Whena functioncall is made, DIRA in-
data structure, and the functionthat inputs the malicious sertsacalltosetjmp(buf)wherebufisthedatafield
data from the memory updates log. Logically, the algo- ofamemorylogrecord.Theread_addrofthisrecordis
rithmtraversesthememoryupdateslogbackwardstofind settothejumpbuffertag.Thismakesthepointpreceding
the first functionwhosefunctionentrytag is earlierthan thefunctioncallapotentialrestartpoint. Atrepairtime,
the function entry tag of both functions. The algorithm the controlcan be transferedto this point byperforming
includestwosteps. Thepurposeofthefirststepistofind longjmp(buf). Finally, the first local update tag is in-
out the depth of f_read with respect to the least com- sertedto thelogwhenthefirst updateto alocalvariable
mondynamicancestoroff_readandf_attack. Inor- isencounteredafterafunctioncall.Thesetagsareusedat
dertodeterminethisdepththememoryupdateslogistra- repairtimetodeterminetheactualrestartpoint,whichcan
versed in backwards direction. The traversal starts from beeitherf_readifnosuchtagsarefoundinf_restart
the last log entry and continues until the function entry betweenthecalltof_readandthecalltof_attack,or
tag of f_read is reached. Variable depth is a loop in- f_restartifatleastonelocalupdatetagwasfound.
variantandhasthefollowingmeaning.Itcontainstherel- Oncetherestartpointis determined,thememorystate
ative depth of the function which the current log record oftheprogramneedstoberolledbacktothestatecorre-
belongs to with respect to the greatest dynamic ancestor spondingtothenewexecutionpoint. Todoso,theattack
functionof f_attack seen so far. It is obviousthat the recovery module needs to traverse the memory updates
traversalwillsoonerorlatergothroughalogentrythatbe- loginthereversedirectionuntilitreachestherestartpoint,
longs to the least common dynamic ancestor of f_read undoingeachglobalvariableupdatealongtheway. After
and f_attack because the control flow should have re- theundo,therecoverymoduleperformsalongjmp()us-
turned to this function at least once between the point ingthejmp_bufcorrespondingtotherestartpoint.
whenf_read was calledandthepointwhen f_attack Torestorethememoryimageoftheprogramthecom-
wascalled. Therefore,depthwilleventuallycontainthe pletepre-imageofeachmemoryupdateshouldbestored
relativedepthoff_readwithrespecttotheleastcommon in the data field of the corresponding log record. The
dynamicancestor. Ateachloopiteration,variabledepth same is also trueaboutlibcfunctionsproxiedby DIRA.
isupdatedasfollows. Ifthetagofthecurrentlogrecord Forinstance,strcpy(a, b)callneedstostorethepre-
is a function entry tag and the depth equals 0 then the image of buffera of length strlen(b) in the data field
nextlogrecordtobetraversedcorrespondstoadynamic of memory updates log record. In addition, several
parent of the current function, and therefore it becomes other classes of libc functions need to be proxied. They
the current greatest dynamic ancestor in which case the are: memory management functions, privilege manage-
valueofdepthdoesnotneedtobechanged.If,however, mentfunctions,processmanagementfunctions,andinter-
thetagofthecurrentlogentryisafunctionexittagthen proceduraljumpsfunctions. Thecompletelistofproxied
the function which that log entry belongs to was called functionsispresentedinTable2. Belowwewillconsider
fromthecurrentfunction. Therefore,weneedtoincrease eachgroupoffunctionsinmoredetail.
depthbyone.Finally,ifthetagofthecurrentlogentryis Memory Management Functions. Each function in
afunctionentrytagandthedepthisgreaterthanzerothen this group is proxied for the following reason: at re-
we need to decrement depth by one as this means that pairtime,theprogramneedstobeabletoundonotonly
thecurrentfunctionisadynamicchildofthegreatestan- global memory changes, but also memory manipulation
cestorfunction. Tosummarize,attheendofthefirststep functions it called before. The proxy_malloc() calls
variabledepthequalstherelativedepthoff_readwith malloc() first andstores theaddress ofthe newly allo-
respect to the least common dynamic ancestor. All we catedobjectinthememoryupdateslog. Atrepairtimeif
needtodoafterthatistotraversethelogbackwardsuntil thisrecordneedstoberolledback,thismemoryobjectis
we reacha functionwhoserelativedepthwith respectto freed.
theleastcommonancestoriszero. Thebeginningofthis During repair time we also need to reallocate objects
function is the beginning of the least common dynamic that were previously deallocated. This is achieved by
ancestoroff_readandf_attack. proxying free(). A straightforward way to restore the
Finding a restart point requires augmentation of the object that was deallocated is to allocate it again with
memoryupdateslogwithseveraltypesoftagswhichare malloc(). However, the new object may be created at
insertedtothelogwhentheprogramrunsnormally.These anewmemorylocationsandallearlierreferencestoitinmemory depth
f0() updates log
-1
f1
f1() f_restart 0
f2
1
possible restart points f3
2
f2()
f4() f2
f_read
f_attack 1
f1
f3() -1 -> 0
execution flow f5() f4
-1 -> 0
gets(big_buf); strcpy(small_buf, big_buf);f5
0
attack detected!
time
Figure 3. An example illustrating how to identify the least common dynamic ancestor in the
functioncallgraphanduseitastherestartpoint. Theright-handsideshowsthememoryupdates
log where f1–f5 are the same functionsas those on the left-hand side. The ovals correspond to
functionboundaries. ThedepthvaluesarethevaluesofdepthvariablethatisdefinedinFigure4.
f_read—functioninwhichmaliciousdatawasreadin;
ent_beg=firstlogentryoff_read(functionentrytag);
depth=0;
ent=last_log_entry();
while(ent!=ent_beg)
if(ent.tagisfunctionentrytag)thendepth−−;
if(ent.tagisfunctionexittag)thendepth++;
if(depth<0)thendepth=0;
ent=get_prev_log_entry();
end;
/*secondphase*/
while(depth≥0)
if(ent.tagisfunctionentrytag)thendepth--;
if(ent.tagisfunctionexittag)thendepth++;
ent=get_prev_log_entry();
end;
Figure4.Algorithmforfindingtheleastcommondynamicancestorinthefunctioncallgraph.
Functionclass Libcfunctions
Copying/concatenation memcpy(),mempcpy(),memmove(),strcpy(),
strncpy(),strcat(),strncat(),bcopy()
NetworkI/O readv(),recv(),recvfrom()
Inter-proceduraljumps setjmp(),longjmp()
Memorymanagement malloc(),calloc(),realloc(),free(),strdup()
Privilegemanagement seteuid(),setreuid(),setegid(),setregid()
Processcreation fork()
FileI/O read(),fread(),scanf(),vscanf(),fscanf(),
vfscanf(),gets(),fgets()
Formatstring sprintf(),snprintf(),vsprintf(),vsnprintf(),
Table2.Thesetoffunctionsthat DIRAneedstoproxytosupportattackidentificationandrepair.the memory updates log will need to be remapped. In- setuid()canreplaceitseffectiveuserIDwithanonzero
stead, we use a deferredfree() approach. Whenthe pro- effective user ID in which case the old effectiveuser ID
gramcallsfree(),theproxy_free()functionjustputs canneverberestored.Inthiscase,thereisnowayforthe
theaddressoftheobjectintothelogwithoutfreeingupthe recoveryprocess to restorethe originaleffectiveuser ID
object. Atrepairtime, we donotneedto doanythingto withoutexplicitsystemsupport.
restoretheoriginalobjectsinceitiskeptinthememory. Process Management Functions. When a program
Finally,theproxy_realloc()functionsavestheorig- compiledby DIRAforksanewprocess,thetwoprocesses
inalpointerinthebuffer,replacestheoriginalrealloc() can access their memory updates logs concurrently be-
call with a malloc() call and saves the pointer to the cause of the copy-on-writesemantics of fork() system
newlyallocatedmemoryaswell. Thenitcopiesthedata call. Inthiscase,twoversionsofthelogarecreatedauto-
tothenewlyallocatedbuffer.Thelengthofthedatabeing maticallybytheOS.However,ifabufferoverflowattack
copiedisobtainedfromthememorybufferheaderthatis is detectedinoneoftheprocessesthentherepairproce-
precedingthe data itself. At repair time, the newlyallo- dure might require the program to be rolled back to the
catedobjectisdeallocated. pointbeforea newprocesswas forked. Thecurrentver-
The description above suggests that during its normal sionof DIRAdoesnotconsidertheproblemofcascading
execution the program will never free up the memory it rollback. Instead,iftheoverflowwasdetectedinthepar-
allocates. However,sincethecapacityofthememoryup- entprocessthenallchildprocessesthathavebeenforked
dateslogislimited,itsrecordsareusedinacircularfash- after the new restart point are killed. However, if an at-
ion. A single record can be reused if the program runs tack is detectedin the childprocessand therestart point
longenough. When arecordis reused, its previouscon- is chosentobebeforethe pointwhereit was forked,the
tent is cleaned up and the recoveryof that operationbe- processisterminatedwithoutaffectingtheparentprocess
comesimpossible. Apartofthecleanupprocedurefora inanyway. Theproxy_fork()functioninsertsspecial
proxy_free()bufferentryisthefree()operationthat tagsinbothparent’sandchild’sprocesslogstofacilitate
wasdeferredbefore. thisprocess.
Inter-procedural Jump Functions. Function
longjmp() performs an inter-procedural jump to one 3.5. Limitations
of the dynamic ancestors of the current function. To
Thememoryupdatesloggingalgorithmcurrentlyused
keep the memory updates log consistent, we need to
inthe DIRAcompilerisdesignedforsimplicity,andthus
add a proper number of function exit tags to the log.
has much room for performance optimization. For ex-
This number equals the numberof functions skipped by
ample, because the current DIRA compiler only tracks
longjmp(). Todetermineit at runtime, weproxyboth
data dependencies carried by simple assignment opera-
setjmp(jmp_buf) and longjmp(jmp_buf, state).
tionsandproxiedfunctions,itcannotidentifydependen-
The proxy_setjmp() function logs the address of the
ciesthatinvolveanyarithmeticexpressions,e.g.,B=A+C.
jmp_buf variable. The proxy_longjmp() function
Thismeansthat DIRA’srecoverymodulemaynotbeable
searches the memory updates log for a log entry corre-
totraceacorruptedcontrol-sensitivedatastructurebackto
sponding to setjmp() call that filled in the jmp_buf
amaliciousnetworkpacketiftheformeris derivedfrom
used in proxy_longjmp(). Once it finds the proper
the latter through any form of transformation other than
log entry, it can find out the nesting level of the current
assignmentoperations.Itispossibletogeneralizethecur-
function with respect to the target function and thus
rentmemoryupdatesloggingalgorithmbyleveragingin-
compute the requirednumber of functionexit tags to be
formation from data flow analysis techniques that allow
added.
DIRA to identify and log those and exactly those state-
Privilege Management Functions. Many programs
mentsthatmaybedatadependentonthenetworkpackets.
changetheireffectiveuserIDandgroupIDvaluesforse-
Data/control flow analysis can also improve the effi-
curityreasons.Atrepairtime,thepropervaluesneedtobe
ciency of state checkpointing. Ideally, the pre-image of
restoredtogivetheprogramsameaccessrightsasthoseit
each global or static variable needs to be recorded ex-
hadatthechosenrestartpoint.Thisisachievedbyproxy-
actlyonceforeachlogicalcheckpoint.However,because
ingfunctionssuchasseteuid()andsetegid().These
afunctionmaybecalledfromdifferentplacesandthecur-
functionssavetheoriginalvalueofuidorgidinthedata
rent DIRA compiler does not perform inter-procedural
field of a memory updates log record. The read_addr
control flow analysis, the pre-image of each global or
field holds the proper proxy function tag that allows the
staticvariableusedinafunctionisrecordedatleastonce
repairproceduretoidentifysuchlogrecordsandcallap-
perinvocationofthatfunction.Furthermore,duetoalias-
propriate privilege management functions with the val-
ing, the pre-image of the same global or static variable
uesstoredinthedatafield. Aprivilegedprocesscalling
may be logged multiple times within a function invoca-tion. Data/controlflowknowledgecanhelpeliminateun- CALL_EXPR trees in the original program. If the func-
necessary recording of pre-images, e.g., when a global tion name of the function call is one of those that need
variableisrepeatedlyupdatedwithinaloop. tobeproxied, DIRAreplacestheoriginalfunctionname
The currentversionof DIRAcan onlyhandleconcur- withtheproxiedfunctionname.Inordertosupportrestart
rent accesses to the memoryupdates log from processes points, DIRA replaces the original CALL_EXPR with a
thatarelaunchedthroughfork()systemcall. However, COMPOUND_EXPR that first makes a call to setjmp() to
itdoesnotrecognizeotherformsofforksuchasvfork(). insertarestartpointandthenmakestheoriginalfunction
In these cases, some form of locking mechanism is re- call.
quiredtoprovideexclusiveaccesstothememoryupdates
log. Itisalsopossiblethataprogramperformssomefile 4.2. TransparentLibraryCompilation
ornetworkI/Ooperationsbetweenthepointwhentheat-
Often programs need to be linked with several non-
tack packets were read in and when the attack was de-
standard libraries. At the same time, same libraries can
tected. In this case, restoring the memory image of the
be reused by multiple applications. Some applications
programwithoutrestoringtheunderlyingfilesystemstate
(typicallyserver-sideapplications)mightneed DIRAsup-
mightleadtoaninconsistentstateoftheprogram.Ideally,
port whereas others (typically client-side applications)
bothmemoryandfilesystemrepairshouldbeperformed.
will most likely not. Therefore, both instrumented and
Thecurrent DIRAprototypedoesnotsupportfilesystem
uninstrumentedversionsofsomelibrariesshouldexistin
repair.
thesystem. Anaiveapproachwouldbetohavetwover-
Signals are frequently used in network daemons as
sionsofthesamelibraryunderdifferentnames.However,
a means of scheduling exceptional events. Currently,
inthiscaseonewillhavetogothroughalltheMakefiles
DIRA’s repair mechanism does not support undo of sig-
oftheprogramandchangeeveryoccurrenceofthename
nals. Ideally,allsignalsthatweresetafterthenewrestart
oftheoldlibrarytothatoftheinstrumentedlibraryifthe
pointneedtobecanceled.
programneeds DIRAsupport. Anotherdrawbackofthis
approachis the fact that a programwouldnotbe able to
4. Implementation Issues
switchfromoneversionofthelibrarytoanotherwithout
beingrecompiled.
4.1. SourceCodeInstrumentation
A better solution of this problem is to duplicate the
Thecurrent DIRAprototypeisimplementedasanex- code of every functionin all the source files that consti-
tensiontoGCC3.3.3. Whencompilingaprogram,GCC tute the library. The first copy of the function is instru-
convertsthe sourcecode to a numberof representations. mentedwhereasthe secondoneis leftintact. DIRA in-
First, it translates the program into an Abstract Syntax sertsanif-statementinthebeginningofeachfunctionand
Tree (AST). Then, the AST representation is converted makesthetwocopiesoftheoriginalfunctionitsthenand
into a Register Transfer Language(RTL) representation. elsebranches. Theif-statementcheckswhetherthefol-
Finally,theRTLcodeisconvertedintothemachinecode lowing condition is true or not: need_logging==NULL
for the target platform. DIRA instruments the source or*need_logging==0,whereint *need_loggingis
codeattwolevels:ASTlevelandmachinelanguagelevel. a special variable inserted by DIRA to the original pro-
The latter is used to generate special prologue/epilogue gram.Iftheconditionistrue,thentheunmodifiedversion
code that supports return address defense as well as in- of the code is executed. Otherwise, the control flow is
serts functionentry/exittags. Currently, DIRA supports transferedtotheinstrumentedversion. Whenanapplica-
onlytheIA-32platform. tionthatdoesnotrequire DIRAsupportis linkedwitha
The code required to support memory updates log- DIRA-compiledlibrary, the controlwill always be trans-
ging is inserted to the source code directly when feredtotheuninstrumentedversionofthecodesincethe
it is represented as an AST. DIRA converts each application is not aware of the need_logging variable
tree of type MODIFY_EXPR representing an assign- whichissettoNULLbydefault.
ment operation X=Y into a compound tree of type This code duplicatingapproachintroducesseveral im-
COMPOUND_EXPR that is equivalent to the following C plementationissues. Thefirstissueisrelatedtocodegen-
code: (log(X,Y,sizeof(Y)), X=Y);. Such a trans- erationforswitchstatements. GCCcreatesasetoflabels
formationcanbeinsertedatanyplaceinthesourcecode. (trees of type CASE_LABEL) for each case expression of
All unary arithmetic operations (such as ++ and --) theswitchstatement. Whenthesecondcopyofthefunc-
containedintheoriginalexpressionarestrippedoffwhen tioniscompiled,theselabelsarereusedinsteadofbeing
theloggingcallismadetoavoidrepeatedvariablemodi- recreated. Asaresult,thecontrolistransferedtothefirst
fication. versionofthe codethat was compiledbefore. The solu-
To proxy necessary function calls DIRA checks all tion to this problem is to recreate the labels each time aswitch statementis processedregardlessofwhetherthey Program Logrecords Logsize,KB
were created before or not. The second issue is related ghttpd 457 32
to a common optimization performed by GCC. When it drcatd 4,000 408
generatesRTLcodeforacomplexASTexpression,GCC named 832 39
wrapsthisASTintoatreeoftypeSAVE_EXPR,whichin- qpopper 27,000 586
dicatesthatthereisanRTLcodeavailablefortheoriginal proftpd 70,000 2073
AST expressionandthereis noneedto processit again.
However, DIRArequiresthatallASTsbeprocessedtwice Table4.Numberoflogrecordsgeneratedfor
sinceotherwisethe loggingcodemightnotbe generated asingleclientrequestasdescribedinTable
for the second copy of the AST. To ensure that this is 3aswellasthetotallogsize(KB)generated
thecase, DIRAwrapsthetreesoftypeSAVE_EXPRinto perclientrequest.
thetreesoftypeUNSAVE_EXPRandnullifiestheeffectof
SAVE_EXPR.
Sometimes,aprogramneedstobelinkedwithalibrary
The hardware setup used in the performance experi-
whichsourcecodeisnotavailable.Inthiscase, DIRAwill
mentsisasfollows.Thenetworkdaemonbeingtestedwas
stillbeabletocompileandlinktheprogram,butallmem-
runningonaservermachinewithaPentium-4M1.7GHz
orymanipulationsthathappeninsidetheuninstrumented
processor and 512 MB of RAM. There were two client
library will not be tracked. As a result, it might not be
machineswithAMDAthlon1.7GHzprocessorsequipped
possible to detect an attack if one of the uninstrumented
with512MB ofRAMeach. Allmachineswererunning
functions is responsible for it or to identify it since the
theLinux2.4.19kernel.Themachineswerelocatedinthe
variabledependencychainmightbebrokenbecauseofa
same 100Mbpslocalnetwork. All programswerecom-
calltoanuninstrumentedfunction.Also,itwillbeimpos-
piledontheservermachinewithoptions-g-O.
sible to undo the side effects of such functions at repair
To measure several run-time characteristics of the in-
timewhichcanleadtomemoryleaksorevenworsetoan
strumented server programs, the client machines were
inconsistentmemorystateoftheprogram.
runningspecialprogramsthatweresimultaneouslysend-
inga numberofrequeststotheservermachine. Thede-
5. EvaluationofDIRA
scriptionoftheperformancetestsisgiveninTable3.
ThelefttableinFigure5presentsthemeasurementsof
5.1. PerformanceOverhead
compilation time overhead, and shows that the compile
Inthissectionwepresenttheevaluationof DIRA.We time overhead varies significantly from program to pro-
areinterestedinitscompilationtimeoverhead,executable gramandcanbebetween130%and550%.
code size increase, and several run-time characteristics TherighttableinFigure5showsthedifferencebetween
suchasthe amountofloginformationgeneratedandthe theexecutablefilesizeproducedby DIRAandthatbythe
performance overhead when a program is compiled in originalGCCcompiler. Since DIRAduplicatesthecode
three different modes of DIRA: D-mode, DI-mode, and ofeachfunction,onemightexpectthattheexecutablepro-
DIR-mode. We also describe our experiences with at- duced by DIRA will be twice as largeas the executable
temptstocompromiseprogramscompiledby DIRAand producedbystandardGCC.Thisturnsouttobethecase
discuss whether repairing the programs is worthwhile at for small programs such as ghttpd and drcatd, but
allorrestartingthemfromthebeginningisabetterstrat- does not hold for larger program. Most likely, this hap-
egy. pens because a binaryusuallycontains a numberof sec-
Weusedatestsuiteoffivenetworkdaemonsinourex- tionssuchthedatasection,PLTsection,symboltablesec-
periments: ghttpd1.4—anhttpserver,drcatd0.5.0 tion,etc. andthecodesectionis justoneofthem. Also,
— a remote cat daemon, named 8.1 — DNS daemon GCCperformsseveraloptimizationstoreducetheoutput
which is a part of BIND program, qpopper 4.0.4 — a binarysize. Thisexplainswhytheincreaseinbinarysize
POP3server,andproftpd1.2.9—anFTPserver. We for larger programs is only 20-40% instead of expected
used several exploit programs for the three programs of 100%.
ourtestsuite:named,ghttpd,anddrcatdavailableat Weconductedseveralseriesofexperimentstomeasure
Fyodor’s Remote Exploit Archive [15] and Securiteam’s different run-time characteristics of instrumented pro-
website[5].Ourexperimentsprovedthattheinstrumented grams.First,wemeasuredthenumberofmemoryupdates
versionsoftheseprogramscandetectattacks,identifyat- logrecordsaswellasthetotalsizeofmemoryupdateslog
tack packets and continue their executionnormally after (inKB)forasingleclientrequestasdescribedinTable3.
repair (the latest is true for 2 out of 3 programs that we The results are presentedin Table 4. As the results sug-
triedtocompromise). gest, the dependencybetweenthe numberoflogrecordsProgram Type Clientrequest Repeated,times
ghttpd HTTPserver fetcha10KBHTMLpage 5,000
drcatd remotecatdaemon fetcha10KBfile 1,000
named DNSserver lookupofadomainname 10,000
qpopper POP3server fetcha1KBmessage 200
proftpd FTPserver fetcha40KBfile 100
Table3.Testprogramsandcorrespondingperformancetests.
Program GCC DIRA Overhead,% Program GCC DIRA Overhead,%
ghttpd 0.82 3.77 359 ghttpd 87145 174778 100
drcatd 1.30 4.50 246 drcatd 70126 156229 123
named 33.38 79.72 138 named 1452030 2036324 40
qpopper 11.58 26.73 130 qpopper 1371275 1654643 21
proftpd 25.88 169.88 555 proftpd 2257744 3113267 38
Figure5.Increaseincompilationtime,sec(left)andtheexecutablefilesize,bytes(right).
andtheactualamountofdatawrittentothelogisnotlin- thatcalleachotherthentheoverheadcanbemuchhigher.
ear. The reason behind this is the fact that different log Therun-timeoverheadoftheprogramscompiledinDI-
recordshavedifferentactualsize. Thetypicallogrecords modeismuchhigherthanthatoftheprogramscompiled
typesareasfollows. Thesizeofasinglevariableupdate inD-modeandisbetween7%and50%.Suchadifference
logrecordis16bytes(4bytesforreadaddress,4bytesfor can beexplainedbythe fact thata programneedsto log
writeaddress,4bytesfordatalengthand4bytestheac- certain informationaboutits memorystate changessuch
tualpayload). Apotentialrestartpointlogrecordhasthe as the read address, the write address, and the length of
size of 160 bytes because it contains a jmp_buf buffer the data being written. Programs compiled in DI-mode
used by setjmp() and longjmp(). Log records gen- makeuse ofproxyfunctionsto trackchangesperformed
erated by proxied string manipulation and network libc bystandardlibccalls. However,thepre-imageofthedata
functionscanhavedifferentsizes. Typically,theirlength beingmodifiedisnotsavedinDI-modeandthisisitsonly
variesfromseveralbytesto1KB. differencefromDIR-mode.
The goal of our second series of experiments was to The measured overhead of programs running in DIR-
measuretherun-timeperformanceoverheadoftheinstru- mode turns out to be pretty close to that of programs
mented programs which is certainly the most important running in DI-mode due to the reason described above
performancemetric of DIRA compiler. We compiledall — there are relatively few differences between the two
fiveprogramsinthreecompilationmodesthat DIRApro- modes. Inadditiontosavingthepre-imageofdatabeing
vides: D-mode that supports attack detection only, DI- modified, programs in DIR mode insert potential restart
modethatsupportsattackdetectionandidentification,and pointsbymakingsetjmp()callsandalsoinsertfirstlo-
DIR-modethatsupportsprogramrepairinadditiontoat- calupdatetags.
tackdetectionandidentification.Themeasurementsfrom Themainconclusionfromtheseexperimentsisthatthe
these experiments are presented in Figure 6 and suggest run-time overheaddepends on the programmingstyle in
thattherun-timeoverheadcanvarysignificantlydepend- whichtheprogramwas written. Therearecertainthings
ing on the programs’ memory access behavior and can thatcanincreasetherun-timeoverheadsuchasbreaking
range from 8% to 60% for programs that support attack uptheprogramintoalargenumberofsmallfunctionsand
detection,identification,andrecovery. using pointer arithmetic extensively. These results also
Theexperimentsshowedthattherun-timeoverheadof suggest a strong need for a more intelligent checkpoint-
programs compiled in D-mode varies from 0% to 15%. ingmechanismthatcanhelpreducetheoverhead.Instead
Webelievethatthisoverheadismostlyaffectedbythefre- of saving the data pre-image upon each update, one can
quencyoffunctioncallsbecauseitmainlycomesfromad- savethepre-imageofthewholedatastructureonceupon
ditionalcodeinthefunctionprologueandepilogue. That functionstart.
is,iffunctionsarerelativelylongandcalledinfrequently, We have also measured the relative frequencyof each
thenthereisnotmuchtodoforthereturnaddressdefense type of log records written to the memory updates log
mechanismandtheoverheadcanbeclosetozeropercent. duringaperformancebenchmarkrun.Theresultsarepre-
If,however,theprogramcontainslotsofsmallfunctions sentedinFigure6. Althoughthereseemstobenodirect80
70
60
50
40
30
20
10
0
ghttpd drcatd named qpopper proftpd
%
,daehrevO
Runtime Performance Overhead
D mode 1.4
DI mode
DIR mode
1.2
1
0.8
0.6
0.4
0.2
0
ghttpd drcatd named qpopper proftpd
Program
sdrocer
gol
lla
fo
noitcarF
Type of Log Records
other wrappers
string wrappers
function boundaries
first local update
variable update
Program
Figure6.Run-timeoverheads for differentmodesofcompilation(left)andtherelative frequency
ofdifferenttypesoflogrecords(right).
correlationbetweenthefrequencyoftypesoflogrecords Program FileIN FileOUT NetIN NetOUT
andtherun-timeoverhead,theseresultsstillsuggestthat ghttpd 45 0 1 49
programswithhigheroverhead(suchasqpopper)insert drcatd 319 0 3 320
more records for variable updates and first local update named 0 0 1 1
tags. Indeed,thesetwotypesofrecordsaccountfor90% qpopper 41 80 5 7
ofallrecordsthatqpopper)hadwrittentothelog.These proftpd 13 63 11 61
resultssuggestonceagainaneedforamoresophisticated
checkpointingalgorithmthatcanhelpreducethenumber Table 5. Network and file I/O activity for a
ofvariableupdatelogrecordsaswellasamoreintelligent singleclientrequestasdescribedinTable3.
mechanism for choosing the restart points. The current
mechanism relies on information about local updates to
determine where restart points are, and consequentlyre-
an attack will not bringthe programinto an inconsistent
quiresgeneratingalotmorefirstlocalupdaterecordsthan
state. The network output operations performed by the
necessary. Ideally, such a mechanismshoulduse depen-
programsarerelatedtocommunicatingwiththeclientthat
dencyanalysistechniquessuchasslicingtofindoutpoints
initiatedtheconnectiononly.Therefore,ifthatclientturns
intheprogramthatcaneventuallyleadtoafunctionthat
outtobemaliciousthereisnoneedtoundotheeffectsof
reads externaldata. Only those points can be program’s
networkoperationsforsuchaclient. Theseobservations
potentialrestartpoints.
allow us to conclude that file system and network undo
In our next series of experiments we measured the
supportisnotreallyrequiredforthenetworkdaemonsthat
amountoffileandnetworkI/Oactivityperformedbythe
wehavestudied.
programsfrom our test suite. This informationcan help
answer the question of whether the file system and net-
5.2. Experiences
work undo is indeed required for the repair process or
the programs can be repaired and continue their execu-
We tried to compromise named, ghttpd, and
tion without file system and network undo. The results
drcatdcompiledinDIR-modebyusingmaliciouscode
are presented in Table 5. The results showed that 3 out
from public databases [15, 5]. All these attempts failed
of5programsthatwetesteddonotperformanyfileout-
becausetheprogramswereabletodetectandidentifythe
put operationswhenservinga single client request. Our
attacks. Moreover, two out of three programs could re-
analysisofthesourcecodeoftheremainingtwoprograms
pairthemselvestotheextentthatallowedthemtocontinue
showedthatthefileoutputoperationsperformedbythose
normalexecution. Belowwedescribeourexperiencesof
programsareusedto createtempfiles andwrite logging
applying DIRAtoeachoftheseprogramsinmoredetail.
information.Webelievethatthisinformationisnotacrit-
BIND named inverse query vulnerability. BIND
ical part of program’sstate and thereforeleaving it after
namedversion8.1hasabuginitsinverseDNSquerypro-cessing function allowing the attacker to gain root con- automatedattackrepairisindeedusefulforthefollowing
trolofthevulnerablesystem. Maliciouscodeavailableto reasons.First,withattackrepair,dynamicattackdetection
usexploitedthisvulnerabilitybysendingasinglepacket isnowaseffectiveasstaticanalysisinprotectingvulner-
and waiting for response. It did not try to run a remote able applications at run time without suffering from the
shellonthevictimmachine. Forthisparticularprogram, latter’sfalsepositiveproblems.Moreconcretely,evenifa
therepairproceduredeterminedthatfunctionf_restart vulnerableapplicationiscompromised, DIRAensuresthe
is function main() of named. However, it turned out application can continue as if the vulnerability does not
thattherewerenolocalvariableupdatesfromf_readto exist in the first place. Second, automated attack repair
f_attack,andthereforetheexecutioncouldberestarted isessentialtoprovideprotectionamongclientsofsingle-
fromf_read(whichwasfunctionevGetNext()inthis threadedorevent-basednetworkapplications.Intheseap-
case). plications,requestsfrommultipleclientsareprocessedin
Format string vulnerability in ghttpd. There is a thesameprocess.Therefore,terminatinganapplicationof
format string vulnerability in function Log(). The re- thistypeupondetectinganattackfromsomeclientisnot
pairproceduredeterminedthatforthisparticularprogram acceptable as it also disrupts the service to other clients
functions f_restart and f_read is the same function as well. Finally, DIRA’s automatedattackrepaircanbe
serverconnection(). However, since there were a used together with other types of attack detection meth-
numberoflocalvariableupdatesbetweenthepointwhere odssuchas systemcall argumentmonitoring,whichcan
thedatawasreadandthepointwhereLog()wascalled, detectattacksthatcoulddamageavictimapplication’sad-
the execution restarted from the beginning of function dressspacewithouthijackingitscontrol. Forthesetypes
f_restart. Still, the initial connection was kept open. ofattacks,theautomatedattackrepairmechanismcanstill
Theexploitprogramthatweusedcontinuedsendingpack- repair the damagedaddress space evenlong after the at-
etstothesameportaswheretheinitialmaliciouspacket tacktakesplace.
wassentto. Thesesubsequentpacketsweretreatedasin-
valid requests by the survivedprogram. It sent the “bad 6. Conclusion
request” HTML page back to the exploit programin re-
Inthispaperwepresentedthefirstknowncompilerthat
sponse.
cantransformarbitraryprogramstoaformthatcandetect
Format string vulnerability in drcatd. There is a
controlhijackingattacks,identifythemaliciousinputand
similarvulnerabilityintheloggingfunctionofdrcatd.
repair the compromised program, all without human in-
However, in this case function main() turned out to be
tervention.Inaddition,theperformanceoverheadofthese
f_restart. In addition, there were a number of local
transformationsisshowntobequitemodest,evenwithout
variableupdatesbetweenf_readandf_attack.There-
anyaggressiveoptimizations.
fore,thewholeprogramneededtoberestartedincaseof
There are a number of ways in which the DIRA pro-
anattack. Thisproblemcanbesolvedintwoways. The
totype can be improved. First, we aim to improve the
firstistoreorganizethesourcecodemanuallybyputting
efficiencyofthememoryupdatesloggingmechanismby
potentially vulnerable parts of the code into a separate
employingcontrolflowanalysis. Currently, DIRAtracks
functionso that theexecutioncan be restartedfromit in
everyupdatetoanyglobalvariable,eventhoughintheory
case ofattack. However,this solutionrequiressome un-
only the first one needs to be logged. Another problem
derstandingofthesourcecodeoftheprogramandthere-
with the current logging mechanism is that it may miss
foreisnotsuitableforautomaticprogramprotection.The
certaindatadependencies,forexample,whenalocalvari-
secondsolutionistologallmemoryupdatesincludinglo-
able is used to transfer information between two global
cal ones. However, currentversionof DIRA cannottell
variables.Comprehensivedatadependencyanalysisisre-
automatically whether tracking global updates only will
quiredtoimprovetheaccuracyofattackidentification.
besufficientornot.Currently,thisoptioncanbeturnedon
Wearegoingtoaddressmulti-threadingissuesinmore
andoffmanually.Whencompiledwiththisoptionturned
detail in the next version of DIRA. Multiple threads of
ondrcatdcanrepairitselfandcontinuenormalexecu-
the same program can concurrently access the memory
tion.However,evenifitturnsoutthatthewholeprogram
updates log and other global data structures, and thus
needstoberestartedtheprogramcanstilldetecttheattack
introduce additional data dependencies. At repair time,
andidentifyit.
DIRAneedstodeterminewhichthreadsshouldberolled
Theanalysispresentedaboveshowsthatitisnotalways
back, restore the state of each such thread to the corre-
possible to repaira programautomaticallyand that even
sponding pre-attack state, and resume its execution. We
whenitis,therestartpointmaybequiteclosetothebegin-
are also planningto broadenthe scopeof the repairpro-
ningoftheprogram.Thisraisesthequestionastowhether
cessbyincludingsupportforfilesystemundo. Although
automatedattackrepairis usefulin practice. We believe
not common among network applications, file systemundocanhelperasethesideeffectsofanattackonafile [13] S.FeldmanandC.Brown.Igor:Asystemforprogramde-
systemsuchastempfiles. buggingviareversibleexecution. InACMSIGPLANNo-
tices, Workshop on Parallel and Distributed Debugging,
January1989.
7. Acknowledgement
[14] M.FrantzenandM.Shuey. StackGhost: Hardwarefacili-
tatedstackprotection.InProceedingsofthe10thUSENIX
We would like to thank the anonymousreviewers and
SecuritySumposium,August2001.
ourshepherdDr.DawnSongfortheirvaluablecomments.
[15] Fyodor. Remote exploits. http://www.insecure.
This research is supported by NSF awards ACI-
org/sploits_remote.html.
0234281, CCF-0342556, SCI-0401777, CNS-0410694
[16] L. A.Grenier. Practical code auditing. http://www.
andCNS-0435373aswellasfundingsfromComputerAs- daemonkitty.net/lurene,2002.
sociates Inc.,New YorkState CenterofAdvancedTech- [17] S.HangalandM.S.Lam. Trackingdownsoftwarebugs
nology in Sensors, National Institute of Standards and usingautomaticanomalydetection. InProceedingsofInt.
Technologies,Siemens,andRetherNetworksInc. Conf.SoftwareEngineering,May2002.
[18] R.HastingsandB.Joyce. Purify: Fastdetectionofmem-
oryleaksandaccesserrors. InProceedingsoftheWinter
References
USENIXConference,1992.
[19] S.C.Johnson. Lint,aCprogramchecker. InAT&TBell
[1] H. Agrawal, R. A. DeMillo, and E. H. Spafford. An
Laboratories:MurrayHill,NJ,July1978.
execution-backtracking approach to debugging. In IEEE
[20] R. Jones and P. Kelly. Bounds checking for
Software,May1981.
C. http://www-ala.doc.ic.ac.uk/~phjk/
[2] H. Agrawal and J. R. Horgan. Dynamic program slic-
BoundsChecking.html,July1995.
ing.InProceedingsofACMSIGPLANConferenceonPro-
[21] H.-A.KimandB.Karp. Autograph: Towardautomated,
grammingLanguageDesignandImplementation,1990.
distributed worm signature detection. In Proceedings of
[3] T.M.Austin,S.E.Breach,andG.S.Sohi.Efficientdetec-
USENIXSecuritySymposium,2004.
tionofallpointerandarrayaccesserrors.ACMSIGPLAN
[22] B.KorelandJ.Laski.Dynamicprogramslicing.Informa-
Notices,29(6),1994.
tionProcessingLetters,29(3),1988.
[4] A.Baratloo,T.Tsai,andN.Singh. Transparentrun-time
[23] B.KorelandJ.Laski. Dynamicslicingofcomputerpro-
defenseagainststacksmashingattacks. InProceedingsof
grams. TheJournalofSystemsandSoftware,13(3),1990.
USENIXAnnualTechnicalConference,June2000.
[24] A.D.Lucia. Programslicing: Methodsandapplications.
[5] Beyond Security’s SecuriTeam. http://www.
InProceedingsofthe1stIEEEInternationalWorkshopon
securiteam.com.
SourceCodeAnalysisandManipulation,2001.
[6] G.CandeaandA.Fox. Crash-onlysoftware. InProceed-
[25] S.L.MinandJ.-D.Choi. Anefficientcache-basedaccess
ingsofthe9thWorkshoponHotTopicsinOperatingSys-
anomalitydetectionscheme. InProceedingsoftheFourth
tems(HotOS-IX),2003.
InternationalConferenceonArchitecturalSupportforPro-
[7] G. Candea, S. Kawamoto, Y. Fujiki, G. Friedman, and
grammingLanguagesandOperatingSystems,1991.
A.Fox.Amicrorebootablesystem—design,implementa-
[26] J. Nazario. Project Pedantic — source code analy-
tion,andevaluation. InProceedingsofOperatingSystem sistool(s).http://pedantic.sourceforge.net,
DesignandImplementationConference,2004.
March2002.
[8] T.-C.ChiuehandF.-H.Hsu. RAD:Acompile-timesolu- [27] Openwallproject. http://www.openwall.com.
tiontobufferoverflowattacks. InProc.of21stIntl.Conf. [28] D.Z.PanandM.A.Linton. Supportingreverseexecution
onDistributedComputingSystems,2001. of parallel programs. In Proceedings of the ACM SIG-
[9] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman, PLAN/SIGOPS Workhop on Paralleland Distributed De-
M.Frantzen,andJ.Lokier. FormatGuard:Automaticpro- bugging,January1989.
tection from printf format string vulnerabilities. In Pro- [29] A. Pasupulati, J. Coit, K. Levitt, S. F. Wu, S. H. Li,
ceedings of 10th USENIX Security Symposium, August J. C. Kuo, and K. P. Fan. Buttercup: On network-based
2001. detection of polymorphic buffer-overflow vulnerabilities.
[10] C.Cowan,C.Pu,D.Maier,J.Walpole,P.Bakke,S.Beat- In Proceedings of Network Operations and Management
tie,A.Grier,P.Wagle,Q.Zhang, andH.Hinton. Stack- Symposium,2004.
Guard: Automatic detection and prevention of buffer- [30] M.PrvulovicandJ.Torrellas.ReEnact:Usingthread-level
overflow attacks. In Proceedings of the7th USENIXSe- speculationtodebugsoftware;Anapplicationtodataraces
curityConference,January1998. inmultithreadedcodes.InProceedingsofthe30thAnnual
[11] H. Etoh. GCC extensions for protecting applications InternationalSymposiumonComputerArchitecture,June
fromstack-smashingattacks.http://www.trl.ibm. 2003.
com/projects/security/ssp,June2000. [31] O. Ruwase and M. S. Lam. A practical dynamic buffer
[12] D.Evans,J.Guttag,J.Horning,andY.M.Tan.LCLint:A overflowdetector.InProceedingsofthe11thNetworkand
toolforusingspecificationstocheckcode.InProceedings DistributedSystemSecuritySymposium,February2004.
of the ACM SIGOFT Symposium on the Foundations of [32] Securesoftwaresolutions. Roughauditingtoolforsecu-
SoftwareEngineering,December1994. rity,RATS2.1.http://www.securesw.com/rats.[33] S. Srinivasan, S. Kandula, C. Andrews, and Y. Zhou.
Flashback: A lightweight extension for rollback and de-
terministicreplayforsoftwaredebugging. InProceedings
ofUSENIXAnnualTechnicalConference,June2000.
[34] P. Team. Non-executable pages design and imple-
mentation. http://pax.grsecurity.net/docs/
noexec.txt.
[35] T.TothandC.Kruegel.Accuratebufferoverflowdetection
viaabstractpayloadexecution.InProc.ofIntl.Symposium
onRecentAdvancesinIntrusionDetection,2002.
[36] Vendicator. StackShieldGCCcompilerpatch. http://
www.angelfire.com/sk/stackshield, January
2001.
[37] J.Viega,J.T.Bloch,T.Kohno,andG.McGraw. ITS4:A
staticvulnerability scannerforCand C++code. InPro-
ceedings of the 16th Annual ComputerSecurity Applica-
tionsConference,December2000.
[38] D. Wheeler. Flawfinder. http://www.dwheeler.
com/flawfinder.
[39] J. Wilander and M. Kamkar. A comparison of publicly
availabletoolsforstaticintrusionprevention. InProc.of
7thNordicWorkshoponSecureITSystems,2002.
[40] J. Wilander and M. Kamkar. A comparison of publicly
availabletoolsfordynamicbufferoverflowprevention. In
Proc. of 10th Network and Distributed System Security
Symposium,2003.
[41] P. Zhou, F. Qin, W. Liu, Y. Zhou, and J. Torrellas.
iWatcher: Efficientarchitectural support forsoftwarede-
bugging. InProceedingsofthe31stAnnualInternational
SymposiumonComputerArchitecture,2004.