Space-Efficient Block Storage Integrity
AlinaOprea∗ MichaelK.Reiter† KeYang‡
Abstract totakemeasuresbeforetransmittingblockstothestor-
ageserviceto protectthe privacyand integrityofthese
blocks.
We present new methods to provide block-level in- Forthispurpose,twoyearsagotheIEEESecurityIn
tegrityinencryptedstoragesystems,i.e.,sothataclient Storage Working Group (SISW) [15] announced a call
will detect the modification of data blocks by an un- for algorithms for block level encryption. Among the
trustedstorageserver. Wepresentcryptographicdefini- requirementswasthatthe newencryption algorithmbe
tionsforthissetting,anddevelopsolutionsthatchange lengthpreserving,sothatblockboundariesdonotshift
neither the block size nor the number of sectors ac- or need to be adjusted as a result of encryption. This
cessed, an important consideration for modern storage callledtothedesignoflength-preservingencryptional-
systems. In order to achieve this, a trusted client com- gorithms (e.g., [13, 14]) that are now being considered
ponent maintains state with which it can authenticate forstandardization.
blocks returned by the storage server, and we explore Inthispaper,weaddressthestorageintegrityproblem
techniques for minimizing the size of this state. We in this context. Due to the length-preserving require-
demonstrate a scheme that provably implements basic ments for cryptographic operations on blocks, it is not
blockintegrity(informally,thatanyblockacceptedwas possibletoaddinformationtoeachblock(e.g.,aMAC)
previouslywritten),thatexhibitsatradeoffbetweenthe inordertodetectitsmodification,afactexplicitlynoted
levelofsecurityandtheadditionalclient’sstorageover- intheSISWrequirements. Moreover,duetotheperfor-
head, andthatinempiricalevaluationsrequiresanav- mance demands of I/O intensive applications, it would
erageofonly0.01bytesper1024-byteblock. Weextend beundesirabletoputtheseMACsinseparateblocksalso
thistoaschemethatimplementsintegrityresistanttore- stored at the service, which would require the retrieval
playattacks(informally,thatanyblockacceptedwasthe oftwoblocks(oneofdata,oneofMACs)onthecritical
lastblockwrittentothataddress)usingonly1.82bytes pathofclientreadoperations. Therefore, herewecon-
perblock,onaverage,inourone-monthlongempirical sider a strategy in which a trusted client component—
tests. presumablythesameonethatholdskeysforencrypting
blocks before their transmission to the storage service,
and for decrypting blocks upon their retrieval—holds
1.Introduction this integrityinformation. Among our primary goals is
tominimizethesizeofthisintegrityinformation, since
Modern network attached storage (NAS) and storage for a client with large storage needs, retaining, e.g., a
areanetwork(SAN)architecturesprovideremoteblock- MAC per block would itself require significant storage
level data storage services for clients, essentially pro- andresultingoverheads.
viding the same interface as a local disk would to the Inthiscontext,wepresentnew,storage-efficientcon-
client file system. Particularly in the case of a SAN, structionsfortwodefinitionsofstorageintegrity.Oneof
thisserviceisoftenownedandmanagedbyanorganiza- thedefinitions,basedonasimilardefinitionforauthen-
tionotherthantheclient’s,anditmayadditionallystore ticatedencryption[4],formallyexpressesthenotionthat
other client organizations’ data using the same physi- if the client returns a block B in response to a read re-
calresources. Insuchanenvironment, itisprudentfor quest for address a, then the client previously wrote B
eachclienttotreatthestorageserviceasuntrusted,and toa. Theseconddefinitionisstrongerbyprovidingde-
fense against “replay attacks”; informally, it expresses
∗Department of Computer Science, Carnegie Mellon University,
Pittsburgh,PA,USA;alina@cs.cmu.edu thenotionthatiftheclientreturnsablockBinresponse
†DepartmentofElectrical&ComputerEngineering,Department to a read request for address a, then B is the content
ofComputerScience,andCyLab,CarnegieMellonUniversity,Pitts- mostrecentlywrittentoaddressa.
burgh,PA,USA;reiter@cmu.edu
Ourconstructionsarenovelinexploitingthefactthat
‡GoogleInc.MountainView,CA,USA;yangke@google.com
1distributionsofblockcontentsandofblockaccesspat- tionschemeandanunforgeablemessageauthentication
terns are not random in practice, and by doing so they code(MAC).However,BellareandNamprempre[4]an-
minimizethestoragerequiredattheclient. Weconfirm alyzethesecurityofthecompositionandprovideproofs
through a month-long empirical evaluation in a Linux that some of the widely believed secure compositions
environment that we accomplish this goal. For exam- are actually insecure. Krawczyk [19] proves that the
ple,ourschemesatisfyingourweakernotionofintegrity generic composition method used in the Secure Socket
achievesclientstorageoverheadoflessthan0.01bytes Layer(SSL)protocolisinsecure,buttheparticularstan-
perblockonaverage(comparedto16-20bytesperblock dard implementation is secure with respect to both pri-
for the scheme in which a hash or MAC is stored for vacyandintegrity. TheauthenticatedencryptioninSSH
each block), assuming a block size of 1024 bytes. Our is also insecure, as demonstrated by Bellare et al. [3].
schemedefendingagainstreplayattacksismoreexpen- There, a new definition for integrity is given, that pro-
sive in terms of storage, but still cheaper than hashing tects against replay and out-of-order delivery attacks;
eachblock: itrequires1.82bytesperblockonaverage Kohno et al. [18] also supply such definitions. While
for1024-byteblocks. we also define integrity against replay attacks, our def-
Therestofthepaperisstructuredasfollows. Wedis- initionsareparticularlytailoredtothestoragescenario,
cuss related work in authenticated encryption and stor- andarethusdifferentfromthenetworkcase.
age security in Section 2. We review necessary defini- A different approach to obtain integrity is to add re-
tionsinSection3. WedefineoursystemmodelinSec- dundancy to plaintexts. Bellare and Rogaway [5] and
tion 4. Our new integrity definitions are given in Sec- AnnandBellare[1]givenecessaryandsufficientcondi-
tion5andourconstructionsaredescribedandevaluated tionsfortheredundancycodesuchthatthecomposition
inSections6and7,respectively. oftheencryptionschemeandtheredundancycodepro-
videintegrity. Ourconstructionsexploitasimilarprin-
2.RelatedWork ciple in a different way, leveraging the redundancy in-
herent in typical disk writes to achieve integrity rather
Encryption algorithms for secure storage have re- thanaddingredundancytodoso(whichisnotpermitted
ceivedmuchattentioninrecentyears,leadingtothede- inthestoragecase).
velopmentoftweakableblockciphers[21]. Inaddition In the area of storage system security, to our knowl-
to a key and a plaintext, a tweakable block cipher has edge all systems that verify the authenticity of re-
as input a tweak, for variability. In the secure storage trievedblocksstoreblockdataintegrityinformationon
model, atweakmightbetheaddressofadiskblockor the server, in contrast to the scenario we study here.
the block identifier. This notion has been extended to For example, TCFS [8], ECFS [6] (both extensions of
that of tweakable enciphering schemes [13] that oper- CFS[7]),NASD[11]andSNAD[23]eachstoreahash
ate on larger plaintexts(e.g., 512 or 1024 bytes), and a or a keyed hash for each block, which increases either
new CMC encryption mode, about twice as expensive the size of each block or the number of blocks that
as CBC, has been designed for this purpose. Recently, must be written per write operation. Cepheus [9] and
aparallelizabletweakableencipheringschemewaspro- SUNDR [20] keep for each file the root of a Merkle
posedwithsimilarserialefficiencyasCMC[14]. These hash tree with leaves the hashes of the corresponding
schemes, being length-preserving, provide good solu- data blocks. Sirius [12] stores a digital signature for
tions to disk block encryption and are currently being each file. In such systems, there is a tradeoff between
considered for standardization by the storage commu- the amount of server-side storage of integrity informa-
nity. tion and the access time to read and write files: e.g., if
Adoptingoneofthesetweakableencryptionschemes the root of a Merkle hash tree is the only information
for confidentiality, our goal is to augment it to provide stored at the server, then each read and write involves
efficient integrity for the storage scenario. Therefore, O(logn) block accesses, with n the number of blocks
therearetwomainorthogonalfieldsrelatedtoourwork: inthefile. Similarly,Siriusretrievesallblocksinafile
authenticatedencryptionandstoragesecurity. in order to check the file’s digital signature (and hence
Authenticatedencryption(e.g.,[4,17,19])isaprim- theauthenticityofanyblock).Inourschemes,wetakea
itive that provides privacy and message authenticity at differentapproach,inwhichwedonotincreaseserver-
the same time. That is, in addition to providing some side storage or block accesses, and strive to minimize
notionofencryptionschemeprivacy(e.g.,[2]),authen- client-sidestoragetotheextentpossible.
ticated encryption ensures either integrity of plaintexts Riedeletal.[25]provideaframeworktoevaluateex-
or integrity of ciphertexts. The traditional approach istingstoragesystemsfromboththesecurityandperfor-
for constructing authenticated encryption is by generic manceperspective. Wereferthereadertothispaperfor
composition, i.e., the combination of a secure encryp-anextensivecomparisonofthesecuritypropertiesofthe Advspr denotes the maximum advantage Advspr(A)
h h
storagesystemsconsidered. forallpolynomial-timeadversariesA.
3.Preliminaries 4.SystemModel
We consider a limited storage client that keeps its
3.1.TweakableEncipheringSchemes
dataonanuntrustedstoragedevice,denotedby“storage
In this section, we review the definitions and secu- server”. Thedataispartitionedintofixed-lengthsectors
rity notions for tweakable enciphering schemes [13]. orblocks. Theclientcanperformtwobasicoperations:
An enciphering scheme is a strong, length-preserving readablockfromaphysicaladdress(orblockidentifier)
pseudorandom permutation. A tweakable enciphering andwriteablocktoacertainaddressontheserver.
scheme is a function of a tweak and has the property In our model, the server can behave maliciously,
thatforafixedtweak,itisanencipheringscheme.More by mounting attacks against the confidentiality and in-
formally, a tweakable enciphering scheme is a func- tegrity of the client’s data. We assume that the server
tion E : K × T × M → M, where K is the key is available, i.e., it responds to client’s read and write
space, T is the tweak set, M is the plaintext space queries.However,noguaranteesaregivenaboutthecor-
(stringsoflengthlbits),andforeveryK ∈ K,T ∈ T, rectnessofitsreplies.
E(K,T,·)=ET(·)isalengthpreservingpermutation. For data confidentiality, we assume that blocks are
K
TheinverseoftheencipheringschemeEistheencipher- encrypted by clients using a tweakable enciphering
ingschemeD :K×T ×M→M,whereX =DT(Y) scheme, in which tweaks are functions of block iden-
K
ifandonlyifET(X)=Y. tifiers. Thisensuresthattheencryptionsoftwodifferent
K
We define Perm(M) the set of all permutations π : blockswithidenticalcontentaredifferent.
M → M and PermT(M) the set of all functions π : The client is responsible for protecting its data in-
T × M → M such that π(t) ∈ Perm(M) for any tegrity from malicious server behavior by keeping ad-
t ∈ T. For a function π : T ×M → M, we define ditional integrity information. Our goal is to design
π−1 : T ×M → M such that π−1(T,y) = x if and schemes that minimize the client storage and provide
onlyifπ(T,x)=y. provableintegrity.
Definition3.1 LetE :K×T ×M→Mbeatweak- We define a storage scheme to be a tuple of algo-
able enciphering scheme and A an adversary. A has rithms S = (INIT,E,D,WRITE,READ,VER) where
accesstooraclesE (·,·)andD (·,·)thattakeasin- E is a tweakable enciphering scheme, D is its inverse,
K K
putatweakandaplaintext, andatweakandacipher- andwhere:
text,respectively. ThePRP-advantageofadversaryAis
1. TheinitializationalgorithmINIT()outputsasecret
definedas:
keyK fortheclientfortheencryptionschemeE;
Advprp(A)=Pr[K←R K:AEK,DK =1]
E
−Pr[π←R PermT(M):Aπ,π−1 =1] 2. The write algorithm WRITE(K,m,bid) takes as
In the rest of the paper, we denote by Advprp(q ,q ) input the secret key generated by the INIT algo-
E 1 2 rithm, block content m and block identifier bid.
the maximum over all polynomial time adversaries A,
Theclientfirstencryptstheblockmwithatweak
that make q queries to E and q queries to D , of
Advprp(A).1 WeomitotherK resource2 s,suchastime,K
from
T derived from bid under the enciphering scheme
E E and then sends the resulting ciphertext, c =
theadvantages. ThedefinitionofPRP-securityisanat-
ET(m)andbidtotheserver.
uralextensionofthestrongpseudorandompermutation K
definitionfrom[24]. 3. When performing a READ(K,bid) operation, the
client gets from the server the ciphertext c of
3.2.SecondPreimageResistantHashFunctions blockbidwhichshouldbethelastciphertextwrit-
ten by the client with that particular block identi-
Let h : M → {0,1}s be an unkeyed hash function.
fier. TheclientdecryptscwithtweakT generated
Intuitively, second preimage resistantance requires that
from bid and outputs the corresponding plaintext
given a message m ∈ M, it is hard to find a collision, m = DT(c). We denote the read operation by
i.e.,m(cid:48) (cid:54)=msuchthath(m(cid:48))=h(m). Moreformally: K
m←READ(K,bid).
Definition3.2 ForanadversaryalgorithmA,wedefine
theadvantageofAinbreakingthesecondpreimagere- 4. The verification algorithm VER(m,bid) is given
sistanceofhashfunctionhas: blockcontentmandblockidentifierbid. Itchecks
Advspr(A)=Pr[m←R M,m(cid:48) ←A(m): m’sintegrity,andoutputs1ifitisvalid,and0,oth-
h
(m(cid:54)=m(cid:48))∧h(m(cid:48))=h(m)] erwise. NotethatVERisnotakeyedfunction.Expint-st(): Expint-st-rep():
S,A1 S,A2
K ←INIT(); K ←INIT();
A adaptivelyqueriesE (·,·)andD (·,·), A adaptivelyqueriesE (·,·)andD (·,·)
1 K K 2 K K
andrepliestoclient’squeries. andrepliestoclient’squeries.
IfA repliestoaREAD(K,bid)clientquerywith IfA repliestoaREAD(K,bid)clientquerywith
1 2
ciphertextcsuchthat,ifm=DT(c)withT ciphertextcsuchthat,ifm=DT(c)withT
K K
generatedfrombid,then: generatedfrombid,then:
1. VER(m,bid)returns1 1. VER(m,bid)returns1
2. cwasneversentbytheclientina 2. cwasnotsentbytheclientinthemostrecent
WRITE(K,·,bid)query WRITE(K,·,bid)query
3. A didnotqueryE (T,m) 3. A didnotqueryE (T,m)
1 K 2 K
thenreturn1,elsereturn0. thenreturn1,elsereturn0.
Figure1.ExperimentsforDefiningStorageIntegrity
5.NotionsofIntegrityforStorageSchemes 6.ConstructionsofStorageSchemes
In this section, we first describe a very simple
Indefiningintegrityforstorageschemes,weconsider
int-st-rep secure construction, which is similar to con-
polynomial time adversaries A and A with access to
1 2
structions from [8, 20]. We include this basic scheme
twooracles: anencipheringoracleE (·,·)andadeci-
K
heretocompareitsclient-sidestorageandperformance
pheringoracleD (·,·). Theencipheringoraclereturns
K
to the more sophisticated schemes described next. In
theciphertextcorrespondingtoatweakandablock.The
the second part of this section, we give a new, space-
decipheringoraclereturnstheplaintextcorrespondingto
efficientint-stconstruction.
a tweak and a ciphertext. Adversaries A and A play
1 2
theserver’sroleinourmodel. TheyalsoacceptREAD
6.1.int-st-repSimpleConstruction
andWRITEqueriesfromclients.
Intuitively,anadversaryforastorageschemewinsif Theconstructionwegivehereisverysimple:foreach
it tricks the client into accepting a block that he never block written at a particular address, the client com-
wrote at a particular address. This is the first notion of putes and stores the block identifier and a hash of the
integritythatwedefine,anditisastraightforwardgen- block. Foragivenaddress,thestoredhashcorresponds
eralizationofthenotionsofintegrityforsymmetricen- to the last written block, thus preventing the adversary
cryption schemes from [4]. A replay attack is one in insucceedingwithareplayattack. Theamountofaddi-
which the server returns an old version of a block (not tional storage kept by the client is linear in the number
thelastblockwrittenbytheclientattheblockaddress), ofblockswrittentotheserver,i.e.,20bytesperblockif
andthe client accepts it as valid. Our second notion of acryptographicallysecurehashfunctionsuchasSHA-1
integrityincorporatesdefenseagainstreplayattack,be- isusedplustheblockidentifiers(2or4bytes,depending
ingstrongerthanthefirstone. ontheimplementation).
To formalize our intuition, we define the two experi- Inordertofullyspecifythescheme,weneedatweak-
mentsfromFigure1. able enciphering scheme E and a second preimage re-
Wedefinetheadvantagesoftheadversariesinattack- sistant hash function on the plaintext space M of E,
ingtheintegrityoftheschemeas: h : M → {0,1}s. The client keeps a list L of pairs
A
A
Thd
d
ev vi S
i S
tn
n
wt t-
-
os st t-( nrA
e op
t1
(
i)
A
on=
2
s)P
o=
fr[ iPE ntx
r
e[p gEi Sn rx, it A
p
t- ys
i
S1t
n
,(
rt A-
e)
s
q2t=
- ure
ir1
p
e(]
) d= iffe1 r]
entcorrect-
(
T
ist hw dee ea
ts
ak
c
i,
h
leeb dmlo
ie
nck
FS
ih
1
ga us
=
rh e),
2(I
.t Nh Ta
I
hTt ei ,s pEi rn
,
oi
D
oti fa
,
ol Wi fz tRe hd
I
eTt fo
E
ol,t lh
R
oe wEe
iA
nm
D
gp
,
pt
V
ry oEs pRe ot
)
-.
nessproperties: sitionisgiveninAppendixA.
Proposition6.1 If h is a second preimage resistant
1. int-st: If the client performs WRITE(K,m,bid), hash function, then the storage scheme S is int-st-rep
1
then block m is accepted as valid, i.e., secure: Advint-st-rep(q ,q )≤Advspr
S1 1 2 h
VER(m,bid)=1.
6.2.NewEfficientint-stConstruction
2. int-st-rep:IfWRITE(K,m,bid)isthemostrecent Wedesignanew,storage-efficientconstructiontoob-
writeoperationtoblockbid,thenblockcontentm tain int-st integrity. Our construction is based on two
isacceptedasvalid,i.e.,VER(m,bid)=1. observations. ThefirstoneisthatblockswrittentodiskINIT() WRITE(K,m,bid) READ(K,bid) VER(m,bid)
K←R K remove(bid,∗)fromL receivecfromserver if(bid,h(m))∈L
L←∅ insert(bid,h(m))intoL T ←bid output1
T ←bid outputm=DT(c) else
K
send(bid,c=ET(m))toserver output0
K
Figure2.SchemeS
1
do not look random in practice; in fact they have very WriteM asM =M M ...M withM ∈{1,2,...,b}
1 2 n i
lowentropy.And,secondly,ifanadversarytriestomod- Computep i =the (cid:80)frequencyofsymboliinM,i=1,...,b
ify ciphertexts encrypted with a tweakable enciphering ComputeH =− b i=1p ilog 2(p i)
scheme, the resulting plaintextlooks random with very IfH <τ,thenreturn0
Elsereturn1
high probability. The second property derives immedi-
ately from the prp-security of a tweakable enciphering
Figure4.IsRand (M)
schemedefinedinSection3.1. b,τ
Inourconstruction,weneedastatisticaltestIsRand
thatcandistinguishuniformlyrandomblocksfromnon-
6.2.2 TheEntropyStatisticalTest
random ones. More explicitly, IsRand(M),M ∈ M
returns1withhighprobabilityifM isauniformlyran- In this section we give an example of a statistical test
domblockinM,and0otherwise. Ofcourse,thestatis- IsRand that can distinguish between random and non-
tical test is not perfect. It is characterized by the false random blocks. IsRand(M),M ∈ M returns 1 with
negative rate α, defined as the probability that a uni- high probability if M is a uniformly random block
formly random element is considered not random by in M, and 0 otherwise. Consider a block M di-
the test. In designing such a statistical test, the goal is vided into n parts of fixed length M = M 1M 2...M n
to have very small false negative rate. We will discuss with M i ∈ {1,2,...,b}. For example, a 1024-byte
moreinSection6.2.2aboutaparticularinstantiationfor block could be either divided into 1024 8-bit parts (for
IsRand. b = 256), or alternatively into 2048 4-bit parts (for
The idea of our new construction is very intuitive: b = 16). The empirical entropy of M is defined as
(cid:80)
before encrypting a block M, the client computes H = − b p log (p ), where p isthefrequencyof
i=1 i 2 i i
IsRand(M). If this returns 1, then the client keeps a symboliinthesequenceM ,...,M .
1 n
hashofthatblockforauthenticity. Otherwise,theclient Ifwefixτ athreshold,dependingonnandb(wewill
stores nothing, as the low entropy of the block will be discusslaterhowtochooseτ),thentheentropytestpa-
used to verify its integrity upon return. The block is rameterized by b and τ is defined in Figure 4. In the
then encrypted with the tweak equal to the block iden- following,wedenoteIsRand (·)bythe8-bitentropy
8,τ
tifier and sent over to the server. When reading a ci- testandIsRand (·)bythe4-bitentropytest.
4,τ
phertext from an address, the client first decrypts it to
obtainaplaintextM andthencomputesIsRand(M). If
Analysis. We give an analytical bound for the false
IsRand(M) = 1 and its hash is not stored in the hash
negativerate,asafunctionofn,bandτ.
list, then the client knows that the server has tampered
Theorem6.3 Foragiventhresholdτ,ifwedenoteδthe
with the ciphertext. Otherwise, the block is authentic.
solutionofequation(1):
ThenewconstructionS isdetailedinFigure3.
2 (cid:181) (cid:182)
1−δ
τ =−(1−δ)log (1)
2 b
6.2.1 TheIntegrityoftheConstruction
thenthefalsenegativerateαofIsRand (·)satisfies:
b,τ
Wegivethefollowingtheoremthatguaranteestheint-st (cid:181) (cid:182) (cid:181) (cid:182)
n n
integrityofS 2,whoseproofisdeferredtoAppendixB. α≤be− 2n bδ2 +b 1 b 4e 4 (2)
Theorem6.2 IfEisaPRP-securetweakableencipher- e b
ingscheme,hisasecondpreimageresistanthashfunc-
TheproofofthetheoremisdetailedinAppendixC.
tionandα(thefalsenegativerateofIsRand)issmall,
thenS isint-stsecure:
2
Advint-st(q ,q ) ≤ Advprp(q ,q )+Advspr+ NumericalInterpretation. Weperformedananalysis
S2 1 2 E 1 2 h forboththe8-bitand4-bitentropytests.Wedetermined
(q2+1)α2l
2l−q1 the threshold τ experimentally: we generated 100,000INIT() WRITE(K,m,bid): READ(K,bid): VER(m,bid)
K←R K remove(bid,∗)fromL receivecfromserver ifIsRand(m)=0
L←∅ ifIsRand(m)=1 T ←bid output1
insert(bid,h(m))intoL outputm=DT(c) else
K
T ←bid if(bid,h(m))∈L
send(bid,c=ET(m))toserver output1
K
else
output0
Figure3.SchemeS
2
b τ δ n α disktracesfromusershasstrongimplicationsforusers’
256 7.7 0.05 224 e−80 privacy.
256 7.7 0.05 225 e−160 Theblocksizesusedbythediskinterfacewere1024
16 2.53 0.5 10000 e−80 and4096bytes.Forourexperiments,wefurtherdivided
16 2.53 0.5 20000 e−160
the blocks into different sizes: 4096, 2048, 1024, 512,
256,128,64and32bytestotesttheapplicabilityofthe
Figure5.RelationsAmongtheParameters
integrityschemesproposedinthispaper. Weperformed
oftheEntropyTest
threedifferenttypesofexperiments:
uniformlyrandom 1024-byte blocks and computed, for Entropy Plots We first plot (Figures 6 and 7) the 8-
each,itsentropy. Forthe8-bittest,therangeoftheen- bit entropy of 1024-byte random blocks, compared to
tropywas7.73-7.86andforthe4-bittest,2.55-2.64. We 1024-byte trace blocks. The entropy of random blocks
picked τ smaller than the minimum entropy of all the ishighlyconcentrated,allthevaluesbeingbetween7.73
randomblocksgenerated. Thisway,weensurethatuni- and 7.86. In contrast, the entropy of trace blocks is
formly random blocks have the entropy greater than τ largelyvarying,between0.01and7.99.Onlylessthan2
withhighprobability. percentoftraceblockshaveanentropylargerthan7.73,
Having set τ, we determine δ from (1). We also set theminimumentropyofarandomblock.
the false negative rate desired and from the bound (2),
wecomputen, thenumberofpartsthatweneedtoen-
surethisfalsenegativerate. TheresultsareinFigure5. Storage Plots For each of the eight block sizes, we
The4-bitentropytestperformsbetter, inthesensethat performedexperimentswiththe8-bitand4-bitentropy
itrequiressmallernforgettingthesameα. Theresults tests. In Figure 8, we plot the average (i.e, per block)
demonstrate,that,intheory,wecouldgetfalsenegative client storage for each of these tests, when we instan-
ratesaslowasneeded, attheexpenseofincreasingthe tiate the collision resistant hash function with SHA-1,
block length and of modifying the parameter b of the whoseoutputlengthis20bytes. ForschemeS 1 (MAC
entropytest. scheme), the client keeps 20 bytes per block. For the
8-bitand4-bitentropyschemes,theaveragestoragede-
6.3.PerformanceEvaluationonDiskTraces creases as a function of block length. This is intuitive
inthesensethat,asadatablockgetslarger,itsentropy
InordertoprojectthebehaviorofS andS inprac- value has less chance of approaching that of a random
1 2
tice,wecollectedapproximately200MBofblockdisk block.
tracesfromaSuSeLinuxenvironment. Theyrepresent For the 4-bit entropy test we can obtain a better the-
asamplingofdiskactivityofoneoftheauthorsduring oreticalboundforthefalsenegativeratethanforthe8-
onemonth.Theapplicationsusedmostfrequentlywere: bit test. But, in practice, the average storage that the
Netscapebrowserande-mailclient,G++compiler,Java clientkeepsforthe4-bittestislargerforblocksizesless
compiler from Sun, XMMS for playing audio, image than 256. Fortunately, both tests perform very well for
viewer GIMP, text editor Kedit, LATEX compiler, Ac- largevaluesoftheblocksize(e.g.,1024),whicharevery
robatandGVviewers,andVNCserver. Thereasonswe commoninpractice. The4-bitentropytestperformsac-
collected traces only from one computer are two-fold: tuallyverywellfor4096-byteblocks,boththeoretically
first, getting the traces proved to be cumbersome, as it andexperimentally: theoretically,thefalsenegativerate
requirednon-trivialkernelmodificationandtheinstalla- αisarounde−64 ≈2−90andtheclientstorageis0.0094
tion of a new drive to store them. Secondly, collecting bytesperblock,onaverage.0.35
0.3
0.25
0.2
0.15
0.1
0.05
0
0 1 2 3 4 5 6 7 8
skcolb
fo
egatnecreP
Entropy for 1024-byte Random Blocks
0.035
Entropy of Random Blocks
0.03
0.025
0.02
0.015
0.01
0.005
0
0 1 2 3 4 5 6 7 8
Entropy
Figure 6. Entropy of 1024-byte Random
Blocks
skcolb
fo
egatnecreP
Entropy for 1024-byte Trace Blocks
Entropy of Trace Blocks
Entropy
Figure 7. Entropy of 1024-byte Trace
Blocks
30
25
20
15
10
5
0
0 500 1000 1500 2000 2500 3000 3500 4000
)setyb
ni(
kcolB
rep
egarotS
egarevA
Average Storage for Integrity
0.6
MAC Scheme
8-bit Entropy Test
4-bit Entropy Test 0.5
0.4
0.3
0.2
0.1
0
0 500 1000 1500 2000 2500 3000 3500 4000
Block Size
Figure 8. Average Client Storage for In-
tegrity
)sm
ni(
emiT
Performance
CMC Encryption
Scheme 1 (Hashing)
Scheme 2 (8-bit Entropy Test)
Block Size
Figure9.PerformanceTimeforDifferent
StorageSchemes
Performance Plots Lastly, but very importantly, we additional storage on the client. This comes at the ex-
measured the average time to encrypt the collected penseofguaranteeingonlyaweakernotionofintegrity,
blocks using the CMC-AES tweakable enciphering namelyonethatpermitsreplays(andleavesthemtobe
mode described in [13]. We also implemented the two dealtwithatahigherlayer).
schemesforintegrityandcomparedtheiroverheadwith
thatoftheCMCencryption.
7. Is There A More Efficient Solution for
The results in Figure 9 show that the overhead due
PreventingReplayAttacks?
to hashing is 44% more than encryption alone, while
the overhead for the entropy test is 19% for 4096-byte
Wehaveanalyzedtwoschemes,onethatkeepsahash
blocks. ForS ,wehaveusedthehashfunctionSHA-1.
1 foreachblockanddefendsagainstthereplayattack;and
OurentropytestisabouttwiceasfastasSHA-1. Asex-
thesecondonemoreefficientthatonlysatisfiesaweaker
pected, the measured times rise linearly with the block
notionofintegrity. Thenaturalquestionthatcomesinto
size.
mindiswhetherthereareotherschemesthatpreventre-
playattacksmoreefficientlythanstoringahashforeach
From the experiments, the advantages and disadvan- block. Inthissection, weanswerthisquestionaffirma-
tagesofthetwointegrityschemesareclear. SchemeS 1 tively.
provides integrity against the replay attack, at the ex- First we give a simple example to demonstrate that
pense of high storage cost on the client and increased scheme S is vulnerable to replay attacks. Consider a
2
clientcomputationtime. Ontheotherhand,oursecond scenarioinwhichtheclientwritestwomessagesm and
1
schemeS 2isveryefficientinbothcomputationtimeand m 2toblockbidinthatorder,bothmessageshavinglowINIT() WRITE(K,m,bid): READ(K,bid): VER(m,bid)
K←R K ifF(bid)=1 if(bid,w)∈L ifIsRand(m)=0
C
L ←∅ if(bid,w)∈L T ←bid(cid:107)w output1
R C
L ←∅ remove(bid,w)fromL else else
C C
F(bid)←0,∀bid w←w+1 ifF(bid)=1 if(bid,h(m))∈L
R
else T ←bid(cid:107)1 output1
w←2 else else
insert(bid,w)intoL T ←bid(cid:107)0 output0
C
else receivecfromserver
w←1 outputm=DT(c)
K
F(bid)←1
T ←bid(cid:107)w
ifIsRand(m)=1
insert(bid,h(m))intoL
R
send(bid,c=ET(m))toserver
K
Figure10.SchemeS
3
entropy. Later, whentheclientperformsareadonbid, version of an encrypted block, the client uses a differ-
imagine that the server replies with m instead of the ent tweak for decrypting it than the one with which it
1
legitimatemorerecentwrittenm . Becausem haslow wasoriginallyencrypted. Then,thechancesthatitstill
2 1
entropy(i.e.,IsRand(m ) = 0),theclientacceptsitas yieldsalow-entropyplaintextaresmall.
1
valid. This demonstrates that the server succeeds in a We denote by L the associative array of (block
R
replayattack. identifiers, block hashes) pairs for random-looking
Thesolutionthatweproposeherestemsfromtheob- blocks,byL theassociativearrayof(blockidentifiers,
C
servationthattheblockaccessdistributioninpracticeis counter) pairs and by F(bid) the flags for each block
notuniformlyrandom,infactitfollowsaZipf-likedis- identifier.Thedetailedscheme,S isgiveninFigure10.
3
tribution. More specifically, there are few blocks that
are written more than once, with the majority of the
SecurityofS TheprooffortheintegrityofS issim-
blocks being written just once. If all the blocks were 3 3
ilar to that of the integrity of S . Here we just state
writtenonlyonce, thenschemeS wouldsufficetode- 2
2 the theorem that relates the security of S to the prp-
fendagainstreplays,aswell. Iftheblockswerewritten 3
securityofE, thecollisionresistanceofthehashfunc-
uniformly,thenschemeS couldbeused. Thesolution
1 tionandthefalsenegativerateoftheentropytest.
wegivehereisahybridscheme,thatcombinesthepre-
Theorem7.1 IfEisaPRP-securetweakableencipher-
vioustwoconstructions.
ingscheme,hisasecondpreimageresistanthashfunc-
Briefly,thesolutionistokeepacounterforeachblock
tionandα(thefalsenegativerateofIsRand)issmall,
thatiswrittenmorethanonce. Thecounterdenotesthe
thenS isint-st-repsecure:
number of writes to a particular block. We also keep a Ad3 vint-st-rep(q ,q ) ≤ Advprp(q ,q )+Advspr+
flag (one bit for each block) that is initially set to 0 for S3 1 2 E 1 2 h
allblocksandbecomes1whentheblockiswrittenfirst.
(q2+1)α2l
2l−q1
We make the observation that we do not need to store
counters for blocks that are written once or not written
Scheme Evaluation A fundamental difference be-
atall,asthecountercouldbeinferredinthesecasesfrom
tween this scheme and the previous two is that in S
3
the flags. We then compute the tweak as a function of
the block tweak (or the block identifier) is used to de-
theblockidentifierandthecounter,sothatifablockis
cide whether to keep the hash of the block or not. For
writtenmorethanonce,itisencryptedeverytimewitha
this reason, it was not possible to divide a block into
differenttweak.Aftercomputingthetweakasindicated,
sub-blocks and we chose to evaluate this scheme sepa-
theschemeproceedsasinS :ateachWRITEoperation,
2 rately. Weevaluatethisschemefortheone-monthlong
ifthemessagehashighentropy,thenitshashisstoredin
trace that we collected, that has 4096-byte and 1024-
alistL . Amessageisconsideredvalidifeitherithas
R byte blocks. In the trace, there were 813,124 distinct
lowentropyoritshashisstoredinL . Theintuitionfor
R blockIDs,fromwhichonly113,785werewrittenmore
thecorrectnessofthisschemeisthatdecryptionsofthe
than once. The amount of storage that the client needs
sameciphertextusingthesamekey,butdifferenttweaks,
tokeepforthethreeschemesisgiveninFigure11. As
areindependent.Thus,iftheserverreplieswithanolder
expected,theamountofclientstorageforS isbetween
3StorageforS 1 StorageforS 2 StorageforS 3 [6] D. Bindel, M. Chew, C. Wells. Extended Crypto-
16.262MB 0.022MB 0.351MB graphicFileSystem.Unpublishedmanuscript,De-
cember1999.
Figure 11. Client Storage for the Three
SchemesforOne-MonthTraces [7] M.Blaze.ACryptographicFileSystemforUnix.
InFirstACMConferenceonCommunicationsand
ComputingSecurity,CCS1993.
thestorageforS andS . Ofcourse,theclientstorage
1 2 [8] G. Cattaneo, L. Catuogno, A. Del Sorbo, P. Per-
increaseswiththelifetimeofthesystem,asmoreblocks
siano.TheDesignandImplementationofaTrans-
are overwritten. One solution to prevent the indefinite
parent Cryptographic File System for UNIX.
expansionofclientstateistoperiodicallychangetheen-
In USENIX Annual Technical Conference 2001,
cryption key, re-encrypt all the data under the new key
FreenixTrack.
(perhaps opportunistically), recompute all the integrity
informationandresetalltheblockflags. [9] K. Fu. Group Sharing and Random Access in
CryptographicStorageFileSystems.Master’sthe-
8.Conclusions sis, Massachusetts Institute of Technology, June
1999.
Wehavegivennewcryptographicdefinitionsandcon-
structionsforblock-levelstorageintegrityinascenario [10] H.Gobioff,G.Gibson,D.Tygar.SecurityforNet-
in which storage servers are assumed to be untrusted. work Attached Storage Devices. CMU SCS Tech-
Inordertoauthenticatedatawithoutchangingtheblock nicalReportCMU-CS-97-185,1997.
size or the number of sectors accessed, clients need to
[11] H.Gobioff,D.Nagle,G.Gibson.IntegrityandPer-
keep themselves additional integrity information. Our
formanceinNetworkAttachedStorage.CMUSCS
constructions minimize the size of the integrity infor-
TechnicalReportCMU-CS-98-182,1998.
mation,areprovablysecure,andarestorage-efficientas
demonstratedbyourexperimentalevaluation. [12] E. Goh, H. Shacham, N. Modadugu, D. Boneh.
SiRiUS: Securing Remote Untrusted Storage. In
9.Acknowledgements Proceedings of the Internet Society (ISOC) Net-
work and Distributed Systems Security (NDSS)
Wewouldliketothanktheanonymousreviewersfor
Symposium2003,pages131-145.
pointingoutanefficiencyimprovementtoschemeS .
3
[13] S. Halevi, P. Rogaway. A Tweakable Enciphering
References Mode.InProceedingsofCrypto2003.
[1] J.Ann, M.Bellare.DoesEncryptionwithRedun- [14] S.Halevi, P.Rogaway.AParallelizableEncipher-
dancyProvideAuthenticity?InProceedingsofEu- ing Mode. In The RSA conference - Cryptogra-
rocrypt2001. pher’strack,RSA-CT’04,LNCSvol.2964,pages
292-304.
[2] M.Bellare,A.Desai,D.Pointcheval,P.Rogaway.
Relations among notions of security for public- [15] IEEE Security in Storage Working Group.
keyencryptionschemes.InProceedingsofCrypto http://siswg.org.
1998,LNCS1462,1998.
[16] M. Kallahalla, E. Riedel, R. Swaminathan,
[3] M. Bellare, T. Kohno, C. Namprempre. Authenti- Q.Wang,K.Fu.Plutus:ScalableSecureFileShar-
catedEncryptioninSSH:ProvablyFixingtheSSH ing on Untrusted Storage. In Proceedings of the
BinaryPacketProtocol.In9thACMConferenceon Second USENIX Conference on File and Storage
ComputerandCommunicationsSecurity,2002. Technologies(FAST),March2003.
[4] M. Bellare, C. Namprempre. Authenticated En- [17] J. Katz, M. Yung. Unforgeable Encryption and
cryption: Relations among Notions and Analysis ChosenCiphertextSecureModesofOperation.In
oftheGenericCompositionParadigm.InProceed- ProceedingsofFSE2000,LNCS1978,pages284-
ingsofAsiacrypt2000. 299,2001.
[5] M. Bellare, P. Rogaway. Encode-then-Encipher [18] T. Kohno, A. Palacio, J. Black. Building Se-
Encryption: How to Exploit Nonces or Redun- cure Cryptographic Transforms, or How to En-
dancy in Plaintexts for Efficient Cryptography. In cryptandMAC.CryptologyePrintArchive,Report
ProceedingsofAsiacrypt2000. 2003/177.[19] H. Krawczyk. The Order of Encryption and Au- SimulationofET(m): SimulationofDT(c):
K K
thentication for Protecting Communications (Or: outputc=G(T,m) outputm=G−1(T,c)
How Secure is SSL?). In Proceedings of Crypto
Figure12.SimulationforA
2001.
[20] J. Li, M. Krohn, D. Mazieres, D. Shasha. Se-
cureUntrustedDataRepository.TechnicalReport
TR2003-841, NYU Department of Computer Sci-
ence,June2003.
[21] M.Liskov,R.Rivest,D.Wagner.TweakableBlock
B.ProofofTheorem6.2
Ciphers.InProceedingsofCrypto2002.
[22] D. Mazieres, M. Kaminsky, M. Kaashoek,
E. Witchel. Separating Key Management From
File System Security. In Proceedings of the 17th
ACM Symposium on Operating Systems Princi-
ples,SOSP1999. Proof:Assumethereisapolynomial-timeattackerAfor
theint-stintegrityofS thatmakesq queriestotheen-
2 1
[23] E. Miller, D. Long, W. Freeman, B. Reed. Strong cryptionoracleandq queriestothedecryptionoracle.
2
Security for Network-Attached Storage. In Pro- We construct a distinguisher D for the PRP-security of
ceedings of the First USENIX Conference on File E. DhasaccesstooraclesGandG−1,whichareeither
andStorageTechnologies(FAST),2002. E ,D withK←R Korπ,π−1withπ←R PermT(M).
K K
D has to simulate oracles E and D for A. The
[24] M. Naor, O. Reingold. On the Construction of K K
simulationisinFigure12. Dmakesthesamenumberof
Pseudorandom Permutations: Luby-Rackoff Re-
encryptionanddecryptionqueriesasA.
visited.InSTOC1997,pages189–199,1997.
If A succeeds, i.e., replies to a READ(K,T) query
[25] E. Riedel, M. Kallahalla, R. Swaminathan. A with c such that the corresponding block m = DT(c)
K
Framework for Evaluating Storage System Secu- is valid (VER(m,T) = 1) and c was not sent in a
rity. In Proceedings of the First USENIX Confer- WRITE(K,·,T)queryorgeneratedinanE(·,·)query,
ence on File and Storage Technologies (FAST), then D outputs 1. Otherwise, D outputs 0. Since
2002. T = bid we use T instead of bid in the READ and
WRITE queries. We express the advantage of distin-
A.ProofofProposition6.1 guisher D as a function of the advantage of adversary
A.
Proof: Assume there is an adversary A with an advan-
tageAdvint-st-rep(A)ofsuccessinattackingthescheme. The PRP-advantage of adversary D, from Definition
S1 3.1is:
A replies to a READ(K,bid) query with c such that:
Advprp(D) = Pr[K←R K,DEK,DK =1]−
(1) VER(m,bid) = 1, i.e., (bid,h(m)) ∈ L, with E
m = DT(c) and T = bid; and (2) c was not sent by Pr[π←R PermT(M),Dπ,π−1 =1]
K
ItisimmediatethattheprobabilityofD outputting1
theclientinthelastWRITE(K,·,bid)query. Thereare
in the case when the oracles G and G−1 are E ,D ,
twopossibilities: K K
respectively,isequaltotheprobabilityofsuccessofA:
• cwasneverwrittenwithblockidentifierbid. Since Pr[K←R K,DEK,DK =1]
(bid,h(m)) ∈ L, there exists a different query
=
Pr[Asucceeds]=Advint-st(A)
WRITE(K,m(cid:48),bid) with m(cid:48) (cid:54)= m and h(m(cid:48)) = S2
In the case when the oracles G and G−1, are π,π−1
h(m). Butthiscontradictsthesecondpreimagere-
with π drawn randomly from PermT(M), we can ex-
sistanceofh.
press the probability of D outputting 1 as a function
• c was written with block identifier bid, but ofthefalsenegativerate of IsRand andthe collision-
it was overwritten by a subsequent query resistanceofh:
WRITE(K,m(cid:48),bid). Assume that m(cid:48) is the Pr[π←R PermT(M),Dπ,π−1 =1]
last query written with block identifier bid. Then = Pr[Asucceeds|A seesrandomc 1,...,c q1 from
h(m) = h(m(cid:48)) and this again breaks the second E K andrandomm 1,...,m q2 fromD K]
preimageresistanceofh. Making the notation A ∼ (m,c,T) for A reply-
ing with c to a READ(K,T) query such that m =
G−1(T,c),thelastprobabilitycanbewrittenas:(cid:80)
Pr[π←R PermT(M),Dπ,π−1 =1] 2. Pr(A ∩···∩A )≥1− m (1−Pr(A ))
1 m i=1 i
= Pr[A∼(m,c,T):cwasnotsentina
WRITE(K,·,T)querytoA
ANDVER(m,T)=1] WealsouseChernoffbounds:
= Pr[A∼(m,c,T):(K,m,T)wasnotaqueryto
WRITEAND(IsRand(m)=0
Chernoff Bounds Let X ,...,X be independent
OR(h(m),T)∈L)] 1 n
Poissontrials: Pr[X = 1] = p ,Pr[X = 0] = 1−p ,
≤ Pr[A∼(m,c,T):(K,m,T)wasnotaqueryto i (cid:80)i i i
0 < p < 1. Denote X = n X ,µ = E(X) =
WRITE,IsRand(m)=0]+ (cid:80) i i=1 i
n p . Thenthefollowingboundshold:
Pr[A∼(m,c,T):(K,m,T)wasnotaqueryto i=1 i
(cid:179) (cid:180)
WRITE,(h(m),T)∈L] µ
1. Forany(cid:178)>0,Pr[X >(1+(cid:178))µ]< e(cid:178)
(1+(cid:178))1+(cid:178)
Denotethelastoftheseprobabilitiesbyp andp :
1 2
p 1 = Pr[A∼(m,c,T):(K,m,T)wasnota 2. Forany0<(cid:178)≤1,Pr[X <(1−(cid:178))µ]<e−µ 2(cid:178)2
querytoWRITE,IsRand(m)=0]
p = Pr[A∼(m,c,T):(K,m,T)wasnota
2
querytoWRITE,(h(m),T)∈L]
Nowwecanproceedtotheanalysis.
We try to upper bound each of these two probabili-
α = Pr(H(R = R R ...R ) ≤ τ), for
ties. In order to bound p , let’s compute the probabil- 1 2 n
1
itythatAoutputsaciphertextcforwhichπ−1(T,c)is R 1,R 2,...,R nrandomin{1,2,...,b}.
Consider a fixed i ∈ {1,2,...,b}. To each R we
considerednotrandombytheentropytest. Amakesq j
1
associate a 0-1 variable X with the property: X =
queries to π, which could not be returned to the client, j j
1⇔R =i.X ,...,X areindependentandthemean
from the int-st definition of adversary’s success. If A j 1 n
picks a c ∈ M, then IsRand(π K−1(T,c)) = 0 with of Dea ec fih neX fj is =E(X (cid:80)j n)= X1 b .
, i.e, f denotes the number
probabilityα,thefalsenegativerateoftheentropytest. i j=1 j i
So,inM,thereareα|M| = α2l ciphertextsforwhich of blocks that have value i. From the independence of
aI ns dRa hn ed c( aπ nK− m1( aT k, ec o)) ne= m0 o. reA gum esa ske tos rq e2 tuq ru ne tr oies tht eo cπ li− en1 t, X 1 W,. e. a. l, (cid:80)sX on d, ei fit nfo ell po iw =sth fa nit .E( Tf hi e) n= thn b e.
entropy of R is
ifthedecryptionofnoneofthoseresultingplaintextsm H =− b p log (p ).
i=1 i 2 i
satisfiesIsRand(m)=0. Thus: WewilluseChernoffboundsforf :
i
p ≤ (q2+1)α2l Foranyδ ∈(0,1]:
1 2l−q1 Pr(p < 1(1−δ))=Pr(f < n(1−δ))
For bounding p 2, if (h(m),T) ∈ L and (K,m,T) i b i b
was not a query to WRITE, then there exists m(cid:48) ∈ = Pr(f
i
<E(f i)(1−δ))<e−E(f 2i)δ2 =e− 2n bδ2
M such that (K,m(cid:48),T) was a query to WRITE and Now,assumethatallp arelessorequalto 1.
h(m)=h(m(cid:48)). Thenp 2 ≤Advs hpr. The function x → −xi log 2(x) is monoton4 ically in-
Toconclude,wehave: creasingontheinterval(0,1],soifp ≥ 1(1−δ),then:
Pr[π←R PermT(M),Dπ,π−1 =1] H =−(cid:80) b p log (p4 )≥−(1i −δ)b log (1−δ)
≤ p 1+p 2 ≤ (q2 2+ l−1 q)α 12l +Advs hpr Forafixedii ,= fr1 omi the2 Chi ernoffbounds,p i ≥2 1 bb (1−δ)
an Ad d:
vi Sn 2t-st(A) = Advp Erp(D)+
w ali lth
i
p =ro 1b ,a .b .il .i ,ty ba wt il te has pt r1 ob− abe i− lit2n ybδ a2 t. lp
ei
as≥
t
11
b
−(1 b− e−δ 2)
n
bf δo 2r
,
Pr[π←R PermT(M),Dπ,π−1 =1]
fromLemmaC.1.
≤ Advprp(D)+Advspr+ (q2+1)α2l τ was defined as τ = −(1 − δ)log (1−δ) and this
E h 2l−q1 2 b
The statement of the theorem follows from the last impliesPr(H ≥τ|p
i
≤ 1 4,i=1,...,b)≥1−be− 2n bδ2.
relation. Let’sboundtheprobabilityPr(p ≤ 1,i = 1,...,b)
i 4
usingChernoffbounds.
For a fixed i ∈ {1,...,b}, let’s denote (cid:178) = b −1.
C.ProofofTheorem6.3 4
Then:
Pr(p > 1)=Pr(p > 1(1+ b −1))
Intheproof,weareusingthefollowinglemma,whose i 4 i b (cid:179) 4 (cid:180)
n
proofisobviousandomittedhere. = Pr(f > n(1+ b −1))< e(cid:178) b
i b 4 (1+(cid:178))1+(cid:178)
LemmaC.1 AssumeA 1,...,A m aresomeevents, not
=
(cid:161) 1(cid:162) n
b
(cid:161) 4e(cid:162) n
4
necessarilyindependent. Then: e b
Usingthelemma,itfollowsthat:
1. Pr(A ∪···∪A )≤(cid:80) m Pr(A ) Pr(p ≤ 1,i=1,...,b)≥1−b(cid:161) 1(cid:162) n b (cid:161) 4e(cid:162) n 4
1 m i=1 i i 4 e bCombiningthebounds,weget:
Pr(H ≥τ)
= Pr(H ≥τ|p ≤ 1,i=1,...,b)·
i 4
Pr(p ≤ 1,i=1,...,b)
i 4
+ Pr(H ≥τ|∃i=1,...,bstp ≤ 1)·
i 4
Pr(∃i=1,...,bstp ≤ 1)
(cid:161)i (cid:162) 4(cid:161) (cid:162)
≥ (1−be− 2n bδ2)(1−b 1 n b 4e n 4)
e b
Inconclusion:
(cid:195) (cid:181) (cid:182) (cid:181) (cid:182) (cid:33)
n n
α ≤ 1−(1−be− 2n bδ2 ) 1−b 1 b 4e 4
e b
(cid:181) (cid:182) (cid:181) (cid:182)
n n
≤ be− 2n bδ2 +b 1 b 4e 4 . (3)
e b