Enabling Reconstruction of Attacks on Users
via Efficient Browsing Snapshots
Phani Vadrevu∗, Jienan Liu∗, Bo Li∗, Babak Rahbarinia†, Kyu Hyung Lee∗, and Roberto Perdisci∗
∗ Department of Computer Science, University of Georgia, USA
† Department of Math and Computer Science, Auburn University Montgomery, Alabama, USA
{vadrevu,jienan,bo,kyuhlee,perdisci}@cs.uga.edu, brahbari@aum.edu
Abstract—Inthispaper,wepresentChromePic,awebbrowser only to understand how a specific attack instance was executed
equippedwithanovelforensicenginethataimstogreatlyenhance (e.g., find the URL from which malware was downloaded), but
the browser’s logging capabilities. ChromePic’s main goal is to also attempt to put the attack into context by reconstructing
enable a fine-grained post-mortem reconstruction and trace-back the steps that preceded it [30] (e.g., whether the user fell for a
ofwebattackswithoutincurringthehighoverheadofrecord-and-
social engineering attack and inadvertently triggered the malware
replaysystems.Inparticular,weaimtoenablethereconstruction
download).Whileexistingbrowserandsystemlogsmayassistin
ofattacksthattargetusersandhaveasignificantvisualcomponent,
reconstructingapartialpictureofhowanattackpagewasreached,
such as social engineering and phishing attacks. To this end,
these logs are often sparse and do not provide sufficient details
ChromePic records a detailed snapshot of the state of a web
page, including a screenshot of how the page is rendered and a to precisely reconstruct the events preceding the user landing on
“deep” DOM snapshot, at every significant interaction between the attack page, and what exactly happened afterwards.
the user and the page. If an attack is later suspected, these fine-
grainedlogscanbeusedtoreconstructtheattackandtraceback Quoting [21], “we tend to lack detailed information [about
the sequence of steps the user followed to reach the attack page. an attack] just when we need it the most.” Therefore, to enable
a detailed reconstruction and trace-back of web attacks we
We develop ChromePic by implementing several careful
need enhanced logging capabilities [19], [21], [28]. For instance,
modifications and optimizations to the Chromium code base, to
systems such as ClickMiner [29] and WebWitness [30] rely on
minimize overhead and make always-on logging practical. We
then demonstrate that ChromePic can successfully capture and full network traffic logs (or traces) and deep packet inspection
aidthereconstructionofattacksonusers.Ourevaluationincludes to reconstruct the sequence of pages visited by users before they
the analysis of an in-the-wild social engineering download attack reach an attack page (e.g., a malware download URL). However,
on Android, a phishing attack, and two different clickjacking even by using full traffic traces, these systems are sometimes
attacks,aswellasauserstudyaimedataccuratelymeasuringthe unable to precisely reconstruct all steps that brought a user to
overheadintroducedbyourforensicengine.Theexperimentalre- encounter an attack page, due to the complexity of modern web
sultsshowthatbrowsingsnapshotscanbeloggedveryefficiently,
technologies and the consequent discrepancies between system
making the logging events practically unnoticeable to users.
events(e.g.,user-browserinteractions)andthenetworktrafficthey
generate [29], [30]. Furthermore, encrypted (e.g., HTTPS) traffic
I. INTRODUCTION would all but prevent these systems from inferring the complete
path to the attack page. Other approaches, such as ReVirt [11]
Web browsers have unfortunately become the preferred entry
and WebCapsule [28], go beyond network traffic logging and
point for a large variety of attacks. For example, through the
analysis, and instead focus on recording fine-grained details at
browser, a user may be exposed to malware infections via social
the system level to enable full attack replay. However, whole-
engineering attacks [31] or drive-by downloads [14], phishing
systemrecord-and-replay[10],[11]iscomputationallyexpensive,
attacks[9],cross-sitescripting[48],cross-siterequestforgery[4],
and is especially difficult to deploy on resource constrained
clickjacking [15], etc.
mobile devices. On the other hand, while in-browser record-and-
While the mechanics of these attacks (i.e., how they are replay [28] can be more easily ported to mobile devices, it is
typically executed within the browser) are well understood, it is hindered by difficulties introduced by OS-level non-determinism
oftenchallengingtodeterminehowusersarrivedtoagivenattack (e.g., due to thread scheduling) and can result in an inaccurate
page in the first place. At the same time, tracing back the steps replay of browsing sessions [28], thus preventing reliable attack
through which an attack unfolds can be critical to fully recover reconstruction. Furthermore, to enable replay, record-and-replay
from an intrusion [18] and prevent future compromises. For systems typically require storing large amounts of information,
instance, security analysts and forensic investigators often try not including all network traffic generated by the browser.
Inthispaper,wepresentChromePic,awebbrowserequipped
Permission to freely reproduce all or part of this paper for noncommercial withanovelforensicengineaimedatgreatlyenhancingChrome’s
purposes is granted provided that copies bear this notice and the full citation
logging capabilities. ChromePic’s main goal is to enable a fine-
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author grained reconstruction and trace-back of web attacks without
(for reproduction of an entire paper only), and the author’s employer if the paper incurring the high overhead typically associated with record-
was prepared within the scope of employment. and-replay systems such as [11], [28]. In particular, we aim to
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
enable the reconstruction of attacks that target users and have
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23100 a significant visual component, such as social engineering andphishing attacks. To this end, we focus on instrumenting Google For instance, there should be no easy way for (malicious)
Chromium [40] (the open source project on which the Chrome javascript code running on a page to detect whether the
browser is based) to efficiently record a browsing snapshot at interactions (inputs) between the user and the page are
every meaningful interaction between the user and the browser. being logged or not. In addition, webshots should also be
For example, every time the user clicks on a page or presses a transparent to users, in that once they are enabled the user
key (e.g., Enter), we record the input information (e.g., mouse should not notice any difference in the behavior of the
coordinates, key code, etc.) and the page URL shown in the browser when webshots are being recorded.
browser bar. Furthermore, we take a screenshot of the rendered
page, and a “deep” snapshot of the related DOM tree and In Sections IV and V we discuss why the existing snapshot-
embedded resources (e.g., iframes, images, etc.). We refer to taking capabilities currently implemented by Chromium do not
this type of detailed browsing snapshots as webshots. Intuitively, satisfy the above requirements. For instance, we describe the
such rich logs would allow a security team or forensic analyst to implementation of a browser extension that attempts to meet the
travel back in time and effectively reconstruct a user’s browsing same requirements described above using the existing extension
actions over a desired time window. In fact, we can consider the API, and demonstrate why such a solution is not viable.
screenshot contained in each webshot as a “video frame.” These
The reader may notice that because ChromePic continuously
screenshots can then be stitched back together to reconstruct
records detailed information about the state of the browser,
precisely what the user saw during every significant interaction
including visual screenshots, our system may produce numerous
withthebrowser.Furthermore,eachscreenshotisassociatedwith
logs, some of which may include sensitive information. While
the related full state of the DOM (including embedded objects
protecting the security and privacy of the logs recorded by
and JavaScript source code) recorded at the very same instant in
ChromePic is outside the scope of this paper, it is important to
time. Namely, we record exactly how a specific page DOM was
notice that existing solutions could be used to mitigate these
structured, how it was rendered at the time of a user-browser
concerns. For example, sensitive URL whitelisting and log
interaction, and how the user interacted with it, thus enabling an
encryption using a key escrow as proposed in [28] could also be
analysis of how the attack was implemented. Our ChromePic
used in ChromePic. We discuss these solutions in more details in
browser addresses the following challenges:
Section VIII. Also, while a typical browsing session may result
in numerous webshots, often the changes to a page between
• Forensic Rigor: Our main goal (and challenge) is to enable
two consecutive user-browser interactions are minimal, thus
webshots to be taken synchronously with user-browser
resulting in few changes between snapshots. This provides an
interactions. Namely, let u(t ) represent a user-browser
0 opportunity for storing only the difference between snapshots.
interaction u (e.g., a mouse click or key press) that occurs
In addition, the visual screenshots can be reduced in size using
at time t . Because we aim to prevent any (potentially
0 lossy compression, and the overall storage requirements for the
malicious)JavaScriptcodethatlistensonufromalteringthe
logs of each browsing session could be further reduced using
pagebeforethewebshotistaken,ourgoalisto“freeze”the
standard archiving tools. We discuss storage requirements in
processing of u until we take both a screenshot of the page
more details in Section VII.
currently displayed by the browser as well as a full DOM
snapshot. Only after the snapshot is completed the event u In summary, we make the following contributions:
will be released and processed by the browser. The need
for this synchronous snapshots constraint is motivated by • We propose ChromePic, a web browser equipped with a
the fact that we intend to prevent any discrepancy between novel forensic engine that aims to enable the reconstruction
what is logged in the webshot and what the user saw (and andtrace-backofwebbrowserattacks,especiallyforattacks
the DOM of the page he/she interacted with) at the very that directly target users and have a significant visual
instant of time t when the event u occurred. component, such as social engineering and phishing.
0
• We develop ChromePic by implementing careful modifi-
• Efficiency:Asattackscannotbeeasilypredicted,ChromePic
cations and optimizations to the Chromium code base, to
aims to be always-on and continuously log webshots.
minimize overhead and make always-on logging practical.
This allows us to record undetected (and unexpected)
Inaddition,wediscusswhyimplementingChromePicusing
attacks, in accordance with the compromised recording
existing facilities, such as Chrome’s extension API, is not
design principle [33]. However, to make always-on logging
a viable option.
practical,efficiencyiscriticalandloggingoverheadmustbe
• We demonstrate that ChromePic can successfully capture
reduced to a minimum. In particular, because webshots are
and aid the reconstruction of attacks on users. Specifically,
taken synchronously with each user input, we effectively
we report the analysis of an in-the-wild social engineering
introduce a processing overhead that increases the natural
download attack on Android, a phishing attack, and two
processing of input events. Therefore, the challenge we face
different clickjacking attacks.
istomakesurethatnonegativeeffect(e.g.,latency)willbe
• We evaluate the efficiency of our solution via a user study
perceived by the user. Based on previous studies on human-
involving 22 different users who produced more than 16.5
computer interaction [47], we target a logging time budget
hours of browsing activities on hundreds of websites. We
of around 150ms, which would make the logging events
provideprecisemeasurementsabouttheoverheadintroduced
practicallyunnoticeabletousers.Tothisend,weimplement
by ChromePic on multiple devices, including desktop and
a number of careful system-level browser modifications and
laptop Linux systems as well as Android tablet devices.
optimizations, which we describe in detail in Section IV.
Our results show that the vast majority of webshots can be
• Transparency: We require webshots to be taken in a taken very efficiently, making them practically unnoticeable
transparent way w.r.t. the web pages that are being logged. to users.
2II. WEBSHOTS entering data in a form usually allows to transition from
an input field to another, thus indicating that the previous
AsmentionedinSectionI,weaimtoenablethereconstruction
field has been fully entered. Other keys (e.g., the space bar)
and trace-back of web attacks that target users, with particular
may be used to scroll a page or pause/start a video, or to
focusonattacksthathaveasignificantvisualcomponent,suchas
navigatetothepreviouspage(e.g.,usingthebackspace).
social engineering and phishing attacks. To this end, we design
We have selected a total of five special keys whose raw
ChromePic to embed an always-on forensic engine. Specifically,
keydown event triggers a webshot.
we instrument the Chromium browser to record rich logs, called
• GenericInputEvents:Allotherinputevents,suchasmouse
webshots,thataimtocapturethestateoftherenderedwebpages
movements, mouse wheel, key presses, etc., that do not fall
at every significant interaction between the user and the browser.
withintheabovecategoriesarealsoconsidered.Specifically,
we trigger awebshot for each “generic”event, but impose a
A. What is a WebShot?
timeconstraint:ifthepreviouswebshothasbeentakenmore
A webshot consists of the following components: (i) a than a predefined number of seconds ago (e.g., 5 seconds),
timestamp and other available details about the user input event we take another webshot, otherwise we skip this event (i.e.,
that triggered the webshot (e.g., mouse event type and related no webshot is taken). Notice that this time constraint only
screen coordinates, keypress code, etc.); (ii) the full URL of the appliesto“generic”inputevents,andtothecasewhenakey
page with which the user interacted; (iii) a screenshot of the iskeptpressed.Forallothersingleeventsmentionedearlier
currently visible portion of the web page (the viewport) rendered (e.g., mouse down, tap, etc.) we always take a webshot,
by the browser; (iv) a “deep” DOM snapshot that consist of the regardless of the time.
page’s DOM structure, all embedded objects (e.g., the content of
Webshots are logged synchronously with the triggering input
all images), the DOM and embedded objects of all iframes,
event, as required by the forensic rigor property introduced in
the JavaScript code running on the page, etc.
SectionI.Effectively,theuserinputwillbeheldfromprocessing
To satisfy the forensic rigor requirement mentioned in until a full webshot is taken. In Section IV, we will explain
Section I, webshots must be taken synchronously with the that because user inputs are processed on the render thread of
triggeringuserinput.Thisrequirement,alongwiththealways-on Chromium’s renderer process, this has the effect of preventing
operational goal for our ChromePic system, has a significant the DOM of the page from changing before the webshot is
impact on the amount of overhead we can afford for producing recorded. Hence, each webshot reflects what the user saw at the
each webshot. In Section IV, we describe a set of very careful moment of her interaction with the page. This has the effect
code instrumentations and optimizations that make efficient of preventing attempts from the attacker to hide the attack by
webshots feasible. altering the log, for example by rapidly changing the DOM
and appearance of the page immediately after a user-browser
B. Input Events that Trigger a WebShot interaction.
WebShots are triggered by user interactions with web pages.
In theory, we could take a screenshot for every single “raw” user
III. USECASES
input event, including every mouse movement, every key-down In this section, we discuss a representative use case scenario,
event, every tap or gesture on a touchscreen, etc. However, many tohighlighthowoursystemcouldbeusedinpractice.Ingeneral,
user input events (e.g., most mouse movements) have no real we envision ChromePic to be particularly useful in aiding the
changing effect on the underlying web page. Furthermore, to reconstructionandtrace-backofattacksthatinvolveuseractions,
reduce overhead, it is desirable to minimize the type and number such as social engineering and phishing attacks. In these cases,
of events that actually trigger a webshot. At the same time, our reconstructing what the user saw or what exact information
goalistocaptureenoughwebshotstoallowforthereconstruction was entered on a phishing page is critical to understand how
and trace-back of possible attacks. To balance these conflicting the attack unfolded. We argue that these types of attack are
goals, we trigger a webshot for each of the following events: difficult to reconstruct without a visual account of what the user
experienced. ChromePic would ideally be deployed in corporate
• Mouse Down: Mouse clicks are a common interaction
and government network environments, where web-based attacks
between users and web pages. Clicks often have important
may represent the first step of larger incidents (e.g., targeted
consequences, such as initiating the navigation to a new
attacks). At the same time, we believe ChromePic may also be
page, submitting a form, selecting a page element, etc. As
useful in other scenarios, such as in web application debugging.
each click starts with a mouse down event, we trigger a
webshot for each such event. Example Use Case: Meet Bob, a corporate employee who, while
• Tap: On touchscreen devices, taps are the initial event for a using the browser at work, falls victim to a social engineering
variety of gestures, including “clicking” on a link or button. malware download attack [31] by clicking on a misleading
Therefore, a tap often (though not always) has an effect advertisement. Once installed, the malware opens a backdoor to
similar to a mouse down event. Therefore, we trigger a thecorporatenetwork,whichislaterusedbythemalwareowners
webshot at every tap event. to gain access to and exfiltrate sensitive information, triggering
• Enter Keypress: In many cases, pressing Enter has a data breach detection (e.g., due to side effects such as selling
the same effect as a mouse click, such as submitting a of information in the underground markets). Then, a forensic
form, navigating to a new link, etc. Therefore, we trigger a analysis team is hired to investigate how the data was leaked. By
webshot at every keydown event for the Enter key. analyzing network logs, such as web proxy logs that report all
• Special Keys: We also trigger a screenshot every time a URLsvisitedbythecorporatenetworkusers,theforensicanalysts
special key is pressed. For example, pressing tab while notice something anomalous (e.g., a particularly suspicious set
3of URLs) in Bob’s web logs recorded a week earlier. Therefore, Browser Browser Renderer Renderer
the analysts ask for authorization to explore Bob’s ChromePic UI Thread IO Thread Main Thread Render Thread
logs. Finally, by exploring the webshots produced by our system, input Send(input) IPCSend(input) Notify(input)
the analysts are able to reconstruct the social engineering attack User I Pn rp ou ct e ssing
that tricked Bob into installing the initial malicious software.
Fig.1. OverviewofhowuserinputstoawebpagearepassedtotheRenderer
By learning how Bob fell for the attack, including obtaining Thread. Dashed arrows indicate asynchronous calls. Notice that the function
a precise reconstruction of the visual tricks used for the social namesareintentionallysimplified,anddonotexactlyreflectthe(longchains
of)functioncallsthatexistsinthesourcecode.
engineering attack, the corporate network security team could
then develop a user training session on social engineering, to
better educate corporate employees on how to decrease the
Furthermore, JavaScript code execution (e.g., initiated due to a
likelihoodofbecomingavictim[16].Inaddition,byhavingboth
listener registered on the input event), is also executed in the
thescreenshottakenattheverymomentwhentheuserclickedon
context of the Render Thread.
the misleading ad, as well as the related full DOM snapshot, this
information could be used to enhance browser-based defenses
against social engineering [3].
Notice that ChromePic enables the reconstruction not only of B. ChromePic Overview
the exact moment in which the attack is triggered (e.g., a click
on a social engineering malware ad), but also of the sequence Figure 2 provides a simplified overview of how our
of pages with which the user interacted before falling for the ChromePic browser generates a webshot. Notice that all dashed
attack. In addition, in case of phishing attacks ChromePic would arrows in the figure represent asynchronous calls.
also provide an account of the exact information the user leaked
on the phishing site. Knowing what information was “phished” In response to a user input, ChromePic takes the following
may be important to decide what actions to take to mitigate main actions: (1) on the Browser process, it calls Chromium’s
the damage to both the user and to the corporate network (e.g., codefortakingascreenshotofthecurrentvisibletab(seedetails
the user may have leaked access credentials related to sensitive inSectionIV-D),towhichtheuserinputisdestined;(2)itopens
corporate assets). a file that will be used to save the DOM snapshot and passes its
file descriptor, fd, to the Renderer, along with the user input;
(3) as the input andfdare received by theRenderer, it saves the
IV. SYSTEMDETAILS
current entire DOM, including embedded objects and JS code,
A. Background in MHTML format; (4) once the DOM snapshot has been saved,
the Renderer waits for confirmation from the Browser that the
Before we present the details of ChromePic, we first provide
screenshot taking process has terminated; only then, (5) the user
a brief overview on the Chromium browser architecture. As
input is processed using the original Renderer’s workflow. In this
Chromium’s architecture is fairly complex, we will limit the
process, notice that if the screenshot finishes before the DOM
following description to highlight only those components that
snapshot is saved, there will simply be no delay between steps
are needed to understand how our code modifications and
(3) and (5).
optimizations work.
The high-level steps described above allow us to guarantee
Chromium uses a multi-process architecture [40], which
thateachwebshotistakensynchronouslywiththeuserinput,and
includes a main browser process, called Browser, and one
rendering process, called Renderer, per each open browser tab1. no DOM modification due to the current input is allowed before
the webshot is logged, in accordance with the forensic rigor
The Browser runs multiple threads [45], including a UI Thread,
requirement stated in Section I. Moreover, our webshot events
which handles UI events among other things, and an IO Thread,
are transparent to the (possibly malicious) page. ChromePic’s
whichhandlestheIPCcommunications[39]betweentheBrowser
code is designed so that after logging the input can continue
and all Renderers. Each Renderer is also multithreaded [38]. The
its “natural” processing path, and no information regarding the
Renderer’s Main Thread is responsible for communicating via
webshot events is transferred to the page (notice that while
IPC with the Browser, whereas the Renderer’s Render Thread
side-channel attacks cannot be excluded, user input timings are
is responsible for rendering web content, including executing
not easily predictable, thus making detecting the existence of
JavaScript code.
ChromePic a laborious, non-deterministic endeavor).
As shown in Figure 1, user inputs to a web page are first
received by the Browser’s UI Thread, and then asynchronously
Challenges.Whiletheprocessoftakingsynchronousscreenshots
communicated via IPC (by the IO Thread) to the Renderer that
may appear straightforward at first, our design of ChromePic
is responsible for the tab where the page is rendered. The IPC
faces two main challenges. First, the limited documentation
message will first be processed by the Renderer’s Main Thread,
for many of the modules we instrumented forced us to a great
and then forwarded to the Renderer’s Render Thread [38]. For
deal of “reverse engineering” of the source code. In fact, our
instance, a click on a hyperlink will be processed by the Render
code modifications had to span not only multiple processes, but
Thread, to decide whether a navigation event should be triggered.
also multiple threads per process (UI, IO, Renderer, GPU, etc.).
In addition, while we strived to limit the number of changes
1Inpractice,aRenderermayinsomecasesberesponsibleforrenderingmore
to existing code as much as possible, to meet our efficiency
thanonetab[40].Tosimplifyourdescription,inthefollowingwewillassume
requirements we had to engineer a number of optimizations, so
onetabperRenderer.Also,wewillnotconsiderout-of-process-iframes[41],
whicharearecentongoingproject. to minimize the webshot overhead shown in Figure 2.
4Browser Browser Renderer Renderer
UI Thread IO Thread Main Thread Render Thread
input Send(input, fd) IPCSend(input, fd)
Notify(input, fd)
TakeScreenshot()
User take DOM
take tab snapshot
screenshot Send(screen_taken) webshot
save to file (fd) overhead
IPCSend(screen_taken) wait for
Save(screen) Browser Notify(screen_taken) screenshot...
File Thread
regular input
processing
Fig.2. SimplifiedviewofhowChromePicprocessesuserinputsthattriggerawebshot.Dashedarrowsindicateasynchronouscalls.
C. Identifying the Target Renderer Process
Browser Browser
GL / GPU
UI Thread IO Thread
Every Renderer Process has a corresponding
input TakeScreenshot()
RenderProcessHost object in the Browser process, User CopyFromCompositingSurface()
which is used to send and receive IPC messages between RequestCopyOfOuput()
the two processes. Effectively, the RenderProcessHost setNeedsCommmit
DrawFrame()
represents the Browser side of a single Browser-Renderer
GetFrameBufferPixels()
IPC connection [40]. A RendererProcessHost object
Result Send(screen_taken) IPC message
communicates with multiple RenderWidgetHost instances, to Renderer
PrepareTextureCopyOutputResult()
Browser
each one representing one tab in the browser [38]. For File Thread CropScaleReadBack
every RenderWidgetHost object, we create a custom Save CopyFromCompositingSurfaceFinished
SnapshotHandler object whose responsibility is to
coordinate the process of taking webshots for a given Fig.3. OverviewofhowscreenshotsaretakenandtheRendererisnotified
(notice that some of the function call names have been shortened and made
tab. When an input event is received, the responsible
morereadableforpresentationpurposes,comparedtothesourcecode).
RenderWidgetHost object is identified by the Browser, and
represents the last point in the Browser after which the event is
passed on to the correct Renderer via IPC message. We take asynchronously within the context of the Browser’s UI thread.
control of the input event just before it is passed on to the Only the ReadBack part of the screenshot taking process is
Renderer, and handle the event via our SnapshotHandler executed on the GPU process/thread).
instead. By doing so, we are able to identify the correct
RoutingID for the IPC messages [39], and therefore we can In simplified terms, we can break down the screenshot-taking
coordinate the process of taking a snapshot with the appropriate process into five main steps: (1) draw (i.e., composite the layers
Render Thread. of) the web page; (2) copy the pixels; (3) crop/scale; (4) read
back the final bitmap; (5) save to file (we execute the file
saving process within the Browser’s File Thread [45]). However,
D. Taking Screenshots Efficiently
we found that once step (2) is completed, the screenshot has
One way to implement the TakeScreenshot func- effectively been taken, and do not need to wait for the crop/scale
tion shown in Figure 2, would be to call Chromium’s operation before we can “release” the user input for further
CopyFromCompositingSurface and simply wait for processing. Namely, after step (2) the screenshot content is not
the CopyFromCompositingSurfaceFinished callback going to be influenced by the processing of the input, even if
(see Figure 3). However, we empirically found that this process the input causes the DOM to change.
sometimes takes a large amount of time to finish (e.g., several
hundred milliseconds, depending on the web page). Obviously, The DrawFrame operation is controlled by the compositor
a large latency would be unsustainable for our purposes, as scheduler cc::scheduler, which takes into account factors
it violates our efficiency requirements. Therefore, we had such as the device’s v-sync and dynamically establishes a target
to break down and study the details of the process used rateatwhichframesaredrawn[36].Forinstance,ondeviceswith
by Chromium to satisfy CopyFromCompositingSurface. a v-sync frequency of 60Hz, a frame would be ideally drawn
While documentation such as [37], [42] helped, this was not an every ∼16ms. Thanks to these properties, the time between
easy task, as it required a much deeper understanding of the the arrival of the user input and our Send(screen_taken)
internals of Chromium’s compositing process than found in the message in Figure 3 is typically on the order of only few tens
sparse Chromium project documents. of milliseconds (see Section VII).
We then discovered that to efficiently take synchronous
E. Taking “Deep” DOM Snapshots Efficiently
screenshots we could safely use the process depicted in Figure 3.
Specifically, to satisfy CopyFromCompositingSurface, Along with each screenshot, we also take a “deep” DOM
the Browser relies on a graphics library (GL) API and assistance snapshot that not only includes the current structure of the DOM
from the GPU (with code running on the GPU process, or GPU (at the time of the input), but also the content of all frames,
thread in Android [37]). The GL/GPU module in Figure 3 is embedded objects (e.g., images), and javascript code. To enable
represented separately from the Browser UI thread for presen- theserichDOMsnapshots,weapplyseveralimportantchangesto
tation convenience (to be more precise, the DrawFrame and Chromium’s code for saving web pages in MHTML format [32].
GetFrameBufferPixels functions are actually executed Specifically, we enhance Chromium’s code to include javascript
5code into the DOM snapshots and, importantly, to significantly is executed it will first serialize the page into MHTML format,
improve efficiency. Below, we focus on detailing these latter and then simply continue with the regular user input processing,
code optimizations. as shown on the right side of Figure 2. This guarantees that the
DOMsnapshotistakensynchronouslywiththerelateduserinput
To save a page in MHTML format, Chromium implements a
event, and before any input-driven DOM changes can occur.
GenerateMHTMLfunction,whichcanbecalledintheBrowser
process from the UI Thread. Given a specific tab, this function There is one remaining question: how can we serialize
is responsible for serializing the tab’s web page content into both the main page and all embedded frames, considering that
MHTML format, and to save it into a file. However, the Browser the original GenerateMHTML code needed to send multiple
does not have direct access to the DOM of the page in each tab. IPC messages? To solve this problem, we write new MHTML
Therefore,tosavetheMHTMLcontenttheBrowsermustrelyon serialization code to explicitly traverse the entire frame tree from
the Renderer process. But because the Renderer executes within the Render Thread, sequentially serialize each frame, and save
a sandbox, it cannot directly open a file to save the MHTML the entire DOM snapshot into the file previously opened by the
content. Chromium’s solution is to (1) open a file in the Browser Browser (in Section VIII we discuss how this process could be
process; (2) pass the file descriptor of the already opened file to further adapted in the future, once out-of-process-iframes [41]
the Renderer; and (3) ask the Renderer (via IPC message) to become enabled by default).
produce the MHTML content of the main page and each frame
it embeds, and to save it into this file. V. ALTERNATIVEIMPLEMENTATIONUSINGEXTENSIONS
Unfortunately, instead of sending only one IPC message to In this section, we discuss whether webshots could be
theRendererfortheentireprocess,Chromium’scoderesultsinto captured using Chrome’s extension API [7]. An extension-
sending one IPC message to request to save the main page, as based implementation would be appealing, because it does not
well as one separate IPC message to the Renderer to request the require any browser instrumentation and can easily be added
saving of each frame embedded in the page2. Because modern to existing browser releases. However, we will show that an
complex web pages contain a potentially large number of frames extension-based implementation of ChromePic is not a viable
(e.g., an iframe for each ad embedded in the page), the full alternative in practice, due to the constraints imposed by the
process of serializing and saving the MHTML content can be browser’sextensionAPIitselfandtothehigheraverageoverhead
quite expensive, lasting from hundreds of milliseconds to a few associated with webshots produced via the extension. In the
seconds. Therefore, using the existing code to take a DOM following, we refer to the extension-based version of ChromePic
snapshot synchronously with each user input would violate our as ChromePicExt.
efficiency requirements.
A. ChromePicExt Overview
Oneofthereasonswhytheaboveprocessishighlyinefficient
isthatforeachIPCthatisreceived,theRenderercreatesaTask, Becauseourforensicrigorrequirement(seeSectionI)dictates
which will (asynchronously) run on the Render Thread, at a time that webshots must be taken synchronously with the user input,
decided by the Renderer Scheduler [35]. As mentioned in [36], the content javascript component of ChromePicExt
“the render thread is a pretty scary place,” due to its complexity. must intercept user inputs before any page javascript code. This
Itsexecution“routinelystallsfortenstohundredsofmilliseconds goal can be achieved in two steps: (1) by setting the run_at
[...]onARM,stallscanbesecondslong”[36].Thereasonisthat property in the extension’s manifest file to document_start;
therearemanydifferenttypesoftasksthatsharethesameRender and (2) by registering an event listener for user input events
Thread processing time. For example, execution commonly stalls (e.g., mousedown, keydown, etc.) on the window object as
due to the execution of “long” javascript code [44]. Therefore, soon as the content javascript starts being executed.
each task related to a frame’s MHTML seralization could easily All ChromePicExt’s event listeners are registered with the
find itself starving for CPU time, thus bloating the overall time useCapture option set to true, to guarantee that the
needed to complete the full DOM snapshot. content javascriptwillbethefirsttocaptureandhandle
the event, before any page javascript has a chance to receive the
To address the above challenges and dramatically reduce same event. In the following, we will use cnt.js to refer to
the overhead related to taking DOM snapshots, we use the the extension’s content javascript.
following approach. Instead of calling GenerateMHTML, thus
generating multiple IPC messages to the Renderer specifically During the interaction between the user and the browser, if
dedicated to MHTML serialization, we send only one IPC a particular event that ChromePicExt is listening on is fired,
message to the Renderer. In fact, we piggyback the “take DOM our listener captures it first and passes the event object to
snapshot” message from the Browser onto the input-passing IPC the handler function implemented by the extension. At this
message that the Browser already must send to the Renderer point, ChromePicExt’s cnt.js needs to temporarily stop the
to communicate the user input (see Figure 2). To this end, propagation of the event object to any other listeners, including
we modify the IPCSend(input) IPC message to also carry listeners registered by the web page with which the user is
a file descriptor parameter, fd, which is related to a file we interacting,untilafullbrowsingsnapshotistaken.Thisiscrucial
explicitly open to allow the Renderer to save the DOM snapshot. toensurethattheothereventlistenerswillnothaveanopportunity
In addition, we instrument the input-processing task that would to change the appearance of the web page before the screenshot
normally only process the user input, so that when its Task and DOM snapshot are recorded. Notice also that because the
execution of javascript code within each renderer process is
2Thisapproachwillbeusefulinthefuture,oncetheout-of-process-iframes single-threaded3 [43], the input event cannot be processed by
projectiscompletedandthefunctionalityisturnedonbydefault,asdiscussed
laterinthepaper. 3NoticethatWebWorkerscannotdirectlychangetheDOM.
6any other listener until cnt.js “yields.” Furthermore, because 1. // Save "shallow" DOM snapshot
cnt.js runs in an isolated world4, the page javascript cannot 2. var domSnapshot = document.head.outerHTML + document.body.outerHTML;
3. chrome.runtime.sendMessage(command: "save_dom", dom: domSnapshot);
observe or interfere with the extension’s event processing. 4.
5. // Take screenshot
6. var md_time = Date.now();
Once a triggering event is received, to take a screen- 7. var filename = "snapshots/"+md_time+".png";
8. var xhr_request = new XMLHttpRequest();
shot of the rendered content cnt.js needs to call the 9.
captureVisibleTabAPIaccessibleviathebackground 10. chrome.runtime.sendMessage(command: "take_screenshot", file: filename);
11. while(true) {
extension component. At the same time, cnt.js also needs 12. try {
13. xhr_request.open('GET', chrome.extension.getURL(filename), false);
to produce a snapshot of the current page’s DOM tree, which 14. xhr_request.send(null); // send synchronous request
could be achieved for example by asking the background 15. break;
16. } catch (err) {
component to call the pageCapture.saveAsMHTML API. 17. // Synchronous XMLHttpRequest has failed
18. }
OnceboththescreenshotandDOMsnapshotaretaken,theevent 19. }
can be released so that the browser can propagate it to other
listeners. Fig.4. Simplifiedcnt.jssourcecode.
Challenges. In Chrome, the content javascript compo-
nentofanextensionhaslimiteddirectaccesstotheextensionAPI. listeners6; (3) wait until the callback from bgnd.js indicates
The full extension API can be accessed via the background that the webshot has been taken; and (4) re-dispatch the event
component. In the following, we refer to the background by injecting e(cid:48), so that the browser will propagate the user event
extension component as bgnd.js, for short. The cnt.js to the remaining listeners. Unfortunately, this will cause the
and bgnd.js components can communicate via message isTrustedpropertyofe(cid:48) tobesettofalse,thuspotentially
passing. For instance, immediately after a user input is captured, preventing some listeners from correctly processing the event. In
cnt.js can use sendMessage and ask bgnd.js to call addition, the value of isTrusted would allow an attack page
captureVisibleTab, thus producing a screenshot of the to infer the presence of ChromePicExt, and perhaps stop the
current page with which the user is interacting. Unfortunately, attack to prevent it from being logged/analyzed, thus violating
the simple approach described above does not satisfy the the transparency requirement (see Section I).
forensic rigor requirement for webshots, because bgnd.js
runs in the extension process [6], rather than the renderer B. Our Approach
process where cnt.js runs, and the screenshot is therefore
To solve the above problems, we proceed as follows. First,
taken asynchronously. Similarly, to take a full DOM snapshot
we will focus only on how to synchronously take a screenshot,
bgnd.jscanmakeuseofsaveAsMHTML,butthisalsocauses
and then discuss how to take a DOM snapshot.
theDOMsnapshottobetakenasynchronouslyw.r.t.theuserinput.
Inotherwords,ifthecnt.jssimplycapturesauserevent,asks Once a message has been sent to bgnd.js to ask for a
bgnd.js to take a webshot (using captureVisibleTab screenshottobetaken,cnt.jsactivelywaitsforthescreenshot
and saveAsMHTML) and then immediately “yields,” the event tobecompleted.However,asmentionedearlier,cnt.jscannot
can be propagated by the browser to other listeners. Therefore, actively wait for a callback from bgnd.js, as this would
there is no guarantee that the page javascript will not change bring cnt.js to stall. Instead, what cnt.js can do is: (1)
the page (DOM and rendering) before the webshot is actually explicitly choose the name of the file where the screenshot
logged. should be stored; (2) pass this information to bgnd.js (via
sendMessage) and at the same time ask it to concretely start
Possible Solutions.Onepossibleapproachtomakethewebshot the screenshot capturing process; (3) actively probe the file
takingfunctionalitysynchronousmaybeforcnt.jstoactively system using a synchronous XMLHttpRequest to the local
wait (e.g., loop) until bgnd.js communicates that the webshot URL 7 to test whether the screenshot file has been saved (via
request has been processed via a callback function. However, captureVisibleTab).
because JavaScript execution within each process is single-
Figure 4 shows a simplified code snippet that implements
threaded5, this would prevent cnt.js from yielding to the
the approach outlined above. The synchronous XMLHttpRequest
callback function, because it would need to run in the renderer
will raise an exception if the file does not exist. In this case,
processwherecnt.jsisactivelywaiting.Therefore,thiswould
cnt.js will try again, until the file can be found on disk
stall the renderer process and thus the web page (we have
(or a maximum number of attempts have been exhausted, as
empirically verified all observations). Another solution could be
a safeguard to avoid waiting indefinitely in case of failure at
to “sleep,” instead of actively waiting, for example by leveraging
the extension process side). After cnt.js exits the active wait
setTimeout or setInterval. However, this would not
loop, the user input event will effectively be “released” and
solvetheproblem,becausewhilecnt.js“sleeps,”iteffectively
passed by the browser to the remaining listeners, thus allowing
“yields” and the captured user event will trickle down to the
the processing of the event to continue (e.g., this could trigger
next listeners, thus again violating the requirement that webshots
some DOM modification by the underlying page javascript).
must be taken synchronously.
Unfortunately, the approach described above cannot be used
One may think that cnt.js could simply capture an event
to synchronously take a DOM snapshot using saveAsMHTML.
object, say e, and (1) make a deep copy of the object, thus
The reason is that while the call to saveAsMHTML happens
creating e(cid:48) =e; (2) cancel the propagation of e to the remaining
6UsingEvent.stopPropagation()
4https://developer.chrome.com/extensions/content scripts 7Notice that this can be enabled in the extension’s manifest file, via the
5WebWorkerscannotbeusedinthescenarioweareconsidering. web_accessible_resourcesparameter.
7(a) (b) (c)
Fig.5. SomeofthescreenshotscapturedbyChromePicduringanin-the-wildsocialengineering“fake-AV-like”attackonAndroid.
asynchronously via bgnd.js, which runs within the extension A. Social Engineering Download Attack
process, ultimately saveAsMHTML will delegate the respon-
During our user study (see Section VII-B), we encountered
sibility of producing and saving the mhtml representation of
an in-the-wild social engineering download attack. Here is how a
the DOM to the same Renderer process where cnt.js also
user arrived to this attack: (1) The user visits www.google.com
runs, within the Render Thread (see Section IV-E). Therefore,
and searches for “wolf of wall street”; (2) after scrolling the
if cnt.js actively waits for the mhtml file to be saved it
results, the user modifies the search terms by adding the letter
will simply wait indefinitely, as the mhtml file cannot be
“f” to the search string (see Figure 5a); (3) the search engine
produced until cnt.js “releases control” of execution on the
suggests “wolf of wall street full movie” as the top search
renderer’s main thread. One way to avoid this problem is to
suggestion, which is clicked (with a touch screen tap) by the
simply program cnt.js to save the DOM structure, as shown
user; (4) the user then clicks on the top search result, which
at the top of Figure 4. However, this is a much more limited,
redirects the browser to a site called fmovies[.]to; (5) as the
“shallow” representation of the DOM, compared to what can be
site loads, with no interaction from the user, an advertisement
obtained with saveAsMHTML, because embedded objects (e.g.,
embedded in the page forces the browser to open a new tab
the content of images or iframes) are not saved.
where a page is loaded from us.intellectual-82[.]xyz; (6) an alert
The cnt.js could be extended to produce a result that is popup window is immediately shown, which warns the user that
more similar to saveAsMHTML. For instance, the content of the device is infected by multiple viruses; (7) clicking on the
imagescanbeaccessedbyfirstloadingthemintoacanvasand OK button makes the alert window disappear, but the user now
then reading the content of the canvas [27]. But this is a quite sees the us.intellectual-82[.]xyz page (which was previously in
cumbersome and inefficient operation. Also, while cumbersome, the background) claiming that the Android device is “28.1%
it would be possible to communicate (e.g., via postMessage) DAMAGED because of 4 harmful viruses” (see Figure 5c) and
to the cnt.js running in the context of the embedded frames8 recommends the user to download an application called “DU
to produce a DOM snapshot, which could then be combined to Cleaner”; (8) clicking on a “REPAIR FAST NOW” button, the
the DOM of the main page to produce a more comprehensive, user is redirected to the Google Play store, and specifically to
“deep” snapshot of the page. information about an app called GO Speed9 (not DU Cleaner,
as stated on the attack page).
It should be apparent by now that the extension-based
approach to taking synchronous webshots is sort of a “hack,” in Using ChromePic, we were able to record all main steps of
that it bypasses some of the restrictions imposed by the browser the attack. In fact, the screenshots in Figure 5 were all taken
on cnt.js and its inability to directly access the extension by ChromePic and confirm that using the recorded webshots,
APIs. Furthermore, screenshots cannot be made fully transparent the social engineering attack described above can indeed be
to the user, because every time a screenshot is taken the browser reconstructed by tracing back the user-browser interactions,
visually indicates that a file is being downloaded (on the bottom including tapping on the “REPAIR FAST NOW” button on
of the browser window). In Section VII, we will also show the attack page. Naturally, after the user clicks on this download
that the extension-based implementation of ChromePic imposes button and control is passed to the Google Play app, ChromePic
a higher overhead, compared to the browser instrumentation could not follow the next user actions (e.g., whether the app was
approach described in Section IV. Overall, this demonstrates installed or not on the device). This is expected, as ChromePic
that extensions are not suitable for meeting all of ChromePic’s is meant to reconstruct all steps of web-based attacks that unfold
design requirements. within the browser. The GO Speed app that the user is asked to
install seems to be benign, as it has been installed by a large
user base (more than 10M users, according to Google Play)
VI. RECONSTRUCTINGATTACKSONUSERS and an analysis of VirusTotal.com reports no anti-virus labels10.
After analyzing the DOM snapshots taken by ChromePic, we
In this section, we report on a number of experiments that suspectthattheattackersaretryingtomonetizeanadvertisement
demonstrate how ChromePic can capture attacks on users, and campaign that pays for every new “referred” installation of
enable their post-mortem reconstruction. Specifically, we will the app. For instance, the attack page contains a link to
discuss three attacks, an in-the-wild social engineering download click.info-apps[.]xyz and another to tracking.lenzmx[.]com with
attackonAndroid,aphishingattack,andtwoclickjackingattacks a URL query parameter mb_campid=du_cleaner_tier2.
proposed in [1].
9https://play.google.com/store/apps/details?id=com.gto.zero.zboost&hl=en
8Assumingtheall_framesoptionissettotrueinthemanifestfile. 10sha1:811b367c4901642ae41b4b8f0167eac2d3ac4039
8(a) (b) (c)
Fig.6. SomeofthescreenshotscapturedbyChromePicduringaphishingattack(theattackURLwasfirstreportedinPhishTank,submission#4359181).
After a mouse click, the browser is redirected (via HTTP 302 recovered.Astheuserclicksonamenubarlink,thesiterequires
redirections) through those two sites to the final market:// thevictimtofillinasetofsecuritycodes,asshowninFigure6b.
URL referring to the GO Speed app. It is likely that the FakeAV- Notice that here the attacker is attempting to essentially steal the
like advertising tactics employed in this social engineering attack user’s entire security code card13. By doing so, the attackers will
are simply a way to convince more users to install the app and subsequently be able to perform any bank transaction operation
(illicitly)increaserevenue,inawaysimilartohowpay-per-install without being blocked by the real bank’s security mechanisms.
networks [20], [46] monetize third-party software installations. Finally,aftertheuserprovidesthesecuritycodecardinformation,
the phishing site also requests the user’s telephone number and
There is a small exception to be noted. ChromePic did not
password (Figure 6c). Once this information is provided, the
take a screenshot of the alert popup window, which should have
site shows a “loading” animation that makes the user believe
been triggered by the user clicking on the OK button to close
his/herdataisbeingverified (notshownin Figure6duetospace
the popup. The reason is that alert windows are rendered “out of
constraints). But at this point the attack has already succeeded.
context” w.r.t. to browser tabs, and our current implementation
of ChromePic does not support taking a snapshot when users
C. ClickJacking Attacks
interact with such alert windows (we plan to add support for
alert windows in future releases of ChromePic). However, it is To demonstrate how ChromePic is able to also capture
worth noting that by analyzing the DOM snapshots taken as the clickjacking attacks, we reproduced two attacks described in [1]:
user interacted with the attack page (at us.intellectual-82[.]xyz) the Destabilizing Pointer Perception attack and the Peripheral
we were able to also reconstruct the content of the alert popup: Vision attack. The (simulated) attacks, which we adapted from
WARNING ! This Google Pixel C is infected with viruses and publicly available code14 by the authors of [1], are available at
your browser is seriously damaged. You need to remove viruses https://chromepic.github.io/clickjacking 15.
and make corrections immediately. It is necessary to remove and
DestabilizingPointerPerception:TheattackisshowninFigure7.
fix now. Don’t close this window. ** If you leave , you will be
In this attack, the user intends to click on a “here” hyperlink.
at risk **
However,asthemousepointerapproachesthelink,thefollowing
events occur: (1) a fake pointer is drawn that has a left-side
B. Phishing Attack
displacementerror,comparedtotherealpointer(whichishidden);
Besides tracing-back the steps followed by users who reach (2) as the user brings the fake pointer on top of the link, the real
an attack page, ChromePic can also assist in understanding how pointer is actually located on the Facebook Like button; (3)
the user interacted with the attack itself. For instance, in the case because the Like button is rendered within a third-party frame,
ofphishingattacks,ourwebshotscaptureawealthofinformation the attack javascript cannot hide the mouse pointer at this time,
about what data was leaked by the user. To demonstrate this, therefore, the attack instead draws other random mouse pointers
we present an example of a recent phishing attack posted on toconfusetheuserandeffectivelypreventtheuserfromnoticing
PhishTank (submission #435918111). that the real mouse pointer is over the Like button; (4) as the
user attempts to click on “here,” the real click actually occurs
After using ChromePic to visit the phishing URL, which on the Like button, thus completing the clickjacking attack.
impersonates a Brazilian banking website, we simulated the
actions of a user who falls for the attack by providing fake Figure 7 shows the screenshot taken by ChromePic at the
information (due to format-checking javascript, we had to figure mouse down event. The center of the red circle is the exact
out how to provide fake but syntax-compliant data). Figure 6 location where the user input event occurred. Notice that the
showssomeofthesnapshotstakenbyChromePicasweinteracted fake mouse pointers are captured by the screenshot, including
with the attack website. Unlike other phishing attacks, which the pointer located over “here.” At the same time, the real mouse
are often limited to stealing the victim’s login credentials, this pointer is not captured in the screenshot, because it is drawn by
attackisfairlysophisticatedasitattemptstoreproducetheentire
banking site. Once the user logs in (by providing his/her CPF12 13AnEnglishlanguageexplanationofhowsecuritycodecardsareusedin
financialapplicationscanbefoundatthislink:https://www.interactivebrokers.
code), the site claims the balance of the user’s bank account has
com/en/?f=%2Fen%2Fgeneral%2FbingoHelp.php
been hidden (presumably for security purposes) and must be 14http://wh0.github.io/safeclick-blast/list.html
15Theoriginalattackcodeiscurrentlybrokenduetoamissingremotefile;
11http://www.phishtank.com/phish detail.php?phish id=4359181 afteranalyzingthecodewefoundaneasyfixandwewereabletorecreatethe
12https://en.wikipedia.org/wiki/Cadastro de Pessoas F%C3%ADsicas attacks.
9Fig.7. Destabilizingpointerperceptionclickjackingattack.
function distract() {
var img = document.createElement('img'); Fig.9. Twoscreenshotsthatcapturetheperipheralvisionclickjackingattack.
img.className = 'random';
img.src = 'http://i.imgur.com/EWmYMN2.png';
img.style.top = Math.random() * 160 + 160 + 'px';
img.style.left = Math.random() * 160 + 240 + 'px'; A. Experimental Setup
playarea.appendChild(img);
var dummy = img.clientHeight;
img.style.top = Math.random() * 160 + 160 + 'px'; Our ChromePic browser is built upon Chromium’s codebase
img.style.left = Math.random() * 160 + 240 + 'px';
setTimeout(function () { version 50.0.2626.2. Our source code modifications amount to
playarea.removeChild(img);
}, RANDOM_MOVE_TIME); approximately 2,000 lines of C++, and will be available at
} https://chromepic.github.io/chromepic-browser/.
Fig.8. ReconstructionofcodeforgeneratingfakepointersfromChromePic’s We evaluate ChromePic on both Android 6.0 on a Google
DOMsnapshots. Pixel-C tablet with an Nvidia X1 quad-core CPU and 3GB of
RAM, as well as on two machines running Linux Ubuntu 14.04:
a Dell Optiplex 980 desktop machine with a quad-core Intel
the OS, not rendered by the browser (only the fake pointers are
Core-i7 processor and 8GB of RAM, and a Dell Inspiron 15
rendered by the browser). Nonetheless, the coordinates of the
laptop with a Core-i7 CPU and 8GB of RAM.
real input event are recorded in our webshot, and it is therefore
straightforward to find the correct location of where the real
mouse pointer was located and draw the red circle accordingly
B. User Study Setup
over the screenshot. Also, by analyzing the DOM snapshots
produced by ChromePic, it is easy to recover the fact that the User Study 1: To evaluate the overhead imposed by our code
mouse is hidden via CSS (using cursor:none), and to also changes to Chromium, we perform a user study involving 22
get the full source code for the javascript functions that enable distinct users (with IRB approval). Specifically, we compile our
the attack, including the creation of fake mouse pointers (see ChromePic browser for both Linux and Android, and ask the
Figure 8). study participants to use the devices described earlier for generic
Internet browsing activities. Users were allowed to freely browse
Peripheral Vision: In this attack, the objective is to attract the
any site of their choosing. The only restriction we imposed was
user’s attention towards an area of the screen that is far from
to avoid visiting any website containing personal data, such as
where the mouse clicks actually occur. To this end, a game is
onlinebankingsites,theirFacebookpage,etc.,toavoidrecording
setup, as shown in Figure 9. In this game, the user needs to
anysensitiveinformation.Eachuserwasaskedtoperformoneor
click on the Play button on the bottom left of the screen, so
more browsing sessions on different devices, with each session
to catch the moving L or R blocks within the purple box on the
lasting approximately 15 minutes. Each user completed no more
right side of the screen. Because the user’s attention is drawn to
than two separate browsing sessions per device (a few users
the right side, while the clicks occur on the bottom left, the user
used only the Android and Linux laptop devices, and did not
may not notice that at some random convenient time the attacker
browse on the desktop Linux machine). Overall, we collected
may replace the Play button with a Facebook Like button. If
363 minutes of browsing activity on the Android tablet from
the mouse click occurs when the Like button is displayed, the
16 different users, 346 minutes on the Linux laptop from 15
clickjacking attack succeeds.
users, and 286 minutes on the Linux desktop from 11 users
Figure 9 shows two screenshots, taken at two different (more than 16.5 hours of browsing overall), which included
mousedown events. In the screenshot on the left, the user clicks severalthousandsinputeventsperdevice.Theusersvisitedmore
on the real Play button. The screenshot on the right shows that than 1,600 different web pages (i.e., URLs) on 204 distinct web
atthesecondmousedowneventthePlaybuttonhadtemporarily sites (i.e., different effective second-level domains, including
(foronlyonesecond)beenreplacedwiththeLikebutton,which google.com, youtube.com, amazon.com, and several other highly
received the user’s click. As can be seen, ChromePic correctly popularsites),producingcloseto6,000webshotsoverall.TableI
captured the two events (the center of the red circle represents reports a summary of the data we collected.
the exact location where the user clicked). Notice that this attack
For this study, the browser was setup so that webshots are
again has a significant visual component that would be difficult
active only on randomly selected pages. Namely, every time the
to reconstruct by analyzing only the page DOM, and that we
user navigates to a new page, the browser “flips a coin” and
were able to correctly capture it thanks to ChromePic’s ability
decides if the webshot logging capabilities should be activated
to take screenshots synchronously with the user inputs.
or not (other experiments described later had the webshot logs
always on). The reason for this is that we wanted to measure
VII. PERFORMANCEEVALUATION
and compare the time needed by the browser to process input
In this section, we present a set of experiments dedicated to events with and without our code changes, to demonstrate that
measuring the overhead introduced by webshots. our webshots do not impose any other input processing delay,
10TABLEI. DATACOLLECTEDDURINGUserStudy1
Platform #Users Browsingtime Sitesvisited Pagesvisited Pagesvisited WebShotevents
(minutes) (webshotson) (webshotsoff)
Android 16 363 92 480 479 2428
Linuxlaptop 15 346 80 777 746 2145
Linuxdesktop 11 286 65 369 404 1376
Total 22(unique) 995 204(unique) 1626 1629 5949
besides the actual time to record the logs. We comment on the
results of this experiment in Section VII-C (see also Figure 11).
1.0
User Study 2: We also performed a smaller targeted user study
involving 4 different users browsing on the Linux laptop device 0.8
(with webshots always on). In this study, we asked the users
to login into sites such as Facebook, Gmail, Twitter, Google 0.6
Drive, etc., using a “temporary” account we created only for this
0.4
study,whichthereforecontainsnotruepersonalinformation.This
Mouse click deltas (1278)
experiment aimed at evaluating ChromePic’s overhead during Key press deltas (1089)
0.2 Laptop webshots (2117)
activities such as writing emails, writing Facebook/Twitter posts, Tablet webshots (2428)
writingaGoogleDoctextdocument,etc.Overall,wecollected53 Desktop webshots (1361)
minutesofbrowsingtime.Theexperimentalresultsarediscussed 0.00 Event Du50 ration (ms) -1 0 m0 ouse, key p15 r0 ess deltas a20 n0 d webshot o25 v0 erheads 300
in Section VII-C. Fig.10. Timeneededtotakewebshotsandcomparisonwithmouse-down/up
and key-down/up time deltas (the number of events on which the CDFs are
User Study 3: Finally, we performed a separate small user study computedareinparenthesis).
involving 6 users to evaluate the performance of ChromePicExt,
theextension-basedimplementationthatattemptstorecordbrows-
ing snapshots similar to the webshots recorded by ChromePic could be further reduced to (max{t ,(t − δ )} − t ) by
sn d f 0
(see Section V). We discuss the related results in Section VII-C. offloading the DOM file saving process to a separate Renderer
process thread (we leave this implementation task to future
C. ChromePic Performance Measurements releases of ChromePic).
UserStudy1:InTableII,wereportabreakdownoftheoverhead Figure 10 shows the distribution of the total time needed to
measurement results performed on browsing traces collected log the webshots on different devices, while Table II reports a
during our User Study 1. Specifically, we report the 50th breakdownofthewebshottimesintotheircomponents(50th-and
percentile (i.e., the median) and 98th percentile of the time 98th-percentiles). On both Linux devices (laptop and desktop)
required for taking screenshots, “deep” DOM snapshots, and for 98% of all webshots are logged in less than 120ms. This is a
the total webshots time. All numbers are in milliseconds. very good result, because any latency below 150ms is practically
unnoticeable to users [47]. On Android, 98% of webshots are
To better explain how the measurements in Table II are
logged in less than 264ms, with a median time of around 78ms.
obtained, let u(t ) be a user input event that occurs at
0 While the 98th-percentile time is higher than our 150ms target,
time t , which triggers a webshot. Also, let t be the
0 sn it is still a low overhead that is on the very low end of the
time at which the screen_taken notification is sent in
“noticeable” latency classification provided in [47]. Also, our
Figure 3 from the GL module to the Browser IO Thread.
results indicate that 82.02% of all webshots on Android can
Namely, this is the time when the screenshot has actually
be taken in less than 150ms. Furthermore, notice that the total
been captured, and the user input can be processed (see
overhead is driven by the DOM snapshot time, including saving
Section IV-D). On the other hand, let t be the time when
sc the DOM to file, rather than the screenshot notification time.
the CopyFromCompositingSurfaceFinished callback
From Table II, we can see that the 98th-percentile of the total
iscalled.Wedefinethescreenshotnotificationtimeas(t −t ),
sn 0 webshot logging time for Android could be reduced to roughly
the screenshot callback time as (t −t ).
sc 0 203ms if file saving was delegated to a separate thread in the
Similarly, let t be the time at which the DOM snapshot Renderer process. In addition, in this setting 89.33% of the
d
has been saved, and the user input can be further processed, as webshots on Android would take less than 150 ms.
discussed in Section IV-E (see also Figure 2), and δ be the
f To further put our results into perspective, we also compared
time taken to save the DOM snapshot to file using the MHTML
the time needed to take webshots to the time in between mouse-
format. The DOM snapshot time with file write is computed as
down/up and key-down/up events. In other words, we measure
(t −t ), whereas DOM snapshot time w/o file write is equal
d 0 the time that it takes for a user to lift her finger from the mouse
to (t −δ −t ), which therefore excludes the time needed
d f 0 button or from a key. The mouse-down/up and key-down/up time
to copy the snapshot to file. The reason why we measure this
deltas are measured on the Linux desktop, with webshots turned
latter quantity is that with some more engineering effort the
off. As we can see from Figure 10, the distribution (CDF) of
DOM snapshot file saving process could be moved to a separate
webshot overhead times on the Linux laptop and desktop are
Renderer processthread, thus effectivelydecreasing the overhead
always to the left of the mouse-down/up and key-down/up time
imposed by the DOM snapshot logging.
deltas curves. Because we start the webshot log at the down
The total webshot time is computed as (max{t ,t }−t ), event,thismeansthatinthevastmajorityofcaseswhenamouse
sn d 0
according to the discussion provided in Section IV. This time click or a key press occurs, the webshot will be fully logged
11TABLEII. UserStudy1-PERFORMANCEOVERHEAD(50TH-AND98TH-PERCENTILE)
Platform Total Total Screenshot Screenshot DOMsnapshottime DOMsnapshottime
withfilewrite(ms) w/ofilewrite(ms) notificationtime(ms) callbacktime(ms) withfilewrite(ms) w/ofilewrite(ms)
Android 78.05,263.06 59.53,203.01 13.02,25.88 65.67,109.97 77.55,261.81 58.86,202.38
Linuxlaptop 39.16,118.43 33.32,109.55 5.38,27.68 36.17,71.05 38.95,118.26 33.12,109.38
Linuxdesktop 22.36,93.19 19.02,76.11 2.74,23.80 38.95,118.04 22.11,85.86 18.74,70.53
measurements, we found that the slight increase in overhead,
comparedtoUserStudy1,wasduetoDOMsnapshotsonGmail,
1.0
due to how the page is structured (e.g., Gmail pages embedded
a larger number of iframe’s and had a larger DOM size).
0.8
Specifically, the 98th-percentile for the total webshot time on
Gmail was around 245ms. The times on all other popular sites
0.6
(Facebook,Twitter,GoogleDocs,etc.)wereinlineorevenlower
0.4 than those obtained in User Study 1. For instance, on Facebook
the 98th-percentile was less than 120ms. Overall, if we exclude
0.2 Gmail from this experiment, 98% of the webshots can be taken
Webshots enabled (1369) in 108ms.
Webshots disabled (1412)
0.00 50 100 150 200 250 300 350 400
Event Duration (ms) - mouse and key events User Study 3: For comparison purposes, we also measured
Fig.11. Comparisonof“natural”inputeventprocessingtimewithandwithout the performance of taking screenshots using the extension-
webshotsenabled(thenumberofeventsonwhichtheCDFsarecomputedare based approach discussed in Section V. These have been done
inparenthesis).
on the desktop machine, and the results should therefore be
compared to the third row of Table II. Also, notice that in
this experiment we are only considering the screenshot time
by the time the user raises her finger. Also, the Android tablet
(as explained in Section V, it is not easy to take synchronous
curve is almost entirely to the left of the mouse-down/up and
“deep” DOM snapshots via the extension API). We found that
key-down/up curves, showing that even on Android the webshots
50% of screenshots require at least 140ms and 98% of them
can be taken efficiently.
require 243ms. This is in contrast with the 2.74ms and 23.80ms,
Another result worth noting is that our screenshot code respectively, that are required by the browser-based version of
optimizations, described in Section IV-D, yield a very significant ChromePic. Furthermore, the extension times are much larger
overhead improvement, as can be seen by comparing the than the total time needed to take a full webshot (including the
notification time and callback time in Table II. DOM) on the desktop machine using the instrumented browser
solution (see Table II). This reinforces our conclusion that an
To verify that our webshots do not negatively impact the extension-based solution is not only cumbersome, as discussed
subsequent “natural” input processing times, in Figure 11 we in Section V, but also much less efficient.
alsocomparetheamountoftimetakenbythebrowsertoprocess
a user input in two different cases: when webshots are disabled
D. Storage Requirements
(dashed line), and when the input is processed right after a
webshot has been logged (solid line). Specifically, let t 0 be the Table III shows the storage requirements for archiving the
time when theBrowser sends a userinput uto the Renderer, and webshots produced during User Study 1. After a straightforward
t i bethetimewhentheRendererconfirmstotheBrowserthatthe compression process (converting screenshots to JPG and using
input has been processed (we use Chromium’s LatencyInfo lossless compression for DOM snapshots), the webshots take
objects to measure this). Also, let t(cid:48) be the “input processed” a maximum of 1.03MB per minute of browsing on the Linux
i
confirmation time related to events that triggered a webshot, and laptop.Androidlogsrequiredonly0.85MB/minuteofstorage,and
δ w be the time delta needed to log a webshot. The first (dashed) 0.92MB/minuteonthedesktopmachine.Thisspacerequirements
curve measures (t i−t 0), which represents the “natural” input could be further reduced by using lossy compression on the
processing time. Similarly, the second (solid) curve measures DOM-embedded images, for instance by converting them to a
(t(cid:48) i−δ w−t 0), which represents the time needed by the browser low- or medium-quality JPG.
to process the input after a synchronous webshot has been taken
Let’snowconsiderascenarioinwhichChromePicisdeployed
(see Figure 2). As can be seen, the two curves are very similar,
in a corporate network setting. Assume that in average users
indicating no unexpected delay to the natural input processing
spend half of their working time (4 hours/day) browsing, while
time due to webshot events. In other words, the webshots do
the other half is spent on other tasks (meetings, development,
not cause any other delays, besides the actual time to take the
design, data analysis, etc.). If we assume 22 business days per
webshots, δ .
w
month, and 1.03MB of storage needed per minute of browsing
User Study 2: As discussed in Section VII-B, we separately (i.e., the maximum amount we observed), a single user would
measured the overhead for user activities on popular web sites, producelessthan6GBofwebshotlogspermonth.Inacorporate
suchasFacebook,Twitter,Gmail,GoogleDrive,etc.Werecorded network with 1,000 users, this would result in less than 6TB of
thousands of user input events, 1,910 of which triggered a storage for an entire month of browsing logs for the network, or
webshot. Of these webshots, 50% were processed in less than 72TB for an entire year of logs. Considering that a multi-TB
66ms, and 98% took less than 240ms. Furthermore, 80% of all hard drive currently costs only a few hundreds US dollars, an
the webshot took less than 150ms. After closely analyzing the entire year of webshot logs could be archived for only a few
12TABLEIII. AVERAGESTORAGEREQUIREMENTS(MBS/MINUTE)
whitelist of sites on which webshots should be turned off. To
Uncompressed Compressed be more strict, ChromePic could be prevented from logging any
Platform
Screenshots DOM Screenshots DOM events on pages loaded via HTTPS that have a valid (not self-
Android 6.80 11.62 0.31 0.54
signed) TLS certificate. Furthermore, a “helper” application (or
Linuxlaptop 4.66 11.33 0.15 0.88
Linuxdesktop 2.31 8.07 0.09 0.83 a separate browser thread) could be responsible for continuously
gathering and encrypting the browser logs. This application
would encrypt logs related to different tabs separately, using
thousand US dollars. In alternative, considering that business- unique keys that could be stored in a key escrow [8]. The key
grade cloud-based storage services are currently priced at less escrowcouldbeownedbytheuseror,inenterpriseenvironments,
than $0.03/GB per month, archiving one entire year worth of by the machine’s administrator, and the keys released only when
webshots for the entire corporate network in the cloud would a security investigation is called for. In addition, because each
cost less than $2,200 per month16. tab can be stored separately and encrypted with a different key,
investigators could be selectively given access only to some tabs
VIII. DISCUSSION rather than the entire browsing history. The decision on whether
to authorize the decryption of a tab would depend on the specific
There exist some corner cases in which it is not possible
investigation, but could for instance be based on the time frame
to “freeze” the state of the DOM/rendering immediately after
in which the attack is suspected to have happened, and on the
a user input arrives. For instance, if a user input arrives while
list of domains that have been visited within the tab, which can
the Render Thread is already executing another task, such as
be recorded as meta-data and encrypted with a “global” key.
a long-running javascript program that affects the DOM, the
In addition, audit logs could be protected from tampering by
processing of the user input will have to wait until javascript
using existing file system features, such as append-only files
terminates, and until its own Task is scheduled for execution
and immutability [24]. We leave the engineering of this key
(see Section IV-E). The net effect is that the DOM snapshot
escrow-based system to future work.
will reflect the state of the DOM after the already running
javascript code terminates. Notice, however, that this is also true
for “natural” input processing. Namely, the input will apply to
IX. RELATEDWORK
the modified DOM, regardless of whether a webshot is taken or
not. Therefore, our snapshots correctly reflect the state of the The analysis of security incidents is often hindered by the
DOM at the time when the input becomes effective. Similarly, lack of necessary logs. As mentioned in [21], “it is all too often
because screenshots need to wait for the compositor to redraw, the case that we tend to lack detailed information just when we
the exact instant in time in which the screenshot is taken is need it the most.” The existing logging functionalities provided
determined by the cc::scheduler (see Section IV-D). If an by modern operating systems and browsers are often insufficient
animation is in progress on the page, it may be possible for the to precisely reconstruct an attack. Below we discuss previous
screenshot to be one (or a very small number of) frame(s) “off” works that aim to enhance logging and improve the ability to
w.r.t. the user input. Again, this also holds for “natural” input investigate security incidents.
processing (i.e., even if webshots were disabled), because the
input may become effective after a redraw. Enhanced Logging. To enable the analysis of security incidents,
Kornexl et al. [19] propose a network “Time Machine,” whose
In Section IV-E, we mentioned that once the out-of-process-
goal is to efficiently record detailed information extracted from
iframes (OOPIFs) [41] project is completed and becomes active
network traffic. The purpose of this system is to support forensic
by default, we will need to slightly adapt our code for taking
analysis and network troubleshooting. To increase efficiency and
DOM snapshots. In fact, we believe that OOPIFs would allow
allow for storing network traffic information for long periods of
us to further decrease the time needed to take a snapshot. The
time,TimeMachineonlyrecordsthefirstportionofeachnetwork
reason is as follows. Assume the user interacts (e.g., clicks
connection. Even with partial recordings, [19] demonstrates that
on a link) with a page that embeds several iframes (e.g., to
this approach enables the analysis of security incidents. Krishnan
display different ads). In the current implementation, both the
et al. [21] propose a virtualization-based forensic engine to
main page and iframes are processed in the same Renderer
keep track and record access to data objects read from disk.
process.Therefore,theDOMofthemainpageandalliframes
The proposed system follows the chain of access operations on
has to be produced at once, synchronously with the input (see
the objects as they are copied into memory and accessed by
Section IV-E). But with OOPIFs we could produce all these
different processes. The output is an audit log that enables the
partial DOM snapshots in parallel by simply sending a “take
reconstruction of the sequence of data changes. Ma et al. [25]
DOMsnapshot”IPCmessagetothemainpageandalliframes
develop a low cost audit logging system for Windows, which
at the same time.
aims to enable accurate attack investigation and significant log
Because ChromePic continuously logs user-browser inter- reduction.
actions and takes screenshots, the recorded logs may contain
The instrumentation of Chrome has been proposed in the
sensitive user information. To mitigate privacy concerns, the logs
past in different security contexts. For example, Bauer et al. [5]
could be securely stored using methods similar to previously
propose an information-flow tracking system that allows for
proposed approaches [12], [34]. Furthermore, the solutions
enforcing fine-grained browser security policies. Excision [2], is
proposed in [28] could also be readily applied to ChromePic’s
aninstrumentationofChromethataimsatdetectingandblocking
output. For instance, ChromePic could employ a customizable
the inclusion of malicious third-party content into web pages.
16Estimatedusinghttp://calculator.s3.amazonaws.com/index.html(withCold To this end, Excision keeps track of the origin of third-party
HDD) content to be loaded as part of the page.
13OurChromePicsystemisdifferent,inthatitamstointroduce X. CONCLUSION
fine-grained logging in Chromium to enable the recording and
In this paper, we presented ChromePic, a web browser
post-mortem investigation of web-based attacks, with particular
equipped with a novel forensic engine whose goal is to greatly
focusonattacksonusersthathaveasignificantvisualcomponent.
enhance the browser’s logging capabilities. ChromePic enables a
Record-and-Repaly Systems. ReVirt’s main goal is to enable fine-grained post-mortem reconstruction and trace-back of web
whole-system record-and-reply [11]. To this end, it uses a attacks without incurring the high overhead of record-and-replay
virtualization-based approach to log detailed information about systems. ChromePic works by recording a detailed snapshot of
a VM’s guest system execution instruction-by-instruction. This the state of a web page, including a screenshot of how the page
enables deterministic replay of the entire system, thus also is rendered and a “deep” DOM snapshot, at every significant
allowing an exact replay of previously recorded intrusions. Other interaction between the user and web pages. If an attack is later
whole-system record-and-replay engines, such as PANDA [10], suspected,thesefine-grainedlogscanbeprocessedtoreconstruct
sharesimilargoals.Whole-systemrecord-and-replayisexpensive the attack and trace back the sequence of steps the user followed
anddifficulttodeployonresource-constrainedmobiledevices.To to reach the attack page.
obviate these problems, Neasbitt et al. propose WebCapsule [28],
We developed ChromePic by implementing several careful
which aims to enable browser-level record-and-replay. WebCap-
modifications and optimizations to the Chromium code base, to
sule is implemented by instrumenting Blink, Chrome’s rendering
minimize overhead and make always-on logging practical. Using
engine. Because recording occurs at a higher level, compared
both real-world and simulated web attacks, we demonstrated that
to[11],WebCapsuledoesnotallowforfullydeterministicreplay.
ChromePic can successfully capture and aid the reconstruction
On the other hand, WebCapsule is portable to multiple platforms,
of attacks on users. Our evaluation included the analysis of an
including mobile devices.
in-the-wild social engineering download attack on Android, a
phishing attack, and two different clickjacking attacks, as well
ChromePicisdifferentfromtheabovesystems,inthatitdoes
as a user study aimed at accurately measuring the overhead
not aim to enable replay. Rather, our system aims to introduce
introduced by our forensic engine. The experimental results
very low overhead, and to record enough detailed information
showed that browsing snapshots can be logged very efficiently,
aboutthestateofthebrowsertoenableanaccuratereconstruction
makingsnapshotloggingeventspracticallyunnoticeabletousers.
of web-based attacks towards users, such as social engineering
and phishing.
ACKNOWLEDGMENT
AutomatedIncidentInvestigation.WebWitness[30]isanincident
investigation system that leverages deep packet inspection This material is based in part upon work supported by the
to reconstruct the steps followed by users who reach social NationalScienceFoundation,undergrantNo.CNS-1149051,and
engineering or drive-by malware download pages. The system by the United States Air Force and Defense Advanced Research
reliesonfullnetworkpackettracestoperformsa(network-based) Agency (DARPA), under Contract No. FA8650-15-C-7562.
analysis of both the content of web pages and the way in which Any opinions, findings, and conclusions or recommendations
the content is requested (e.g., by analyzing referrers and HTTP expressed in this material are those of the authors and do not
redirections), and is able to reconstruct the web browsing path necessarily reflect the views of the National Science Foundation
thatbroughttheusertothefinalattackpage.UnlikeWebWitness, or DARPA.
which is purely based on an analysis of network traces using a
set of heuristics and inference methods, ClickMiner [29] aims
REFERENCES
to reconstruct the path to an attack page by replaying network
traces into an instrumented browser. [1] D. Akhawe, W. He, Z. Li, R. Moazzezi, and D. Song, “Clickjacking
revisited:Aperceptualviewofuisecurity,”in8thUSENIXWorkshopon
BackTracker[18]isasystemforautomaticallyreconstructing OffensiveTechnologies(WOOT14),Aug.2014.
the sequence of steps followed by an attacker to compromise a [2] S.Arshad,A.Kharraz,andW.Robertson,“Includemeout:In-browser
detectionofmaliciousthird-partycontentinclusions,”inProceedingsof
machine.Givenaninitialdetectionpoint,suchasamaliciousfile
the20thInternationalConferenceonFinancialCryptographyandData
identifiedbyasecurityanalyst,BackTrackertracesbackprocesses
Security(FC),22016.
and files that have a causal relation to the detection point,
[3] L.Ballard,“Nomoredeceptivedownloadbuttons,”2016,https://security.
by leveraging OS-level logs. The final result is a dependency googleblog.com/2016/02/no-more-deceptive-download-buttons.html.
graph that explains what system objects affected (or caused) [4] A.Barth,C.Jackson,andJ.C.Mitchell,“Robustdefensesforcross-site
the presence of the malicious file on disk, thus potentially requestforgery,”inProceedingsofthe15thACMConferenceonComputer
revealing the attacker’s entry point into the system. Taser [13] andCommunicationsSecurity,ser.CCS’08,2008.
andRETRO[17]useOS-levellogsandperformforwardtracking [5] L.Bauer,S.Cai,L.Jia,T.Passaro,M.Stroucken,andY.Tian,“Run-time
to identify and recover form intrusions, whereas other recent monitoringandformalanalysisofinformationflowsinChromium,”in
Proceedingsofthe22ndAnnualNetworkandDistributedSystemSecurity
works [22], [23], [26] have focused on improving accuracy in
Symposium,Feb.2015.
backward- and forward-tracking of intrusions, and on reducing
[6] Chrome,“Backgroundpages,”https://developer.chrome.com/extensions/
the space for OS logs.
background pages.
[7] ——,“Extensions,”https://developer.chrome.com/extensions.
Our work is different from the systems discussed above,
[8] D.E.DenningandD.K.Branstad,“Ataxonomyforkeyescrowencryption
in that ChromePic’s main goal is to produce highly efficient
systems,”Commun.ACM,vol.39,no.3,pp.34–40,1996.
fine-grained browser logs. In the future, these logs could be
[9] R. Dhamija, J. D. Tygar, and M. Hearst, “Why phishing works,” in
used to enable and improve the accuracy of automated incident
ProceedingsoftheSIGCHIConferenceonHumanFactorsinComputing
investigation systems. Systems,ser.CHI’06,2006.
14[10] B.Dolan-Gavitt,J.Hodosh,P.Hulin,T.Leek,andR.Whelan,“Repeatable [31] ——, “Towards measuring and mitigating social engineering software
reverse engineering with panda,” in Proceedings of the 5th Program downloadattacks,”inProceedingsofthe25thUSENIXConferenceon
ProtectionandReverseEngineeringWorkshop,ser.PPREW-5,2015. SecuritySymposium,ser.SEC’16,2016.
[11] G.W.Dunlap,S.T.King,S.Cinar,M.A.Basrai,andP.M.Chen,“Revirt: [32] J.Palme,A.Hopmann,andN.Shelness,“Mimeencapsulationofaggregate
Enablingintrusionanalysisthroughvirtual-machineloggingandreplay,” documents,suchashtml(mhtml),”1999,https://tools.ietf.org/html/rfc2557.
SIGOPSOper.Syst.Rev.,vol.36,no.SI,Dec.2002. [33] J.SaltzerandM.Schroeder,“Theprotectionofinformationincomputer
[12] R. Geambasu, J. P. John, S. D. Gribble, T. Kohno, and H. M. Levy, systems,”http://web.mit.edu/Saltzer/www/publications/protection/.
“Keypad:Anauditingfilesystemfortheft-pronedevices,”inProceedings [34] B.SchneierandJ.Kelsey,“Secureauditlogstosupportcomputerforensics,”
oftheSixthConferenceonComputerSystems,ser.EuroSys’11. ACM, ACMTrans.Inf.Syst.Secur.,vol.2,no.2,pp.159–176,May1999.
2011,pp.1–16.
[35] The Chromium Project, “Blick scheduler,” https:
[13] A.Goel,K.Po,K.Farhadi,Z.Li,andE.deLara,“Thetaserintrusion //docs.google.com/document/d/16f RIhZa47uEK
recoverysystem,”inProceedingsoftheTwentiethACMSymposiumon OdtTgzWdRU0RFMTQWMpEWyWXIpXUo/edit#heading=h.
OperatingSystemsPrinciples,ser.SOSP’05,2005. srz53flt1rrp.
[14] C.Grier,L.Ballard,J.Caballero,N.Chachra,C.J.Dietrich,K.Levchenko, [36] ——, “Compositor thread architecture,” https://www.chromium.org/
P.Mavrommatis,D.McCoy,A.Nappa,A.Pitsillidis,N.Provos,M.Z. developers/design-documents/compositor-thread-architecture.
Rafique,M.A.Rajab,C.Rossow,K.Thomas,V.Paxson,S.Savage,and [37] ——, “GPU accelerated compositing in Chrome,”
G.M.Voelker,“Manufacturingcompromise:Theemergenceofexploit- https://www.chromium.org/developers/design-documents/
as-a-service,” in ACM Conference on Computer and Communications gpu-accelerated-compositing-in-chrome.
Security,ser.CCS’12,2012.
[38] ——,“Howchromiumdisplayswebpages,”https://www.chromium.org/
[15] L.-S. Huang, A. Moshchuk, H. J. Wang, S. Schecter, and C. Jackson, developers/design-documents/displaying-a-web-page-in-chrome.
“Clickjacking:Attacksanddefenses,”inPresentedaspartofthe21st
[39] ——, “Inter-process communication,” https://www.chromium.org/
USENIXSecuritySymposium(USENIXSecurity12),2012.
developers/design-documents/inter-process-communication.
[16] S. Institute, “A multi-level defense against social engineering,” [40] ——,“Multi-processarchitecture,”https://www.chromium.org/developers/
2003, https://www.sans.org/reading-room/whitepapers/engineering/ design-documents/multi-process-architecture.
multi-level-defense-social-engineering-920.
[41] ——, “Out-of-process iframes,” http://www.chromium.org/developers/
[17] T.Kim,X.Wang,N.Zeldovich,andM.F.Kaashoek,“Intrusionrecovery design-documents/oop-iframes.
usingselectivere-execution,”inProceedingsofthe9thUSENIXConference
[42] ——, “Proposal for frame capture con-
onOperatingSystemsDesignandImplementation,ser.OSDI’10,2010.
tent API,” https://docs.google.com/document/d/
[18] S.T.KingandP.M.Chen,“Backtrackingintrusions,”inProceedingsof 1gRndVmVn7gWJ-rbIHaaOMNsCjSIBn4CAJbZuwLM2ROE/edit.
theNineteenthACMSymposiumonOperatingSystemsPrinciples,ser. [43] ——,“Therenderingcriticalpath,”https://www.chromium.org/developers/
SOSP’03,2003. the-rendering-critical-path.
[19] S.Kornexl,V.Paxson,H.Dreger,A.Feldmann,andR.Sommer,“Building [44] ——,“Schedulingjstimerexecution,”https://docs.google.com/document/
atimemachineforefficientrecordingandretrievalofhigh-volumenetwork d/163ow-1wjd6L0rAN3V U6t12eqVkq4mXDDjVaA4OuvCA/edit#.
traffic,”inProceedingsofthe5thACMSIGCOMMConferenceonInternet
[45] ——, “Threading,” https://www.chromium.org/developers/
Measurement,ser.IMC’05,2005.
design-documents/threading.
[20] P.Kotzias,L.Bilge,andJ.Caballero,“Measuringpupprevalenceandpup
[46] K. Thomas, J. A. E. Crespo, R. Rasti, J.-M. Picod, C. Phillips, M.-A.
distributionthroughpay-per-installservices,”in25thUSENIXSecurity
Decoste, C. Sharp, F. Tirelo, A. Tofigh, M.-A. Courteau, L. Ballard,
Symposium(USENIXSecurity16),Aug.2016.
R. Shield, N. Jagpal, M. A. Rajab, P. Mavrommatis, N. Provos,
[21] S.Krishnan,K.Z.Snow,andF.Monrose,“Trailofbytes:Efficientsupport E.Bursztein,andD.McCoy,“Investigatingcommercialpay-per-install
forforensicanalysis,”inProceedingsofthe17thACMConferenceon and the distribution of unwanted software,” in 25th USENIX Security
ComputerandCommunicationsSecurity,ser.CCS’10,2010. Symposium(USENIXSecurity16),Aug.2016.
[22] K.H.Lee,X.Zhang,andD.Xu,“Highaccuracyattackprovenancevia [47] N.Tolia,D.G.Andersen,andM.Satyanarayanan,“Quantifyinginteractive
binary-basedexecutionpartition,”inNDSS,2013. user experience on thin clients,” Computer, vol. 39, no. 3, pp. 46–52,
March2006.
[23] ——,“Loggc:garbagecollectingauditlog,”inProceedingsofthe2013
ACMSIGSACconferenceonComputer&#38;communicationssecurity, [48] P.Vogt,F.Nentwich,N.Jovanovic,E.Kirda,C.Kruegel,andG.Vigna,
ser.CCS’13,2013. “Cross site scripting prevention with dynamic data tainting and static
analysis.”inNDSS,vol.2007,2007,p.12.
[24] LinuxManPages,“Chattr,”http://man7.org/linux/man-pages/man1/chattr.
1.html.
[25] S.Ma,K.H.Lee,C.H.Kim,J.Rhee,X.Zhang,andD.Xu,“Accurate,
lowcostandinstrumentation-freesecurityauditloggingforwindows,”in
Proceedingsofthe31stAnnualComputerSecurityApplicationsConference,
ser.ACSAC2015,2015.
[26] S.Ma,X.Zhang,andD.Xu,“Protracer:Towardspracticalprovenance
tracingbyalternatingbetweenloggingandtainting,”inNDSS,2016.
[27] MozillaDevelopersNetwork,“Usingimages,”https://developer.mozilla.
org/en-US/docs/Web/API/Canvas API/Tutorial/Using images.
[28] C.Neasbitt,B.Li,R.Perdisci,L.Lu,K.Singh,andK.Li,“Webcapsule:
Towardsalightweightforensicengineforwebbrowsers,”inProceedings
ofthe22NdACMSIGSACConferenceonComputerandCommunications
Security,ser.CCS’15,2015.
[29] C. Neasbitt, R. Perdisci, K. Li, and T. Nelms, “Clickminer: Towards
forensicreconstructionofuser-browserinteractionsfromnetworktraces,”
inProceedingsofthe2014ACMSIGSACConferenceonComputerand
CommunicationsSecurity,ser.CCS’14,2014.
[30] T.Nelms,R.Perdisci,M.Antonakakis,andM.Ahamad,“Webwitness:
Investigating,categorizing,andmitigatingmalwaredownloadpaths,”in
Proceedingsofthe24thUSENIXConferenceonSecuritySymposium,ser.
SEC’15,2015.
15