HOP:
Hardware makes Obfuscation Practical
Kar$k Nayak
With Christopher W. Fletcher, Ling Ren, Nishanth Chandran, Satya Lokam,
Elaine Shi and Vipul Goyal
1Compression
1 MB 1 KB
Used by everyone, perhaps license it
No one should “learn” the algorithm - VBB Obfusca$on
Another scenario: Release patches without disclosing
vulnerabili$es
2Known Results
Heuris$c approaches to obfusca$on [KKNVT’15, SK’11, ZZP’04]
- Efficient
- No guarantees - “Confuse” the user
Impossible to achieve program obfusca$on in general [BGIRSVY’01]
3Approaches
Cryptography Secure Processors
1. Indis$nguishability Obfusca$on 1. Intel SGX, AEGIS, XOM
[SCGDD’03,
[BGIRSVY’01, GGHRSW’13] LTMLBMH’00]
- Not strong enough in prac$ce - Reveal access paaerns
- Non standard assump$ons - Obfusca$on against s/w only
- Inefficient [AHKM’14] adversaries
2. Using Trusted Hardware Tokens 2. Ascend, GhostRider
[FDD’12,
LHMHTS’15]
[GISVW’10, DMMN’11, CKZ’13]
- Assume public programs
- Boolean circuits
- Inefficient (FHE, NIZKs)
4Key Contribu$ons
FHE, NIZKs Boolean circuits
Efficient obfusca$on of RAM programs
1
using stateless trusted hardware token
Design and implement hardware system
2
called HOP using stateful tokens
5x-238x better than
3 a baseline scheme
Scheme Op$miza$ons
8x-76x slower than
an insecure system
5Using Trusted Hardware Token
Sender (honest) Receiver (malicious)
Store Key
Obfuscate
IIInnnpppuuuttt 23
OOOuuutttpppuuuttt23
Execute
6Stateful Token
Maintain state between invoca$ons
Oblivious load a5, 0(s0)
add a5, a4, a5
RAM
add a5, a5, a5
Authen$cate memory
auth
oramSt
Run for a fixed $me T
7A scheme with stateless tokens is
more challenging
Advantage: Enables context switching
Given a scheme with stateless tokens,
using stateful tokens can be viewed as
an op$miza$on
8Stateless Token
Does not maintain state between invoca$ons
Oblivious load a5, 0(s0)
add a5, a4, a5
RAM
Authen$cated
add a5, a5, a5
PID
Encryp$on auth
oramSt
PID
auth
oramSt
9Stateless Token - Rewinding
load a5, 0(s0)
Oblivious
Time 0: load a5, 0(s0)
add a5, a4, a5
RAM
Time 1: add a5, a4 a5
add a5, a5, a5
PID
auth’
Rewind!
oramSt’
Time 0: load a5, 0(s0)
Time 1: add a5, a4 a5
Oblivious RAMs are generally not secure
against rewinding adversaries
100 1 2 3 4 5 6 7
A Rewinding Aaack!
Access Paaern: 3, 3 Access Paaern: 3, 4
44742 1 TTTT====0110
33 4
4 4
T = 0: leaf , reassigned 2 Time 0: leaf , reassigned …
2 1
T = 1: leaf , reassigned … Time 1: leaf , reassigned …
Rewind! Rewind!
4 4
T = 0: leaf , reassigned 7 Time 0: leaf , reassigned …
7 1
T = 1: leaf , reassigned … Time 1: leaf , reassigned …
11For rewinding aaacks, ORAM uses
PRF (program digest, input digest)
K
12Stateless Token – Rewinding on inputs
Inp 1 = 20
Inp 2 = 10
Inp 3 = 40
Inp 1 = 20
Inp 2 = 10
Oblivious
Inp 3 = 30
PID
auth’
RAM
oramSt’
13For rewinding on inputs, adversary
commits input digest during
ini$aliza$on
14Main Theorem: Informal
Our scheme UC realizes the ideal func$onality in the F -hybrid
token
model assuming
- ORAM sa$sfies obliviousness
- sstore adopts a seman$cally secure encryp$on scheme and a
collision resistant Merkle hash tree scheme and
- Assuming the security of PRFs
Proof in the paper.
15Efficient obfusca$on of RAM programs
1
using stateless trusted hardware token
Next:
1. Interleaving arithmetic
Scheme
2
and memory instructions
Op$miza$ons
2. Using a scratchpad
Design and implement hardware system
3
called HOP
16Op$miza$ons to the Scheme – 1. ANM Scheduling
Types of instruc$ons – Arithme$c and Memory
Naïve schedule:
1 cycle ~3000 cycles
Memory accesses visible to the adversary A M A M A M …
12000 extra cycles
M
1170: load a5,0(a0)
A
1174: addi a4,sp,64
M
1178: addi a0,a0,4 A
M
117c: slli a5,a5,0x2
A
M
1180: add a5,a4,a5 A
1184: load a4,-64(a5) M
1188: addi a4,a4,1
A
M
118c: bne a3,a0,1170
A
Histogram – main loop
17Op$miza$ons to the Scheme – 1. ANM Scheduling
Types of instruc$ons – Arithme$c and Memory
Naïve schedule:
1 cycle ~3000 cycles
Memory accesses visible to the adversary A M A M A M …
12000 extra cycles
M
1170: load a5,0(a0)
A
1174: addi a4,sp,64
What if a memory access is
1178: addi a0,a0,4 A
performed arer “few” arithme$c
117c: slli a5,a5,0x2
A
1180: add a5,a4,a5 A
instruc$ons?
1184: load a4,-64(a5) M
AA
1188: addi a4,a4,1
A
A4M schedule:
118c: bne a3,a0,1170
A
2 extra cycles
Histogram – main loop
18Op$miza$ons to the Scheme - 1. ANM Scheduling
Ideally, N should be program independent
𝑁=​𝑀𝑒𝑚𝑜𝑟𝑦 𝐴𝑐𝑐𝑒𝑠𝑠 𝐿𝑎𝑡𝑒𝑛𝑐𝑦 /𝐴𝑟𝑖𝑡ℎ𝑚𝑒𝑡𝑖𝑐 𝐴𝑐𝑐𝑒𝑠𝑠 𝐿𝑎𝑡𝑒𝑛𝑐𝑦 =​3000/1
A A A A M A A M 6006 cycles of actual work
2996 A 2998 A < 6000 cycles of dummy work
19Amount of dummy work < 50% of the
total work
Our schedule incurs ≤ 2x- overhead
rela$ve to best schedule with no
dummy work
20Op$miza$ons to the Scheme – 2. Using a Scratchpad
Program Why does a scratchpad help?
void bwt-rle(char *a) { Memory accesses served
bwt(a, LEN);
by scratchpad
rle(a, LEN);
}
void main() { Why not use regular hardware
char *inp = readInput();
caches?
for (i=0; i < len(inp); i+=LEN)
spld(inp + i, LEN, 0);
Cache hit/miss reveals
len = bwt-rle(inp + i);
informa$on as they are
}
program independent
21HOP Architecture
512 KB
Variant of Path ORAM
- Freecursive ORAM
- PMMAC
- 64 byte block,
1. single stage 32b - 4 GB memory
integer base
2. spld
16 KB
For efficiency, use stateful tokens
22Slowdown Rela$ve to Insecure Schemes
Slowdown to Insecure
8x-76x
23Conclusion
We are the first to design and prototype a
secure processor with a matching
cryptographically sound formal abstrac$on
in the UC framework
Thank You!
kar$k@cs.umd.edu
24