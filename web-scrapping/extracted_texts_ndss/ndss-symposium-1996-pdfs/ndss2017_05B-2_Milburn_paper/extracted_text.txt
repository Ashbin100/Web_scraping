SafeInit: Comprehensive and Practical Mitigation of
Uninitialized Read Vulnerabilities
Alyssa Milburn Herbert Bos Cristiano Giuffrida
Vrije Universiteit Amsterdam Vrije Universiteit Amsterdam Vrije Universiteit Amsterdam
amilburn@zall.org herbertb@cs.vu.nl giuffrida@cs.vu.nl
Abstract—Usage of uninitialized values remains a common attacks. Today’s compiler warnings and static analysis tools
error in C/C++ code. This results not only in undefined and flagonlyasmallsubsetoftheseuninitializedreads,andworse,
generally undesired behavior, but is also a cause of information the common occurrence of false positives in the warnings
disclosure and other security vulnerabilities. Existing solutions means that programmers often ignore them altogether. Given
for mitigating such errors are not used in practice as they are
the growing popularity of uninitialized reads in real-world
either limited in scope (for example, only protecting the heap),
exploits[21],[53],[8],[50],thecurrentlackofcomprehensive
or incur high runtime overhead.
protectionisconcerning.Inthispaper,weshowthatautomatic
In this paper, we propose SafeInit, a practical protection initialization of all values on the heap and stack at allocation
system which hardens applications against such undefined be- time is possible with minimal performance penalties.
havior by guaranteeing initialization of all values on the heap
and stack, every time they are allocated or come into scope. Worryingly, C/C++ compilers can even introduce new
Doing so provides comprehensive protection against this class of vulnerabilities when taking advantage of the fact that reading
vulnerabilities in generic programs, including both information uninitialized memory is ‘undefined behavior’; the optimiza-
disclosure and re-use/logic vulnerabilities. tionsappliedbymoderncompilerscanremovesanitychecksor
other code in such circumstances [63]. Worse, recent research
Weshowthat,withcarefullydesignedcompileroptimizations,
our implementation achieves sufficiently low overhead (<5% for [44] has also shown that many programmers are unaware of
typical server applications and SPEC CPU2006) to serve as a these dangerous consequences. For C/C++ programs running
standard hardening protection in practical settings. Moreover, in production systems, there are few options for preventing
weshowthatwecaneffortlesslyapplyittohardennon-standard attacks that exploit uninitialized read errors. Solutions such as
code, such as the Linux kernel, with low runtime overhead. valgrind [54] and MemorySanitizer [58], in widespread use
during the development process, are much too expensive for
I. INTRODUCTION useinproductionsystems,evenwhenusingcomplexdata-flow
analysis to reduce this overhead [65].
The use of uninitialized memory in C/C++ programs
introduce vulnerabilities that are popular among attackers to Clearingmemory: Theobviousmitigationforthisproblem
manipulateaprogram’scontrolflowortodiscloseinformation. is to always clear memory. For instance, Chow et al. [11]
In addition to the obvious issue of revealing sensitive data, proposed to clear all memory at deallocation time. However,
the exposure of metadata has become a more prominent prob- they only obtained acceptable overhead for heap allocations
lem in recent years, since information disclosure increasingly – not for the high frequency allocations and deallocations on
becomes an essential prelude to successful exploits (e.g., to the stack. Moreover, the solution fails to address the problem
circumvent ASLR or other hardening methods) [56]. Unfortu- of undefined behavior. The PaX project [49] offers a limited
nately, concerns about the performance overhead have made butverypracticalsolutionintheformofLinuxkernelpatches
compiler writers reluctant to adopt strong mitigations against which protect against common uninitialized value errors, in-
this attack vector. cluding gcc plugins. Recently, and concurrent to our work,
UniSan [38] proposed more comprehensive protection than
Languages such as Java and C# ensure the definite as-
thisagainstanarrowerthreat—informationdisclosurefromthe
signment of variables, requiring them to be initialized on all
Linux kernel—using data-flow analysis to initialize memory
possible paths of execution. Unfortunately, C and C++ do not
and variables which might be disclosed to an attacker. While
enforce this property. As a result, the vast body of existing
both of these solutions provide acceptable overhead, neither
C/C++ code, which includes many runtimes and libraries for
provide a complete solution for uninitialized values, and are
safer languages, is potentially vulnerable to uninitialized read
currently applicable to only the Linux kernel.
In this paper, we describe a comprehensive and practical
Permission to freely reproduce all or part of this paper for noncommercial solution for mitigating these errors in generic programs, by
purposes is granted provided that copies bear this notice and the full citation
adapting the toolchain to ensure that all stack and heap
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author allocations are always initialized. SafeInit is implemented
(for reproduction of an entire paper only), and the author’s employer if the at a compiler level, where low-overhead static analysis and
paper was prepared within the scope of employment. optimizations are available, and can be enabled using a single
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
compiler flag. We show that the overhead can be reduced
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23183 to acceptable levels, by applying a set of carefully designedoptimizations;forexample,thesemorethanhalvetheoverhead III. BACKGROUND
of SafeInit on SPEC CINT2006 from 8% down to <4% (with
Memory is constantly reallocated, and thus reused, in
the remaining overhead largely due to excessively complex
almostallapplications.Onthestack,functionactivationframes
code,whichcanberesolvedusingminimal-effortannotations).
contain data from previous function calls; on the heap, allo-
Summarizing, our contributions are: cations contain data from previously-freed allocations. Issues
with uninitialized data arise when such data is not overwritten
• WeproposeSafeInit,acompiler-basedsolutionwhich before being used, extending the lifetime of the old data
– together with a hardened allocator – automatically beyond the point of the new allocation.
mitigates uninitialized value reads by ensuring initial-
Many variables are clearly initialized before they are used;
ization, both on the stack and on the heap.
as an example, consider an integer counter used only in a
• We present optimizations which reduce the typical for loop, which is explicitly assigned a new value for every
overheadofoursolutiontominimallevels(<5%),and iteration of the loop. We can trivially see that such a variable
arestraightforwardtoimplementinmoderncompilers. is always initialized before it is used.
• We discuss our prototype implementation of SafeInit, On the other hand, the initialization state of a variable
basedonclangandLLVM,andshowthatitcanbeap- which is only used if a complicated conditional is true may
pliedtothemajorityofreal-worldC/C++applications depend itself on other conditionals, resolving of which would
without any additional manual effort. require executing large portions of the program – or at least
extensive optimization and analysis.
• We evaluate our work on CPU-intensive (including
Memory may also only be partially initialized; structures
SPEC CPU2006) and I/O intensive (server) applica-
and union types in C are often deliberately incompletely
tions,aswellastheLinuxkernel,andverifythatreal-
initialized, and for simplicity or performance reasons, arrays
world vulnerabilities are successfully mitigated.
are often allocated with larger sizes than (initially) necessary
In summary, we argue that SafeInit provides a comprehen- to store their contents.
sive and practical solution to a serious real-world problem,
Inpractice,reuseofmemoryisnotonlycommon,butalso
show that it provides significant advantages compared to
desirable for performance reasons [17]. When it is unclear
existing techniques and tools, and demonstrate that it offers
whether a variable will be initialized before it is used, the
acceptable levels of overhead. We believe this system is
only practical and safe approach is to initialize it in all cases.
sufficiently practical to make it useful in production systems,
withoverheadbelowthelevelstypicallydemandedforindustry
A. Sensitive data disclosure
adoption[60],andhopetoseeitbecomeastandardingredient
ofthehardeningtransformationsofferedbymoderncompilers. The most obvious danger of information disclosure due to
uninitialized data is the disclosure of directly sensitive data,
such as encryption keys, passwords, configuration information
II. THREATMODEL
and the contents of confidential files. Chow et al. have dis-
cussed [10] that data lifetimes can last far longer than we
Uninitializedreaderrorsoccurwhenavariable,ormemory,
would expect, and that many unintentional copies of data may
is used without having first been initialized. This can occur
be made.
after a stack variable comes into scope, or after heap memory
has been allocated. We consider an attacker seeking to exploit In fact, even when all copies of such data are appar-
anyofthevulnerabilitiescausedbysuchreadsofuninitialized ently explicitly cleared, problems persist. Many programs call
values,includinginformationdisclosureanduseofunintended memset to clear sensitive data; unfortunately, if the data is
values (such as function pointers). We assume that such no longer valid and thus no longer used after that point, such
potential attackers have a copy of all binaries in use, and are calls can be (and are) optimized away by compilers. Common
thus aware of details such as the exact stack layout chosen by ‘workarounds’ which attempt to hide these calls from com-
the compiler. piler analysis are often optimized by ever-improving compiler
analysis passes, and alternative functions (such as memset_s
Weassumetheprogramhasbeenalreadyhardenedagainst
andexplicit_bzero)whichcompilersareprohibitedfrom
other classes of vulnerabilities using existing (e.g., memory
optimizing away are not yet commonly available.
safety) defenses. Although mitigating uninitialized value vul-
nerabilities can probabilistically mitigate some vulnerabilities If the use of uninitialized data in a program is not directly
caused by other temporal (such as pointer use-after-free) and influenced by untrusted input, it is tempting to conclude
spatial errors (such as out-of-bounds reads), there are existing that the security consequences of these classes of issues is
low-impact solutions – such as baggy bounds checking [2] – otherwise minimal. However, experience has shown that a
which provide superior defenses against such attacks, and we wide range of potential attack vectors must be considered,
do not consider them in our threat model. and this varied attack surface means that all uninitialized data
vulnerabilities should be taken seriously.
We also only consider C/C++ code. Extending this work
to similar languages should be possible (as shown, for exam- One illustrative example was a vulnerability [29] in the
ple, by existing compiler functionality for local variables in PostScript font rendering on Windows, caused by failure to
Fortran), but in particular, custom assembly-language routines initialize a temporary buffer which could be read by font
fall outside the scope of our work. bytecode. By providing a font which rendered glyphs based
2on the contents of this buffer, JavaScript in a web browser This is far from a new problem; Microsoft described
could disclose memory by reading back rendered pixels. an arbitrary write vulnerability due to an uninitialized stack
variable in Microsoft Excel in 2008 [45], and in 2010, Kees
Similarly,informationdisclosurefromkernelstouserspace
Cook disclosed [12] an arbitrary Linux kernel memory write
programs, or from hypervisors to guest virtual machines, is a
vulnerability caused by an uninitialized structure on the stack.
commonandseriousissue[8].Containersandvirtualmachines
running code from untrusted parties, or as a vital layer of A common mistake is to fail to initialize variables or
sandboxingfromuntrustedsoftwaresuchasJavaScriptinweb buffers on the execution path taken when an error is encoun-
browsers,arenowastandardcomponentofmanysystems.As tered. For example, Samba had a vulnerability[61] caused by
such, even code such as device driver interfaces and emulated failure to check the error value returned by a function before
devices must be free of security issues. using a pointer value which was only initialized in the error-
freepath.Similarly,abuginMicrosoft’sXMLparser[1]made
B. Bypassing security defenses avirtualfunctioncallusingapointerstoredinalocalvariable
whichwasnotinitializedonallexecutionpaths.By‘spraying’
Even where software does not make use of any seemingly thestackwithpointersusingJavaScript,attackerscouldcontrol
‘sensitive’ data, or such data is sufficiently isolated to avoid thecontentsofthememorywherethevariablewasstored,and
the possibility of it being disclosed due to uninitialized data exploit this vulnerability from within a web browser.
issues, many modern software defenses depend on the secrecy
of sensitive metadata, and so information disclosure is still It is clear that all of these vulnerabilities must be taken
seriously,andthatpreventinginformationdisclosureaddresses
a critical flaw. Stack ‘canaries’ provide an obvious example;
only a subset of uninitialized value vulnerabilities.
their protection relies on the canary value remaining secret.
Defenses such as address space layout randomization
D. Detection tools
(ASLR) [57] depend on the secrecy of pointers in general,
and since this is typically done by randomizing only one base Rather than attempting to mitigate uninitialized value er-
address, an attacker only needs to disclose a single pointer rors, there are a variety of tools which attempt to detect
to defeat the protection entirely. Such pointers may be code, them during the development process, allowing them to be
stack or heap pointers, and these are typically stored on both manuallycorrectedbytheprogrammer.Compilerwarningsand
the stack and the heap, so uninitialized value errors provide a static analysis tools are limited by their nature [33], and often
rich source of the pointer disclosures required to thwart such themselves contain bugs [59]. Reporting all values which may
information hiding. be uninitialized is counter-productive, since when presented
with more than a handful of false positives, programmers will
Heapallocatorsmaydiscloseheapmetadataiftheystoreit
starttosimplyignorethewarnings.Thismeansthatanyuseful
inline, while other allocators are careful to maintain this sep-
tool is forced to err on the side of caution in reporting; the
arately. Some allocators re-use memory almost immediately,
authors of one commercial static analysis tool, Coverity, state
which is important in modern high-performance allocators
that [6] “when forced to choose between more bugs or fewer
which maintain per-thread pools. Notably, often disclosing
false positives we typically choose the latter”.
just a single byte of such metadata is enough to significantly
reduce security guarantees; disclosing 8 bits of a pointer can Morefundamentally,compilerwarningsanddetectiontools
significantly reduce ASLR entropy [55]. onlyreportproblems,ratherthanfixingthem.Thiscanleadto
incorrectanddangerousfixes,asillustratedbythe2008Debian
Another example is LLVM’s SafeStack defense, based on
OpenSSL flaw [66]; a patch ‘fixing’ a valgrind warning about
work by Kuznetsov et al. [32], which attempts to provide
uninitialized data also removed the code which added entropy
protectionagainstarbitrarymemorywritevulnerabilitiestothe
during key generation, leading to the widespread generation
stack, by hiding the pointer to the ‘safe’ (machine) stack, and
and use of predictable keys.
moving unsafe variables to a separate stack. However, at the
time of writing, it can be trivially defeated by disclosing the
E. Stack variables
contents of an uninitialized stack buffer; these contents are
within the bounds of a stack variable, and so remain on the
A function stack frame contains copies of local variables
‘safe’ stack, but almost always contain safe stack pointers.
which are either too large to be stored in registers, or which
havetheiraddressestaken(forexample,tobepassedtoanother
C. Software exploitation function). The stack also generally contains spilled copies
of other local variables and compiler-generated temporary
Other vulnerabilities caused by uninitialized data allow
variables, as well as function arguments, frame pointers and
attackers to directly hijack control flow. For example, virtual
return addresses. Given the constant re-use of stack memory,
function calls may be made using uninitialized local variables
these frames provide a rich source of sensitive data.
whicharemeanttocontain(pointersto)C++objects.Potential
attackers can often influence the contents of the stack or heap Moderncompilersusesophisticatedalgorithmsforregister
by causing specific computation or a specific set of calls to be and stack frame allocation [42], and both temporaries and
made[40];theirabilitytocontrolthecontentsofaspecificpart variables with non-overlapping lifetimes can be assigned the
ofmemorydependsonfactorswhichseemdifficulttopredict, same portion of a stack frame (or registers). This reduces
such as the results of the compiler’s stack slot allocation memory usage and improves cache locality, but means that
algorithm, but which can often easily be determined by an evenclearingregistersandstackframesbefore/afterafunction
attacker with access to the compiled binary. call is insufficient to avoid all potential uninitialized variables.
3main() { define @main() {
int x; %x = alloca i32, align 4 define @main() {
printf("%d", x); %0 = load i32, i32* %x call @printf(..., i32 undef)
} call @printf(..., i32 %0) }
}
(a)Ccode (b)LLVMbitcode,beforemem2reg (c)LLVMbitcode,aftermem2reg
Fig.1. LLVMtransformsuninitializedreadsintoundefvaluesearlyintheoptimizationprocess;laterpassescannotrecovertheinformationremovedin(c)
for (i = 0; i < n; ++i) { cc -fsafeinit file.c
int x;
if (i == 0) {
x = getSecretValue();
Modified compiler
} C/C++ Source
frontend
doSomething(x);
}
Compiler IR Initialization pass
Fig. 2. Memory re-use for local variables in a loop; doSomething will be
passedthesecretvalueinallloopiterations,notjustthefirst
Even when stack coloring is disabled, and every local Optimizer
variable is allocated a separate portion of an initialized stack,
uninitialized variables can still be a problem. Memory re-use
in a function stack frame also occurs inside loops, such as in
Figure2;here,avariableisinitializedduringthefirstiteration Improved dead Existing compiler
of a loop, but not in later iterations. store elimination optimizations
F. Undefined behavior
Hardened
Undefined behavior [63] occurs when a C/C++ program Binary
allocator
fails to follow the rules imposed by the language. Most
importantly in the context of our discussion, this is the
case when code reads uninitialized stack variables, or even Fig.3. High-leveloverviewofSafeInit
uninitialized heap allocations. The C/C++ standards state that
permissible consequences of undefined behavior includes the
prerequisite for almost all other compiler optimization passes
compiler’s code generation “ignoring the situation completely
or analyses. This illustrates why hardening transformations
with unpredictable results”, but many programmers are un-
must be run before any other optimizations, and most impor-
aware [44] of the fact that these consequences have more
tantly, why they must be performed in the compiler itself.
serious consequences for their compiled binaries than simply
producing code which will read potentially uninitialized data. This also limits the analysis available to such transforma-
tions; any analysis must be performed on the initial, unop-
This is not a merely theoretical problem, but a serious
timized code from the frontend. This not only reduces the
practical issue; to enable the maximum number of opti-
accuracy of any analysis, but also has a serious impact on
mizations, especially in code which may be expanded from
performance; these problems are particularly troublesome for
templates and macros and eventually largely be discarded as
interprocedural analysis, and in any case, other functions may
unreachable, modern compiler transforms (such as those used
beunavailableuntillink-timeoptimization(LTO)isperformed.
byLLVM[34])takeadvantageofthisundefinedbehaviorona
Attempting to delay all optimization until LTO time has a
large scale. Unfortunately, such transformations may interpret
severeimpactoncompilationtime,makingitfarlesspractical.
undefined values (and thus, also uninitialized values) as any
valuewhichmakesoptimizationsmoreconvenient,evenifthis
IV. OVERVIEW
makes program logic inconsistent. These situations often only
become apparent after other compiler transformations have SafeInit mitigates uninitialized value problems by forcing
already been applied, and cannot be detected by dynamic the initialization of both heap allocations (after their alloca-
analysis tools, since they rely on the machine code which has tions)andallstackvariables(whenevertheycomeintoscope).
been generated after this process. This is done by modifying the compiler to insert initialization
calls directly at all such points.
Even a very basic level of compiler optimizations will
cause problems with such code. For example, Figure 1 shows In order to provide both practical and comprehensive
clang/LLVM generating undef values due to an uninitialized security,thisinstrumentationmustbedonewithinthecompiler
local variable. This is caused by the mem2reg pass, which itself. SafeInit can be enabled by simply passing an additional
converts local variables to SSA form; this transformation is a hardening flag during the compilation process. As can be seen
4in Figure 3, this enables an additional compiler pass which char err_msg[MAX_MSG];
adds the necessary initialization. ...
if (error) {
A naive initialization approach would lead to excessive setErrMessage(err_msg);
runtime overhead, and an important element of our system printf(err_msg);
is a customized hardened allocator. This is able to avoid return error;
initialization in many cases by taking advantage of extra }
information, combined with our compiler instrumentation.
Finally, the SafeInit optimizer provides non-invasive trans-
Fig. 4. Typical code using error message buffer; the buffer need not be
formations and optimizations which we run alongside existing initializedunlessthebranchhereistaken.
compiler optimizations (themselves modified where neces-
sary), as well as the final component, an extension of existing
allocation time, large allocations are at least several pages in
‘dead store elimination‘ optimizations. These build on top of
size, and often allocated by using mmap directly.
ourinitializationpassandallocator,performingmoreextensive
removal of unnecessary initialization code, demonstrating that Modern operating systems also provide support for
the runtime overhead of our solution can be minimized. clearing regions of such memory directly (such as
MADV DONTNEED on Linux) by releasing the underlying
Perhaps most importantly, SafeInit is practical to imple-
pages;whilethiscomeswithpotentialperformancedownsides
ment in modern compilers. Our system requires minimal
[31], it is already used by modern allocators to minimize
changes and is non-invasive; no new analyses are required,
memory usage, and is ideal for our needs. By ensuring that
and the extended optimizations we propose are not specific to
large allocations are always released, we can ensure they
SafeInit. Our design is also compatible with recent develop-
will be cleared even if they are reused for another allocation,
ments such as ThinLTO [28], where later optimization passes
without incurring any performance penalty for clearing areas
may not have access to the IR/bitcode of called functions.
of memory which will not be used.
Our allocator also exports non-initializing variants of al-
V. MITIGATINGUNINITIALIZEDVALUES
location functions; the requested memory is not zeroed when
A. Initialization pass these are called, but the gap between the requested allocation
size and the true allocated size is always cleared. An applica-
SafeInit initializes all local variables before their first use,
tion may later make a realloc call which can lead to the
treating the point at which variables come into scope (for
re-useofthisspace,andkeepingtrackofindividualallocation
example, in a loop) as a newly-allocated variable. We propose
sizes consumes more memory and leads to excessive runtime
inserting initialization code at all such points where a stack
overhead (we observed overheads of >5%).
variable comes into scope; the necessary scope information is
provided by the compiler frontend.
C. Optimizer
Specifically, SafeInit’s stack hardening pass modifies the
Our optimizer design provides several efficient and practi-
compiler’s intermediate representation (IR) of the code being
cal optimizations which improve the performance of SafeInit
compiled and inserts a store instruction (ideally, a memset
whilebeingefficientandnon-invasive.Theprimarygoalofthe
builtin/intrinsic) after every variable comes into scope; other
optimizeristomakesimplechangeswhichwillallowthemany
optimizations can later remove or simplify these. This clears
other standard optimizations available in modern compilers to
all of the memory allocated for the variable, including any
remove any unnecessary initializations. We hope that SafeInit
padding within a structure, or between array elements.
will become a standard hardening technique, and so it needs
to be as practical as possible; in particular, we need to avoid
B. Hardened allocator adding complex or invasive analysis.
SafeInit’s hardened allocator ensures that all newly- 1)Sinking stores: Ideally, stores to local variables should
allocated memory is cleared to zero before being returned to beascloseaspossibletotheiruses.Thisisimportantforcache
the application. We do this in the allocator for safety – we locality,andforminimizingthememoryusageofstackframes;
overrideallheapallocationfunctionstoensurethesehardened minimizing the lifetime of a variable allows stack coloring
allocator functions are always used – as well as to improve algorithms to allocate stack frame space more efficiently.
performance by taking advantage of the extra information
Our optimizer attempts to move our initialization stores to
available to the allocator.
the dominating point of the uses of a variable. Importantly,
Importantly, the compiler is aware that our hardened allo- this also avoids unnecessary initialization; variables which are
cator is in use; any code using allocated memory is no longer unused in certain paths need only be initialized in the paths
making use of undefined behavior, and cannot be modified or where they are used. A common example is where variables
removed by the compiler. areonlyusedinerrorpaths,suchaswiththecodeinFigure4.
This code path is not executed during normal execution, and
All memory pages allocated by the operating system ker-
we do not need to initialize the buffer until we reach a path
nel are already cleared to zero, and so allocators can take
in which it will be used.
advantage of this and avoid clearing such pages. Although
the overhead of keeping track of this for small allocations is If this dominating point of the uses of a variable is
excessive, and so small allocations must always be cleared at reachable from itself, and it does not go out of scope when
5int buf[50]; row *r = malloc(sizeof(row));
for (int i = 0; i < 50; ++i) r->row_num = 0;
buf[i] = 1; r->length = 0;
r->user_word = NULL;
Fig. 5. Example of initialization using a loop; ‘buf’ is fully initialized but
thiscodecannotbeconvertedintoamemset. Fig. 7. Example of removed zero stores (from ‘espresso’); the memory
returnedfrommallocisalreadyclearedwithzerovalues.
sprintf (t3, "%s%s;", t1, t2);
strcpy (t1, t3); int buf[n];
memset(buf, 0, n);
memset(buf, 1, n);
Fig.6. t3isa‘safe’stringbuffer(fromgccinSPECCPU2006)whichdoes
notneedinitialization
Fig. 8. Example of an unnecessary non-constant-length store; the first
memsetcanalwaysberemoved.
following this execution path, then it is not an appropriate
place for initialization; this typically occurs if the first stores
to a variable are inside a loop. To resolve this, we instead use another store without ever being read. We propose DSE-style
aninitializationpointwhichalsodominatesallthepredecessor optimizations which are particularly appropriate for removing
basic blocks of such dominating points. initializations;existingoptimizationsareoftenill-suitedtothis
task,sincethesesituationsoccurlessfrequentlyinothercode,
2)Detectinginitialization: Weproposedetectionoftypical
and so are less of a priority for compiler development.
codewhichinitializearrays(orportionsofthem),whichallows
other compiler optimizations to remove or shorten previous Only relatively simple DSE optimizations are available in
stores which are revealed to be overwritten. current compilers, generally limited to only statically-sized
stores within a single basic block. However, this is an active
Typical compiler optimizations perform this only for indi- area of compiler development, and as we will later discuss,
vidual store instructions, or intrinsics such as memset. While support for these forms of complex DSE is slowly being
modern compiler transforms attempt to convert some loops to introduced in mainstream compilers. The optimizations we
memset calls [18], this is only possible if a single-byte (or present here serve to demonstrate demonstrate the importance
in some cases, two-byte) pattern is used. This is insufficient of this work and the potential performance improvements
formanycommoncases,suchasinitializinganarrayof(four- which are possible from more intensive optimization.
byte) integer values to the value ‘1’, as shown in Figure 5.
1)Heapclearing: Sinceallheapallocationsareguaranteed
Our design detects such code, treating these loops as if they
to be initialized to zero, our compiler can remove any zero
were single stores which cover the entire range they initialize.
storestofreshly-allocatedheapmemory(treatingallallocation
3)String buffers: Buffers which are used to store C-style functions as equivalent to calloc); an example is shown in
null-terminated strings are often only used in a ‘safe’ manner, Figure 7. Similarly, any loads from freshly-allocated memory
where the data in memory beyond the null-terminator is never are known to be zero (rather than being undefined behavior),
used. We propose a low-cost check which catches simple and we can replace them with a constant value.
cases, such as that in Figure 6; buffers which are only passed
If memory is fully initialized to a non-zero value, then our
to known C library string functions (such as strcpy and
optimizer can also rewrite the allocator call to an alternative
strlen)are‘safe’.Wheninitializingwithzero,onlythefirst
allocation function which skips any potential (unnecessary)
byte of such buffers must be initialized.
initialization; however, we want to be sure that only these
Compilers already know about and detect such ‘built-in’ instances are left uninitialized by our custom allocator.
string functions, so we can take advantage of their existing
2)Non-constant-length store removal: Dead Store Elimi-
infrastructure to detect these functions; there is no need to
nation is generally only performed when the stores are of a
addannotations.Wheretheoptimizercanprovethatthestring
known constant length; we propose transforming stores with
is always initialized, the initialization can later be removed
non-constant lengths, which is important to remove unneces-
entirely; however, this often only becomes clear after further
sary initializations of both dynamic stack allocations and heap
optimizations have been applied.
allocations. The simplest such situations are when an entire
existingstoreisoverwritten,suchasthecodeinFigure8.Our
D. Dead Store Elimination DSE also removes stores of a non-constant size, such as some
of our initialization stores, when they are entirely overwritten
Tominimizetheperformancecostofinitialization,SafeInit
by later stores.
alsoincludesavarietyofimprovedoptimizationpasses.These
are more complex than our other optimizations, and may 3)Cross-block DSE: Our optimizer also performs Dead
not always be necessary to obtain low overhead. However, Store Elimination across multiple basic blocks. This is an
they resolve real situations which we found to introduce active area of improvement for existing compilers, but is far
unnecessary overhead when using our hardening passes. more relevant when universal initialization is introduced, and
is necessary to enable many of the optimizations below.
In particular, we need so-called ‘dead store elimination’
(DSE) optimizations, a standard class of compiler optimiza- We need to remove both stores which are partially or
tions[4]whichremovestoreswhicharealwaysoverwrittenby completelyoverwrittenbyotherstores(standardDSE)aswell
6int result_buf[BUF_SIZE]; discussed, the dead store optimizations which are vital for
return shared_func(data, result_buf); acceptable performance are an active area of development, so
we based our work on a recent pre-release version of the code
(LLVM revision 269558, from mid-May 2016).
Fig.9. Exampleofwrite-only/‘scratch’buffer;initializationisunnecessaryif
shared_funconlywritestothepointerprovidedasthesecondargument.
A. Initialization pass
We implemented stack clearing as an LLVM pass, which
as stores which are never used (for example, because the
we run before any other optimization pass is allowed to run
value goes out of scope before being used), and while we are
– mostly importantly, before mem2reg, which will introduce
primarily concerned about memset, we also remove normal
undef values when an uninitialized stack variable is read.
stores. New opportunities for rewriting heap functions may
also be revealed during this process, and our optimizer also LocalvariablesinLLVMaredefinedbyusingthealloca
applies these optimizations here. instruction;ourpassperformsinitializationbyaddingacallto
the LLVM memset intrinsic after each of these instructions.
4)Non-constant-length store shortening: To enable other
This guarantees that the entire allocation is cleared, and are
optimizations, particularly involving string or other library
transformed into store instructions where appropriate.
functions, we also attempt to shorten stores by non-constant
lengths.Forexample,ifthefirstxbytesofanarrayareinitial-
B. Hardened allocator
ized,thenwemaybeabletoshortenanearlierinitializationby
xbytes,assumingthatthevalueofxdoesnotchangebetween We implemented our hardened allocator by modifying
the stores. However, the compiler must either be able to prove tcmalloc, a modern high-performance heap allocator [22].
that x is never larger than the size of the array, or add an
The underlying pages for the allocator are obtained using
additional (and potentially expensive) bounds check. mmap or sbrk,andare guaranteedtoinitiallybebezero. We
In practice, writing beyond the bounds of an array is force the use of MADV DONTNEED (or equivalent) when
undefined behavior, and existing compiler optimizations take freeing any such allocations, and so large heap allocations are
advantage of this to make assumptions. If execution is always alwayszero,andneednotbeinitialized.Theperformanceover-
guaranteed to reach the second store after it has reached the head of tracking the initialization status of smaller allocations
first, the compiler can assume that the second store does not is excessive, so we simply clear all other heap allocations to
write beyond the size of the array, and thus that the first store zero before the allocator returns a pointer.
may always be shortened. We also modified LLVM to treat reads from newly-
allocated memory as returning zero, rather than undef, when
The conservative approach proposed by our design fails to
SafeInit is enabled. As discussed, this is vital for avoiding the
remove some stores which, in practice, are always safe. As
unpredictable consequences of undefined values.
we discuss in implementation, this turned out to be a serious
limitation.Theperformanceoverheadofthisoptimizationalso
C. Optimizer
means that it is only worthwhile on relatively large stores; we
only apply it for stack allocations beyond a fixed size. We implemented our proposed sinking stores optimization
for stack initialization by moving our inserted memset calls
5)Write-onlybuffers: Sometimes,memoryisallocated,but
to the dominating point of all uses of the alloca (ignoring
neverwrittento.Removingunusedlocalvariablesisknownto
those which do not actually use the variable, such as casts or
beanimportantoptimization[27],buttypicallyinterprocedural
debugintrinsics).Whencompilingwithoptimizationsenabled,
analysis has been unnecessary. A typical example is shown in
clang will emit ‘lifetime’ markers which indicate the points
Figure 9, where a function requires a memory buffer as an
at which local variables come into scope; we modified clang
argument for storing results, but the caller never reads from
to emit appropriate lifetime markers in all circumstances, and
this buffer, simply discarding the content. Our initialization
insert the initialization after these points.
further complicates this, by adding a new unnecessary write
to initialize such buffers. The alloca instructions corresponding to local variables
are placed in the first basic block, which is necessary for the
If the called function never reads from the buffer, then the
majority of LLVM optimizations to function correctly, and for
entire buffer is unnecessary. One approach is to clone such
stack coloring to be performed. However, dynamic allocation
functions and remove the arguments in these cases, enabling
of stack space within a function may not be in the first block
removal of the stores. However, this can dramatically increase
(such as when an alloca call is made from C/C++ code); in
code size; inlining or cloning can be very expensive, and
these circumstances, we have to also ensure that initialization
our design aims to remain practical by avoiding the need for
is not performed before the allocation takes place.
any additional interprocedural analysis. Instead, we annotate
allocations and function (pointer) arguments which are only We implemented initialization detection optimization by
written to. If we can then show that portions of memory are adding a new intrinsic function, ‘initialized’, which has the
onlystoredto,andnotread,thenallthestorescanberemoved. same store-killing side effects as memset, but is ignored by
code generation. By extending components such as LLVM’s
loop idiom detection to generate this new intrinsic where
VI. IMPLEMENTATION
replacing code with a memset is not possible, we allow
We implemented a prototype of SafeInit by extending the other existing optimization passes to take advantage of this
clang compiler, and the LLVM compiler framework [35]. As information without the need to modify them individually.
7D. Dead Store Elimination int deny_access;
if (deny_access) {
We implemented the other optimizations described above printf("Access denied.");
by extending existing LLVM code, keeping our changes mini- return 0;
mal where possible. Our implementation of write-only buffers }
madeuseofthepatchinD18714(sincemerged),whichadded printf("Access granted.");
the basic framework for a writeonly attribute.
We also based our implementation of cross-block Dead
Fig. 10. (Simplified) example of an uninitialized read which is optimized
Store Elimination on the (rejected) patch in D13363. Due to awaybyexistingcompilertransforms;inthisexample,thecodeinthebranch
performance regressions, we disable this cross-block DSE for istypicallyremovedentirely.
smallstores(≤8bytes);wealsoextendedthiscodetosupport
removing memset, and shortening such stores. $ var-cc -O2 example.c
$ multivar ./example-v0 ./example-v1
Our prototype currently only applies non-constant short-
! SYSCALL MISMATCH for variants v0 and v1
ening to memset calls which overwrite an entire object, and
˜ 0: write(1, "Access granted.", 15)
requiresthattheybeatleast64bytesfortheefficiencyreasons
˜ 1: write(1, "Access denied.", 14)
discussed above. LLVM’s limited support for range analysis
== Backtrace ==
severely limits the current optimization opportunities for such
ip = 7271a9620 __write+16
shortening, since in the majority of cases we are unable to
...
prove accesses are safe without performing our own analysis.
ip = 727120de9 _IO_printf+153
Since our goal is to show techniques which are practical ip = 4007ce check_access+366
to implement without needing additional analysis, we limited
ourselves to the typical analyses which are used by existing
Fig. 11. Example of an uninitialized read being detected, using optimized
in-tree code in such circumstances. These include checking
buildsofthecodeinFigure10;sincethereisnouninitializedmemoryusage
known bits, and making use of the ‘scalar evolution’ code for
intheoptimizedbinaries,toolssuchasvalgrindfailtodetectsuchcases.
loop variables. In turn, these limitations remove opportunities
forlibrarycalloptimizations;wefoundthatevenouroptimiza-
tions for string functions are of limited usefulness (outside of Filling memory with a constant value is much faster than
artificial micro-benchmarks) due to the effect of these safety using random values, so we fill all uninitialized bytes of
checks. memory in each variant with the same constant. Some opti-
mizations are no longer possible when using non-zero values;
E. Frame clearing inparticular,weneedtoclearallheapmemory,sincethezero
pages returned from the kernel are no longer appropriate.
Toputourevaluationintocontext,wealsoimplementedan
alternative compiler hardening pass which clears the portion However, multi-variant systems do not necessarily require
of each frame reserved for local variables in every function synchronization (they need not run variants in ‘lockstep’);
prologue. The performance of this frame clearing provides an systemcallsneedonlybeexecutedforoneofthevariants,the
estimate of the lower bound for these naive approaches; we so-called ‘leader’. Since our hardening has already mitigated
apply our normal stack hardening pass to protect non-static potential security issues, there is no need to run the variants
(dynamically-allocated) local variables. in lockstep. We initialize the values of the leader process with
zero, allowing it to run ahead of the other variants, which
Thisimprovesperformancecomparedtosimplyclearingall
reducestheoverallruntimeimpactofthisslowerinitialization.
frames,sincewedonotclearspacereservedforotherpurposes
suchasspilledregisters(althoughouroptimizedclearingcode
sometimes clears part of this space, for alignment reasons).
VIII. EVALUATION
This approach also fails to provide guarantees for overlapping
orre-usedvariableswithinthefunction;anychangestoresolve Our benchmarks were run on a (4-core) Intel i7-3770
these (such as disabling stack coloring to avoid overlapping with 8GB of RAM, running (64-bit) Ubuntu 14.04.1. CPU
variables) resulted in significantly worse performance. frequency scaling was disabled, and hyperthreading enabled.
TransparentHugePageswereturnedoff,duetotheirextremely
VII. DETECTION unpredictable effect on runtime and memory usage – this is a
commonly-recommendedvendorconfiguration,andalthoughit
Our hardened toolchain can also be combined with a
has a negative effect on some benchmarks, it does not appear
modernhigh-performancemulti-variantexecutionsystemsuch
to meaningfully change our overhead figures.
as[30]toprovideadetectiontool,inspiredbyDieHard[5].We
compile multiple versions of the same application, initializing Our baseline configuration is an unmodified version of
memory to different values in each variant. This allows us to clang/LLVM, using an unmodified version of tcmalloc. As
perform high-performance detection of the majority of uses of well as comparing this to SafeInit, we also present results for
uninitialized values, including those which would typically be the naive approach, which simply applies our initialization
removedbycompileroptimizationsoronlystoredinregisters, pass without any of our proposed optimizations, using a
without the false positives resulting from ‘harmless’ memory hardened allocator which simply zeroes all allocations. We
reads which do not affect the output. Example usage can be do make use of a modified compiler which performs local
seen in Figure 11. variableinitializationandensuresthatsafetyismaintained;for
820% 76% 36% 12%
10 naiveSafeInit 3
2 2.2%
SafeInit
8 8.0% 1
0
6 −1
−2
24
3.5%
milc namd dealII soplex povray lbm sphinx3
0
Fig.14. SPECCFP2006,runtimeoverhead(%)forSafeInit
−2
perlbench bzip2 gcc mcf gobmk hm mer sj le in bg quantum h264ref omnetpp ast xa ar lancbmk 01
−1
Fig. 12. SPEC CINT2006, runtime overhead (%) when hardening with −2
SafeInit
20% 160%36%
perlbench bzip2 gcc mcf gobmk hm mer sj le in bg quantum h264ref omnetpp ast xa ar lancbmk
10
frameclearing Fig. 15. SPEC CINT2006, runtime overhead (%) of SafeInit’s optimizer
8 SafeInit withouthardeningapplied
6
baseline compiler. Results for CFP2006 are similar, as shown
4 in Figure 14, with an average overhead of 2.2%.
2 Table I provides details of the number of allocas (repre-
sentingthenumberoflocalvariables,plusoccasionalcopiesof
0 arguments or dynamic allocations) for each benchmark. Many
initializationsaretransformedorremovedduringoptimization,
−2
but the table contains the number of initializations which are
perlbench bzip2 gcc mcf gobmk hm mer sj le in bg quantum h264ref omnetpp ast xa ar lancbmk s b Nt ii otl c tl o er de e tp h,r ae b ts oe t tn h ht ee w sd eitha ms a aa n ydm swe tim i lt lhs oe but et oi cn u or nt vh c ee u rs tfi t eo dn mal i is np e todos ot s- p to otp i rmt ei sm izi a dz t ua io rt ii n no s gn .
code generation, and that although the optimizer often fails to
Fig.13. SPECCINT2006,runtimeoverhead(%)offrameinitialization remove initializations entirely, it can still obtain performance
benefits due to transforming, moving or shortening them. The
table also provides the (stripped) binary size; in many cases,
example, zero is propagated from heap allocation sites, rather
theimpactoftheinitializationmakesnodifferencetothefinal
than undef.
binary size whatsoever, and in the worst case it is minimal.
When our optimizer is enabled without hardening, only a
A. SPEC CPU2006
minimalperformanceimprovementofaround0.3%isseen,as
We built all C/C++ benchmarks in SPEC CPU2006 us- showninFigure15.Thehighestoverheadisforh264ref;the
ing LTO and -O3, except the specrand test benchmark. We impact of this overhead can also be seen in Figure 12 above.
present overhead figures for the median of 3 runs, using the We do not believe the regressions seen here are fundamental,
reference dataset. The runtime overhead of applying SafeInit butinanycase,ourotheroverheadfiguresincludetheeffectof
to CINT2006 is shown in Figure 12. anysmallregressions.Ifnecessaryinpractice,anyproblematic
individual optimizations could be adjusted or simply disabled
SafeInit incurs a low performance cost for many bench-
when compiling without hardening.
marks, even without our optimizer; these are generally CPU-
boundand/ormaketheirallocationsonlyatstartup.Forexam- The mean overhead when using our optimizer as the
ple, mcf already uses calloc for allocating heap memory, baseline is 3.8%; the primary contributors to this differ-
and does not make significant use of the stack. However, ence are small performance regressions of perlbench and
otherbenchmarksexperiencesignificantruntimeoverhead;the xalancbmk, and a reduced performance improvement for
(geometric)meanoftheruntimeoverheadis8%,whenapplied omnetpp. The latter has a >1.5% performance improvement
without our optimizer. against both baselines in any case, thanks to the combination
of our optimizations and improved cache behavior.
Applying our optimizer reduces the overhead for the re-
maining benchmarks significantly, as expected, resulting in Figure 13 presents the performance overhead of our frame
average overhead for CINT2006 of 3.5% compared to our initialization pass, combined with our hardened allocator.
9TABLEI. SPECCINT2006DETAILS.#INITSISTHENUMBEROFLARGEINITIALIZATIONSLEFTAFTEREXISTINGCOMPILEROPTIMIZATIONSANDOUR
OPTIMIZERHAVERUN,RESPECTIVELY.SIZEISTHE(STRIPPED)BINARYSIZE.
Benchmark #allocas #inits(naive) #inits(opt) size(baseline) size(naive) size(optimizer)
astar 790 7 4 43736 43736(0%) 43736(0%)
bzip2 679 23 20 80488 84584(5.1%) 84584(5.1%)
gcc 31551 650 596 4108712 4133288(0.6%) 4120992(0.3%)
gobmk 17039 325 300 3554640 3566928(0.3%) 3566928(0.3%)
h264ref 4229 122 122 630664 638856(1.3%) 638856(1.3%)
hmmer 3333 19 18 189592 189592(0%) 189592(0%)
libquantum 567 3 2 31336 31336(0%) 31336(0%)
mcf 184 1 1 19040 19040(0%) 19040(0%)
omnetpp 7638 110 110 806712 810808(0.5%) 814904(1%)
perlbench 12327 175 167 1272584 1284872(1%) 1280792(1%)
sjeng 770 61 48 133976 133976(0%) 133976(0%)
xalancbmk 92396 1701 1302 3871528 3908392(1%) 3892008(0.5%)
6 6
5 naiveSafeInit 5 naiveSafeInit
4 SafeInit 4 SafeInit
3 3
2 2
1 1
0 0
K K B K K B K K B K K B
sendfile-4 sendfile-64 sendfile-1M writev-4 writev-64 writev-1M 4 64 1M sendfile-4 sendfile-64 sendfile-1M
Fig.16. requests/secoverhead(%)forhardeninglighttpd Fig.17. requests/secoverhead(%)forhardeningnginx
Given the average overhead of 13.5%, it is clear that such Average overhead is minimal when sending the large
frame-based initialization without the benefit of compiler op- (1MB) file. In the extreme case of the small 4Kb file, where
timizations is too slow. Despite this simpler approach offering we process almost 70,000 requests per second, overhead is
considerably less safety, only bzip2 gains significant perfor- still less than 3%; the majority of execution time here is spent
mance benefit from these reduced guarantees. parsing incoming requests and maintaining internal structures.
Wealsoinvestigatedanotherapproachforweakeningguar- Much of lighttpd’s overhead for these tiny requests is
antees to improve performance, by increasing the lifetimes of caused by small heap allocations for strings in the chunk
variables inside loops so they would only be initialized once, queue;onlythefirstbyteoftheseisinitializedbythecaller,but
before the loop. The impact of this on stack coloring and our hardened allocator clears the entire allocation for safety.
registerallocationresultedinworseperformanceforalmostall Theremainingoverheadforbothsituationsisduetolighttpd’s
benchmarks (and average overhead for CINT2006 of >5%). writev code, used by both backends for writing these al-
locations to the network, uses a fixed-size stack buffer. Our
B. Servers current optimizer fails to optimize away the unused portion of
thebuffer,butimprovedoptimizationsorminorchangestothe
We evaluated the overhead of SafeInit for less
code could reduce the overhead further. In fact, older versions
computationally-intensive tasks by using two modern
of lighttpd used a larger buffer in this code, but recently a
high-performance web servers, nginx (1.10.1) and lighttpd
“sanelimit”wasimposedonthebuffersize;suchmodifications
(1.4.41). We built the web servers using LTO and -O3. Since
demonstrate how general code improvements can also reduce
theyareI/Oboundwhenusedonour1gbpsnetworkinterface,
the overhead imposed by SafeInit.
we benchmarked them using the loopback interface. This is
an extreme scenario; in practice, the overhead of SafeInit is nginx: We tested nginx both with a default configuration
insignificant for these servers. (which is similar to the one we used for lighttpd) and with
sendfileenabled(whichsignificantlyincreasesperformancefor
We used apachebench to repeatedly download 4Kb, 64Kb
serving the 64Kb and 1MB files). All logging was disabled;
and 1MB files, for a period of 30 seconds. We enabled
our overhead is slightly reduced when logs are enabled. The
pipelining, used 8 concurrent workers, and used CPU affinity
results are shown in Figure 17.
to reserve a CPU core for apachebench. We measured the
overheadforthemediannumberofrequestspersecond,across Overhead of full SafeInit, including our optimizer, is not-
10 runs; we did not see significant amounts of variance. icably higher with the 64Kb files; however, the overhead of
SafeInit remains below 5% in all circumstances.
lighttpd: We attempted to configure lighttpd to optimize
throughput, allowing 100 requests per pipelined connection, nginx makes use of a custom pool-based memory allo-
and evaluated both the sendfile (default) and writev cator, which makes it difficult for our optimizer to analyse
network backends. The results are shown in Figure 16. code. However, we manually verified that memory is not (by
10TABLEII. PHP7.0.9MICRO-BENCHMARKRESULTS(INSECONDS)
userspace allocator; our automatic hardening only protects
bench.php micro_bench.php local variables. Protecting other sources of uninitialized data,
baseline 1.029 3.983 suchastheSLABandbuddyallocators,wouldrequiremanual
newoptimizer 1.007(-2.1%) 3.879(-2.6%) changes, and presumably add further overhead; such sanitiza-
naiveSafeInit 1.004(-2.5%) 3.994(0.3%) tion is already offered by kernel patches such as grsecurity.
SafeInit 0.999(-3%) 3.897(-2.8%)
Table III provides a selection of latency and bandwidth
figures for typical system calls, using LMbench, a kernel
TABLEIII. LMBENCHRESULTS.TIMEINMICROSECONDS,PLUS%
OVERHEADABOVEBASELINE. microbenchmarking tool [43]. We ran each benchmark 10
times, with a short warming-up period and a high number of
Sub-benchmark Baseline w/Optimizer StackSafeInit
iterations (100) per run, and provide the median result. TCP
syscallnull 0.0402 0.0402(0%) 0.0402(0%)
connectionsweretolocalhost,andotherparameterswerethose
syscallstat 0.2519 0.2369(-5.9%) 0.2571(2.1%)
used by the default LMbench script. The overhead numbers
syscallfstat 0.0739 0.0742(0.4%) 0.0775(4.9%)
for the hardened kernels include the (negligible) overhead of
syscallopen 0.7049 0.6778(-3.8%) 0.7119(1%)
hardening LMbench itself.
syscallread 0.0817 0.0819(0.2%) 0.0819(0.2%)
syscallwrite 0.0981 0.0979(-0.2%) 0.0971(-1%) We incur substantial overhead for the stat and open
selecttcp 4.5882 4.6714(1.8%) 4.6497(1.3%) system calls; while this is largely mitigated by the improved
siginstall 0.0964 0.0977(1.4%) 0.1000(3.7%)
performance provided by our optimizer, it is a cause for
sigcatch 0.6534 0.6495(-0.6%) 0.6648(1.7%)
concern, and we intend to investigate it further, along with
sigprot 0.2220 0.2210(-0.4%) 0.2350(5.9%)
fstat and the (signal) protection fault, which is the only
procfork 65.5904 66.6386(1.6%) 67.7927(3.4%)
system call we saw with overhead >5%.
procexec 208.8846 209.8519(0.5%) 212.3462(1.7%)
pipe 3.3500 3.3834(1%) 3.4145(1.9%) To evaluate the real-world performance of SafeInit applied
tcp 6.7489 6.7163(-0.5%) 6.6835(-1%) to the kernel stack, we hardened both nginx and the kernel
bwpipe(MB/s) 4988.09 4974.89(0.3%) 5182.4(-3.9%) with SafeInit, and compared performance to a non-hardened
bwtcp(MB/s) 8269.34 8245.39(0.3%) 8350.71(-1%) nginxrunningunderanon-hardenedkernel.Usingthesendfile
configuration we discussed above, and again using the loop-
back interface to provide an extreme situation, we observed
default) re-used within the pool, to ensure that any potential
overhead of 2.9%, 3% and 4.5% for the 1M, 64kB and 4kB
uninitialized memory vulnerabilities would still be mitigated.
cases respectively.
We also ran nginx using our detection tool (using two
Wepresentthenumbersaboveasaviewofwhatispossible
variants);overhead(aboveourhardenedversion)wasgenerally
with only automatic mitigation, without application-specific
similar to that reported by Koning et al. [30], with worst-case
knowledge. Our optimizer could be extended with knowledge
overhead of <75%.
of heap functions, inline assembly, and core kernel functions
PHP: We also evaluated a modern high-performance such as copy_from_user, which would provide both im-
scripting language, PHP 7.0.9. We used the default compiler proved guarantees and more opportunities for optimization.
flags(-O2),sinceweencounteredbuildsystemproblemswhen
attempting to use LTO. However, PHP makes extensive use of D. Residual Overhead
an internal memory allocator, which re-uses memory obtained
The average overhead of CINT2006 is distorted by the
fromourhardenedallocator;thisreducesoursafetyguarantees
performance overhead of two outliers. The most significant
for smaller allocations.
is sjeng, a chess program. It stores game moves in large on-
We ran both supplied PHP micro-benchmarks (from the stack arrays in several recursive functions, and these arrays
Zend directory). The median of 21 runs (we saw little are then passed to many other functions, with the size stored
variation between runs) is shown in Table II; the combination in a global variable. This code is so convoluted that, even
of SafeInit and our new optimizer result in performance with manual inspection, we are unable to determine whether
improvements of around 3% for both micro-benchmarks. We ornotarrayelementsmaybeusedwithoutbeinginitialized.An
saw approximately 1% overhead (above the hardened version) appropriate approach might be to refactor or rewrite the code
when running these benchmarks under our detection system inquestion,removingsuch‘codesmells’,whichwouldbenefit
(using two variants). both compiler analysis as well as our manual inspection.
This may be unrealistic in some cases, so we added
C. Linux
compiler support for annotating variables and types with a
We built the latest LLVMLinux [37] kernel tree1 using our ’no zeroinit’ attribute, and annotated sjeng’s move_s type;
toolchain. We customized the build system to allow use of this single annotation successfully reduced sjeng’s runtime
LTO,re-enabledbuilt-inclangfunctions,andmodifiedthegold overhead to 6.5% (which would, in turn, reduce the mean
linker to work around some LTO code generation issues we overheadforCINT2006tolessthan2%),incombinationwith
encountered with symbol ordering. our full set of optimizations.
SincetheLinuxkernel(inherently)performsitsownmem- lighttpd’s buffer preparation function, discussed earlier,
ory management, it does not get linked with our hardened could also benefit from such an annotation. However, since
lighttpd does not clear the entire buffer, this would also
1 basedonmainlinerevisionf800c25b require detailed manual inspection to ensure it was safe; we
11TABLEIV. WARNINGPASSOUTPUT,FORCINT2006 $ multivar php poc.php
Starting php-zero (20439)
Benchmark #Warnings Notes
Starting php-poison (20440)
bzip2 4 oneisa4MBbufferaddedbySPEC
20440 term sig: Segmentation fault (11)
gcc 1
gobmk 8 mostlytoocomplextoanalyze
h264ref 7
Fig.18. DetectionoutputwhencheckingPHPCVE-2016-4243
perlbench 1 unusedatruntime
sjeng 19 17ofthesearemove_s
xalancbmk 16 temporary(wide)stringbuffers Our hardening does not prevent programs from reusing
memory internally. For example, a stack buffer may be reused
TABLEV. VERIFIEDUNINITIALIZEDVALUEMITIGATIONS
for different purposes within the same function, or a custom
CVEnumber Software Mitigated? Description internal heap allocator may reuse memory without clearing it,
2016-4243 PHP (cid:88) Use of uninitialized stack variables, such as we saw with PHP. Although it would potentially be
includingapointer.
possible to catch some of these cases using heuristics, or by
2016-5337 qemu (cid:88) Infodisclosuretoguest;missingnull
attaching annotations of some kind, we do not believe it is
terminatorforstackstringbuffer.
2016-4486 Linux (cid:88) Infodisclosuretouserspace;uninitial- realistic nor reasonable for a compiler to support this.
izedpaddinginstructonstack.
Clearing variables to zero ensures that any uninitialized
pointersarenull.Anattempttodereferencesuchapointerwill
do not believe the reduced safety in adding such annotations result in a fault; in such situations, our mitigation has reduced
is justified, given the low overhead of our approach. a more serious problem to a denial-of-service vulnerability.
We also added a warning pass to our compiler, which can Inmanycases,codewillspecificallycheckfornullpointers
omit warnings (at link time) about large on-stack allocations or other variables, and so clearing variables mitigates issues
(by default, >4kB) for which our optimizer failed to remove entirely; when running our detection system, we noticed that
initialization. Figure IV summarizes the results for CINT2006 many uninitialized pointer dereferences were only triggered
(excluding the benchmarks which output no warnings). Many in the variant initialized with a non-zero value. For example,
of these are not on critical paths for performance, and some Figure 18 shows the output of our detection system executing
are completely unused in practice, such as a 8kB buffer in a proof-of-concept exploit for PHP CVE-2016-4243. Only the
perlbench described in the source code as “The big, slow and variant initialized with a non-zero value attempts to derefer-
stupidway“.Thesewarningscouldbecombinedwithprofiling encethevalue(whichresultsinafault,caughtbyoursystem).
to determine which code needs to be refactored or annotated.
Initializing all variables with zero also has the potential to
activate vulnerabilities which would otherwise have remained
E. Security
dormant. A contrived example could be a ‘insecure’ variable,
To verify that SafeInit works as expected, we not only which is used to force a check of some kind, but is used
consideredavarietyofreal-worldvulnerabilities,suchasthose uninitialized. This may not be a problem in practice under
in Table V, but also created a suite of individual test cases. some environments, where the underlying memory happens to
We inspected the bitcode and machine code generated for the alwayscontainanon-zerovalue.However,thismaychangeat
relevant code manually, and also ran our test suite using the any time, and since compilers are allowed to transform such
detection system we described above. We also used valgrind undefined behavior, it is always possible that such code may
to verify our hardening; for example, we confirmed that all be optimized away.
uninitialized value warnings from valgrind disappear when
As stated in our threat model, we only consider C/C++
OpenSSL 0.8.9a is hardened with SafeInit.
code; assembly routines fall outside the scope of this work,
Aswithallcompileroptimizations,ourimprovementsmay althoughtypicalinlineassemblywilldeclarelocalvariablesin
expose latent bugs in other compiler code or in the source C/C++code,whichwouldthenbeinitializedbyourprototype.
being compiled, or even contain bugs themselves. We verified Since we have implemented our SafeInit prototype as an
that the benchmarks we ran produced correct results. We also LLVM pass, other compiler frontends making use of LLVM
extensively tested our hardened kernel, and where available could also easily benefit from our work; we look forward to
ran test suites for the compilers and software we hardened experimenting with NVIDIA’s upcoming Fortran front-end.
(such as PHP). However, the potential for such issues remains
an inherent risk when using any modern compiler, as shown IX. LIMITATIONS
by Yang et al. [64]. Formal verification of compilers (e.g.,
Libraries: Forcompleteprotectionagainstalluninitialized
CompCert[36])orindividualoptimizationpasses(suchasthat
value vulnerabilities, all used libraries must also be instru-
by Zhao et al. [67] and Deng et al. [16]).
mented. The standard C library used on Linux, glibc, does
However, in total, our SafeInit prototype adds or modifies not build under clang, so our prototype implementation is
less than 2000 lines of code in LLVM, including some debug- unable to instrument it; this is a limitation of our specific
ging code and around 400 lines of code based on third-party implementation, not our design. Stepanov et al. [58] state that
patches. Although our modifications are complex, this is a they implemented interception of ‘close to 300’ libc functions
relativelysmallamountofcodeandeachcomponentshouldbe inMemorySanitizer;whilesuchknowledgeoflibraryfunctions
individually reviewable; for comparison, our (separate) frame is not required by SafeInit, having access to the bitcode for
clearing pass alone is more than 350 lines of code. libraries would also allow further performance improvements.
12SinceboththetoolchainandClibraryareusuallyprovided require less manual effort to fix. Recent research [65] claims
together, we feel it would be reasonable to make small im- to have reduced MSan overhead even further.
provementstotheClibrarytomitigateanyperformanceissues
Berger et al. proposed using multi-variant execution to
for specific functions. However, in any case, we observed no
detect uses of uninitialized heap allocations in DieHard [5].
meaningful overhead (<0.1%) when building benchmarks and
By running multiple variants of the same program and filling
applicationsagainstanunmodifiedalternativeClibrary(musl).
newly-allocated heap memory with random values, and pro-
Performance: Our modified optimizer can cause (small) vidingallvariantswithidenticalinput,anydeviationinoutput
performance regressions in some code, caused by unintended was likely to be due to use of uninitialized memory. To obtain
consequences on other optimizations and code generation. For reliability against memory errors, they proposed running sev-
example, removing stores makes functions smaller, and so eral variants, and dropping any reporting inconsistent results.
morelikelytofallundertheinliningthreshold;wecanimprove
Stack clearing: gcc’s Fortran compiler provides an
performance across all of our benchmarks by modifying the
-finit-local-zerooption,intendedonlyforcompatibil-
threshold. To be as fair as possible, we presented our results
itywithlegacyFortrancode.SeveralC/C++compilersprovide
without any such changes. The optimizations proposed in
options for automatic initialization of function stack frames,
our design and implemented in our prototype are deliberately
intended only for debugging purposes. As discussed, such
minimal,withoutadditionalanalysis,toshowtheyarepractical
stack frame clearing adds a significant performance penalty,
to implement in current compilers; this limits many of the
and provides fewer guarantees.
possible transformations. Despite this, we expect the overhead
of SafeInit to decrease significantly over time, as the related Chen et al. presented StackArmor [9], a binary hardening
compiler optimizations continue to improve. system which isolated function frames containing potentially
unsafe buffers using guard pages and random reordering. This
There will inevitably be cases where performance is un-
makes it more difficult for attackers to predict which data
acceptable in real-world code, as we saw with sjeng. Where
may be present in uninitialized portions of frames, providing
annotations are an unacceptable solution, making changes to
probabilistic mitigation of uninitialized data vulnerabilities;
thecodemaybenecessary.However,suchrefactoringcanalso
they combined it with analysis to add zero-initialization to
improve the code in other ways, whether just making it more
potentially uninitialized portions of non-isolated frames, but
readable and easier to understand, or as we saw with lighttpd,
reported high average overhead of 28% on SPEC CPU2006.
also by resolving potential memory or performance issues.
Heap clearing: Heap allocation clearing is an option in
Relevant recent developments in LLVM include improve- some existing allocators, such as jemalloc [20], although
ments to loop analysis and optimization [47] as well as trans- generally intended only for debugging; for example, the je-
forming entire structure definitions to improve performance malloc documentation warns that it “will impact performance
[26]. During the development of our project, improvements to negatively”. Wang et al. [62] proposed zero-initializing and
LLVM’sstoreoptimizationshavealsocontinued;forexample, padding heap allocations at allocation time, by wrapping
one recent patch improved removal of stores which are over- malloc, to protect against buffer overread vulnerabilities.
written by multiple later store instructions, allowing removal Araujo and Hamlen [3] suggested just zeroing the first byte
of unnecessary initializations when individual members of a of all allocations, giving limited benefits (e.g., for C strings)
structureareinitialized.Welookforwardtoseeinghowfuture but adding almost no overhead.
optimizations further decrease the overhead of our work.
Chow et al. proposed Secure Deallocation [11], which
modifies the system C library to zero heap allocations when
X. RELATEDWORK freed, and modifies compiler code generation to clear stack
frames in function epilogues; this provides less comprehen-
Detection: Dynamic analysis tools for detecting uses of
sive protection and misses optimization opportunities. They
uninitialized data, such as valgrind’s memcheck [54], track
claimedruntimeoverheadof<7%forheapclearing,but10%-
the initialized state of each bit of memory and (optionally)
40%overheadforstackclearing,althoughtheirapproachdoes
the origin of any uninitialized data. The high overhead of this
protect against some vulnerabilities outside our threat model.
trackingmakesitoftenprohibitiveforuseduringdevelopment,
and completely impractical to deploy. It is almost essential to Heap isolation: Isolating all heap allocations mitigates
use optimized binaries, where undefined behavior may have some classes of memory vulnerabilities, such as overflows;
already introduced undetectable vulnerabilities, along with however, this is at best a probabilistic defense, since limited
otherissueswhichreducethereliabilityofthisapproach,such available address space means memory is inevitably reused
as re-use of stack memory within functions. after a certain point. DieHard [5] allocates memory randomly
across an oversized heap, and Archipelago [41] allocates
More recent detection tools using a similar approach in-
memoryacrosstheentireaddressspace.OpenBSD[46]imple-
clude Dr. Memory [7], which significantly reduces overhead
mented such a random allocator by default, including moving
byapplyingoptimizations,andMemorySanitizer[58](MSan),
metadata out-of-bound, and DieHarder [48] built upon this to
whichreducesoverheadevenfurtherbyinstrumentingbinaries
increase entropy at an additional performance cost of 20%,
during compilation (using LLVM). The execution time over-
due to the cost of memory fragmentation.
head for MSan is reported as 2.5x (with optimized binaries),
which is sufficient to make it usable as part of continuous Informationdisclosuredefenses: Manydefenseshavebeen
integration for projects such as Chrome, and advancements proposed for protecting sensitive data. TaintEraser [68] uses
such as chained origin tracking mean that reported errors tainting to track sensitive user input and prevent it from
13escaping to the filesystem or network. Harrison and Xu [24] may result in significantly better overhead in some cases,
proposed techniques for probabilistically protecting private particularly for the heap. We believe similar results could be
cryptographic keys against memory disclosure attacks, and obtained by adding knowledge of Linux heap functions and a
SWIPE [23] tracks sensitive data using static analysis and Linux-specific optimization pass to SafeInit; combining both
erases it at the end of its lifetime. techniques may also be a promising approach.
Defenses which depend on information hiding to protect
pointers or other metadata are particularly vulnerable to infor-
XI. CONCLUSION
mation disclosure. Advances such as fine-grained ASLR [25] Uninitialized data vulnerabilities continue to pose a secu-
arerendereduselessifuninitializedmemoryerrorscanbeused rity problem in modern C/C++ software, and ensuring safety
to disclose pointers. Defenses such as Code-Pointer Integrity againsttheuseofuninitializedvaluesisnotaseasyasitmight
[32],Readactor[15]andASLR-Guard[39]aimtoprotectcode seem. Threats ranging from simple information disclosures to
pointers against more sophisticated disclosure attacks such as serious issues such as arbitrary memory writes, static analysis
those proposed by Evans et al. [19] and Schuster et al. [51]. limitations, and compiler optimizations taking advantage of
undefined behavior, combine to make this a difficult problem.
Linux kernel
We presented a toolchain-based hardening technique,
Uninitialized data vulnerabilities in the Linux kernel have SafeInit,whichmitigatesusesofuninitializedvaluesinC/C++
had increased attention in recent years; as well as obvious programs by ensuring that all local variables and stack alloca-
issues of exposing confidential information, knowledge of tions are initialized before use. By making use of appropriate
kerneladdresseshasbecomeimportantforattackerswishingto optimizations, we showed that runtime overhead for many
bypassdefensessuchasstackcanaries(usinggcc’sStackGuard applicationscanbereducedtoalevelwhichmakesitpractical
[14]) and ASLR (kASLR [13]). In 2011, Chen et al. [8] per- to apply as a standard hardening protection, and that this can
formed an extensive analysis of kernel vulnerabilities and re- be done practically in a modern compiler.
ported that the most common category were uninitialized data
To foster further research in this area, we are open
errors,almostallofwhichledtoinformationdisclosure.More
sourcing our SafeInit prototype, which is available at
recently, Peiro´ et al. [50] provided more in-depth discussion
https://github.com/vusec/safeinit. We hope to
of such kernel info disclosure vulnerabilities, and presented a
worktowardsmakingSafeInitavailableasastandardcompiler
technique for identifying stack information disclosures using
feature, and improving the optimizations it depends upon.
static analysis. Linux also includes kmemcheck, a dynamic
analysis tool for detecting uses of uninitialized heap memory.
ACKNOWLEDGEMENTS
grsecurity/PaX: The PaX project [49], as part of the
hardened grsecurity Linux patches, provides two different We would like to thank Kees Cook, Kangjie Lu and the
mitigationsforpotentiallyuninitializedkernelstackdata,using anonymous reviewers for their comments. This work was
gcc plugins. One annotates structures which may be disclosed supportedbytheEuropeanCommissionthroughprojectH2020
to userspace, and initializes any such structures on the stack ICT-32-2014 SHARCS under Grant Agreement No. 644571
to prevent accidental information disclosure. The other takes and by the Netherlands Organisation for Scientific Research
a more aggressive approach, clearing the kernel stack be- through grant NWO 639.023.309 VICI Dowsing.
fore/aftersystemcalls.Agccplugintracksthemaximumstack
depth used for each call, providing efficient protection against REFERENCES
stack re-use between different system calls, although still
[1] “CVE-2012-1889:VulnerabilityinMicrosoftXMLcoreservicescould
theoretically allowingan attacker toexploit such issueswithin
allowremotecodeexecution,”2012.
a single call. Both grsecurity and recent mainline kernels can
[2] P. Akritidis, M. Costa, M. Castro, and S. Hand, “Baggy bounds
also be configured to initialize and/or clear heap allocations.
checking:Anefficientandbackwards-compatibledefenseagainstout-
of-boundserrors.”inUSENIXSecurity,2009.
UniSan: Concurrently to our work, Lu et al. developed
[3] F. Araujo and K. Hamlen, “Compiler-instrumented, dynamic secret-
UniSan[38], a compiler-based approach for mitigating infor-
redaction of legacy processes for attacker deception,” in USENIX
mationdisclosurevulnerabilitiescausedbyuninitializedvalues Security,2015.
in the Linux kernel. They propose using static data-flow [4] M.AuslanderandM.Hopkins,“AnoverviewofthePL.8compiler,”
analysis to trace potential execution paths (after optimizations inSIGPLANSymposiumonCompilerConstruction,1982.
havebeenapplied),andinitializinganyvariableswhichcannot [5] E. D. Berger and B. G. Zorn, “DieHard: probabilistic memory safety
be proven to be initialized before potentially being disclosed; forunsafelanguages,”inPLDI,2006.
they implemented a prototype using LLVM, and manually [6] A.Bessey,K.Block,B.Chelf,A.Chou,B.Fulton,S.Hallem,C.Henri-
inspectedtheiranalysisresultstofindanddisclosevariousnew Gros, A. Kamsky, S. McPeak, and D. Engler, “A few billion lines
of code later: using static analysis to find bugs in the real world,”
uninitialized value disclosure vulnerabilities (some of which
CommunicationsoftheACM,vol.53,no.2,pp.66–75,2010.
we used to verify the correctness of our own work).
[7] D.BrueningandQ.Zhao,“Practicalmemorycheckingwithdr.mem-
Ourapproachmitigatesawiderrangeofpotentialuninitial- ory,”inCGO,2011.
ized value vulnerabilities on the stack (such as dereferencing [8] H. Chen, Y. Mao, X. Wang, D. Zhou, N. Zeldovich, and M. F.
Kaashoek, “Linux kernel vulnerabilities: State-of-the-art defenses and
uninitialized pointers [40] or even control-flow-based side-
openproblems,”inAPSys,2011.
channel attacks [52]), and SafeInit obtains good performance
[9] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida,
withoutadditionaldata-flowanalysis.However,UniSan’sinter-
“StackArmor: Comprehensive protection from stack-based memory
proceduralanalysisandspecificknowledgeofkernelfunctions errorvulnerabilitiesforbinaries.”inNDSS,2015.
14[10] J. Chow, B. Pfaff, T. Garfinkel, K. Christopher, and M. Rosenblum, [39] K. Lu, C. Song, B. Lee, S. P. Chung, T. Kim, and W. Lee, “ASLR-
“Understandingdatalifetimeviawholesystemsimulation,”inUSENIX Guard:Stoppingaddressspaceleakageforcodereuseattacks,”inCCS,
Security,2004. 2015.
[11] J. Chow, B. Pfaff, T. Garfinkel, and M. Rosenblum, “Shredding [40] K. Lu, M.-T. Walter, D. Pfaff, N. Stefan, W. Lee, and M. Backes,
your garbage: Reducing data lifetime through secure deallocation.” in “Unleashinguse-before-initializationvulnerabilitiesintheLinuxkernel
USENIXSecurity,2005. usingtargetedstackspraying,”inNDSS,2017.
[12] K. Cook, “Kernel exploitation via uninitialized stack,” DEFCON 19, [41] V. B. Lvin, G. Novark, E. D. Berger, and B. G. Zorn, “Archipelago:
2011. tradingaddressspaceforreliabilityandsecurity,”inASPLOS,2008.
[13] ——,“Kerneladdressspacelayoutrandomization,”2013,LinuxSecu- [42] V. Makarov, “The integrated register allocator for GCC,” in GCC
ritySummit. DevelopersSummit,2007.
[43] L.W.McVoyandC.Staelin,“LMbench:Portabletoolsforperformance
[14] C.Cowan,C.Pu,D.Maier,J.Walpole,P.Bakke,S.Beattie,A.Grier,
analysis,”inUSENIX,1996.
P.Wagle,Q.Zhang,andH.Hinton,“StackGuard:Automaticadaptive
detectionandpreventionofbuffer-overflowattacks,”inUSENIXSecu- [44] K. Memarian, J. Matthiesen, J. Lingard, K. Nienhuis, D. Chisnall,
rity,1998. R. N. M. Watson, and P. Sewell, “Into the depths of c: Elaborating
thedefactostandards,”inPLDI,2016.
[15] S.Crane,C.Liebchen,A.Homescu,L.Davi,P.Larsen,A.-R.Sadeghi,
S.Brunthaler,andM.Franz,“Readactor:Practicalcoderandomization [45] Microsoft, “MS08-014 : The case of the uninitialized stack variable
resilienttomemorydisclosure,”inS&P,2015. vulnerability,”1998.
[16] C.DengandK.S.Namjoshi,“Securingacompilertransformation,”in [46] O.Moerbeek,“Anewmalloc(3)forOpenBSD,”inEuroBSDCon,2009.
StaticAnalysis,2016. [47] A.NemetandM.Zolotukhin,“Advancesinloopanalysisframeworks
andoptimizations,”inLLVMDevelopers’Meeting,2015.
[17] C. Ding and Y. Zhong, “Predicting whole-program locality through
reusedistanceanalysis,”inPLDI,2003. [48] G.NovarkandE.D.Berger,“DieHarder:securingtheheap,”inCCS,
2010.
[18] D. Edelsohn, W. Gellerich, M. Hagog, D. Naishlos, M. Namolaru,
E. Pasch, H. Penner, U. Weigand, and A. Zaks, “Contributions to the [49] PaXTeam,“PaX-gccpluginsgalore,”2013,H2HC.
GNUcompilercollection,”IBMSystemsJournal,2005. [50] S. Peiro´, M. Munoz, and A. Crespo, “An analysis on the impact and
[19] I.Evans,S.Fingeret,J.Gonza´lez,U.Otgonbaatar,T.Tang,H.Shrobe,
detectionofkernelstackinfoleaks,”LogicJournalofIGPL,2016.
S.Sidiroglou-Douskos,M.Rinard,andH.Okhravi,“Missingthepoint [51] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
(er):Ontheeffectivenessofcodepointerintegrity,”inS&P,2015. T. Holz, “Counterfeit object-oriented programming: On the difficulty
ofpreventingcodereuseattacksinc++applications,”inS&P,2015.
[20] J. Evans, “A scalable concurrent malloc(3) implementation for
FreeBSD,”inBSDCan,2006. [52] J.Seibert,H.Okhravi,andE.So¨derstro¨m,“Informationleakswithout
memorydisclosures:Remotesidechannelattacksondiversifiedcode,”
[21] H.Flake,“Attacksonuninitializedlocalvariables,”BlackHatEurope,
inCCS,2014.
2006.
[53] F. J. Serna, “The info leak era on software exploitation,” Black Hat
[22] S. Ghemawat and P. Menage, “TCMalloc : Thread-caching malloc,”
USA,2012.
2007.
[54] J.SewardandN.Nethercote,“Usingvalgrindtodetectundefinedvalue
[23] K.Gondi,P.Bisht,P.Venkatachari,A.P.Sistla,andV.N.Venkatakr- errorswithbit-precision,”inUSENIX,2005.
ishnan,“SWIPE:Eagererasureofsensitivedatainlargescalesystems
[55] H.Shacham,M.Page,B.Pfaff,E.-J.Goh,N.Modadugu,andD.Boneh,
software,”inCODASPY,2012.
“Ontheeffectivenessofaddress-spacerandomization,”inCCS,2004.
[24] K. Harrison and S. Xu, “Protecting cryptographic keys from memory
[56] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and
disclosureattacks,”inDSN,2007.
A.-R. Sadeghi, “Just-in-time code reuse: On the effectiveness of fine-
[25] J.Hiser,A.Nguyen-Tuong,M.Co,M.Hall,andJ.W.Davidson,“ILR: grainedaddressspacelayoutrandomization,”inS&P,2013.
Where’dmygadgetsgo?”inS&P,2012.
[57] B. Spengler, “Detection, prevention, and containment: A study of
[26] G. Hoflehner, “LLVM performance improvements and headroom,” in grsecurity,”2002,libresSoftwareMeeting.
LLVMDevelopers’Meeting,2015. [58] E. Stepanov and K. Serebryany, “MemorySanitizer: fast detector of
[27] J.Hubicka,“InterproceduraloptimizationframeworkinGCC,”inGCC uninitializedmemoryuseinc++,”inCGO,2015.
DevelopersSummit,2007. [59] C. Sun, V. Le, and Z. Su, “Finding and analyzing compiler warning
[28] T. Johnson and D. L. Xinliang, “ThinLTO: A fine-grained demand- defects,”inICSE,2016.
driveninfrastructure,”inEuroLLVM,2015. [60] L. Szekeres, M. Payer, T. Wei, and D. Song, “SoK: Eternal war in
[29] M. Jurczyk, “Enabling QR codes in Internet Explorer, or a story of a
memory,”inS&P,2013.
cross-platformmemorydisclosure,”2015. [61] R.vanEeden,“Unexpectedcodeexecutioninsmbd,”2015.
[30] K.Koning,H.Bos,andC.Giuffrida,“Secureandefficientmulti-variant [62] J. Wang, M. Zhao, Q. Zeng, D. Wu, and P. Liu, “Risk assessment of
executionusinghardware-assistedprocessvirtualization,”inDSN,2016. buffer“heartbleed”over-readvulnerabilities,”inDSN,2015.
[31] B. C. Kuszmaul, “SuperMalloc: a super fast multithreaded malloc for [63] X. Wang, H. Chen, A. Cheung, Z. Jia, N. Zeldovich, and M. F.
64-bitmachines,”inISMM,2015. Kaashoek,“Undefinedbehavior:whathappenedtomycode?”inAPSys,
2012.
[32] V.Kuznetsov,L.Szekeres,M.Payer,G.Candea,R.Sekar,andD.Song,
“Code-PointerIntegrity,”inOSDI,2014. [64] X.Yang,Y.Chen,E.Eide,andJ.Regehr,“Findingandunderstanding
bugsinccompilers,”inPLDI,2011.
[33] W.Landi,“Undecidabilityofstaticanalysis,”ACMLett.Program.Lang.
[65] D.Ye,Y.Sui,andJ.Xue,“Acceleratingdynamicdetectionofusesof
Syst.,1992.
undefinedvalueswithstaticvalue-flowanalysis,”inCGO,2014.
[34] C. Lattner, “What every C programmer should know about undefined
[66] S.Yilek,E.Rescorla,H.Shacham,B.Enright,andS.Savage,“When
behavior,”2011,LLVMprojectblog.
privatekeysarepublic:resultsfromthe2008DebianOpenSSLvulner-
[35] C. Lattner and V. Adve, “LLVM: A Compilation Framework for ability,”inIMC,2009.
LifelongProgramAnalysis&Transformation,”inCGO,2004.
[67] J. Zhao, S. Nagarakatte, M. M. Martin, and S. Zdancewic, “Formal
[36] X.Leroy,“Formalverificationofarealisticcompiler,”Communications verificationofSSA-basedoptimizationsforLLVM,”inPLDI,2013.
oftheACM,no.7,pp.107–115,2009. [68] D.Y.Zhu,J.Jung,D.Song,T.Kohno,andD.Wetherall,“TaintEraser:
[37] LinuxFoundation,“LLVMLinuxproject.” Protecting sensitive data leaks using application-level taint tracking,”
ACMSIGOPSOperatingSystemsReview,2011.
[38] K.Lu,C.Song,T.Kim,andW.Lee,“UniSan:Proactivekernelmemory
initializationtoeliminatedataleakages,”inCCS,2016.
15