Stack Bounds Protection with Low Fat Pointers
Gregory J. Duck and Roland H. C. Yap† Lorenzo Cavallaro‡
Department of Computer Science Information Security Group
National University of Singapore Royal Holloway University of London
{gregory, ryap}@comp.nus.edu.sg lorenzo.cavallaro@rhul.ac.uk
with “buffer overflow” on the NVD (National Vulnerability
Database) returns at least 972 entries for the past three years
Abstract—Object bounds overflow errors are a common
alone. The 2014 Heartbleed [12] bug, which was perhaps one
source of security vulnerabilities. In principle, bounds check
of the most serious and widespread vulnerabilities of recent
instrumentation eliminates the problem, but this introduces high
times, was also a buffer overflow.
overheads and is further hampered by limited compatibility
againstun-instrumentedcode.On64-bitsystems,low-fatpointers
Given the well understood nature of buffer overflow and
are a recent scheme for implementing efficient and compatible
the numerous proposed solutions, it is reasonable to ask why
bounds checking by transparently encoding meta information
protection mechanisms that prevent buffer overflow are not in
within the native pointer representation itself. However, low-fat
widespread use. There are a number of barriers to adoption
pointers are traditionally used for heap objects only, where the
allocator has sufficient control over object location necessary for that have been identified [24], including:
the encoding. This is a problem for stack allocation, where there
• Performance: Does the solution slow the program down
exist strong constraints regarding the location of stack objects
too much? Does the solution use too much memory?
thatisapparentlyincompatiblewiththelow-fatpointerapproach.
• Software Compatibility: Does the solution work with
To address this problem, we present an extension of low-fat
pointers to stack objects by using a collection of techniques, existing code bases without additional modification?
suchaspointermirroringandmemoryaliasing,therebyallowing • Binary Compatibility: Does the solution change the
stackobjectstoenjoyboundserrorprotectionfrominstrumented Application Binary Interface (ABI) meaning that binary
code. Our extension is compatible with common special uses of modules (e.g., system or proprietary libraries) need to be
the stack, such as alloca, setjmp and longjmp, exceptions, and re-compiled?
multi-threading, which rely on direct manipulation of the stack
pointer. Our experiments show that we successfully extend the Low runtime performance overheads are important (and in
advantages of the low-fat pointer encoding to stack objects. The generalthelowerthebetter),howevertheimpactisapplication
end result is a competitive bounds checking instrumentation for dependent. For example, the AddressSanitizer [22]-hardened
the stack and heap with low memory and runtime overheads, Tor browser [25] is an example application where security
and high compatibility with un-instrumented legacy code. is prioritized over performance. Memory overheads are also
important, especially in server contexts where available sys-
I. INTRODUCTION tem memory may be at a premium. Memory overheads can
translate into time overheads under low memory conditions.
System code and applications with high-performance re-
Software compatibility means that programs which use a
quirements are usually written in low-level languages such
variety of compiler and language specific features continue
as C and C++. These programming languages do not provide
to work, e.g., undefined behavior (out-of-bounds pointers,
any protection against memory errors (e.g., buffer overflows),
integer overflows, etc.), abnormal control-flow (longjmp, C++
and this is a well known source of security vulnerabilities
exceptions, etc.), and inline assembly. Binary compatibility is
and exploits. Although memory errors have been well re-
a necessity in the real world given that source code is not
searched with numerous proposed solutions [24], [26], the
always available for libraries. Solutions that change the ABI
threat nevertheless persists. For example, a search for CVEs
are automatically incompatible with such applications.
† This research was partially supported by a grant from the National Re- Recently,aboundsoverflowprotectionmechanism[10]for
searchFoundation,PrimeMinister’sOffice,SingaporeunderitsNationalCy- C/C++ was proposed that achieves good runtime performance
bersecurityR&DProgram(TSUNAMiproject,No.NRF2014NCR-NCR001-
and software compatibility, along with excellent memory per-
21)andadministeredbytheNationalCybersecurityR&DDirectorate.
formance and binary compatibility. The protection mechanism
‡ThisresearchwaspartiallysupportedbytheUKEPSRCresearchgrant
EP/L022710/1. is based on low-fat pointers that transparently encodes bounds
meta information (i.e., an object’s base address and size) into
thenativemachinerepresentationofapointeritself.Thismeta
Permission to freely reproduce all or part of this paper for noncommercial information can be later retrieved to check all read and write
purposes is granted provided that copies bear this notice and the full citation
accesses are within the bounds of the corresponding object,
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author a.k.a. bounds checking. Since low-fat pointers are also regular
(for reproduction of an entire paper only), and the author’s employer if the machine pointers, good runtime performance and excellent
paper was prepared within the scope of employment. memory performance with binary compatibility is achieved.
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
Thelow-fatpointerapproachisfeasibleon64-bitsystemswith
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23287 sufficient pointer bit-width, such as the x86_64.The main challenge for low-fat pointers is that sufficient - Data Flow attacks [6], [13], where a data value is
control over the memory allocator is required in order to overwritten causing the program to misbehave in a way
enforcethepointerencoding.Thisisfeasiblefortheheapallo- beneficial to the attacker, e.g., privilege escalation.
cator (e.g., malloc), but is more difficult for stack allocations
OOB reads can lead to:
wheretheplacementofobjectsinmemoryishighlyrestricted.
This is a major deficiency since many buffer/object overflow - Information Leakage attacks, such as the exploitation of
bugs still affect the stack [1]. the Heartbleed bug [12]. This can also be seen as a
subclass of data flow attacks.
In this paper, we show how to extend low-fat pointers
to stack objects, thereby enjoying the same bounds overflow One effective method for preventing OOB-errors is bounds
protectionasheapobjects.Toachievethis,weintroducealow- checking instrumentation. The basic idea is as follows: given
fat stack allocator, that replaces the default stack allocation a pointer p associated with an object O with base address
scheme automatically inserted by the compiler, but ensures (base) and size (size), then p is out-of-bounds with respect to
that pointers to allocated stack objects satisfy the location and O if the following test (isOOB) succeeds:
alignment requirements of the low-fat pointer encoding. The
(p<base) || (p>base+size−sizeof(*p)) (isOOB)
low-fat stack allocator uses a variety of techniques introduced
in this paper, such as fast allocation size over-approximation, Object bounds errors can be prevented by instrumenting every
dynamicstackobjectalignment,stackobjectpointermirroring memory read or write involving p as follows (instrumentation
(for location), and memory aliasing optimization to keep code is shaded):
memory overheads low. Our solution specially focuses on the
if (isOOB(p,base,size))
key practical barriers against adoption, such as overheads and
error();
software/binary compatibility. Good software compatibility is
v = *p; or *p = v;
achievedbytransparentlysupportingCandC++features,which
make direct use of the stack, e.g., setjmp/longjmp, C++
Herefunctionerror()reportstheboundserrorandabortsthe
exceptions. Binary compatibility is achieved because: (a) the
program—preventing any control/data or information leakage
representation of pointers and the ABI is unchanged (low-fat
attacks. The object’s size and base is otherwise known as the
pointerareregularmachinepointers);and(b)un-instrumented
bounds meta information.
codecanbefreelymixedwithinstrumentedcodethatsupports
bounds checking (e.g., can link un-instrumented libraries).
A. Traditional Bounds Checking Methods
We have implemented a version of the low-fat heap+stack
allocatorsforCandC++ontheLinuxx86_64systemarchitec- Over the years many different bounds check instrumenta-
ture. We experimentally evaluate the implementation against tionsystemshavebeenproposed.Mostdifferontheunderlying
the SPEC 2006 benchmarks [23], the Apache web server, implementation technology, which we summarize below.
the Wilander [28] and RIPE [29] benchmarks, as well as SystemssuchasSafe-C[4],CCured[20]andCyclone[15]
several recent CVEs concerning stack object overflows. We use “fat pointers” which fuse pointer values and associated
show that runtime overheads are competitive: a 54% overhead bounds meta information into one unified object, e.g.:
for memory read+write instrumentation on SPEC 2006 (while
protectingbothheapandstack),anda17%overheadbyinstru- struct { void *ptr; void *base; size_t size; }
menting memory writes only. Memory overheads are as low
The program is transformed such that fat pointer objects
as 3%. Our performance figures are significantly better than
replacenativemachinepointers.Boundsmetainformationcan
AddressSanitizer [22] memory error sanitizer and comparable
then be read directly from the fat pointers, e.g., (p.base)
totheoriginalworkof[10]thatprotectsheapobjectsonly.The
and (p.size), and this information can be used for bounds
Wilander, RIPE and CVEs benchmarks show that our method
check instrumentation. That said, there are several significant
iseffectiveatprotectingagainststackobjectboundsoverflows
disadvantagestothisapproach,namely:problemsarisingfrom
for both artificial and real-world test cases.
changes to memory layout, high performance overheads, in-
creasedmemoryoverheads,andnearzerobinarycompatibility.
II. BACKGROUND
FatpointerschangetheunderlyingABI,meaningthatlibraries
Objectboundserrors(e.g.,bufferoverflows)areaperennial (includingsystemlibraries)mustberecompiledormarshalled.
problem for low-level programming languages such as C and
C++. There exists a significant body of previous literature An alternative to fat pointers is to store (some represen-
regarding proposed solutions and mitigations, including [3], tation of) the bounds meta information in a shadow space or
[4], [9], [10], [11], [14], [15], [19], [20], [22], [30] amongst shadow memory that is separate from the main memory of the
others.Inthissectionwegiveabriefoverviewofthedifferent program. Some form of shadow memory is used in memory
approaches. safetysystemssuchasSoftBound[19],PAriCheck[30],Baggy
Bounds Checking [3], [9], MudFlap [11] and Intel MPX [14].
The threat model for bounds errors is well known, so we
The basic idea is to map objects/pointers in the main memory
only provide a summary below. An attacker can induce an
to associated meta information stored in the shadow memory.
Out-of-Bounds (OOB) memory write to corrupt other objects
AddressSanitizer[22]usesaslightlydifferentapproachinthat
in memory. This forms the basis of several kinds of attacks:
shadow memory is used to track poisoned red-zones placed
- Control Flow Hijacking attacks, where the attacker over- around objects. Here, an overflow into a red-zone is detected
writes a code pointer (e.g. a return address on the stack) as an error. That said, overflows that skip red-zones into other
to gain control over the execution of the program. valid objects may not be detected.
2Shadow memory schemes tend to have better binary com- performanceoverheadsareverygood:∼8.4%forCPI,∼1.9%
patibility since the layout of objects in main memory has not for CPS, and <0.1% for SafeStack [16].
changed. That said, binary compatibility is not perfect. For
One problem with shadow-stacks, CFI, CPI, CPS, and
example, linking against un-instrumented code that allocates
SafeStackschemesisthattheyonlytargetcontrolflowattacks
memory without updating the corresponding shadow memory
(with varying degrees of completeness). Turing completeness
may lead to inconsistencies that cause program misbehavior.
of non-control data attacks means that arbitrary code exe-
Another problem is that shadow memory consumes additional
cution can happen even without a control-flow attack [13].
resources leading to higher memory overheads.
Conversely, DFI only targets data flow attacks but not control
Another difference between bounds instrumentation sys- flow. Bounds checking can protect against control flow, data
tems is the scope of the OOB-error protection. For example, flow and information leakage attacks, all at once.
PAriCheck[30]andBaggyBoundsChecking[3],protectarray
bounds errors only. In contrast, systems such as AddressSan- III. LOW-FATPOINTERS
itizer [22] and SoftBound [19] also protect against overflows
arisingfromimplicitpointerarithmeticfromfieldaccess(e.g., Low-fat pointers [10], [17] are a recent method for track-
p->val). Furthermore, most bounds instrumentation systems, ing bounds meta information that takes advantage of 64-bit
suchas[3],[10],[30],protectagainstallocationboundsonly— systems with sufficient pointer bit-width. The basic idea is
meaning that only overflows beyond the allocation size of to encode bounds meta information within the representation
the object (including any padding added by the allocator) of machine pointer itself. This is in contrast to fat pointer
are detected. Overflows into padding are normally considered or shadow space methods that store bounds meta information
benign (such an overflow cannot overwrite code pointers nor explicitly in separate memory. Many possible low-fat pointer
data values and is generally not exploitable). These systems encodings are possible:
also do not detect sub-object bounds overflows. However, Example 1 (A Hypothetical Low-Fat Pointer Encoding):
the issue is complicated by the fact that many sub-object
The following is a simple low-fat pointer encoding:
bounds overflows are intentional, e.g., initializing an object
with memset. union { void *ptr;
struct {uintptr_t size:10; // MSB
B. Other Protection Mechanisms uintptr_t unused:54; } meta;} p;
Duetothecostandcompatibilityissuesofboundschecking Here (p.ptr) is a native machine pointer to an object that
many other different protection mechanisms have been pro- also stores the object size (p.size) in the upper 10 bits. The
posed. These alternatives generally attempt to disrupt attacks base pointer of p can be stored implicitly by ensuring that all
or protect control flow rather than prevent memory errors. We objects are aligned to multiples of the object size. The base
giveabriefoverviewofsomeofthemoreprominentsolutions. can therefore be retrieved by rounding (p.ptr) down to the
nearest object size multiple. Variable p is a low-fat pointer
ASLR [21] randomizes memory layout and DEP [27] pre-
since (a) p is a regular machine pointer (via cast p.ptr), and
vents data execution. These methods aim to frustrate attacks.
(b)pcanbeusedtoextractboundsmetainformation,e.g.,the
ASLR is widely deployed, but implementations tend to be
object size via (p.size) and the object base via rounding.
incomplete for performance/compatibility reasons.
Shadowstacks[8]splitthestackintotwoparts:a“shadow” The hypothetical encoding from Example 1 is difficult to
stack for storing sensitive data such as code pointers (e.g., the implement in practice as it imposes strong constraints on the
return address) and the main stack for storing everything else. program’s virtual address space layout. Other low-fat pointer
Another variant [31] splits the stack into multiple parts based encodings have been proposed, including [17] (for specialized
onobjecttype.Securityisderivedfromthephysicalseparation hardware) and a more flexible encoding [10] for standard
of the main and shadow stacks. Traditional shadow stacks architectures such as the x86_64.
store code pointers contiguously, and parallel shadow stacks
doublestackmemorytomaintainaone-to-onecorrespondence A. Flexible Low-Fat Pointers
between main and shadow locations. Performance overheads
In this paper we use the more flexible encoding from [10]
rangefrom∼10%fortraditional[8],∼4%forparallel[8],and
which is summarized below. The flexible encoding was ini-
<1% for multi-stacks [31].
tially designed for heap allocation only, i.e., low-fat replace-
Control Flow Integrity (CFI) [2] ensures that all indirect ments for the malloc-family of functions (malloc, realloc,
jumps target some statically determined set of valid locations. memalign, etc.). The main contribution of this paper is to
The performance overhead of CFI is ∼16% [2]. Data Flow extendthisencodingtostackallocationinadditiontotheheap.
Integrity (DFI) [5] is analogous to CFI but for data-flow
The basic idea of the flexible low-fat encoding from [10]
attacks. The overhead of DFI is higher at ∼104% [5].
is to divide the program’s virtual address space into several
Code Pointer Integrity (CPI) [16] and the relaxation Code regions of equal size (as specified by a REGION_SIZE param-
Pointer Separation (CPS) use program analysis and instru- eter). Regions are contiguous and can be very large, e.g., the
mentation to isolate code pointers into a separate region of implementation in this paper assumes REGION_SIZE=32GB.
memory. The protection is similar to that of shadow stacks, Regions are further classified into two main types: low-fat
butalsocoverscodepointersinglobalsandheapobjects(e.g., regions and non-low-fat regions (or non-fat regions for short).
C++ virtual method tables). SafeStack [16] is a stack-specific Low-fatregionsarereservedforthelow-fatheapallocator,and
instance of CPS. Because code pointers are typically sparse, non-fat regions cover everything else (including text, global,
3txet. atad.
ssb. krb
1#
paehbus
2#
paehbus
3#
paehbus
M#
paehbus
kcats
0x0 32GB 64GB 96GB 128GB M×32GB
... ...
region#0 region#1 region#2 region#3 region#M region#stack
Fig.1. Programvirtualaddressspacelayoutillustration.
stack and file mappings, etc.). Figure 1 illustrates the low-fat over the placement and alignment of objects. However, satis-
scheme used in [10] and extended in this paper, as follows: fyingtheseconditionsismorechallengingforstackallocation,
as will be discussed later in this paper.
- The stack is placed in the non-fat region labelled #stack.
- Globals and code (bss, data, text) are placed in the 2)Reconstructing Meta-information: A pointer p that
non-fat region #0. points to (possibly the interior of) a low-fat object is a low-
- The heap is split into several sub-heaps that are placed fat pointer. We can reconstruct the size and base bounds meta
in low-fat regions #1 to #M. information from p using the following operations:
Eachofthelow-fatregions#1-#M isassociatedwithaspecific size(p)=TABLE[p / REGION_SIZE].size
allocation size (or allocSz for short) that is determined by a
base(p)=(p / size(p)) * size(p)
size configuration (or Sizes) parameter. The size configuration
represents the sequence of allocation sizes supported by the Here (/) and (*) are 64-bit integer division and multiplication
low-fat heap allocator. For example, the size configuration: respectively, and TABLE is a pre-defined lookup table2 that
maps the region index, computed by (p / REGION_SIZE), to
Sizes=(cid:104)16,32,48,64,80,96,..(cid:105)
the corresponding allocation size from the size configuration
specifies that the low-fat allocator supports allocation sizes of (Sizes).ThesizeoftheobjectcanthenberetrievedbyaTABLE
16bytes (region #1), 32bytes (region #2), 48bytes (region #3), lookup. The base of the object is calculated by rounding p
etc. During allocation, the requested object size (i.e., the size down to the nearest multiple of size(p); taking advantage of
parameter to malloc) is rounded-up (over-approximated) to thelow-fatalignmentcondition.Thebase(p)operationcanbe
the nearest allocation size (allocSz) that fits. For example, optimized using bit-masks if Sizes are all powers-of-two or
consider an object O of type char[50] with an object size of fixed point division otherwise. See [10] for more details.
size=sizeof(O)=50.Assumingtheabovesizeconfiguration,
Not all pointers are low-fat (e.g., code, globals, file map-
size will be rounded up to an allocation size of allocSz=64
pings). To handle non-fat pointers, we define:
by adding 14bytes of padding. To be consistent with the C
standard, at least one byte of padding is always added (so TABLE[I].size=SIZE_MAX I (cid:54)∈1..M
allocSz>size) to ensure the pointer-to-the-end-of-an-object is
never considered OOB. for all non-fat regions #I. Thus, if q is a non-fat pointer, then
size(q) = SIZE_MAX (largest possible size) and base(q) =
Thelargeregionsize(32GB)ensuresthatitisunlikelyany 0=NULL.Bydesign,non-fatpointershavethewidestpossible
given region will be exhausted for a typical program. If a full bounds, and thus will “pass” any bounds check. This property
region does occur, this can be handled by returning ENOMEM of non-fat pointers is essential for binary compatibility.
or by reverting to libc malloc as a fail-safe, depending on
theconfiguration.Unusedmemory,includingpaddingonlarge
B. Bounds Checking with Low-Fat Pointers
(>1 page) objects, is marked as NORESERVE1 meaning that it
will not consume physical memory (RAM/swap) resources. With low-fat pointers we can reconstruct bounds meta
informationandusethisfordynamicboundscheckinstrumen-
By design, the memory layout described in Figure 1 is
tationthatenforcesspatialmemorysafety.Toassociatebounds
compatible with the traditional layout of a standard Linux
meta information with pointers, we transform the program
process.Thatis,thestandardmemorysegments(text,stack,
using the meta information propagation schema from [10].
etc.) are all placed in their standard locations.
The transformation is applied automatically using an LLVM
1)Low-fat Conditions: In order to implement low-fat compilerinfrastructure[18]pass.Thebasicideaissummarized
pointers, the heap allocator allocates objects O (of allocation as follows: for a given function f, the size(p) and base(p)
size allocSz) according to the following conditions: primitives are used to construct meta information for all input
pointers p. Here an input pointer p is any pointer value that
• Region: The object O is allocated from the sub-heap in
is a function argument (f(int *p) {..}), return value from
region #I, where Sizes[I]=allocSz; and
another call (p = g(..)), read from memory (p = *q), or
• Alignment: The object O is allocSz-aligned.
castfromaninteger(p = (int *)i).Next,metainformation
An object O that satisfies these conditions is known as a low- ispropagatedusingthefollowingrule:ifapointerq isderived
fatobject.Bothlow-fatconditionsarerelativelyeasytosatisfy from pointer p through pointer arithmetic (e.g., p=q+100),
for heap allocation, where the allocator has significant control then q inherits the same meta information as p. Note that,
1Seethemmapmanpage. 2TABLEisread-onlyandsmall(oneentryper32GB region).
4void memcpy(void *dst, void *src, int n) goodsoftwarecompatibilityandexcellentbinarycompatibility.
1
{
2 Binary compatibility is a consequence of the fact that low-
void *dst_base = base(dst);
3 fatpointersarealsoregularmachinepointers,andcantherefore
size_t dst_size = size(dst);
4
be passed to and from non-instrumented code without any
void *src_base = base(src);
5
size_t src_size = size(src); special handling or marshalling. Likewise, non-fat pointers
6
for (int i = 0; i < n; i++) { generatedbynon-instrumentedcodeareautomaticallycompat-
7
void *dst_tmp = dst + i; ible with instrumented code, albeit without bounds protection.
8
9 void *src_tmp = src + i; Binary compatibility is very important in practice [24], since
10 if (isOOB(dst_tmp, dst_base, dst_size)) it is not always possible to recompile code, such as system or
11 error(); external proprietary libraries.
if (isOOB(src_tmp, src_base, src_size))
12
13 error(); Thelow-fatpointerencodingalsoachievesahighdegreeof
14 *dst_tmp = *src_tmp; softwarecompatibility.Themainsourceofsoftwareincompat-
15 } ibilityarisesfromcodethatintentionallycreatesOOB-pointers
}
16 (technically undefined behavior under the C standard). That
said, many intentional OOB-pointers are compatible, provided
Fig.2. Instrumentedversionofsimplememcpy. the (1) OOB-pointer is not accessed (read or write) and (2)
does not escape according to the rules in Section III-B1.
Exceptions include some uncommon programming idioms,
contrarytosomerelatedwork(e.g.,[3],[30])wealsoconsider
such as: using base−1 as a sentinel, accessing arrays via
field access (e.g., q =&p->val) to be pointer arithmetic.
offsets (e.g. using (a−k)[k] to access a[0]), and copying
Example 2 (Instrumented Memory Copy): The following objects using pointer difference. Such idioms are relatively
simplified memcpy is to show meta information propagation. rare in practice—with only 24 functions out of the SPEC
2006 benchmark (∼1.1 million lines of C/C++ code) being
void memcpy(void *dst, void *src, int n) {
affected [10]. The rest of the SPEC 2006 code is compatible
for (int i = 0; i < n; i++) dst[i] = src[i];
without any additional modification.
}
Low-fat pointers are not compatible with all machine ar-
The instrumented form is shown in Figure 2 with the instru-
chitectures.Specifically,low-fatpointerencodingsassumethat
mentation highlighted. Here, dst and src are input pointers, thenativepointerbit-widthissufficienttoencodeboundsmeta
and dst_tmp and src_tmp are derived pointers from pointer information. In practice this means only 64-bit architectures
arithmetic.Theboundsmetainformationfortheinputpointers
(such as the x86_64) are supported. We do not consider
is calculated on lines 3-6. The memory operation on the
this to be a significant limitation as 64-bit architectures are
derived pointers (line 14) is protected by the bounds checks
commonplace. For the rest of the paper, we assume the
on lines 10-13.
underlying target architecture is the x86_64. The paper is
By design, the code in Figure 2 is compatible with both written targeting x86_64 assembler and Linux where needed
low-fat and non-fat pointers. However, only low-fat pointers to clarify details.
enjoy bounds protection. For non-fat pointers, the size and
base operationsreturn“widebounds”meaningthattheisOOB IV. LOW-FATSTACKALLOCATION
checks on lines 10-13 never fail.
The flexible low-fat pointer encoding presented in Sec-
1)Handling OOB Pointers: Bounds meta information
tion III was initially designed for heap allocation only. This
propagation handles the case where the input pointer is within
means that stack allocated objects are non-fat by default and
bounds, and a subsequent derived pointer is out-of-bounds.
thus are not protected against bounds errors. In this section,
However, it does not handle the case where the input pointer we design a new stack allocator, called the low-fat stack
itself is already out-of-bounds. To catch such cases [10] allocator, that extends the coverage of the flexible low-fat
enforces a global invariant that all escaped pointers must be
pointer encoding to also include stack objects. The low-fat
within bounds. Here, an escaping pointer p is any pointer that
stack allocator aims to retain all of the desirable properties of
is passed to another function as an argument (f(p)), returned
the default stack allocator, such as efficiency and automatic
from the current function (return p), written to memory
stack object deallocation (for both normal and abnormal con-
(*r = p), or cast to an integer value (i = (int)p). OOB- trol flow). The latter excludes replacing stack allocation with
pointers are prevented from escaping by inserting a bounds heap allocation, such as that with CCured’s heapified stack
check before the relevant operation, i.e.:
objects[20].Furthermorewewishtoretaintheexistingflexible
p = q + k; low-fat pointer encoding so that stack and heap allocation are
if (isOOB(p, q_base, q_size)) compatible.
error();
Thelow-fatstackallocatormustallocateobjectsaccording
i=(int)p; or *r=p; or f(p); or return p;
to the alignment and region conditions from Section III-A1.
Satisfying these conditions is not a problem for the heap
C. Compatibility allocator(whichhassignificantfreedomregardingthelocation
and alignment of objects). However, stack allocation is much
The flexible low-fat pointer encoding and bounds instru-
more restricted:
mentation summarized in Sections III-A and III-B achieves
51) Stack allocation works by modifying the stack pointer void f(int len) {
whichcanonlyeverpoint-to/allocate-fromasingleregion int x; // Local variable
of memory. Under the reasonable assumption that stack int buf1[50]; // Local array (fixed-length)
objects are not of uniform size, it is necessary to allocate float buf2[len]; // Local array (variable-length)
char *buf3 = alloca(len); // Explicit allocation
objects from different memory regions.
... }
2) The stack pointer is only guaranteed to be aligned to the
default system stack alignment, typically 8 or 16 bytes.
Stack space for &x/buf1/buf2 will be implicitly allocated
Low-fat objects are required to be aligned by allocation
by code generated by the compiler. Stack space can also be
size. Furthermore, for variable sized objects, such as explicitly allocated using the alloca standard library call,3
variable length arrays (VLAs), the stack alignment must where alloca(size) allocates size bytes of space from the
be calculated dynamically for a given object size.
stack frame of the caller. Here buf3 is allocated using this
method.
Problem 1) will be addressed by splitting the stack across
several regions—one for each potential stack object allocation Without loss of generality, we shall assume that all stack
size. The result of a stack allocation will be a pointer to local allocations are of the explicit alloca-form:
stackmemorycontainedwithintheappropriatelow-fatregion.
The challenge for such a split is twofold: (a) maintaining a void *ptr = alloca(size); (STACKALLOC)
small allocation state that is compatible with the default stack
Hereinputsize istheobjectsizeandoutputptr istheresulting
allocator(e.g.,usedbyun-instrumentedcode),and(b)avoiding
pointer to the stack allocated object. All other forms of stack
excessmemoryusagecausedbyfragmentingstackobjectsover allocation are rewritten into the (STACKALLOC) form, e.g.:
multiple memory regions. We shall present solutions to both
of these challenges. Problem 2) will be addressed by suitably int x &x=alloca(sizeof(int))
int buf1[50] → buf1=alloca(50*sizeof(int))
aligning all low-fat stack allocated objects.
float buf2[len] buf2=alloca(len*sizeof(float))
Fortherestofthissectionweshallreviewthedefaultstack
The LLVM compiler infrastructure [18] already does such a
allocator,discusssomeassumptions,andthenpresentthelow-
transformation internally.
fat stack allocation schema.
2)Default Stack Allocator Implementation: The default
stack allocator implementation is compiler, hardware and
A. Default Stack Allocation
operating-system specific. For this paper, we assume the de-
On most systems, stack objects are (de)allocated by ad- fault stack allocator as implemented by the LLVM compiler
justing the stack pointer. For example, on the x86_64 (where infrastructure [18] for the Linux x86_64 target. That is, stack
the stack grows down towards low memory addresses), the (de)allocation is implemented by (de-)incrementing the stack
allocationofanS-byteobjectistraditionallyhandledbydecre- pointer that is stored in the %rsp register. The low-fat stack
mentingthestackpointerregister(%rsp)byS bytes.Likewise allocation method presented in this paper can be adapted to
the object can be deallocated by incrementing %rsp by S other compilers and targets.
bytes—restoring the old value of the stack pointer. Compilers
3)A Special Size Configuration for Stack Allocation: The
emit code that automatically deallocates all stack objects on
size configuration (Sizes) specifies the set of all allocation
function exit and (in the case of optimizing compilers) when
sizes supported by the low-fat heap allocator. For low-fat
stack objects go out-of-scope under the C/C++ scoping rules.
stack allocation, we shall assume a special stack-specific
From the point of view of the programmer, stack allocation
sizeconfiguration(StkSizes)thatcomprisesthepowers-of-two
has several advantages, namely:
subset of Sizes. Here StkSizes can be defined as follows:
- Efficiency ((de)allocation is a few instructions);
StkSizes=Sizes∩{16,32,64,128,..}
- Automaticlifetimemanagementanddeallocationonfunc-
tion exit, including normal return or abnormal function We assume Sizes contains a reasonable StkSizes subset. Ap-
exit such as C++ exceptions or longjmp. pendix A gives the configuration used by our implementation.
- Small allocation state (single word stack pointer).
ThemotivationforStkSizesistospeeduplow-fatstackal-
Stack objects are allocated from stack memory, which is location(andfastallocationisimportantforthestack).Specif-
created by the operating system before the program starts. ically, powers-of-two sizes allow for efficient stack object
Since stack memory is outside the low-fat heap regions #1- allocationsizeover-approximation(discussedinSectionIV-C)
#M (see Figure 1), stack objects are non-fat by default. andallocationsizealignment(discussedinSectionIV-D).The
main disadvantage is that the more coarse-gained size config-
uration leads to higher memory over-approximation overheads
B. Assumptions
for stack allocated objects. We note that this does not affect
In order to simplify the low-fat stack allocator we make heap allocated objects which continue to use the original fine-
several assumptions that are listed below. The assumptions grained size configuration (Sizes).
include:ageneralizedstackallocationtemplate,theimplemen-
Weshallnowintroducethelow-fatstackallocationschema
tation details of the default stack allocator, and a restricted set
that replaces default stack allocation represented by the tem-
of allocation sizes supported by the low-fat stack allocator.
plate (STACKALLOC) defined above. The schema is divided
1)Stack Allocation Template: Stack allocation has many
forms, as illustrated by the following pseudo-code: 3Seetheallocamanpage.
6into three parts: allocation size over-approximation (Sec- 50bytes, i.e. size=50, then
tionIV-C),allocationsizealignment(SectionIV-D),andstack
index(size)=clz(50)=58
object pointer mirroring (Section IV-E).
allocSz =SIZES[58]=64
C. Allocation Size Over-approximation Note that the indexes idx∈60..64 correspond to object sizes
ofsize∈0..15bytes.Thesemaptotheminimumallocationsize
During allocation, the object size is over-approximated
of 16bytes.
(a.k.a. rounded up) to the nearest size from StkSizes that fits.
For stack allocation, it is important for this operation to be
fast. Our basic approach is to map object sizes to allocation D. Allocation Size Alignment
sizes using a lookup table. This is a two-step process:
Low-fat objects are required to be aligned to a multiple of
1) First the object size (size) is mapped to an index (idx ∈ the allocation size as specified by the alignment condition of
0..64) using a suitable logarithmic index function we Section III-A1. To support dynamic alignment, we use a pre-
name index(size). One possible definition is:4 computed MASKS lookup table (analogous to the SIZES table
defined above). The MASKS table is defined as follows:
idx =index(size)=(cid:100)log (size+1)(cid:101)
2 MASKS[i]=UINT64 MAX << log (SIZES[i])
2
2) Nextweuse(idx)tolookupthecorrespondingallocation
Given allocSz =SIZES[i], a pointer p can be allocSz-aligned
size from a pre-defined lookup table we name SIZES.
by the bit-mask operation (p & MASKS[i]). This is possible
OurapproachtakesadvantageofthefactthatStkSizescontains because stack allocation sizes are always powers-of-two. The
onlypower-of-twosizes,meaningthatthebase-2logarithmof schema for aligned stack allocation is therefore:
each allocation size maps to a unique index. The schema for
allocation size over-approximation is therefore as follows: .
.
.
size_t idx = index(size); %rsp = %rsp - allocSz;
size_t allocSz = SIZES[idx]; uint64_t mask = MASKS[idx];
%rsp = %rsp & mask;
void *ptr = %rsp;
Here size is the input object size and allocSz is the resulting
allocation size. The SIZES table is pre-computed as follows:
Here (idx) and (allocSz) are calculated according to the
fits(allocSz,i)=∀size,index(size)=i:size ≤allocSz schemafromSectionIV-Cwhichisrepresentedbythevertical
ellipses. Aligned stack allocation proceeds as follows:
SIZES[i]=min {allocSz ∈StkSizes | fits(allocSz,i)}
1) Stackspaceisreservedbydecrementingthestackpointer
Essentially SIZES[i] is the “best-fit” allocation size with re-
%rsp by the allocation size of allocSz bytes.
spect to all possible object sizes (size) where i=index(size).
2) Next the stack pointer %rsp is allocSz-aligned by mask-
A suitable choice for the index function (index) depends ing %rsp with mask=MASKS[idx].
onwhatcanbeefficientlyimplementedforagivenunderlying 3) Finally, pointer ptr is set to the now allocSz-aligned
system architecture. For the x86_64, a good choice is the stack pointer %rsp. The allocated object spans addresses
leading zero count function (clz) that returns the number of ptr..ptr +size, where size is the original object size.
leading zero bits in a 64-bit word, defined as follows:
In LLVM, the stack pointer register %rsp can be indirectly
clz(size)=64−(cid:100)log (size+1)(cid:101) manipulated using the stack_save/stack_restore builtins.
2
Example 4 (Alignment): WecontinueExample3.Suppose
For example, clz(50)=clz(0x32)=58. The leading zero count
that the stack pointer is %rsp=0x7fff00001110 and given:
function is available as an LLVM [18] compiler built-in
function (clzll) which compiles down a single leading zero
index(50)=clz(50)=58 allocSz =SIZES[58]=64
count instruction (lzcnt) on modern versions of the x86_64
architecture. On older x86_64 CPUs, that do not support the then aligned stack allocation proceeds as follows:
lzcntinstruction,bitscanforward (bsf)isagoodsubstitute.5
%rsp:=0x7fff00001110−64=0x7fff000010d0
Example 3 (Over-approximation): Assuming that leading %rsp:=%rsp & MASKS[58]
zerocountisusedastheindexfunction,thentheSIZESlookup
=0x7fff000010d0 & (UINT64 MAX << 6)
table is defined as follows:
=0x7fff000010c0=ptr
SIZES[57]=128 SIZES[61]=16
SIZES[58]=64 SIZES[62]=16 By design, the output ptr is allocSz-aligned, i.e.
···
SIZES[59]=32 SIZES[63]=16
0x7fff000010c0 mod 64=0
SIZES[60]=16 SIZES[64]=16
Suppose the program intends to allocate a stack object of size E. Stack Object Pointer Mirroring
4Theincrement(size+1)ensures(allocSz>size),seeSectionIII-A. Thedefaultstackallocatorallocatesobjectsfromanon-fat
5Themaindisadvantageofbsfisthatitisundefinedforsize=0. region (region #stack in Figure 1) meaning that stack objects
7txet. atad.
ssb. krb
kcats
0x0 32GB 64GB 96GB 128GB
... ...
region#0 region#1 region#2 region#3 region#M region#stack
1#
kcats
2#
kcats
3#
kcats
M#
kcats
M×32GB
Fig.3. ModifiedProgramvirtualaddressspacelayoutillustration.
are non-fat by default. For the low-fat stack allocator, the memory—thereby reducing memory overheads.
region condition (Section III-A1) requires that objects are al-
1)Stack Memory Layout: To implement virtual stacks, the
locatedfromthelow-fatregioncorrespondingtotheallocation
program’s virtual address space layout of Figure 1 is modified
size.Toachievethis,thissectionintroducesthenotionofstack
to that shown in Figure 3. The main difference is that each
objectpointermirroringthatmapsnon-fatstackobjectpointers
region #I is now partitioned into disjoint stack and heap sub-
to an equivalent low-fat pointer to the corresponding region.
regions, as represented by the dashed lines bisecting each
We show that pointer mirroring preserves the key properties
low-fat region. Each virtual stack #I is wholly contained
of the default stack allocator, namely: automatic deallocation,
within the stack sub-region #I. The exact partition between
a small allocator state and compatibility with existing code.
the heap and stack sub-regions is left as a design choice. Our
The basic idea of pointer mirroring is to split the main implementation reserves 4GB for the stack sub-region6 and
program stack into several region-local virtual stacks, one 28GB for the heap sub-region (for a 32GB total region size).
for each possible allocation size from (StkSizes). Here each Eachvirtualstack#I isconfiguredtosatisfythefollowingkey
region-local virtual stack #I is wholly contained within the properties:
low-fat region #I. When space for an object (of allocation
1) Samesize:Themain/virtualstacksarethesamesize;and
size allocSz) is allocated on the main program stack, the
2) Same offset: The base address of virtual stack #I relative
corresponding space for an object (of size allocSz) will be
toregion#I isequaltothebaseaddressofthemainstack
implicitly allocated on virtual stack #I. The pointer to the
relative to region #stack, thus giving the relationship:
original space on the main stack is thus “mirrored” by the
pointer to the space on virtual stack #I. The mirrored pointer
base −base =base −base
islow-fatsinceitsatisfiesthealignmentandregionconditions, stack#I region#I stack region#stack
and will be afforded OOB-error protection in instrumented Here base represents the base address of object.
object
code. The main stack (in region #stack) is not completely
replaced by the virtual stacks and is retained for several The purpose of these properties is to establish the following
reasons: linear relationship between a pointer (ptr) to the main stack
and “mirrored pointers” (ptr ) to each virtual stack #I:
#I
- Function prologue/epilogues;
- Register spills and other non-fat stack allocations that do ptr =ptr +(I−4095)×REGION SIZE (MIRRORING)
#I
not need OOB-error protection; and
- Compatibility with non-instrumented code. Here the constant 4095 is region index of region #stack. The
virtualstackpointer#I foreachI isdefinedtobethemirrored
Essentially, each virtual stack #I is analogous to the main main stack pointer (%rsp).
stack, but is specialized for objects of the specific allocation
size corresponding to low-fat region #I. One problem is how 2)Implementation: Assuming the modified layout de-
to maintain the virtual stack state analogous to the main stack scribed above, pointer mirroring is implemented using a pre-
state, a.k.a. the stack pointer (%rsp). Explicitly maintaining computed OFFSETS lookup table analogous to the SIZES and
separate virtual stack pointers conflicts with our design goal MASKS tables defined previously. The OFFSETS table contains
of keeping the overall low-fat stack allocator state small. For the pointer difference between the main stack and the virtual
example,afunctionreturnorlongjmpwouldrequirerestoring stack corresponding to each allocation size. Pointer mirroring
all virtual stack pointers, rather than one (%rsp) in the default can then be achieved by the addition of the appropriate entry
case. To solve this problem we represent each virtual stack from the OFFSETS table to a main stack object pointer.
pointerimplicitlyasalinearfunctionofthemainstackpointer
TheOFFSETStableisindexedbytheindex(size)function,
(%rsp), similar to parallel shadow stacks [8]. In the case of
and is defined as follows:
function return and longjmp, restoring the main stack pointer
(%rsp) to an old value also implicitly restores all virtual stack OFFSETS[i]=(I−4095)×REGION SIZE
pointers.
Here I is the region index corresponding to SIZES[i] and
Initially, we assume the na¨ıve approach where the main
constant 4095 is region index of region #stack.
stack and virtual stacks are distinct physical regions of mem-
ory. This is potentially wasteful: as the overall stack memory Apointer(ptr)toamainstackallocatedobjectismirrored
usage is, in the worst case, multiplied by the total number of to the appropriate virtual stack using the following schema:
virtualstacks.LaterinSectionVIweshallintroduceamemory
aliasingoptimizationthatmapsallstackstothesamephysical 6Enoughtosupportmultiplestacksformulti-threadedprograms.
8/* Compute allocation size (Section IV-C). */
. size_t idx = index(size);
.
.
size_t allocSz = SIZES[idx];
int64_t offset = OFFSETS[idx];
ptr = ptr + offset;
/* Allocate aligned object (Section IV-D). */
%rsp = %rsp - allocSz;
Note that since the region size (REGION_SIZE) and stack uint64_t mask = MASKS[idx];
allocation sizes (StkSizes) are both powers-of-two, pointer %rsp = %rsp & mask;
mirroring will preserve the allocation size alignment of the void *ptr = %rsp;
transformed pointer. The resulting mirrored pointer therefore
satisfies both the low-fat alignment and region conditions, and /* Mirror allocated pointer (Section IV-E). */
thus will enjoy OOB-error protection in instrumented code. int64_t offset = OFFSETS[idx];
ptr = ptr + offset;
Example 5 (Pointer Mirroring): We continue Example 4:
Fig.5. Thecompletelow-fatstackallocationschema.
allocSz =64 idx =58 ptr =0x7fff000010c0
Thefinalstepistomirror(ptr)totheappropriatevirtualstack. (c) Thestackpointer%rspisalignedtoanallocSz-boundary
Assuming the size configuration (Sizes) from Appendix A,
(Example 4);
then allocSz =64 corresponds to region #4, thus:
(d) The final state with %rsp=0x7fff000010c0;
OFFSETS[58]=(4−4095)×REGION_SIZE=−140565689663488 (e) The final state of virtual stack #4, where (OBJECT) is
allocated at virtual stack pointer #4 (Example 5):
ptr :=ptr +OFFSETS[58]
%rsp+(4−4095)×REGION SIZE=0x27000010c0.
=0x7fff000010c0+(−140565689663488)
=0x27000010c0 Low-fat stack deallocation is identical to that of the default
stack allocator, and is achieved by restoring the stack pointer
The resulting mirrored pointer ptr =0x27000010c0 satisfies %rsp to its original value 0x7fff00001110. This implicitly
the region and alignment conditions of low-fat pointers: restores the virtual stack pointer #4 to its original value of
0x2700001110, thereby deallocating (OBJECT).
• region condition: (0x27000010c0 / REGION_SIZE)=4
• alignment condition: 0x27000010c0 mod 64=0 We shall now discuss compatibility issues and optimiza-
tions of the low-fat stack allocator.
Object pointer mirroring is similar to shadow stacks [8],
[31], which also splits the main stack into distinct regions of
V. COMPATIBILITY
memory. The main difference is how security guarantees are
enforced: we rely on the low-fat pointer encoding and bounds One of the main advantages of low-fat pointers is that
checking instrumentation, whereas shadow stacks mitigate they maintain very high compatibility with existing non-
control flow attacks by physically separating memory. In the instrumented binary code. This is because (a) low-fat pointers
caseofpointermirroring,itisnotrequiredthatthememorybe are regular machine pointers, so the binary interface (ABI)
physicallyseparated,aswillbeexplainedfurtherinSectionVI. remains unchanged, and (b) there is no shadow memory that
needs to be maintained, which is especially problematic for
non-instrumented code. Although binary compatibility is a
F. Low-fat Stack Allocation
securitytrade-off(non-instrumentedcodeisnotaffordedOOB-
Finally, we combine allocation size over-approximation error protection), in practice it is not always possible to re-
(Section IV-C), allocation size alignment (Section IV-D) and compile and re-instrument everything, such as with closed-
stack object pointer mirroring (Section IV-E) to derive the sourceorsystemlibraries.Solutionslike[7]workonbinaries,
complete low-fat stack allocation schema as shown in Fig- but provide stack-only protections and generally introduce
ure 5. The low-fat stack allocator itself is implemented as overheads higher than the one reported in our experiments.
an LLVM compiler pass that replaces default stack allocation The lack of binary compatibility inhibits the adoption of a
(STACKALLOC)—as represented by the LLVM intermediate solutionintherealworld[24].Itisthereforeessentialthatthe
representation alloca instruction—with an instantiation of low-fat stack allocator exhibits a high-level of compatibility
the pseudo-code shown in Figure 5. As discussed above, similar to that of the heap allocator.
the resulting pointer (ptr) satisfies both the alignment and
Inthissectionweexaminecompatibilityissuesconcerning
region conditions, and thus will enjoy OOB-error protection
the low-fat stack allocator, including compatibility with the
in instrumented code.
default allocator (still used by uninstrumented code), multi-
Example 6 (Low-Fat Stack Allocaton): Thecompletelow- threading, and the compiled code.
fatstackallocationsequenceforExamples3,4and5isshown
in Figure 4. The allocation sequence proceeds as follows: A. Comparison with the Default Stack Allocator
(a) Theinitialstatewith%rsp=0x7fff00001110.Theinitial 1)AllocatorState: Boththedefaultandlow-fatstackallo-
virtual stack pointer #4 is implicitly the mirrored pointer: catorsusethesameallocatorstate,i.e.,thestackpointerthatis
%rsp+(4−4095)×REGION SIZE=0x2700001110. storedinthe%rspmachineregister.Thelow-fatstackallocator
(b) The stack pointer %rsp is decremented by allocSz =64 alsomaintainsseveralvirtualstacks.However,thevirtualstack
bytes (Example 3); pointers are derived from a linear function (mirroring) of the
9mainstack virtualstack#4
0x7fff00001110 0x2700001110
0x7fff000010d0 OBJECT
0x7fff000010c0 0x27000010c0
(a) (b) (c) (d) (e)
Fig.4. Examplelow-fatstackallocationsequence.States(a),(b),(c)and(d)applytothemainstack,and(e)tovirtualstack#4.
main stack pointer %rsp value, and thus do not need to be sub %rax, %rsp
represented/stored explicitly. (a) and $-8, %rsp
mov %rsp, %rbx
Since both the default and low-fat stack allocators use the
same allocation state, no special treatment is required when
lzcnt %rax, %rax
transitioningtoandfromlegacy(non-instrumented)code.The
sub SIZES(,%rax,8), %rsp
legacy code may continue to allocate objects on the (main)
(b) and MASKS(,%rax,8), %rsp
stack as normal. However, pointers to these objects will be
mov %rsp, %rbx
non-fat and not enjoy OOB-error protection.
add OFFSETS(,%rax,8), %rbx
2)Deallocation: Both default and low-fat stack deallo-
sub $56, %rsp
cation works by restoring the main stack pointer (%rsp) to
(c)
mov %rsp, %rbx
somepreviousvalue.Inthecaseofthelow-fatstackallocator,
this also implicitly restores the virtual stack pointers for
sub $64, %rsp
all virtual stacks, thereby deallocating any relevant low-fat
and $-64, %rsp
stack objects. This means that the low-fat stack allocator is
(d)
mov %rsp, %rbx
automatically compatible with all of the kinds of standard
add OFFSETS+464(%rip), %rbx
stack deallocation, including stack frame clean-up on normal
function exit, abnormal function exit (such as longjmp and
C++ exceptions), and even direct stack pointer manipulation Fig.6. Comparisonofstackallocatorcompiledcode,assuming%rax=size
(ifapplicable)and%rbx=ptr:(a)default(variablelength)(b)low-fat(variable
(e.g., via inline assembly). Furthermore, C++ stack unwinding
length) (c) default (fixed length=50, rounded up to length=56 to preserve
(that automatically runs destructors for stack objects on the
alignment)(d)low-fat(fixedlength=50,roundeduptolength=64).
event of an exception) is not affected by the low-fat stack
allocator.
x86_64 compiled version7 of the low-fat stack allocator, as
3)AlternativeStacksandMulti-threading: Aprogrammay shown in Figure 6(b), with that of the default stack allocator,
usemorethanonestack—themostcommoncasebeingmulti- as shown in Figure 6(a). Here we assume that the input size
threaded programs where a new stack is created for each parameter is stored in the general purpose register %rax, and
thread.Thedefaultstackallocatoriscompatiblewithanystack the resulting allocated ptr is to be stored in register %rbx.
provided the corresponding memory is accessible. However, The default stack allocation (Figure 6(a)) consists of three
the low-fat stack allocator imposes the additional requirement instructions:
that (a) each stack be allocated from region #stack (to be
- Decrementing size (%rax) bytes from the stack pointer
compatible with the OFFSETS table), and (b) be “mirrored”
%rsp;
to a set of virtual stacks as illustrated in Figure 3.
- Aligning the stack pointer to the default stack alignment
(here is assumed to be 8); and
For common cases, such as multi-threading, our prototype
implementation intercepts relevant standard library function
- Saving the new stack pointer value into ptr (%rbx).
calls, such as pthread_create, to create low-fat allocator By comparison, low-fat stack allocation consists of five in-
compatiblestacks.Thisachievesahighdegreeofcompatibility structions, including:
with most programs. However, it does not guarantee full
- a leading zero count lzcnt instruction that implements
compatibility with more esoteric programs that create custom
the index function introduced in Section IV-C; and
stacks using other methods, e.g., direct allocation of stack
- tablelookupsforSIZES,MASKSandOFFSETSandthecor-
memory and manipulation of the stack pointer (%rsp).
respondingover-approximation/alignment/mirroringoper-
4)Speed: The default stack allocator is very fast, with ations.
(de)allocation typically implemented in a few low-latency
The insertion of extra instructions and memory reads intro-
instructions. The low-fat stack allocator, as represented by
ducessomeruntimeoverheadcomparedwiththedefaultstack
the schema in Figure 5, is more complicated. In lieu of the
experimental results in Section VII, we first compare the 7HereweuseAT&Tstylesyntaxforassemblycode:opsrc dst.
10allocator.However,theimpactofthememoryreadsispartially virtalstack#1 virtualstack#2 virtualstack#3 mainstack
mitigatedbythefactthatthelookuptablesaresmall(allthree
fit into a single page) and are read-only, and thus are cache
friendly. The overall performance impact of the low-fat stack
allocator will be experimentally evaluated in Section VII.
VI. OPTIMIZATIONS
...
The low-fat stack allocator introduces both time and space
overheads compared with the default stack allocation scheme.
Fig.7. Low-fatstack(3differentobjectsizes).
In this section we consider three optimizations, namely fixed-
sizedobjects,non-escapingpointers,andmemoryaliasing,that
help reduce the overhead of the low-fat stack allocator. Of
virtual stack memory is arranged. The na¨ıve approach is to
these optimizations, memory aliasing is particularly important
keep each stack in separate regions of physical memory—a
with respect to the overall feasibility of our approach.
similar approach to parallel shadow stacks [8].
A. Fixed-size Stack Objects The problem with the na¨ıve approach is that it can lead
to high memory overheads. In the worst-case, physical stack
It is common for stack allocated objects to have a known memory usage will be multiplied by N+1, where N is
fixedsizeatcompiletime.Wecanexploitthistooptimizelow- the number of virtual stacks. The overhead can be partially
fat stack allocation by using constant propagation to simplify mitigatedbyusingNORESERVEmemory—meaningthatvirtual
the compiled code. This optimization can be described by the pages that are never touched (e.g. if the program does not
following example: allocate stack objects of a particular size) will not consume
physical memory resources. Nevertheless the potential for
Example 7 (Fixed-Size Stack Objects): Assuming the
significant stack memory overheads remain.
fixed object size of size=50, the following values can be
evaluated at compile time: We address this problem by using the memory aliasing
optimization, where each virtual stack is backed by the same
idx =58 allocSz =64
physicalmemoryasthemainstack.Thisoptimizationexploits
mask =0xffffffffffffffc0=−64
the virtual memory implementation of modern CPUs, such as
Under these assumptions, the schema from Figure 5 can be the x86_64, where a single page of physical memory can be
compiled into the more optimal code shown in Figure 6(d). mapped multiple times to different pages of virtual memory
The optimized allocation has eliminated the lzcnt (clz) at different addresses. Each virtual addresses can then be
index calculation and the SIZES/MASKS table lookups from used to access and modify the underlying physical memory
Figure 6(b). The resulting code uses two instructions over the equally. Where applicable, memory aliasing reduces memory
default allocator of Figure 6(c). Note that the OFFSETS table overheads—i.e.,althoughlogicallymultiplevirtualpagesexist,
lookupisnotremoved.8Thisisbecause,unlikeallocationsizes in reality only a single page of physical memory is actually
and masks, offsets are too big to store as x86_64 immediate consumed.
values (constants are limited to 32-bit values under x86_64).
Inthecontextofthelow-fatstackallocator,memoryalias-
ing takes advantage of the fact that allocated stack objects are
pairwise disjoint with respect to other objects from different
B. Non-Escaping Stack Object Pointers
virtual stacks. That is, when an object is allocated on virtual
A pointer to a stack object escapes if it can be passed stack #I, the corresponding memory remains unallocated on
(directly or indirectly) to another function invocation. Stack the main stack and all virtual stacks #J for J=(cid:54) I, as partly
object pointers can be passed directly as function parameters illustratedbyFigure4.Allstackallocatedobjectscantherefore
or indirectly by being stored in memory. be mapped to the same physical memory without collision.
This can be illustrated with a simple example:
If a stack object pointer (1) does not escape, and (2) all
access to the object can be statically determined to be within Example 8 (Stack Memory Aliasing): Considerthesimpli-
bounds,thentheobjectcanbeallocatedusingthedefaultstack fied virtual stack layout as shown in Figure 7. Here we
allocator. This eliminates all low-fat stack allocator overheads assume there are three low-fat regions and virtual stacks #1,
for that object. Escape analysis (already provided by the #2, #3. Each stack object is allocated from the virtual stack
LLVM compiler infrastructure) can be used to determine if corresponding to the allocation size, with small objects from
pointers to stack objects escape or not. virtual stack #1, medium from #2, and large from #3. All
objects are pairwise disjoint and can be projected back onto
C. Stack Memory Aliasing the main program stack. The main and virtual stacks can use
memory aliasing to share the same physical memory without
In order to satisfy the low-fat region condition, objects are objects overlapping.
allocatedfromthevirtualstackcorrespondingtotheallocation
size. Thus far, it has not been specified how the main and MemoryaliasingcanbeimplementedusingPOSIXshared
memoryobjects9 andtheLinuxshm_openAPI.Thebasicidea
8The operand (OFFSETS+464(%rip)) represents the OFFSETS[58] lookup
generatedbythecompiler,where58×sizeof(ssize t)=464. 9Nottobeconfusedwithsharedobjects.Seetheshm_overviewmanpage.
11istocreateasharedmemoryobjectandmapitmultipletimes, - ASAN a.k.a. AddressSanitizer [22]: a popular and robust
once for each of the main and virtual stacks. This effectively programming tool for detecting memory bugs based on
replaces N+1 stacks with a single physical stack. poisoned red-zones.
Finallywenotethatallocationsizeoverapproximationand For a fairer comparison we disable AddressSanitizer’s instru-
allocation size alignment also introduce memory overheads mentation for globals, alloc/free mismatch detection, and leak
unrelatedtomemoryaliasing.Theseoverheadsareunavoidable detection. We choose to compare against AddressSanitizer for
but are less significant. We defer further discussion to the several reasons, namely: prominence (actively used by large
experimental evaluation in Section VII. projects such as Google Chrome [22] and Mozilla Firefox),
stability, accessibility (already “built-in” to clang [18]), and
1)ImplementationIssues: Theshm_opencallunavoidably works“out-of-the-box”(afterapatch10isapplied)ontheSPEC
createsatemporarynameonthefilesystemthatcanbeusedby
2006 benchmark suite. The tested version of AddressSanitizer
otherprogramstoaccesstheobject.Thisnameisimmediately
does have one notable limitation in that it only instruments
deleted but a race condition remains. To solve this, our
fixed-sized stack objects. LOWFAT instruments both fixed and
implementation ensures that the object is opened exactly once
variable-sized stack objects which may translate to a small
(i.e., by the program) using the Linux fcntl lease API.
performance disadvantage in our tests.
If memory aliasing is used, care must be taken with Our LOWFAT implementation detects all 24 OOB-pointer
handling the fork family of system calls. The problem arises violationssummarizedinSectionIII-C.Forthesakeofperfor-
from the Linux fork semantics concerning shared memory mance testing, we disable instrumentation for the correspond-
mappings, such as the aliased stack. Ordinarily, the stack is ingfunctionsforbothLOWFATandAddressSanitizer.Theonly
a private mapping, meaning that fork will create a local knownunintentionalSPEC2006stackboundsoverflowrelates
copy of the stack for the child process that is backed by toanoff-by-oneerrorintheh264refbenchmark.UnderLOW-
different physical memory. In contrast, shared mappings are FAT this overflow affects allocation padding only—and does
directly inherited by the child. This means that the parent and notaffectotherobjects.Againforthesakeoftesting,thiserror
childwillcompeteforthesamephysicalstackmemory,which ispatchedforbothLOWFATandAddressSanitizer.Finally,out
inevitablyresultsinmemorycorruption.Tosolvethisproblem, of all the SPEC 2006 benchmarks, only perlbench uses the
ourimplementationinterceptstheforksystemcallandcopies fork system call. This is handled using the method described
the stack manually. Note that this problem does not exist for in Section VI-C1.
operating systems that do not support fork-like operations,
1)Timings: The timings for the SPEC 2006 benchmarks
such as Windows.
are shown in Figure 8(a). The original timings and the best
instrumented timings are highlighted in bold. Here (Total)
VII. EXPERIMENTS
represents the sum of each column and (Avg. Ratio) the
average ratio per benchmark relative to the (Orig) baseline.
In this section we evaluate the performance and effec-
tiveness of an implementation of the low-fat stack allocator.
In addition to the (base) LOWFAT implementation, we also
test the following variants:
Our implementation, called LOWFAT, extends the low-fat
heap allocator described in [10]; and is configured using the - +alias: Enables memory aliasing (Section VI-C);
parameters from Appendix A. The low-fat stack allocator - +pow2: Restrict both heap and stack allocations to
is implemented as an LLVM compiler infrastructure [18] power-of-two sizes for faster bounds checking (see [10]
pass that replaces default stack allocation (as represented by Section 5.2); and
the LLVM intermediate representation alloca instruction) - +w.o.: Instrument memory write operations only.
accordingtotheschemashowninFigure5.Thecompilerpass
Optimizations are cumulative left-to-right. Note that both the
implements all of the optimizations described in Section VI.
fixed-object-size optimization (Section VI-A) and the no-
The runtime component is implemented as a library that is
escape optimization (Section VI-B) are enabled by default for
linked against the resulting executable.
all LOWFAT variants. The +w.o. variant reduces instrumen-
Allexperimentswererunonax86_64GNU/Linuxsystem tation (no reads) and thus exchanges security for speed. The
with an Intel Xeon E5-2660 v3 CPU (clocked at 2.60GHz) rationale is that most control and data flow attacks require
with 64GB of RAM. We use the clang-3.5 compiler for an OOB write, so the +w.o. variant still provides sufficient
both the instrumented and un-instrumented tests. defense. That said, the +w.o. variant will not protect against
information leakage attacks, such as Heartbleed [12].
A. Performance The base LOWFAT implementation exhibits a 62% (63%
avg.ratio)overheadcomparedwiththeun-instrumentedbench-
To measure the performance of the LOWFAT implemen-
marks(Orig).Thisisreducedtoa58%overheadwhen+alias
tation we use the SPEC 2006 benchmark suite [23]. For
isenabled.The+alias variantbenefitsfrombetterstackobject
these experiments we focus on the combined performance
locality in physical memory; translating in to a ∼4% overall
of the heap and stack OOB-error protection, as this is the
reduction in overhead.
intended use case. The results are shown in Figure 8(a) for
timingsand8(b)formemoryusage.Wecomparethe LOWFAT The +pow2 optimization restricts the size configuration
implementation with: (Sizes) to be powers-of-two for both the heap and stack. This
- Orig: The un-instrumented program that uses the default 10https://github.com/google/sanitizers/blob/master/address-sanitizer/spec/
heap (i.e., stdlib malloc) and stack allocators; and spec2006-asan.patch
12Orig LOWFAT ASAN Orig LOWFAT ASAN
Bench. base base +alias +pow2 +w.o. base +w.o. Bench. base base +alias +pow2 base
perlbench 310 494 485 464 393 1032 921 perlbench 680 650 632 735 2461
bzip2 479 829 799 793 589 866 633 bzip2 872 883 869 869 917
gcc 288 585 580 541 497 656 571 gcc 908 928 897 897 3030
mcf 244 296 308 299 252 401 276 mcf 1718 1724 1718 1718 1956
gobmk 452 585 571 543 512 820 594 gobmk 31 60 34 34 449
hmmer 423 1070 1070 987 538 819 473 hmmer 28 42 29 29 643
sjeng 480 554 548 550 514 884 618 sjeng 180 213 182 182 206
libquantum 321 364 347 361 331 392 353 libquantum 100 109 100 100 415
h264ref 537 1070 1072 1003 611 1236 734 h264ref 67 91 69 74 427
omnetpp 306 480 393 490 392 647 578 omnetpp 175 189 171 223 943
astar 393 642 621 592 433 636 449 astar 335 362 348 570 1138
xalancbmk 204 306 290 277 185 435 372 xalancbmk 432 522 511 646 1817
milc 529 718 659 674 477 616 504 milc 697 712 698 698 1025
namd 356 565 568 552 390 563 376 namd 49 67 51 51 127
dealII 275 561 549 499 349 621 457 dealII 815 863 843 1047 2214
soplex 217 312 301 304 229 337 279 soplex 443 638 621 621 1001
povray 142 299 297 277 172 408 277 povray 7 27 9 9 400
lbm 341 408 402 401 339 361 339 lbm 420 427 421 421 496
sphinx3 482 870 853 804 693 903 549 sphinx3 46 69 48 48 591
Total 6779 162% 158% 154% 116% 186% 138% Total 8003 107% 103% 112% 253%
Avg. Ratio 100% 163% 158% 154% 117% 192% 145% Avg. Ratio 100% 135% 106% 115% 797%
(a)Timings(s) (b)Memoryusage(MB)
Fig.8. SPEC2006benchmarktimingsandmemoryusage.
allows for faster bounds check instrumentation that uses bit- overhead compared with the un-instrumented baseline. This is
masks in place of fixed-point division for calculating the base furtherreducedtoa3%(6%avg.ratio)overheadwhen+alias
address of objects. This optimization reduces the overhead isenabled.Finally,weseethat+pow2 tradesspeedforhigher
to 54% at the cost of higher memory usage (see below). memory overheads, with 12% (15% avg. ratio) overall.
Finally, the +w.o variant significantly reduces the amount of
instrumentation leading to an overall 16% (avg. ratio 17%)
In contrast to LOWFAT, AddressSanitizer exhibits a very
high153%(avg.ratio697%)memoryoverheadoverall.Thisis
overhead. This is low enough to be used in production code
because AddressSanitizer uses poisoned red-zones which are
for some applications.
memory intensive.
AddressSanitizerexhibitshigheroverheads,with86%(avg.
ratio 92%) for base and 38% (avg. ratio 45%) for the +w.o. In addition to the “big picture” results in Figure 8(b), we
variant. The LOWFAT +w.o. variant is faster in 16 out of also measured the precise stack memory usage overheads for
19 benchmarks with one benchmark (lbm) tied. We note that, each benchmark. For this experiment, we initialize each page
for some benchmarks, the overhead of AddressSanitizer is of stack memory with a random nonce during program initial-
particularly high, e.g., almost 3x slower for perlbench. ization.Nextwemeasurethenumberofpagesthatwerealtered
at program exit. Assuming that memory aliasing optimization
2)Memory Usage: One of the main advantages of low-
was disabled, it was determined that the stack memory usage
fat pointers is that there is no need to explicitly store bounds
for the SPEC 2006 benchmarks is 5.20x over the (Orig)
meta information, meaning that memory overheads are low
baseline.Theworstaffectedbenchmarkwasxalancbmk,with
compared with the un-instrumented code (Orig). That said,
an 8.01x increase in stack memory usage. With the +alias
the low-fat stack allocator introduces several new sources of
optimizationenabled,theoverallphysicalstackmemoryusage
memory overheads, namely:
isreducedto1.95x,whichiscomparablewithparallelshadow
- Extra space for virtual stacks (assuming that the +alias stacks [8]. For many programs, the space used by the stack is
optimization is disabled); onlyasmallfractionofthetotalmemoryusage.Thereforethe
- Allocation size over-approximation (Section IV-C); overall memory overhead for LOWFAT in Figure 8(b) remains
- Allocation size alignment (Section IV-D). low.
Theextraoverheadsarebalancedbythefactthatstackmemory
tendstobesmall(Linuxdefaultis8MB)andstackobjectsare B. Web Server
typicallyshort-lived.Inthissectionweexperimentallyevaluate
To test the performance for I/O bound applications, we
thememoryoverheadsofthelow-fatstackallocator,including
compiled the Apache HTTP server (∼275K lines of code)
the overall program memory usage and the precise memory
using LOWFAT and compared it with an un-instrumented
usage for stack memory only.
version (Orig). For this test we transfer a 2GB file with the
The results for the overall memory usage are shown in daemon connected to the local host. Two types of tests were
Figure 8(b). For these tests we measure the peak resident set performed: one where the file was cached in RAM, and the
size (RSS), the same method used in [10]. The base LOWFAT other where the disk cache was purged. Each test was run for
implementation introduces a 7% (35% avg. ratio) memory a total of 50 times and results averaged.
13Bench. Orig LOWFAT Bench. sLOC #Test Abort Pad
httpd-2.4.23 (cached) 1.06 1.07 Wilander [28] 0.4K 12 12 0
httpd-2.4.23 (purged) 24.0 24.4 RIPE [29] + glibc 6.7K 70 70 0
CVE-2016-1234 (glibc-2.19) 1.4K 1 1 0
Fig.9. ApacheHTTPserverbenchmarktimings.
CVE-2016-3191 (pcre2-10.20) 73.6K 1 0 1
CVE-2016-6297 (php-7.0.3) 759.5K 1 0 1
CVE-2016-6289 (php-7.0.3) (cid:48)(cid:48) 1 1 0
The results (in seconds) are shown in Figure 9. In both
CVE-2016-2554 (php-5.5.31) 781.6K 1 0 1
cases, the overhead of LOWFAT was very low (<2%). In
applications such as Apache, which is not primarily CPU- Fig.10. EffectivenessagainstvariousbenchmarksandCVEs.
bound, we expect that the overheads of LOWFAT bounds
checking to be small.
thesLOCcolumnfromFigure10.ForallfiveCVEstested,two
are detected (Abort) and three overflow into padding (Pad).
C. Effectiveness
To test the effectiveness of the low-fat stack allocator we D. Comparison with Other Systems
use the Wilander [28] and RIPE [29] benchmarks in addition
Our system extends [10] with low-fat pointers for stack
to some recent CVEs. The results are shown in Figure 10.
objects in addition to the heap. Our 58% overhead result for
Here, (sLOC) is the number of source lines of code, (#Test)
+alias corresponds to the 67% overhead result for +fdiv
isthenumberoftestcases,(Abort)isthenumberofallocation
from [10] Figure 4(a). Despite protecting both the heap and
boundoverflowsthatweredetected(causing LOWFAT toabort
stack our version is faster overall—the result of an improved
execution),and(Pad)isthenumberofoverflowsintopadding
implementationwithbetteroptimization.Forthe+w.o.variant
introducedby allocationsizeover-approximation. Thelatteris
we are slightly slower, with 17% overhead versus 13%. The
considered benign for the application of program hardening,
overall memory performance is similar.
i.e., an overflow in padding cannot corrupt code pointers or
data values stored in other objects. Our results are also competitive with other bounds in-
strumentation systems. PAriCheck [30] and BaggyBounds [3]
The Wilander benchmarks [28] consist of 12 stack-based
report 49% and 60% overheads respectively for the SPEC
overflows, all of which are detected by LOWFAT.
2000 benchmarks. Note that this paper uses the SPEC 2006
benchmarkssotheresultsarenotdirectlycomparable.Further-
The RIPE benchmarks consists of several test cases that
combine a bounds overflow error followed by a control flow
more, unlike LOWFAT, both PAriCheck and BaggyBounds do
not instrument field access, resulting in less bounds checking.
hijack attack. Some issues were encountered when testing the
SoftBound [19] reports a similar 67% performance overhead
RIPE benchmarks, namely:
for SPEC 2000, but with a significantly higher 64% mem-
1) RIPE requires 32-bit whereas LOWFAT requires 64-bit; ory overhead. For SPEC 2006, CPI reports that they could
and only compile four benchmarks with SoftBound and the time
2) The RIPE attacks are fragile and break when ported. overheads range between 60–249% [16]. This also highlights
the importance of compatibility issues. Alternatives to bounds
To solve these issues we only port (to 64-bit) the RIPE tests
checking, such as shadow-stacks, CPI, CPS, SafeStack [8],
such that execution only up to the buffer overflow error is
[16], tend to have lower performance overheads, ranging from
preserved.Therationaleis:ifthememoryerrorisdetectedthen
0.1%–10%dependingonthesolution.Thatsaid,noneofthese
any subsequent control flow hijack attack will be prevented.
solutions prevent memory errors. Rather, such solutions aim
The RIPE benchmarks contain 10 unique bounds errors: one
to mitigate any subsequent control flow attack. The LOWFAT
direct array overflow (homebrew), and 9 errors induced by
+w.o.variantwitha17%overheadcanprotectagainstcontrol
passinginvalidparameterstostdlibfunctionssuchassprintf,
flow attacks in addition to other kinds of attacks, such as
sscanf, etc. For this experiment we recompile the relevant
data flow [6]. This, combined with high compatibility, makes
glibcfunctionswith LOWFAT instrumentationenabled.11 We
LOWFAT a competitive solution.
test all RIPE parameter combinations that (1) are stack object
overflows,(2)arenotreportedas“impossible”bytheRIPEtest
framework, and (3) are not sub-object overflows. This yields VIII. CONCLUSION
a total of 70 tests, all of which are detected as OOB-errors by
Object bounds errors are a common source of security
LOWFAT (Abort).
vulnerabilities and bounds check instrumentation with low-
Finally we test several recent (2016 at the time of writing) fat pointers (with low overheads and high compatibility) is an
CVEs relating to stack buffer overflows that are listed in attractivesolution.However,low-fatpointersrequiresufficient
Figure 10. The purpose of these tests is to show that LOWFAT control over object allocation, and as such, previous work was
is applicable to real world bugs in addition to artificial tests. limited to heap objects only. In this paper, we have shown
The CVEs originate from glibc (standard C library), pcre2 how to extended low-fat pointers to stack objects by using a
(Perl Compatible Regular Expressions) and php (a server-side combinationoftechniques,including:fastallocationsizeover-
scriptinglanguage).Asabove,fortheglibctest,werecompile approximation, dynamic stack object alignment, stack object
onlythefunction(s)relevanttotheerror,andthisisreflectedin pointer mirroring, and the memory aliasing optimization. We
show that the new low-fat stack allocator is compatible with
11Currently it is not possible to recompile glibc in its entirety. This is existing software and binary code. Our experiments show that
becauseglibcrequiresgccwhereasLOWFATisimplementedusingclang. the overall performance and memory impact of stack object
14protectionisminimaloverthepreviouslypublishedresults[10] [17] A. Kwon, U. Dhawan, J. Smith, T. Knight, and A. DeHon, “Low-fat
forheaponly.Furthermore,forprotectingmemorywritesonly, Pointers: Compact Encoding and Efficient Gate-level Implementation
the overhead drops to 17%, which is low enough for enabling of Fat Pointers for Spatial Safety and Capability-based Security,” in
ComputerandCommunicationsSecurity. ACM,2013.
real-world deployments while still preventing many attacks.
[18] LLVM,http://llvm.org,2016.
With low-fat pointers extended to both heap and stack [19] S.Nagarakatte,Z.Santosh,M.Jianzhou,M.Milo,andS.Zdancewic,
objects, the remaining class yet to be covered is globals. In “SoftBound:HighlyCompatibleandCompleteSpatialMemorySafety
forC,”inProgrammingLanguageDesignandImplementation. ACM,
principle, low-fat global objects could be realized by further
2009.
splitting each low-fat region to also include a global sub-
[20] G.Necula,J.Condit,M.Harren,S.McPeak,andW.Weimer,“CCured:
region, in addition to the heap and stack sub-regions. Global Type-safeRetrofittingofLegacySoftware,”TransactionsonProgram-
objectsarethenplacedintheappropriatesub-region(basedon mingLanguagesandSystems,2005.
allocationsize)bythelinker.Modifyingthestaticanddynamic [21] PaX,“AddressSpaceLayoutRandomization,”http://pax.grsecurity.net/
linkers to be “low-fat aware” is left as future work. docs/aslr.txt.
[22] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Ad-
dressSanitizer: A Fast Address Sanity Checker,” in USENIX Annual
TechnicalConference. USENIX,2012.
REFERENCES
[23] SPEC,https://www.spec.org/cpu2006/,2016.
[1] “CVE-2016-1234, CVE-2016-3191, CVE-2016-6297, CVE-2016- [24] L. Szekeres, M. Payer, T. Wei, and D. Song, “SoK: Eternal War
6289.” in Memory,” in IEEE Symposium on Security and Privacy. IEEE
ComputerSociety,2013.
[2] M. Abadi, M. Budiu, Z. Erlingsson, and J. Ligatti, “Control-Flow
[25] Tor,“TheTorProject,”https://www.torproject.org/.
Integrity,”inComputerandCommunicationSecurity. ACM,2005.
[26] V.vanderVeen,N.Dutt-Sharma,L.Cavallaro,andH.Bos,“Memory
[3] P. Akritidis, M. Costa, M. Castro, and S. Hand, “Baggy Bounds
Errors:ThePast,thePresent,andtheFuture,”inResearchinAttacks,
Checking: An Efficient and Backwards-Compatible Defense Against
Intrusions,andDefenses. Springer,2012.
Out-of-Bounds Errors,” in USENIX Security Symposium. USENIX,
2009. [27] A. Ven, “New Security Enhancements in Red Hat Enterprise Linux,”
http://www.redhat.com/f/pdf/rhel/WHP0006US Execshield.pdf.
[4] T.Austin,S.Breach,andG.Sohi,“EfficientDetectionofAllPointer
and Array Access Errors,” in Programming Language Design and [28] J.WilanderandM.Kamkar,“AComparisonofPubliclyAvailableTools
Implementation. ACM,1994. forDynamicBufferOverflowPrevention,”inNetworkandDistributed
SystemSecuritySymposium. TheInternetSociety,2003.
[5] M.Castro,M.Costa,andT.Harris,“SecuringSoftwarebyEnforcing
Data-flow Integrity,” in USENIX Symposium on Operating Systems [29] J. Wilander, N. Nikiforakis, Y. Younan, M. Kamkar, and W. Joosen,
DesignandImplementation. USENIX,2006. “RIPE:RuntimeIntrusionPreventionEvaluator,”inAnnualComputer
SecurityApplicationsConference. ACM,2011.
[6] S. Chen, J. Xu, E. Sezer, P. Gauriar, and R. Iyer, “Non-control-
[30] Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar, F. Piessens, and
data Attacks are Realistic Threats,” in USENIX Security Symposium.
W. Joosen, “PAriCheck: An Efficient Pointer Arithmetic Checker for
USENIX,2005.
CPrograms,”inInformation,ComputerandCommunicationsSecurity.
[7] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida, ACM,2010.
“StackArmor: Comprehensive Protection From Stack-based Memory
[31] Y.Younan,D.Pozza,F.Piessens,andW.Joosen,“ExtendedProtection
ErrorVulnerabilitiesforBinaries,”inNetworkandDistributedSystem
AgainstStackSmashingAttacksWithoutPerformanceLoss,”inAnnual
SecuritySymposium. TheInternetSociety,2015.
ComputerSecurityApplicationsConference. IEEEComputerSociety,
[8] T.Dang,P.Maniatis,andD.Wagner,“ThePerformanceCostofShadow 2006.
Stacks and Stack Canaries,” in ACM Symposium on Information,
ComputerandCommunicationsSecurity. ACM,2015.
APPENDIX
[9] B. Ding, Y. He, Y. Wu, A. Miller, and J. Criswell, “Baggy Bounds
with Accurate Checking,” in International Symposium on Software A. Parameters
ReliabilityEngineeringWorkshops. IEEEComputerSociety,2012.
This paper uses the following low-fat allocation parameters:
[10] G.DuckandR.Yap,“HeapBoundsProtectionwithLowFatPointers,”
inCompilerConstruction. ACM,2016.
REGION SIZE=32GB
[11] F.Eigler,“Mudflap:PointerUseCheckingforC/C++,”inGCCDevel-
M =|Sizes|=61
oper’sSummit,2003.
[12] Heartbleedbug,http://heartbleed.com,2016. (cid:104)16,32,48,64,80,96,112,128,144,160,192,224,256,
272,320,384,448,512,528,640,768,896,1024,1040,
[13] H.Hu,S.Shinde,S.Adrian,Z.Chua,P.Saxena,andZ.Liang,“Data-
1280,1536,1792,2048,2064,2560,3072,3584,4096,
Oriented Programming: On the Expressiveness of Non-Control Data
Attacks,”inIEEESymposiumonSecurityandPrivacy. IEEEComputer Sizes= 4112,5120,6144,7168,8192,8208,10240,12288,
Society,2016. 16KB,32KB,64KB,128KB,256KB,512KB,1MB,
2MB,4MB,8MB,16MB,32MB,64MB,128MB,
[14] Intel Corporation, “Intel 64 and IA-32 Architectures Software Devel-
256MB,512MB,1GB,2GB,4GB,8GB(cid:105)
opersManual,”2016.
[15] T.Jim,G.Morrisett,D.Grossman,M.Hicks,J.Cheney,andY.Wang, (cid:104)16,32,64,128,256,512,1024,2048,4096,8192,
“Cyclone:ASafeDialectofC,”inUSENIXAnnualTechnicalConfer- 16KB,32KB,64KB,128KB,256KB,512KB,
ence. USENIX,2002. StkSizes= 1MB,2MB,4MB,8MB,16MB,
[16] V.Kuznetsov,L.Szekeres,M.Payer,G.Candea,R.Sekar,andD.Song, 32MB,64MB,128MB,256MB,512MB
“Code-pointerIntegrity,”inUSENIXSymposiumonOperatingSystems 1GB,2GB,4GB,8GB(cid:105)
DesignandImplementation. USENIX,2014.
15