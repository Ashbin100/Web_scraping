Fast Actively Secure OT Extension for Short Secrets
Arpita Patra Pratik Sarkar Ajith Suresh
Indian Institute of Science Indian Institute of Science Indian Institute of Science
arpita@csa.iisc.ernet.in pratik.sarkar@csa.iisc.ernet.in ajith.s@csa.iisc.ernet.in
Abstract—Oblivious Transfer (OT) is one of the most funda- the theoretical importance of OT. On the practical front, OT
mental cryptographic primitives with wide-spread application in has been pivotal in building several state-of-the-art practically
general secure multi-party computation (MPC) as well as in a efficient general MPC protocols [11], [15], [24]–[26], [32],
numberoftailoredandspecial-purposeproblemsofinterestsuch [37] and several protocols for special-purpose problems of
as private set intersection (PSI), private information retrieval
interest such as private set intersection (PSI) [8], [34], [35].
(PIR), contract signing to name a few. Often the instantiations
There is a fundamental limitation to OT’s efficiency as it is
of OTrequire prohibitive communication andcomputation com-
unlikely that OT is possible without public-key cryptography
plexity.OTextensionprotocolsareintroducedtocomputeavery
and solely relying on symmetric-key cryptography [16]. The
large number of OTs referred as extended OTs at the cost of a
small number of OTs referred as seed OTs. OTextensionprotocols[3]–[5],[17],[18],[21],[31]havebeen
introduced to theoretically circumvent the above limitation of
We present a fast OT extension protocol for small secrets OTs.TheyproducealargenumberofOTsreferredasextended
in active setting. Our protocol when used to produce 1-out-of-
OTs from a small number of OTs referred as seed OTs and
n OTs outperforms all the known actively secure OT extensions.
symmetric-keyprimitives.Whenthegoalistogeneratealarge
Ourprotocolisbuiltonthesemi-honestsecureextensionprotocol
number of OTs which is usually the case for the applications
ofKolesnikovandKumaresanofCRYPTO’13(referredasKK13
of OT, the amortized cost of generating a single OT via OT
protocol henceforth) which is the best known OT extension
for short secrets. At the heart of our protocol lies an efficient extensions turns out to be a constant number of symmetric-
consistency checking mechanism that relies on the linearity of key operations. So most of the known practically efficient
Walsh-Hadamard(WH)codes.Asymptotically,ourprotocoladds general and special-purpose MPC protocols are byproduct
acommunicationoverheadofO(µlogκ)bitsoverKK13protocol of concretely efficient OT extension protocols. Of particular
irrespectiveofthenumberofextendedOTs,whereκandµrefer interesttocryptographiccommunityarethefollowingvariants
to computational and statistical security parameter respectively. of OT: (a) In a 1-out-of-2 OT [9], S holds two inputs x ,x ,
0 1
Concretely, our protocol when used to generate a large enough
andRholdsachoicebitb.TheoutputtoRisx andnoother
numberofOTsaddsonly0.011-0.028%communicationoverhead b
party learns anything. (b) A straight-forward extension of 1-
and 4-6% runtime overhead both in LAN and WAN over KK13
out-of-2 OT is 1-out-of-n OT [6] where S holds n inputs and
extension. The runtime overheads drop below 2% when in
R holds a choice index of logn bits. While the first kind finds
addition the number of inputs of the sender in the extended
OTs is large enough. applicationinMPC[12],[38],thesecondkindisusefulinPSI
[34], [35], symmetric PIR [29], and oblivious sampling [29],
Asanapplicationofourproposedextensionprotocol,weshow
oblivious polynomial evaluation [28]. As discussed below,
thatitcanbeusedtoobtainthemostefficientPSIprotocolsecure
attempts have been made to construct OT extension protocols
against a malicious receiver and a semi-honest sender.
to output both the above kinds of OTs.
I. INTRODUCTION
A. OT Extensions
ObliviousTransfer(OT)[6],[9],[19],[29],[36]isperhaps
the most fundamental primitive in cryptographic protocol The theoretical feasibility of OT extension was proved by
theory. It is a two party protocol between a sender S and Beaver [5]. Ishai, Kilian, Nissim and Petrank [17] (referred
a receiver R. The sender holds an array of inputs and the as IKNP protocol henceforth) presented the first efficient OT
receiver holds an index indicating its intended pick from the extension protocol that builds on κ seed OTs and requires
sender’s array. OT allows the sender to send the receiver’s computing and sending just two hash values per extended
selected input while preserving the secrecy of the sender’s OT. In [3], IKNP protocol has seen several optimizations that
other inputs on the one hand and the choice of the receiver boost both its communication and computation complexity.
on the other. The necessity and sufficiency of OT for secure Specifically, the communication per extended OT is brought
multi-party computation (MPC) [12], [13], [19], [39] backs down to one hash value for a special case where the extended
OTs are needed for random inputs of the sender. The com-
putation bottleneck for implementing matrix transposition is
Permission to freely reproduce all or part of this paper for noncommercial tackled by introducing a cache-oblivious algorithm. Yet an-
purposes is granted provided that copies bear this notice and the full citation
othercontributionfrom[3]istheircrucialobservationthatthe
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author actualbottleneckintheruntimeofIKNPprotocolresultsfrom
(for reproduction of an entire paper only), and the author’s employer if the its communication time, particularly in wide area networks
paper was prepared within the scope of employment. (WANs)thathavehighlatencyandlowbandwidth.Inafirstof
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
itskindapproach,KolesnikovandKumaresan[21](referredas
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23089 KK13protocolhenceforth)presentedanOTextensionprotocolthat outputs 1-out-of-n OTs starting from 2κ 1-out-of-2 seed number of generated extended OTs. Asymptotically, our OT
OTsandrelyingonspecificsofWalsh-Hadamard(WH)codes. extensionmatchestheKK13protocolineveryrespect.TableI
KK13 protocol improves over all its predecessors (including showstheefficiencyofvariousOTextensionprotocolsachiev-
IKNP) customized to generate 1-out-of-n OTs by a factor ing2−κ computationalsecurityand2−µ statisticalsecurityfor
O(logn) in communication complexity when the inputs of producing m 1-out-of-n OTs with (cid:96)-bit inputs of the sender.
the extended OTs are of short size. So far KK13 protocol The following parameters have been used for comparison: (i)
remains to be the most efficient way of generating 1-out-of-n number of seed OTs, (ii) communication complexity and (iii)
OTs for short inputs. All the protocols discussed above work computation complexity in terms of number of hash value
when the adversary is assumed to be semi-honest. A passive computations.
orsemi-honestadversaryfollowstheprotocolspecificationbut
attemptstolearnmorethanallowedbyinspectingtheprotocol
transcript.Anadversaryisreferredasactiveormaliciouswhen
TABLEI:AsymptoticcostofvariousOTextensionsforproducingm1-out-
of-nOTswith(cid:96)-bitinputsofthesenderandforachieving2−κcomputational
it behaves in any arbitrary way in an attempt to break the
securityand2−µ statisticalsecurity.
security of the protocol.
OTextensionliteraturefindsnumerousattemptstoachieve Reference #SeedOTs Communication(bits)/ Security
Computation(#hashes)
active security. All the attempts restrict their attention in
transforming the semi-honest secure IKNP protocol to an [21] 2κ O(m(κ+n(cid:96))) semi-honest
activelysecureone.SincetheIKNPprotocolisresilienttoany [17] κ O(m(κlogn+n(cid:96))) semi-honest
[31] 8κ O(m(κlogn+n(cid:96))) active
maliciousbehaviorofthesender,anactivelysecureIKNPstyle 3
[4] κ+1.55µ O(m(κlogn+n(cid:96))) active
protocol needs to enforce honest behaviour for the receiver.
[18] κ O(m(κlogn+n(cid:96))) active
Adding consistency checks for the receiver has been the ThisPaper 2κ O(m(κ+n(cid:96))) active
strategyfollowedinalltheknownconstructions.Theefficiency
(bothcommunicationandcomputationwise)oftheconsistency
Concretely, our protocol when used to generate large
checks defines the overhead for an actively secure IKNP style
enough number of OTs adds only 0.011-0.028% communi-
protocol. The consistency check introduced in [17] employs
cation overhead and 4-6% runtime overhead both in LAN and
expensive cut-and-choose technique on µ parallel instances of
WANoverKK13protocol.Theruntimeoverheadsdropbelow
thesemi-honestIKNPprotocolwhereµisastatisticalsecurity
2% when in addition the number of inputs of the sender in
parameter.[14],[30]proposesconsistencychecksperextended
the extended OTs is large enough. Our construction put in the
OTs. This is improved in [31] where the checks are done
context of other OT extensions are presented in Table II. The
per seed OT. In order to tackle information leakage in their table presents figures for generating 1.25 × 106 1-out-of-16
consistencycheck,[31]needstostartwith 8κseedOTswhich
3 OTs with sender’s input length as 4 bits. The overheads are
is 8 times more than what IKNP protocol needs. This inflates calculatedwithrespecttoKK13protocol.Theimplementation
3
their concrete communication and computation complexity by of [18] is not available in the same platform as the other
thesamefactor.[4]improvesover[31]bytradingcomputation OT extensions given in the table. As per the claim made in
in consistency checks for a reduced number of seed OTs. [18], the runtime of their OT extension bears an overhead of
Namely, the OT extension of [4] requires κ+1.55µ seed OTs 5% with respect to IKNP protocol both in LAN and WAN.
comparedto 8κof[31]andthusimprovesthecommunication So the runtime and overhead in runtime of [18] with respect
3
done via seed OTs. In a recent work, [18] reports the most ef- to KK13 protocol are calculated based on that claim. As
ficientactivelysecureIKNPstyleprotocolthatbringsbackthe evident from Table II, our protocol when used to compute
number of seed OTs to κ and handles the information leakage 1-out-of-n OTs with short inputs of the sender outperforms
in the consistency check by sacrificing κ+µ extended OTs. all the known actively secure OT extensions and secures the
The check requires an O(κ) bits communication irrespective second best spot among all the OT extension protocols listed
of the number of extended OTs and two finite field operations in Table II closely trailing KK13 which is the overall winner.
per extended OT. More elaborate empirical results supporting the above claim
with varied number of extended OTs and varied number of
Above we concentrated on practically efficient OT exten-
inputs of the sender in the extended OTs appear later in the
sion literature. Some interesting theoretical questions on OT
paper.
extension are addressed in [23], [27].
Lastly, the OT extensions presented in all the works in
B. Our Contribution the table except [21] inherently produce 1-out-of-2 OTs. The
transformation from 1-out-of-2 to 1-out-of-n OT given in [29]
We present an actively secure OT extension for short
is used to transform their extended OTs to 1-out-of-n OTs.
secrets building upon the semi-honest secure protocol of [21].
The transformation that works for reverse direction [29] is
Like KK13 protocol, our extension protocol turns 1-out-of-2
unfortunately not maliciously secure. This prevents us from
seed OTs to 1-out-of-n extended OTs. Similar to IKNP proto-
claiming a similar gain when our protocol is used to generate
col, KK13 protocol is secure against any malicious behaviour
1-out-of-2 OTs. We leave open the question of finding an
of sender but falls apart in the face of a maliciously corrupt
efficient actively secure transformation from 1-out-of-n to 1-
receiver. We present a concrete attack on KK13 and add an
out-of-2 OT.
efficient consistency check to enforce correct behaviour of the
receiver. Our check relies on the linearity of WHcodes. Com- We show an interesting application of our proposed exten-
bined with an additional trick, our efficient consistency check sion protocol in OT-based PSI protocols. Specifically, we use
incurs a communication of O(µlogκ) bits irrespective of the ourmaliciouslysecureOTextensioninthePSIprotocolof[22]
2TABLE II: Concrete cost of various OT extension protocols for producing 1.25×106 1-out-of-16 OTs with sender’s input length as 4 and for achieving
computationalsecurityof2−128 andstatisticalsecurityof2−40.
Comm Runtime(insec) Overheadw.r.t.[21](in%)
Reference #Seed
OTs (inMB) LAN WAN Communication RuntimeinLAN RuntimeinWAN
[21] 256 47.69 21.68 115.34 0 0 0
[17] 128 87.74 24.07 133.81 84 11.02 16
[31] 342 215.95 24.84 143.20 352.7 14.6 24.14
[4] 190 166.54 24.81 158.6 249.1 14.4 37.5
[18] 128 >87.74 >25.27 >140.5 >84 >16.5 >21.8
ThisPaper 256 47.70 22.50 121.94 0.028 3.78 5.72
to obtain the most efficient PSI protocol that is maliciously are different. For a vector c of length, say p, and an index set
secure against a corrupt receiver and semi-honestly secure I ⊂[p], PRN (c) denotes the pruned vector that remains after
I
against a corrupt sender. In brief, a PSI protocol between removing the bits of c corresponding to the indices listed in
two parties, namely a sender S and a receiver R holding sets I. For a set C of vectors {c ,...,c }, PRN (C) denotes the
1 m I
X = {x ,x ,...x } and Y = {y ,y ,...y } respectively, set of pruned vectors {PRN (c ),...,PRN (c )}.
1 2 n1 1 2 n2 I 1 I m
outputs the intersection X ∩Y to the receiver and nothing to
Security Parameters. We denote the statistical security param-
the sender. As evident from the theoretical and experimental
eter by µ and the cryptographic security parameter by κ. A
results presented in this work, our maliciously secure OT
negligiblefunctioninκ(µ)isdenotedbynegl(κ)(negl(µ)),
extension protocol is a better choice compared to the existing
while negl(κ,µ) denotes a function which is negligible in
maliciously secure extension protocols [4], [18], [31] when
both κ and µ. A function negl(·) is negligible if for every
1-out-of-n OTs are required as output. As PSI employs 1-
polynomialp(·)thereexistsavalueN suchthatforalln>N
out-of-n (instead of 1-out-of-2) OTs, our extension protocol
it holds that negl(n)< 1 . We write PPT for probabilistic
fits the bill. Lastly, we find a concrete vulnerability for the p(n)
polynomial-time.
malicious corrupt receiver case in Lambæk’s PSI protocol
when semi-honest KK13 OT protocol is used in it. This Oblivious Transfers. For oblivious transfers, we denote the
confirms Lambæk’s concern of privacy breach of his PSI sender by S and the receiver by R. In a 1-out-of-2 OT on
protocolthatmayresultfromprivacybreachoftheunderlying (cid:96) bit strings, S holds two inputs x ,x , each from {0,1}(cid:96) and
0 1
OTprotocolsandfurtherconfirmsthenecessityofmaliciously Rholdsachoicebitb.TheoutputtoRisx andnootherparty
b
secure OT extension in Lambæk’s PSI protocol. learns anything. We denote a 1-out-of-2 OT on (cid:96) bit strings
as
(cid:0)2(cid:1)
-OT . We denote a 1-out-of-n OT on (cid:96) bit strings as
II. PRELIMINARIES (cid:0)(cid:0) nn 1(cid:1)(cid:1) --1 OO TT
(cid:96)
.. SF(cid:96) ii mna il ll ay r, lyw ,e (cid:0)2w
(cid:1)
-r Oite T(cid:0) mn 1(cid:1) d- eO noT tm
(cid:96)
est mod ie nn sto at ne cm esi on fs (cid:0)ta 2n (cid:1)c -Oes Tof
.
We present below the required preliminaries and tech- 1 (cid:96) 1 (cid:96) 1 (cid:96)
niques. We revisit the KK13 [21] protocol and present a
B. Walsh-Hadamard (WH) Codes
concrete attack on it in Section III. Next, our proposed
actively secure protocol with efficiency and security analysis Walsh-Hadamard(WH)codeisalinearcodeoverabinary
is presented in Section IV. Section V shows our empirical alphabet F that maps messages of length p to codewords of
2
findings and analysis. Lastly, the application of our actively length2p.WeuseWHcodethatmapsmessagesoflengthlogκ
secure protocol in PSI appear in Section VI. to codewords of length κ. For x∈{0,1}logκ, WH(x) denotes
theWHencodingofxdefinedasWH(x):=(x⊗a) .
a∈{0,1}logκ
A. Notations Itistheκ-bitstringconsistingofinnerproductsofeachlogκ-
bitstringawithx.Foreachκ,theWHcode,denotedbyCκ is
WH
Weuse⊕todenotebitwiseXORoperationand(cid:12)todenote defined as the set {WH(x)} . Note that Cκ contains
x∈{0,1}logκ WH
bitwise AND operation. We denote vectors in bold smalls and κcodewordseachoflengthκbits.OurOTextensionprotocol
matricesinboldcapitals.ForamatrixA,weleta j denotethe relies on the following well-known property of WH codes.
jthrowofA,andai denotetheithcolumnofA.Foravector
a, a i denotes the ith element in the vector. For two vectors a Theorem II.1. The distance of C Wκ H is κ 2 when κ is a power
and b of length p, we use the notation a⊕b to denote the of 2.
vector (a ⊕b ,··· ,a ⊕b ) and the notation a(cid:12)b to denote
1 1 p p
m C. Hash Function and Random Oracle Model
(cid:76)
the vector (a (cid:12)b ,··· ,a (cid:12)b ). The notation a denotes
1 1 p p j
j=1 We use a hash function H :{0,1}∗ →{0,1}Poly(κ) which
theXORofmvectors,i.e.a 1⊕···⊕a m.Wedenotebya⊗b we model as a random oracle. Namely, we prove the security
p
(cid:76) of our protocol assuming that H implements a functionality
theinner-productvalue a (cid:12)b .Finally,supposec∈{0,1},
i i
F which for different inputs x, returns uniform random
i=1 RAND
then c(cid:12)a denotes the vector (c(cid:12)a 1,··· ,c(cid:12)a p). We denote output values from the range of H(x).
by a← A the random sampling of a from a distribution A.
R
We denote by [x], the set of elements {1,...,x}. III. ANATTACKON[21]PROTOCOL
We denote by HDI a function that takes two binary vectors The KK13 OT extension protocol is known to provide
of same length and returns the indices where the input vectors the best communication complexity among the existing con-
3structions when the input length of the sender is ‘short’. The message is H(i,b ) (since a = (b ⊕(s(cid:12)c ))) which the
i i i ri
protocol is proven to be secure against a semi-honest receiver receivercancomputewiththeknowledgeofBmatrix.Forthe
and a malicious sender. It was not known if the protocol is jth message where j is different from r , the pad turns out to
i
(cid:0) (cid:1)
secure against malicious receiver. We show that the protocol be H i,b ⊕(s(cid:12)(c ⊕c )) where c and c are distinct
i ri j ri j
is insecure against a malicious receiver. We prove this by codewords. Since the distance of WH code Cκ is κ/2, c
WH ri
giving an attack that can be mounted by a maliciously corrupt and c are different at κ/2 positions implying that κ/2 bits
j
receiver to break the security of the sender. Our finding sets of s contribute to the input of the random oracle H. Since
thestageforamaliciouslysecureOTextensioninKK13style the vector s is unknown to the receiver (recall that the sender
which is the concern of this paper. Below we recall the KK13 picks s), it is hard for an PPT receiver to retrieve the other
OT extension protocol prior to presenting our attack. We also pads making the protocol secure for a sender. The protocol of
briefly recall its efficiency analysis from [21]. KK13 that realizes (cid:0)n(cid:1) -OTm given ideal access to (cid:0)2(cid:1) -OTκ
1 (cid:96) 1 m
appears in Fig. 1.
A. KK13 OT Extension Protocol
It is easy to verify that the protocol is correct (i.e., z =
i
on
aT nhe inO stT ane cx ete on fsi (cid:0)o 2n
(cid:1)
-p Or Tot κo .c Wol eco ren cs atr lu lc tt hs ea si(cid:0) mn 1(cid:1) p- leO rT vm
(cid:96)
ersr ie oly nin og
f
x i,ri) when both parties follow the protocol.
the protocol that re1 ducesκ (cid:0)n(cid:1) -OTm to (cid:0)2(cid:1) -OTκ. It is well-
known that (cid:0)2(cid:1) -OTκ can be1 cons(cid:96) tructed1 from m (cid:0)2(cid:1) -OTκ with B. An Attack
1 m 1 κ
some additional cost.
Attheheartoftheattackliesacleverwayofmanipulating
Following the footstep of [17], KK13 OT extension allows the E matrix (cf. Section III-A) which should contain WH
thereceivertosendanm×κmatrixcolumn-wisetothesender codewords in its rows in an honest execution. Recall that the
using an instance of (cid:0)2(cid:1) -OTκ where the sender acts as the security of the sender lies in the fact that the distance of WH
receiver and vice versa1 . In [1m 7] OT extension, the ith row of codeCκ isκ/2.Thepadsforthemessagesthatarenotchosen
WH
the transferred matrix allows the sender to create two pads for as the output by the receiver, are the random oracle outputs of
thetwomessagesintheithextendedOT.Oneofthetwopads an input consisting of κ/2 bits of s. Since the receiver R does
is a function of the sender’s input bit vector to (cid:0)2(cid:1) -OTκ and not know s, it cannot guess the pads too in polynomial time.
1 m
thus is unknown to the receiver. The other pad is completely So one way of breaking the privacy of the other inputs of the
knowntothereceiver.Thepadknowntothereceiverisusedas senderistofindoutthebitsofthevectors.Ourstrategyallows
the mask for the intended message of the receiver. The above the receiver to recover the ith bit of s at the cost of two calls
allows the receiver to unmask and learn its intended message to the random oracle under the assumption that R has apriori
foreachextendedOTbutnothingmore.Goingalongthesame knowledge of its chosen input x i,ri for the ith extended OT.
line, KK13 OT extension allows the sender to create n pads This is achieved by tweaking the rows of E matrix which are
for the n messages in the ith extended OT using the ith row codewords from C Wκ H in an honest execution. Specifically, the
of the transferred matrix. Much like IKNP, the receiver knows ithrowofE,e iisc ri inanhonestexecution.Itisnowtweaked
exactly one pad out of the n pads and the pad it knows is to a κ-bit string that is same as c ri in all the positions barring
in fact the mask for its intended message. All the remaining the ith position. Specifically, recall that a WH codeword c i
n − 1 pads are function of the sender’s input bit vector to from C Wκ H is a κ-length bit vector (c i,1,...,c i,κ). We denote
(cid:0)2 1(cid:1) -OTκ m and thus are unknown to the receiver. The ability complement of a bit b by b. Then the ith row e i of E is set
to generate n masks instead of just 2 from each of the rows as(c i,1,...,c i,i,...,c i,κ).Thematrixistweakedasabovefor
of the transferred matrix is achieved by cleverly incorporating every ith row as long as i ≤ κ. The rest of the rows in E
WHcodewordsfromCκ ineachoftherowsofthetransferred starting from κ to m do not need to be tweaked. The matrix
WH
m×κ matrix. The use of Cκ restricts the value of n to be at Eaftertweakingisgivenbelow.Wedenotethetweakedmatrix
WH
most κ. as E and the tweaked rows as c ri for i≤κ.
The protocol uses WH code Cκ that consists of κ code-
WH
words each of length κ denoted as (c ,··· ,c ). The receiver
1 κ
R chooses two random m×κ matrices B and D such that c c ... ... ... c   c 
r1,1 r1,2 r1,κ r1
i stht eh e ndr ro ee rw ce Sio vf e prm icf ka ot srri ax th κE e i b= t ih tB le ex n⊕ t gen tD hde vi ds ecOc tor Ti r.w sOh une nr t ie h foer ri moi t ls h yet rh ae tha ri an n np d du , ot t mho ef
.
  

c r2 . . .,1 c r2 . . .,2 . .. ... .. . . .. . .. ... c r2 . . .,κ   
 
  
 
c r . . .2   
 
T Nh ae mep la yr ,ti te hs et sh ee nn dei rnt Ser aa cc tt sv ai sa th(cid:0) e2 1(cid:1) r- eO ceT iκ m verre wv ie tr hsi in ng put th seir anr dol te hs e. E=   c r . . .i,1 c r . . .i,2 . .. ... c r . . .i,i . .. ... c ri . . .,κ    =    c . . .ri    
tr
A
th hec e ee se ui bv x
c
ie e
th
wr cu
t
iR
h
sti eao ta n Ac tht o Ns ef Da i(cid:0) ts 2 1
h
o(cid:1)a f- rO os swe Tn κ m aod nf,e dr t Ah cw e ii sst ,h e tn
h
ii .d
e
en e .p r iu
t
ahhts o rl o{ =d wb sj a (o, bn fd mj
B
⊕} j ×
x
(∈ so[κ κ
r
(cid:12)e]. dm cA a wtf r it )i te )x hr
.
    


cc rr κκ
.
.
.,,1 1 cc rr κκ
.
.
.,, 22 .. ... .... c rc (κr +κ
.
.
., 1j ),j .. ... .... c rc (κr +κ
.
.
., 1κ ),κ    



    


cc rκr
.
.
.+κ 1    



ri i i ri
With the ith row a i of the matrix A, the sender creates n c m,1 c m,2 ... ... ... c m,κ c rm
pads for the n messages in the ith extended OT as follows:
(cid:8) (cid:0) (cid:1)(cid:9)
H i,a ⊕(s(cid:12)c ) where H is a random oracle. The
i j j∈[n]
jth pad will be used to blind the jth message of the sender in When R uses E instead of E, the ith row of A for i≤κ
the ith extended OT.It is easy to note thatthe pad for the r th will be a =(b ⊕(s(cid:12)c )). The pad used to mask the r th
i i i ri i
4Fig. 1: The KK13 OT Extension Protocol
Protocol for (cid:0)n(cid:1) -OTm from (cid:0)2(cid:1) -OTκ
1 (cid:96) 1 m
(cid:8) (cid:9)
– Input of S: m tuples (x ,··· ,x ) of (cid:96) bit strings.
i,1 i,n i∈[m]
– Input of R: m selection integers (r ,··· ,r ) such that each r ∈[n].
1 m i
– Common Inputs: A security parameter κ such that κ≥n, and Walsh-Hadamard code Cκ =(c ,··· ,c ).
– Oracles and Cryptographic Primitives: A random oracle H :[m]×{0,1}κ →{0,1}(cid:96).WH An ide1 al (cid:0)2(cid:1) -Oκ Tκ primitive.
1 m
1) Seed OT Phase:
a) S chooses s←{0,1}κ at random.
b) R forms two m×κ matrices B and D in the following way:
– Choose b ,d ←{0,1}κ at random such that b ⊕d =c . Let E:=B⊕D. Clearly e =c .
i i i i ri i ri
c) S and R interact with (cid:0)2(cid:1) -OTκ in the following way.
1 m
– S acts as receiver with input s.
– R acts as sender with input
(cid:8) (bj,dj)(cid:9)
.
j∈[κ]
– S receives output {aj} and forms m×κ matrix A with the jth column of A as aj. Clearly
j∈[κ]
i. aj =(cid:0) bj⊕(s (cid:12)ei)(cid:1) and
j
(cid:0) (cid:1) (cid:0) (cid:1)
ii. a = b ⊕(s(cid:12)e ) = b ⊕(s(cid:12)c ) .
i i i i ri
2) OT Extension Phase:
(cid:0) (cid:1)
a) For every i∈[m], S computes y =x ⊕H i,a ⊕(s(cid:12)c ) and sends {y } .
i,j i,j i j i,j j∈[n]
b) For every i∈[m], R recovers z =y ⊕H(i,b ).
i i,ri i
message x in ith extended OT is: protocol, the efficient transformation of [29] is used. The
H(cid:0) i,ai i,r ⊕i (s(cid:12)c ri)(cid:1) =H(cid:16) i,b i⊕(cid:0) s(cid:12)(c
ri
⊕c ri)(cid:1)(cid:17) atr da dn is tf io or nm alat (i oo un tsg ide ene thra ete es xe(cid:0) cn 1 u(cid:1) t- iO onT1 (cid:96) offr (cid:0)o 2m (cid:1) -O(cid:0) T2 1(cid:1) lo- gO nT )l κo cg on mmw uit nh ica an
-
1 κ
(cid:16) (cid:17) tioncostofO((cid:96)n)bits.Thistransformationcanberepeatedm
=H i,b ⊕(s(cid:12)0i−110κ−i
i times to reduce (cid:0)n(cid:1) -OTm to (cid:0)2(cid:1) -OTmlogn with an additional
=H(cid:0) i,b i⊕0i−1s i0κ−i(cid:1) communicationco1 stofO(cid:96) ((cid:96)mn1 )bits.κ Sotoget(cid:0)n 1(cid:1) -OTm
(cid:96)
asthe
Now note that the malicious receiver has cleverly made the outputfromIKNPprotocol,first(cid:0)2 1(cid:1) -OTm κ logn isproducedvia
pad used for x a function of sole unknown bit s . With the [17] and then the reduction from (cid:0)n(cid:1) -OTm to (cid:0)2(cid:1) -OTmlogn
i,ri i 1 (cid:96) 1 κ
knowledge of its chosen input x and the padded message is used that requires an additional communication cost of
i,ri
y thatthereceiverreceivesintheOTextensionprotocol,the O((cid:96)mn) bits. So the total communication turns out to be
i,ri
malicious receiver R recovers the value of the pad by finding O(mlogn·(κ+κ)+(cid:96)mn)=O(m(κlogn+n(cid:96))) bits. Now
y ⊕ x . It further knows that y ⊕ x is same as recall that n ≤ κ, a restriction that comes from the KK13
Hi, (cid:0)ri i,b ⊕i,r 0i i−1s 0κ−i(cid:1) . Now two calli s,r ti o thei, rr ai ndom oracle OT extension (due to the fact that Cκ contains κ codewords).
i i WH
H with inputs (cid:8) (i,b ⊕0i−1s 0κ−i)(cid:9) is sufficient to Giventhisbound,aslongas(cid:96)=Ω(logn),KK13OTextension
i i si∈{0,1} gives better communication complexity than IKNP protocol.
find the value of s . In the similar way, it can find entire
i
input vector of the sender, s with 2κ number (polynomial in
κ) of calls to the random oracle breaking the privacy of the IV. ACTIVELYSECUREOTEXTENSIONFORSHORT
sender completely. The attack works in the version of KK13 SECRETS
that reduces (cid:0)n(cid:1) -OTm to (cid:0)2(cid:1) -OTκ without any modification.
1 (cid:96) 1 κ WemaketheKK13OTextensionprotocolsecureagainsta
maliciousreceiverbyaddingaconsistencycheckthatrelieson
C. Efficiency of [21]
linearityofWHcodeandaddsacommunicationofO(µlogκ)
Since efficiency is the prime focus of this paper and we bits irrespective of the number of extended OTs. We first
build an OT extension protocol in KK13 style secure against discuss the properties of WH code relevant to us for the
malicious adversaries, we recall the communication complex- correctness of the consistency check. We then discuss the
ity of KK13 from [21]. For complexity analysis we consider check and our actively secure protocol. As we will see the
the version of KK13 that reduces (cid:0)n(cid:1) -OTm to (cid:0)2(cid:1) -OTκ (pre- check involves an additional trick apart from the linearity of
1 (cid:96) 1 κ
sented in Appendix D of [21]) and requires less communi- WH codes to achieve the claimed communication complexity.
cation than the one that reduces (cid:0)n(cid:1) -OTm to (cid:0)2(cid:1) -OTm. The We also describe the required ideal functionalities.
1 (cid:96) 1 κ
communication complexity of KK13 OT extension producing
(cid:0)n(cid:1) -OTm is O(m(κ+n(cid:96))) bits. A. Randomized Linearity Testing
1 (cid:96)
The best known semi-honest OT extension protocol before We focus on WH code that maps messages of length
KK13 is IKNP protocol [17] which has a communication logκ to codewords of length κ. A WH codeword for a
complexity of O(m(κ + (cid:96))) bits for producing (cid:0)2(cid:1) -OTm logκ-bit input x can be viewed as a truth table of a linear
from (cid:0)2(cid:1) -OTκ. To get (cid:0)n(cid:1) -OTm as the output from1 IKN(cid:96) P function L : {0,1}logκ → {0,1} parametrised with x
1 κ 1 (cid:96) x
5where L (a) = x ⊗ a. The WH codeword for x can be |A|=|B|=2η−1.Wenowshowthatatleast2η−1 stringslead
x
definedasWH(x):=(L (a)) .Itiseasytonotethat toanon-codewordwhentheyareusedaslinearcombinersfor
x a∈{0,1}logκ
L x(a) = L a(x) for any a ∈ {0,1}logκ. So we can rewrite the set of non-codewords y i1,...,y iη. We prove our claimby
the WH codeword for x as WH(x) := (L (x)) . showing that for every element in set A, there exists at least
a a∈{0,1}logκ
It is also easy to note that L () is a linear function since oneuniquestringthatwhenusedforlinearcombinationofthe
a
L (x⊕y)=L (x)⊕L (y)foranyxandyin{0,1}logκ.This non-codewordswillleadtoanon-codeword.Considerastring
a a a
implies that given codewords, say c and c corresponding w from set A. We have two cases to consider:
x y
to x and y respectively, the codeword for x ⊕ y can be (i)wwhenusedasthelinearcombinerfory i1,...,y iη yieldsa
obtained as c ⊕ c . In general, any linear combination of non-codeword.Inthiscasewitselfisthestringandelementin
x y
a set of WH codewords will lead to a WH codeword. On the Athatwhenusedasthelinearcombinerforthenon-codewords
other hand XOR of a codeword and a non-codeword will be a will lead to a non-codeword.
non-codeword. We note that the above statements are true for (ii)wwhenusedasalinearcombinerfory i1,...,y iη yieldsa
pruned code PRN (Cκ ) for any I of size less than κ/2. The codeword.Notethatwisastringthatdenotesanevennumber,
I WH
distance of PRN (Cκ ) is κ/2−|I| which is at least 1. saypin{0,...,2η−1}.Theleastsignificantbitofwisazero.
I WH
The string corresponding to p+1 will belong to the set B and
In our OT extension protocol, we need to verify whether
will have the same form as w except that the least significant
a set strings are individually valid WH codewords or not. In
bit will be 1. The linear combination of y ,...,y with
particular the number of strings to be verified is proportional
i1 iη−1
respecttowisacodeword.Weexcludey fromthelistsince
to the number of extended OTs output by the OT extension
iη
the least significant bit of w is zero. Whereas y is a non-
protocol. In practice, it will be in the order of millions.
iη
codeword and will be included in the linear combination with
Individual string testing may inflate the computation and the
respect to the string corresponding to p+1.
communication cost many-fold. We take the following route
to bypass the efficiency loss. Given ν strings for validity Clearly, the string corresponding to p+1 will lead to a
verification, we compress them to one string via linear com- non-codeword as the linear combination of a codeword and a
bination taken using a uniform random vector of length ν and non-codeword always gives a non-codeword. We have shown
then check the compressed string only for validity. We show that for every w that leads to a codeword, there is a unique
that the compression process ensures that the output string stringinB thatleadstoanon-codeword.Themappingisone-
will be a non-codeword with probability at least 1 if the to-one.
2
input set contains some non-codeword(s). Below we present
We can now conclude that at least half the possibilities of
the randomized linearity test for ν strings in Fig 2 and its
b ,...,b leads to a non-codeword when used as a linear
probability analysis in Theorem IV.1.
i1 iη
combiner. Since the linear combiners are chosen uniformly
at random, the probability that the linear combination that
Fig. 2: A Randomized Linearity Test for Many Strings will result from the non-codewords y ,...,y is a non-
i1 iη
codeword is at least 1. Recall that any linear combination
2
Randomized Linearity Test for ν Strings of the remaining strings that are codewords will result in a
– Input: ν κ-bit strings y ,...,y . codeword.Sothecompressedstringy resultedfromthelinear
1 ν
– Output: Accept or Reject indicating whether combination of all the ν strings will be a non-codeword with
the strings y 1,...,y ν passes the test or not. at least 1 probability too.
2
1) Selection of Random Combiners: Choose ν bits
It is easy to note that the above theorem holds true for
b ,...,b uniformly at random.
2) T1 hetest:ν Computey=(cid:76)ν i=1b i(cid:12)y i.OutputAccept PRN I(C Wκ H) for any I of size less than κ/2. So we get the
ifyisavalidWHcodeword,outputRejectotherwise. following corollary.
Corollary IV.2. Let I ⊂ [κ] be a set of size less than κ/2.
Theorem IV.1. Assume that some of the ν κ-bit strings Assumethatsomeoftheνκ−|I|-bitvectorsy ,...,y arenot
1 ν
y te1 s, t. p. r. e, sy eν ntea dre inno Ft iW gH
2
c oo ud tpe uw to srd Rs e. jT eh ce tra wn id to hm pi rz oe bd al bin ile ita yri aty
t
p ar tu len ae sd tW 1H whc eo rd ee ywo =rd (cid:76)s. T νhen
b
y (cid:12)(cid:54)∈ yP aR nN dI( thC eWκ H b) itw si bth ,p .r .o .b ,a bbi ali rty
e
least 1. uniform2 random. i=1 i i 1 ν
2
Proof: Without loss of generality, let i 1,...,i η denote B. Functionalities
the indices of the input strings that are non-codewords. That
is, {i ,...,i } ⊆ {1,...,ν} and y ,...,y are exactly the We describe the ideal functionalities that we need. Below
non-c1 odeworη
d strings among the
sei1
t of ν
iniη
put strings. It is we present an OT functionality parameterized using three
easy to verify that any linear combination of the remaining parameters (cid:96) that denotes the string length of the sender’s
strings that are codewords will result in a codeword. So we inputs, n that refers to 1-out-of-n OTs and m that denotes
concentrate on the linear combination that can result from the number of instances of the OTs.
the non-codewords y i1,...,y iη. Let the uniform random bits Next we present a functionality to generate uniformly
used to find the linear combination of the non-codewords be random common coins.
b ,...,b . There are 2η possibilities in total for these η bits
i1 iη
whichcanbeinterpretedasnumbersintheset{0,...,2η−1}.
C. The Protocol
We divide these 2η strings or numbers in two sets, say A and
B. A and B consist of all the strings that corresponds to even Wenowdescribetheprotocolthatrealizes(cid:0)n(cid:1) -OTm given
and odd numbers respectively from {0,...,2η −1}. Clearly idealaccessto(cid:0)2(cid:1) -OTκ.Theprotocolissimilart1 othep(cid:96) rotocol
1 κ
6Fig. 3: The Ideal Functionality for (cid:0)n(cid:1) -OTm the protocol is aborted in both the real and ideal worlds when
1 (cid:96) the latter event happens. Our construction appears in Fig. 5.
Functionality F O(n T,m,(cid:96)) 1)Security: The correctness of our protocol follows from
F(n,m,(cid:96)) interacts with S, R and the adversary S and is param- thecorrectnessoftheKK13protocolandthecorrectnessofthe
OT
eterized by three parameters (cid:96) that denotes the string length of consistencycheck.WhiletheformerisexplainedinSectionIII,
the sender’s inputs, n that refers to 1-out-of-n OTs and m that
the latter is explained below. The linearly combined vectors
denotes the number of instances of the OTs. e(l) for l ∈[µ] will be valid codewords follows directly from
(cid:8) (cid:9)
• Upon receiving m tuples (x ,··· ,x ) of (cid:96)
i,1 i,n i∈[m] thelinearityofWHcodeasmentionedinSectionIV-A.When
b suit cs htr ti hn ag ts ef aro chm rSa ∈nd [nm
]
fs roel mect Rio ,n thin ete fug ner cs ti( or n1 a, li· t· y· s, er nm d)
s
R is honest we have a i = b i⊕(e i(cid:12)s) and c α(l) = e(l) for
(cid:8) (cid:9) i l∈[µ]. Thus, for every l∈[µ],
x to R. Otherwise it aborts.
i,ri i∈[m]
m+µ m+µ
Fig.4:TheIdealFunctionalityforgeneratingrandomcommon a(l) = (cid:77) w(l)(cid:12)a = (cid:77) w(l)(cid:12)[b ⊕(e (cid:12)s)]
i i i i i
coins
i=1 i=1
(cid:34)m+µ (cid:35) (cid:34)(cid:32)m+µ (cid:33) (cid:35)
Functionality F COIN = (cid:77) w i(l)(cid:12)b i ⊕ (cid:77) w i(l)(cid:12)e i (cid:12)s
F interacts with S, R and the adversary S.
COIN i=1 i=1
• Upon receiving (coin,(cid:96)) from both S and R, the =b(l)⊕(e(l)(cid:12)s)
functionality generates (cid:96) random bits, say w and sends
κ κ
w to both S and R. Otherwise it aborts. a(l) =(cid:77) a(l) =(cid:77) (b(l)⊕(s (cid:12)e(l)))=b(l)⊕p(l)
i i i i
i=1 i=1
of KK13 (cf. Fig. 1), except that our protocol includes a
consistencycheckforpreventingRfrombehavingmaliciously Now it is easy to verify that the protocol is correct (i.e., z i =
andusingnon-codewordsinmatrixE.Thecheckmakesuseof x i,ri) when both the parties follow the protocol.
the Randomized Linearity Testing described in Section IV-A.
Wenowmoveontothesecurityargumentforourprotocol.
ItistrivialtoseethatRandomizedLinearityTestalonedoesn’t
The original OT extension of [21] provides security against a
suffice, since a malicious R can provide some vector for the
malicious S. Since our consistency check involves message
check independent from what he had used in the seed OTs.
communication from R to S, it does not offer any new scope
Thus we need a check to ensure that the vector provided by
for a malicious sender to cheat. However, the check may
R for the check is consistent with the vectors used in the seed
revealsomeinformationaboutR’sinput.RecallthatR’sinput
OTs. We make use of the fact that if both S and R are honest,
is encoded in the rows of matrix E and during the check,
then we have a = b ⊕(e (cid:12)s). A closer analysis of this
i i i a random linear combination of the rows of E (where the
expressiongivesasimpleverificationmechanismforacorrupt
combinerisknowntoS)ispresentedtoSforverification.The
R. Namely, R sends to S a random linear combination of the
check is repeated for µ times. To prevent information leakage
rows of B and E, say b and e respectively, for a commonly
on R’s input, E is padded with µ extra rows consisting of
agreed random linear combiner generated using a coin tossing
random codewords. This ensures that the linear combination
protocol. S then applies the same random linear combiner on
presentedinaninstanceofthecheckwilllookrandomandwill
therowsofAtoobtainaandchecksifbandeareconsistent
bear no information about the m rows of E that encode R’s
with s and a. Namely, whether a=b⊕(e(cid:12)s) holds or not.
input, unless the bits of the random combiner corresponding
Whiletheabovecheckissimple,itrequirescommunicationof
to the padded µ rows are zero. However, the probability of
κ-bit vectors, namely b and e. The communication is brought
that happening is only 1 .
downtoO(logκ)usingacoupleoftricks.First,asecondlevel 2µ
of compression function is applied on a, b and e(cid:12)s via xor A corrupt R can cheat by not picking the rows of E as
on the bits of the individual vectors. This results in three bits codewords. Our consistency check ensures an overwhelming
a, b and p respectively from a, b and e(cid:12)s. Then the check is probability for catching such a misconduct when ‘large’ num-
simplytoverifyifa=b⊕p.Noticethate(cid:12)scanbeperceived berofpositionsinthecodewordsaretweaked.Iffewpositions
as the linear combination of e for random combiner s. Since are tweaked, then we show that the tweaked codewords are
s is privy to S, R cannot compute the linear combination of error-correctable with high probability allowing the simulator
e(cid:12)s, namely p. So R sends across the index of the codeword in the proof to extract input of the corrupt R. We now prove
that matches with e and on receiving it S computes p after security formally.
computing e (cid:12) s. The index requires just logκ bits as Cκ
WH Theorem IV.3. The protocol in Fig. 5 securely realizes
consists of κ codewords. Thus our final consistency check
needscommunicationofO(logκ)bitsandasequenceofcheap F O(n T,m,(cid:96)) in the (F O(2 T,κ,κ),F COIN)-hybrid model.
xor operations. Lastly, the above check is repeated µ times,
where µ denotes the statistical security parameter. We show Proof:OurproofispresentedinUniversalComposability
that either a corrupt R tweaks few positions of the codewords (UC) framework recalled briefly in Appendix A. To prove
allowing error-correction or it is caught. Either event takes the security of our protocol, we describe two simulators.
place with overwhelming probability. Looking ahead to the The simulator S simulates the view of a corrupt sender
S
proof, the former event allows the simulator to extract the and appears in Fig. 6. On the other hand, the simulator S
R
inputs of corrupted R and thereby making the real and the simulates the view of a corrupt receiver and is presented in
ideal world indistinguishable with high probability. Whereas, Fig. 7.
7Fig. 5: Actively Secure OT Extension Protocol
Protocol for (cid:0)n(cid:1) -OTm from (cid:0)2(cid:1) -OTκ
1 (cid:96) 1 κ
(cid:8) (cid:9)
– Input of S: m tuples (x ,··· ,x ) of (cid:96) bit strings.
i,1 i,n i∈[m]
– Input of R: m selection integers (r ,··· ,r ) such that each r ∈[n].
1 m i
– Common Inputs: A security parameter κ such that κ≥n, and Walsh-Hadamard code Cκ =(c ,··· ,c ).
WH 1 κ
– Oracles, Cryptographic Primitives and Functionalities: A random oracle H : [m]×{0,1}κ → {0,1}(cid:96) and a pseudorandom
generator G:{0,1}κ →{0,1}m+µ. An ideal OT functionality F(2,κ,κ) and an ideal coin tossing functionality F .
OT COIN
1) Seed OT Phase:
a) S chooses s←{0,1}κ at random.
b) R chooses κ pairs of seeds (k0,k1) each of length κ.
j j
c) S and R interact with F(2,κ,κ) in the following way.
OT
– S acts as receiver with input s.
– R acts as sender with input
(cid:8) (k0,k1)(cid:9)
.
i i i∈[κ]
– S receives output {ksi} .
i i∈[κ]
2) OT Extension Phase I:
a) R forms three (m+µ)×κ matrices B, E and D in the following way and sends D to S:
– Set bj =G(k0).
j
– Set e =c for i∈[m]. For i∈[m+1,m+µ], set e to a randomly picked codeword from Cκ.
i ri i WH
– Set dj =bj⊕G(k1)⊕ej.
j
b) OnreceivingD,Sforms(m+µ)×κmatrixAwiththejthcolumnofAsetasaj =(cid:0) s (cid:12)dj(cid:1) ⊕G(ksj).Clearly,
(i) aj =(cid:0) bj⊕(s (cid:12)ej)(cid:1) and (ii) a =(cid:0) b ⊕(s(cid:12)e )(cid:1) =(cid:0) b ⊕(s(cid:12)c )(cid:1) . j j
j i i i i ri
3) Checking Phase:
a) S and R invoke F with (coin,µ(m + µ)) and receives an µ (m + µ)-length random bit vectors say
COIN
w(1),...,w(µ). On receiving the vectors, the parties do the following for l∈[µ]:
m+µ m+µ κ
– Rcomputesb(l) = (cid:76) w(l)(cid:12)b ,e(l) = (cid:76) w(l)(cid:12)e andb(l) = (cid:76) b(l).Itsendsb(l)andα(l)wheree(l) =c
i i i i i α(l)
i=1 i=1 i=1
to S.
m+µ κ κ
– S computes a(l) = (cid:76) w(l)(cid:12)a , a(l) = (cid:76) a(l), p(l) = s(cid:12)c and p(l) = (cid:76) p(l). It aborts the protocol if
i i i α(l) i
i=1 i=1 i=1
a(l) (cid:54)=b(l)⊕p(l).
4) OT Extension Phase II:
(cid:0) (cid:1)
a) For every i∈[m], S computes y =x ⊕H i,a ⊕(s(cid:12)c ) and sends {y } .
i,j i,j i j i,j j∈[n]
b) For every i∈[m], R recovers z =y ⊕H(i,b ).
i i,ri i
Fig. 6: Simulator S for Malicious Sender
S
Simulator S for S
The simulator plays the role of the honest R and simulates each stepS of the protocol (cid:0)n(cid:1) -OTm as follows. The communication of the
1 (cid:96)
Z with the adversary A who corrupts S is handled as follows: Every input value received by the simulator from Z is written on A’s
input tape. Likewise, every output value written by A on its output tape is copied to the simulator’s output tape (to be read by the
environment Z).
1) Seed OT Phase: On behalf of F(2,κ,κ), S receives s, the input of S to the functionality F(2,κ,κ). Next it picks κ PRG
OT S OT
seeds k each of length κ and sends (cid:8) k (cid:9) to S on behalf of F(2,κ,κ).
i i i∈[κ] OT
2) OT Extension Phase I: S picks a (m+µ)×κ matrix D uniformly at random and sends to S. It then computes matrix A
using the PRG seeds sent tS o S, s and D. Namely, it sets aj =(cid:0) s (cid:12)dj(cid:1) ⊕G(k ).
j j
3) CheckingPhase:Onreceiving(coin,µ(m+µ))fromSonbehalfofF ,S sendsµ(m+µ)-lengthrandombitvectors
COIN S
say w(1),...,w(µ). For l ∈ [µ], it then computes a(l) and a(l) using w(l) and A just as an honest S does. It chooses a
random WH codeword, say e(l), sets b(l) =a(l)⊕(s(cid:12)e(l)) and computes b(l) using b(l). Finally, it sends α(l), the index
of e(l) and b(l) to S.
(cid:8) (cid:9) (cid:0) (cid:1)
4) OT Extension Phase II: On receiving (y ,··· ,y ) from S, S computes x =y ⊕H i,a ⊕(s(cid:12)c ) for
i,1 i,n i∈[m] S i,j i,j i j
1≤i≤m and sends (cid:8) (x ,··· ,x )(cid:9) to functionality F(n,m,(cid:96)) on behalf of S.
i,1 i,n i∈[m] OT
c
We now prove that IDEAL ≈ hybrid model, we note that the difference between the
F O(n T,m,(cid:96)),SS,Z
simulated and the real view lies in D matrix. In the simulated
REAL when A corrupts S. In (F(2,κ,κ),F )-
(n)-OTm,A,Z OT COIN world, the matrix D is a random matrix, whereas in the real
1 (cid:96)
8κ κ
world it is a pseudo-random matrix. The indistinguishability and p = (cid:76) s (cid:12)e(l), we have a(l) = (cid:76) a(l) = b(l) ⊕p(l).
i i i
can be proved via a reduction to PRG security. i=1 i=1
Let a corrupt R sends the index α(l). Let ¯b(l) denote the bit
Next, we prove that IDEAL F O(n T,m,(cid:96)),SR,Z ≈c sent along with α(l) and let p¯(l) = (cid:76)κ s i(cid:12)c( il) where c
α(l)
=
REAL (n)-OTm,A,Z whenAcorruptsRviaaseriesofhybrids. i=1
The out1 put o(cid:96) f each hybrid is always just the output of the [c( 1l),...,c( κl)]. Now the check passes when b(l)⊕p(l) =¯b(l)⊕
environment Z. Starting with HYB = REAL , p¯(l). The equation implies that
0 (n)-OTm,A,Z
1 (cid:96)
we gradually make changes to define HYB 1 and HYB 2 as b(l)⊕¯b(l) = p(l)⊕p¯(l)
follows: (cid:32) κ (cid:33) (cid:32) κ (cid:33)
= (cid:77) s (cid:12)e(l) (cid:77) (cid:77) s (cid:12)c(l)
HYB : Same as HYB , except that in the Checking i i i i
1 0
Phase,theprotocolisabortedwhenthesimulatorS fails i=1 i=1
R κ
to extract the input of R. = (cid:77) s (cid:12)(e(l)⊕c(l))
i i i
HYB : Same as HYB , except that the default value 0(cid:96)
2 1 (cid:8) (cid:9) i=1
is substituted for the inputs x .
i,j i∈[m]∧j(cid:54)=ri Nownotethatthebitsofscorrespondingtotheindicesnotin
κ
concC ll ue da er ,ly a, sH wY eB
sh2
ow= thI aD tE eA veL
ryF O( tn Tw,m o,(cid:96) c) o,S nR s, eZ
c. utO ivu er hp yr bo ro idf sw ai rl el T Sod 2o κ−no |Tt |h pav oe ssa ibn iy lii tm iespa oc ft to hn et vh ee ctv oa rlu se wo if lli(cid:76)
= le1
as di(cid:12) to( pe a( il s) s⊕ ingc( il t) h) e.
computationally indistinguishable.
check.Sincesischosenuniformlyatrandomandisaκ-length
c bitvector,theprobabilitythatthechosenvectorwillhitoneof
HYB 0 ≈ HYB 1: The difference between HYB 0 and the 2κ−|T| possibilities is 2κ−|T| . The probability of passing
sH H oY Y mB B e1 0
l
∈tl hie e [s µp ]i rn (o ct fot .h c Fe o il gc .io s 5n )ad .bit Woio rt hn e ed ro en w ash ,a eb in nor a Hti (n l Y)g B(cid:54)=the tb h( elp )r p⊕o rt oo p tc o(o l c)l o. lfI o in sr t hh ie
t
tc hh eec vk aluis et oh fus ¯b(2 l)|1 T i| n. A aln lo thth ee2 µκ r w ina sy tao nf cep sas os fin tg heth ce hec ch kec sk oi ts ht ao
t
abortedwheneithertheconditionforabortion1 inHYB istrue the equalities b(l) ⊕p(l) = ¯b(l) ⊕p¯(l) for l ∈ [µ] hold good.
0
ortheextractionfails.Thelatterimpliesthateither |T|≥κ/2 Theprobabilityofpassingthecheckinthiswaythusturnsout
or there exist an index i such that PRN T(e i) (cid:54)∈ PRN T(C Wκ H). to be 21 µ. This concludes the proof.
Let PC denote the event of passing the consistency check Lemma IV.5. Pr[D]≤ 1 , when |T|<κ/2.
for a corrupt R who commits a non-codeword matrix E 2µ
in the seed OT phase. Let FE denote the event of failed
Proof: From Equation 1, we get the inequality Pr[D] ≤
extraction of R’s input. Lastly, let D denote the event that
Pr[FE | PC]. We now show that Pr[FE | PC] ≤ 1 . We note
Z distinguishes between HYB and HYB . Then, we have 2µ
0 1 that when |T| < κ/2, the reason for failure in extraction
Pr[D | ¬PC]=0 (since the execution aborts in both hybrids)
happens because some of the pruned rows of E do not
and Pr[D | PC]=Pr[FE | PC]. So we have,
belong to the the pruned code PRN (Cκ ). That is, there
T WH
exists an index i such that PRN (e ) (cid:54)∈ PRN (Cκ ). Now
Pr[D]=Pr[D | PC]·Pr[PC]+Pr[D | ¬PC]·Pr[¬PC] (1) T i T WH
the fact that the distance of Cκ is κ/2 and the number of
=Pr[FE | PC]·Pr[PC] WH
indices that are pruned are strictly less that κ/2 implies that
PRN (Cκ ) consists of κ vectors with distance κ/2 − |T|
We now show that Pr[D] is negligible in κ and µ because T WH
which is at least one. Now Corollary IV.2 implies that if
either the probability of passing the check is negligible or the
some of the pruned rows of E do not belong to PRN (Cκ ),
probability of failure in extraction when check has passed is T WH
then PRN (e(l)) belongs to PRN (Cκ ) with probability at
negligible.Inotherwords,weshowthatPr[PC]≤negl(κ,µ) T T WH
most 1/2. Since e(l)s are computed using independent and
when |T| ≥ κ/2 and Pr[FE | PC] ≤ negl(κ,µ) otherwise.
uniformly picked random linear combiners, at least one of
We capture the above in the following two lemmas.
PRN (e(1)),...,PRN (e(µ))donotbelongtoPRN (Cκ )with
T T T WH
Lemma IV.4. Pr[D]≤max( 1 , 1 ), when |T|≥κ/2. probability at least 1− 1 . Recall that e(l) is computed using
2|T| 2µ 2µ
w(l). But since PRN (e(l))=PRN (c ) and PRN (c )∈
T T α(l) T α(l)
Proof:When|T|≥κ/2,wenotethatPr[FE|PC]=1as PRN (Cκ ) for all l ∈ [µ], it implies that PRN (ei) for all
T WH T
theextractionalwaysfails.PluggingtheequalityinEquation1, i ∈ [m + µ] belong to PRN (Cκ ) with probability at least
T WH
we get Pr[D] = Pr[PC]. Next we conclude the proof by 1− 1 . So we have Pr[¬FE | PC] ≥ 1− 1 which implies
2µ 2µ
showing that Pr[PC] = max( 1 , 1 ) which is negligible in Pr[FE | PC]≤ 1
2|T| 2µ 2µ
κ and µ.
c
HYB ≈ HYB : The difference between HYB and HYB
1 2 1 2
Consider lth iteration of the check in Checking Phase. (cid:8) (cid:9)
lies in the values for the inputs x . In HYB
Recall that a(l) at S’s end is computed as follows. First a(l) is i,j i∈[m]∧j(cid:54)=ri 1
these values are the real values of an honest S whereas in
m+µ
calculatedasa(l) = (cid:76) w i(l)(cid:12)a i wherea i =(cid:0) b i⊕(s(cid:12)e i)(cid:1) . HYB 2 these are the default value 0(cid:96). The security in this
i=1 case will follow from the random oracle assumption of H.
m+µ m+µ
Denoting b(l) = (cid:76) w(l)(cid:12)b and e(l) = (cid:76) w(l)(cid:12)e , we We proceed in two steps. First, assume that the distinguisher
i i i i of HYB and HYB does not make any query to H. We
i=1 i=1 1 2
have a(l) = b(l) ⊕(s(cid:12)e(l)). Lastly, denoting b(l) = (cid:76)κ b(l) showthatthepadsusedtomasktheunknowninputsofSwill
i be uniformly random and independent of each other due to
i=1
9Fig. 7: Simulator S for Malicious Receiver
R
Simulator S for R.
The simulator plays the role of the honest S and simulates each stepR of the protocol (cid:0)n(cid:1) -OTm as follows. The communication of the
1 (cid:96)
Z with the adversary A who corrupts R is handled as follows: Every input value received by the simulator from Z is written on A’s
input tape. Likewise, every output value written by A on its output tape is copied to the simulator’s output tape (to be read by the
environment Z).
1) Seed OT Phase: On behalf of F(2,κ,κ), S receives the input of R to the functionality, namely (cid:8) (k0,k1)(cid:9) .
OT R i i i∈[κ]
2) OT Extension Phase I:OnreceivingmatrixDfromR,S
computesEusingtheknowledgeof(cid:8) (k0,k1)(cid:9)
.Thatis,it
R i i i∈[κ]
computes E as ei =G(k0)⊕G(k1)⊕di, where i∈[κ].
i i
3) CheckingPhase:Onreceiving(coin,µ(m+µ))fromRonbehalfofF ,S sendsµ(m+µ)-lengthrandombitvectors
COIN R
say w(1),...,w(µ) to R. Then l ∈ [µ], it receives b(l) and α(l) from R and performs the consistency check honestly like
an honest S. If the check fails, then it sends Abort to F(n,m,(cid:96)) on behalf of R and halts. If none of the check fails, S
OT R
m+µ µ
computese(l) = (cid:76) w(l)(cid:12)e usingtherowsofEandfindsT =HDI(e(l),c )forl∈[µ].ItthencomputesT = (cid:83) T.
i i i α(l) l
i=1 l=1
If |T|≥κ/2 or there exists an index i such that PRN (e )(cid:54)∈PRN (Cκ)a, then it sends Abort to F(n,m,(cid:96)). Otherwise, S
T i T WH OT R
extracts the ith input of R as r where PRN (e )=PRN (c ) for i∈[m].
i T i T ri
4) OT Extension Phase II: S sends the input of R, namely (r ,··· ,r ) (such that each r ∈[n]) to functionality F(n,m,(cid:96))
R 1 m i OT
on behalf of R. From F(n,m,(cid:96)), it receives (cid:8) x (cid:9) . It then runs the protocol with R using (cid:8) x (cid:9) and 0(cid:96) for the
OT i,ri i∈[m] i,ri i∈[m]
(cid:8) (cid:9)
unknown inputs x .
i,j i∈[m]∧j(cid:54)=ri
aNote that PRNT(C Wκ H) consists of κ vectors with distance κ/2−|T| which is at least one when |T| < κ/2. This follows from the fact that the
distanceofCκ isκ/2.
WH
random oracle assumption. Recall that the pads for masking a hash function H : {0,1}∗ → {0,1}(cid:96)(κ) is C-correlation-
(cid:8) (cid:9) (cid:8) (cid:0) (cid:1)(cid:9)
x are H i,b ⊕(s(cid:12)(c ⊕c )) . robust if for any polynomial m(κ) and any non-uniform PPT
Sini c,j e Ci∈ κ[m i] s∧j a(cid:54)= Wri H code, the Hi ammingr wi eighj t of ei∈ ac[m h]∧ vej(cid:54)= ctr oi r distinguisherAprovidedwithinputC hasnegl(κ)probability
in the sW eH t (cid:8) (c ⊕c )(cid:9) is at least κ/2. Since s is of distinguishing the following distributions:
(p cic rk ie ⊕d ca jt )(cid:9)ra in ∈d
[mr oi
m ]∧j(cid:54)=fr
rj
o im
isi∈
{
u[ 0m
n,
i]
1
f∧ o}j rκ(cid:54)= m,r li
e yac dh isto rif buth tee dv oa vlu ee rs ain
do(cid:8)
ms ai(cid:12)
n –
(cid:110)(cid:8)(cid:0)
j,k,H(i,b i⊕((c j⊕c
k)(cid:12)s))(cid:1)(cid:9) i∈[m],j,k∈[n],j(cid:54)=k(cid:111)
where
of size at least 2κ/2. Now random oracle assumption lets us each string in {b i} i∈[m] is a κ-bit and s is a κ-bit
concludethatthepads(cid:8) H(cid:0) i,b ⊕(s(cid:12)(c ⊕c ))(cid:1)(cid:9) string chosen uniformly at random and independent of
i ri j i∈[m]∧j(cid:54)=ri {b } .
are random and independent of each other and thus pro- i i∈[m]
– U ; U denotes uniform distribution over
vide information-theoretic blinding guarantee to the values m(n−1)(cid:96) m(n−1)(cid:96)
(cid:8)
x
(cid:9)
.
{0,1}m(n−1)(cid:96).
i,j i∈[m]∧j(cid:54)=ri
Next,followingthestandardofproofsintherandomoracle 2)Efficiency: The actively secure protocol incurs a com-
model we allow the distinguisher to make polynomial (in κ) municationofO(κ2)bitsinSeedOTPhase.InOTExtension
number of adaptive queries to H. Clearly, if a distinguisher Phase I, R sends κ(m+µ) bits to S. In Checking Phase,
(cid:8)(cid:0)
mak (cid:1)e (cid:1)s (cid:9)a query to H on any of the values i,b i⊕(s(cid:12)(c ri⊕ S and R invokes F COIN. We follow the implementation of
c j)
i∈[m]∧j(cid:54)=ri
thatareusedtomasktheunknowninputsof [18] for F
COIN
that generates µ(m + µ) bits at one go
S, then it can distinguish between the hybrids. Such queries and uses a pseudorandom function (PRF) and a PRG. Let
are denoted as offending queries. As long as no offending F : {0,1}2κ → {0,1}κ be a keyed PRF with k ∈ {0,1}κ
k
query is made, each of these m(n−1) offending queries is be a uniform random string and G : {0,1}κ → {0,1}µ(m+µ)
(individually) distributed uniformly at random over a domain be a PRG. Then F can be realized as follows:
COIN
of size (at least) 2κ/2 and so the distinguisher’s probability of
hittinguponanoffendingqueryremainsthesameasinthecase 1. R generates and sends random s ←{0,1}κ to S.
R
hedoesnotmakeanyqueryatalltoH.Soifthedistinguisher 2. S generates and sends random s ←{0,1}κ to R.
S
makes q queries, then it’s probability of distinguishing only 3. Both parties compute s = F (s ,s ) and output
k S R
increases by a polynomial factor over 2−κ/2. w ||w ...||w =G(s) where each w ∈{0,1}(m+µ).
1 2 µ i
Our security proof relies on random oracle assumption of
H.However,asmentionedin[21],therandomoracleassump- WiththeaboveimplementationofF COIN,CheckingPhase
tion can be replaced with a generalized notion of correlation- incurs a communication of O(µlogκ). In OT Extension
robustness [17] referred as C-correlation-robustness [21] in a PhaseII,Scommunicatesmn(cid:96)bitstoR.Sothetotalcommu-
straightforwardway.Forcompleteness,werecallthedefinition nication our protocol is O(κ2+κ(m+µ)+µlogκ+mn(cid:96))=
of C-correlation-robust hash functions below. O(m(κ+n(cid:96))) (assuming m is asymptotically bigger than κ
and µ) bits which is same as that of KK13 OT extension.
Definition IV.6 ( [21]). Let C = {c ,...,c } be a set of
1 n
κ-bit strings such n = Poly(κ) and for any j,k with j (cid:54)= Computation-wise, Checking Phase constitutes the addi-
k, the Hamming distance between c and c is Ω(κ). Then tional work that our protocol does over KK13 protocol. The
j k
10Checking Phase involves cheap xor and bit-wise multiplica- IKNP, ALSZ15 and NNOB generate OTs of type
(cid:0)2(cid:1)
-OT .
1 1
tion operations. To compare with IKNP, ALSZ15 and NNOB, we convert the
output OTs of these protocols, namely
(cid:0)2(cid:1)
-OT to
(cid:0)n(cid:1)
-OT
1 1 1 (cid:96)
V. EMPIRICALRESULTS using the efficient transformation of [29] (cf. Section III-C).
WecompareourworkwiththeexistingprotocolsofKK13 To obtain a computational security guarantee of 2−128,
[21], IKNP [17], ALSZ15 [4] and NNOB [31] in terms of while KK13 and our protocol need 256 seed OTs, IKNP,
communication and runtime in LAN and WAN settings. The NNOB and ALSZ15 need 128, 342 and respectively 170 seed
implementation of KOS [18] is not available in the platform OTs. Among these, except IKNP and KK13, the rest are
that we consider for benchmarking. As per the claim made in maliciouslysecure.Toobtainastatisticalsecurityguaranteeof
KOS, the runtime of their OT extension bears an overhead of 2−40 against a malicious receiver, ALSZ15 and NNOB need
5%withrespecttoIKNPprotocolbothinLANandWAN.The 380 checks whereas we need 96 checks.
communication complexity of KOS is at least the complexity
We follow the approach of ALSZ15 implementation and
of IKNP. These results allow to get a clear idea on how KOS perform the OT extension in batches of 216 in sequential
fares compared to our protocol.
order. For each batch, the sender and the receiver perform the
In any practical scenario, the computation is not the prime seed OTs, participate in a coin tossing protocol, perform the
bottleneck, as computing power has improved a lot due to checks and finally obtain the output. We use one thread in the
improvements in hardwares. The communication overhead is sender as well as in the receiver side in order to calculate the
the main issue, and so most of the aforementioned protocols upper bound on the computation cost. However our code is
are aimed at improving the communication complexity. Our compatible with multiple threads where each thread can carry
empirical results show that our proposed protocol performs out a batch of OTs. Lastly, our seed OT implementation relies
way better than even the passively secure IKNP in terms of on the protocol of [33].
communication complexity when
(cid:0)n(cid:1)
-OTs with short input
1
are expected outcomes. Since ALSZ15, NNOB and KOS are A. Performance Comparison
built upon IKNP, they lag behind our protocol in performance
Since we build upon KK13 protocol, we first display in
too.Thoughourprimefocusistoimprovethecommunication
Table III-IV the overhead (in %) of our protocol compared
complexity, our protocol outperforms IKNP and the existing
to KK13. Notably, the communication overhead lies in the
actively secure protocols in runtime both in LAN and WAN
range 0.011%-0.028%. Table III shows that for large enough
setting. We now detail the software, hardware and imple-
numberofextendedOTs,theruntimeoverheadofourprotocol
mentation specifications used in our empirical analysis before
over KK13 ranges between 4-6% for both LAN and WAN.
presenting our experimental findings.
Table IV demonstrates that the runtime overheads drop below
Software Details. We build upon the OT extension code 2%wheninadditionthenumberofinputsofthesenderinthe
provided by the Encrypto group on github [1]. It contains the extended OTs is large enough.
OT extension implementations of KK13, NNOB and ALSZ15
Next, our empirical results are shown in Table V-VI and
in C++, using the Miracl library for elliptic curve arithmetic.
Fig. 8-9. First, we discuss our results in Table V and Fig. 8
WebuildupontheKK13codeforouractivelysecureprotocol.
where we vary m. Next, we focus on the results displayed in
AES-128 has been used for the PRG instantiation and the
TableVIandFig.9wherewevaryn.Inboththecasestudies,
random oracle has been implemented by the SHA-256 hash
ourprotocolturnsouttobethebestchoiceamongtheactively
function.
secure OT extensions and second best overall closely trailing
HardwareDetails.WehavetestedthecodeinastandardLAN KK13whichistheoverallwinner.Communicationcomplexity
networkandasimulatedWANsetting.Ourmachinehas8GB wise, our protocol is as good as KK13 and is way better than
RAM and an Intel Core i5-4690 CPU with 3.5 GHz processor the rest. The empirical results are in concurrence with the
speed. For WAN simulation, we used the tc tool of Linux, theoretical logn improvement of KK13 and our protocol over
where we introduced a round trip delay of 100 milliseconds IKNP (and its variants).
into the network, with a limited bandwidth of 20 Mbps.
Performance Comparison for varied m values. The results in
Implementation Details. We discuss our choice of m, n and (cid:96) Table V reflects that KK13 is the best performer in terms of
denoting the number of extended output OTs, the number of communicationas wellasruntimein LANandWAN. Ourac-
inputsofSineachextendedOTandthebitlengthofS’sinput tivelysecureprotocolisthesecondbestcloselytrailingKK13.
respectively. In other words, we refer to the parameters m,n Our protocol has communication overhead of 0.012-0.028%
and (cid:96) of (cid:0)n(cid:1) -OTm. Recall that as long as the input length of over KK13, while IKNP, ALSZ15 and NNOB have overheads
1 (cid:96)
S, namely (cid:96) satisfies the relation (cid:96) = Ω(logn), theoretically of 79.7-84%, 249% and 352% respectively. Noticeably, we
KK13 OT extension (and our proposed OT extension) gives observethatthecostforgenerating5×105 (cid:0)16(cid:1) -OT usingour
b IKet Nte Prc po rm otm ocu on lic aa nt dio in tsc vo am rip al ne tx sit (y cff .or Sep cro tid ou nci In IIg -C(cid:0)n )1 .(cid:1) F-O orTm (cid:96) benth ca hn
-
p ur so into gco Nl Nis Ole Bs .s Sth ia mn ilt ah re lyco ts ht eof cog se tne or fati gn eg ne1 r. a21 t5 in× g1 10 .5 2(cid:0) 51 16 ×(cid:1) - 1O 0T
6
marking, we take two approaches. First, we fix n = 16 and (cid:0)16(cid:1)
-OT using our protocol is 71.6% of the cost of generating
(cid:96)=4(=log16)andexperimentonthefollowingvaluesofm: 51 ×105 (cid:0)16(cid:1) -OT using ALSZ15.
1.25×105, 2.5×105, 5×105 and 1.25×106. Next, we fix m 1
to a value and vary n from 8 to 256 in the powers of 2. The In LAN setting, the overheads over KK13 vary in the
value of (cid:96) for each choice of n is set as logn. Our protocol rangeof3.78-6.48%,11-17.60%,14.4-22.7%and14.5-20.8%
and KK13 directly generate OTs of type
(cid:0)n(cid:1)
-OT whereas respectivelyforourprotocol,IKNP,ALSZ15andNNOB.The
1 (cid:96)
11each of its σ-bit element x into t blocks of η-bits. Next,
T ovA erB KL KE 13II fI o: rR pu ron dti um ce ina gnd (cid:0)1 1C 6(cid:1)o -m Om Tu m 4n .icationOverhead(in%)ofOurprotocol a forra knd =om 1(cid:0) ,.2 1η .(cid:1) .- ,O tT whis eru ese thd efi ro ar ndk oth mb Olo Tck do of esre tc he eiv fe or l’ ls owin ip nu gt
.
Denoting N = 2η, a random OT of above type generates
Runtime
Communication N random masks and delivers them to S. R receives from
m LAN WAN
the OT the mask corresponding to its block which acts as its
1.25×105 6.48 9.27 0.012
choicestring.Sthengeneratesamaskforeachofitselements
2 5. ×5× 101 505 6 5. .3 83
8
8 7. .7 06
9
0 0. .0 01 12
2 in X using the masks received from the t random
(cid:0)N(cid:1)
-OTs.
1.25×106 3.78 5.72 0.028 Similarly, R combines the masks it receives from t1 he OTs
to generate the mask corresponding to its input element y.
TABLEIV:RuntimeandCommunicationOverhead(in%)ofOurprotocol
The verification whether y is included in X is then done by
overKK13forproducing(cid:0)n 1(cid:1) -OT1 lo0 g6 n. performingchecksoverthemasks.NamelySsendsacrossthe
masks corresponding to all its elements in X. R verifies if the
Runtime mask corresponding to y matches with one of them or not. In
Communication
n LAN WAN a naive approach, PSI can be achieved by having the receiver
run the set inclusion protocol n times, once for each element
8 6.16 11.77 0.011 2
in Y. [35] and subsequently [34] improved the complexity
16 4.13 6.6 0.012
32 4.5 2.29 0.013 of the naive approach by reducing the number of OTs and
64 3.65 1.81 0.014 improving the input length of S in the OTs. Various hashing
128 1.24 1.18 0.015
techniques such as Simple Hashing [35] and Cuckoo Hashing
256 0.58 0.8 0.015
(with a stash s [20]), h-ary Cuckoo Hashing [10] and Feistel-
like functions [2] were used to achieve the goal. However, as
mentioned before, both [35] and [34] works in semi-honest
similar figures in WAN setting are 5.72-9.26%, 16-22.6%, setting. Indeed, Lambæk in his detailed analysis [22] finds
35.3-39%and24.1-29.1%respectivelyforourprotocol,IKNP, three vulnerabilities in [34], [35] when malicious adversaries
ALSZ15 and NNOB. A pictorial representation is shown in are considered. Details follow.
Fig. 8.
One of vulnerabilities corresponds to sender corruption.
Performance Comparison for varied n values. Here we set
Fixing the problem remains an open question. The remaining
m = 5 × 104 and vary n from 8 to 256 in the powers
two vulnerabilities correspond to the receiver corruption. In
of 2. Similar to the previous case study, KK13 turns out
moredetails,thefirstproblemcomesfromamaliciousreceiver
the best performer here as well (cf. Table VI). Our protocol
whocanlearnwhethersomeelementsofitschoiceoutsidehis
is the second best closely trailing KK13. Our protocol has
set Y of size n belong to S’s input X or not. The solution
communication overhead of 0.011-0.028% over KK13, while 2
proposed in the thesis to thwart this attack uses Shamir secret
IKNP, ALSZ15 and NNOB have overheads of 74.5-384.6%,
sharing (SS) paired with symmetric-key encryption (SKE).
239.5-549.4%and341.8-652.9%respectively.InLANsetting,
Recall that, S sends the masks corresponding to its elements
the overheads over KK13 vary in the range of 3.5-8.8%,
in X after the OT executions to help R identify the elements
12.2-263.8%, 22.2-282.7% and 20.5-267.5% respectively for
in the intersection. The idea of the proposed solution of [22]
our protocol, IKNP, ALSZ15 and NNOB. The similar figures
is to lock the masks using a key of SKE, secret share the key
inWANsettingare13.7-20.2%,27.1-77.4%,36.7-106.3%and
and allow R to recover the key only when R uses less than or
30.9-86.6% respectively for our protocol, IKNP, ALSZ15 and
equal to n elements in the set inclusion protocols (i.e. in the
NNOB. A pictorial representation is shown in Fig. 9. 2
OT executions). The second vulnerability may result from any
maliciousbehaviourofRintheOTexecutionsofsetinclusion
VI. APPLICATIONTOPRIVATESETINTERSECTION protocol.[22]proposestofixtheproblembyusingmaliciously
secure (against corrupt receiver) OT protocols. Using off-
Inaprivatesetintersection(PSI)protocol,asenderSanda
the-shelves maliciously secure OT extension protocols, [22]
receiver R hold sets X ={x ,...x } and Y ={y ,...y }
1 n1 1 n2
therefore obtains a PSI protocol that is maliciously secure
respectively.Thegoaloftheprotocolistoletthereceiverknow
against corrupt R but semi-honestly secure against corrupt S.
the intersection X ∩Y and nothing more. Put simply, a PSI
For complete details of the protocol of Lambæk, refer [22].
protocol realizes the functionality F (X,Y)=(⊥,X∩Y).
PSI
The set sizes are assumed to be public.
We propose to use our maliciously secure OT extension
We set our focus on the PSI protocols that are OT-based protocolinthePSIprotocolof[22]toobtainthemostefficient
so that we can employ our OT extension protocol in them to PSI protocol that is maliciously secure against corrupt R but
improve efficiency. [35] introduced an OT-based PSI protocol semi-honestly secure against corrupt S. As evident from the
relying on black-box usage of random
(cid:0)n(cid:1)
-OT. Subsequently, theoretical and experimental results presented in this work,
1
[34] improved the communication overhead of [35]. Both the our maliciously secure OT extension protocol is a better
protocolsaresemi-honestlysecure.Atthecoreoftheprotocols choice compared to the existing maliciously secure extension
liesanimportantbuildingblockcalledsetinclusionthatallows protocols [4], [18], [31] when the OTs required are of type
R to check whether its input, say y, is contained in X, owned
(cid:0)n(cid:1)
-OT. As PSI employs
(cid:0)n(cid:1)
-OT (instead of
(cid:0)2(cid:1)
-OT), our
1 1 1
by S, while preserving the input privacy of both the parties. extension protocol fits the bill. Lastly, we find a concrete
In the set inclusion protocol, the receiver breaks its σ-bit vulnerability for the malicious corrupt R case in Lambæk’s
element, say y into t blocks of η-bits. Similarly S breaks PSI protocol when semi-honest KK13 OT extension is used
12TABLE V: PerformanceComparisonofvariousOTextensionsforproducing(cid:0)16(cid:1) -OTm.
1 4
RuntimeinLAN(insec) RuntimeinWAN(insec) Communication(inMB)
m
KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB
1.25×105 02.16 02.30 02.54 02.65 02.61 13.38 14.62 16.40 18.10 16.90 04.77 04.77 08.66 16.67 21.60
2.5×105 04.23 04.50 04.88 05.26 05.05 24.32 26.45 29.26 33.80 31.40 09.54 09.54 17.15 33.33 43.21
5×105 08.50 09.00 09.78 10.04 10.10 47.39 50.75 56.9 65.00 60.40 19.08 19.08 34.79 66.62 86.39
1.25×106 21.68 22.50 24.07 24.81 24.84 115.34 121.94 133.81 158.60 143.20 47.69 47.70 87.74 166.54 215.95
Fig. 8: PerformanceComparisonofvariousOTextensionsforproducing(cid:0)16(cid:1) -OTm.
1 4
(a) LANRuntime
25
20
15
10
5
0
1.25 2.5 5 12.5
NumberofOTs(oforder105)
)s(emitnuR
(b) WANRuntime
KK13
150
Thispaper
IKNP
ALSZ15 100
NNOB
50
0
1.25 2.5 5 12.5
NumberofOTs(oforder105)
)s(emitnuR
(c) Communication
KK13
200
Thispaper
IKNP 150
ALSZ15
NNOB 100
50
0
1.25 2.5 5 12.5
NumberofOTs(oforder105)
)BM(noitacinummoC
KK13
Thispaper
IKNP
ALSZ15
NNOB
TABLE VI: PerformanceComparisonofvariousOTextensionsforproducing(cid:0)n(cid:1) -OT5×104 .
1 logn
RuntimeinLAN(insec) RuntimeinWAN(insec) Communication(inMB)
n
KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB KK13 This paper IKNP ALSZ15 NNOB
8 0.70 0.73 0.79 0.86 0.85 5.06 6.08 7.38 7.67 7.41 1.43 1.43 2.5 4.87 6.34
16 0.96 1.01 1.15 1.23 1.17 6.70 7.72 8.52 9.15 8.77 1.91 1.91 3.53 6.69 8.65
32 1.22 1.28 1.48 1.64 1.58 7.46 8.53 9.10 10.2 9.86 2.39 2.39 4.89 8.81 11.29
64 1.33 1.45 2.26 2.37 2.36 8.88 10.31 11.29 12.97 12.64 2.86 2.86 7.01 11.7 14.68
128 1.50 1.63 3.61 3.94 3.71 9.56 11.05 14.84 16.63 15.16 3.34 3.34 10.85 16.36 19.8
256 1.75 1.89 6.37 6.70 6.43 10.96 12.46 19.43 22.6 20.45 3.82 3.82 18.5 24.8 28.75
Fig. 9: PerformanceComparisonofvariousOTextensionsforproducing(cid:0)n(cid:1) -OT5×104 .
1 logn
(a) LANRuntime
6
4
2
8 16 32 64 128 256
Valueofn
)s(emitnuR
(b) WANRuntime
KK13
Thispaper 20
IKNP
ALSZ15
NNOB 15
10
5
8 16 32 64 128 256
Valueofn
)s(emitnuR
(c) Communication
30
KK13
Thispaper
IKNP
ALSZ15 20
NNOB
10
0
8 16 32 64 128 256
Valueofn
)BM(noitacinummoC
KK13
Thispaper
IKNP
ALSZ15
NNOB
in it. This confirms Lambæk’s concern of privacy breach of executions. The outputs to S are used to compute the masks
his PSI protocol that may result from privacy breach of the for the elements of X. Therefore by violating the privacy of
underlying OT protocols and further confirms the necessity of semi-honest KK13, R can completely recover the masks for
maliciously secure OT extension in Lambæk’s PSI protocol. all the elements of X bypassing the security of secret sharing
TheattackbythecorruptRgoesasfollows:Usingtheconcrete technique coupled with SKE. This allows R to learn whether
attack discussed in Section III for KK13 protocol, a corrupt someelementsofitschoiceoutsidehissetY ofsizen belong
2
R in the PSI protocol can recover the outputs to S in the OT to S’s input X or not.
13ACKNOWLEDGEMENTS [15] Y.Huang,J.Katz,V.Kolesnikov,R.Kumaresan,andA.J.Malozemoff,
“Amortizing garbled circuits,” in Advances in Cryptology - CRYPTO
We thank Peter Scholl and Emmanuela Orsini for point- 2014-34thAnnualCryptologyConference,SantaBarbara,CA,USA,
ing out a bug in the initial version of the paper. We also August17-21,2014,Proceedings,PartII,2014,pp.458–475.
thank Michael Zohner and Thomas Schneider for a useful [16] R.ImpagliazzoandS.Rudich,“Limitsontheprovableconsequencesof
discussion on the implementation part of the work. This one-waypermutations,”inProceedingsofthe21stAnnualACMSym-
posiumonTheoryofComputing,May14-17,1989,Seattle,Washigton,
work is partially supported by INSPIRE Faculty Fellowship
USA,1989,pp.44–61.
(DST/INSPIRE/04/2014/015727) from Department of Science
[17] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank, “Extending oblivious
& Technology, India.
transfersefficiently,”inAdvancesinCryptology-CRYPTO2003,23rd
Annual International Cryptology Conference, Santa Barbara, Califor-
nia,USA,August17-21,2003,Proceedings,2003,pp.145–161.
REFERENCES
[18] M.Keller,E.Orsini,andP.Scholl,“ActivelysecureOTextensionwith
optimaloverhead,”inAdvancesinCryptology-CRYPTO2015-35th
[1] “Encrypto group otextension code,” https://github.com/encryptogroup/
AnnualCryptologyConference,SantaBarbara,CA,USA,August16-20,
OTExtension.
2015,Proceedings,PartI,2015,pp.724–741.
[2] Y. Arbitman, M. Naor, and G. Segev, “Backyard cuckoo hashing:
[19] J.Kilian,“Foundingcryptographyonoblivioustransfer,”inProceedings
Constantworst-caseoperationswithasuccinctrepresentation,”in51th
ofthe20thAnnualACMSymposiumonTheoryofComputing,May2-4,
AnnualIEEESymposiumonFoundationsofComputerScience,FOCS
1988,Chicago,Illinois,USA,1988,pp.20–31.
2010,October23-26,2010,LasVegas,Nevada,USA,2010,pp.787–
796. [20] A. Kirsch, M. Mitzenmacher, and U. Wieder, “More robust hashing:
Cuckoo hashing with a stash,” SIAM J. Comput., vol. 39, no. 4, pp.
[3] G. Asharov, Y. Lindell, T. Schneider, and M. Zohner, “More efficient
1543–1561,2009.
oblivioustransferandextensionsforfastersecurecomputation,”in2013
ACMSIGSACConferenceonComputerandCommunicationsSecurity, [21] V. Kolesnikov and R. Kumaresan, “Improved OT extension for trans-
CCS’13,Berlin,Germany,November4-8,2013,2013,pp.535–548. ferring short secrets,” in Advances in Cryptology - CRYPTO 2013 -
33rdAnnualCryptologyConference,SantaBarbara,CA,USA,August
[4] ——, “More efficient oblivious transfer extensions with security for 18-22,2013.Proceedings,PartII,2013,pp.54–70.
malicious adversaries,” in Advances in Cryptology - EUROCRYPT
[22] M. Lambæk, “Breaking and fixing private set intersection protocols,”
2015 - 34th Annual International Conference on the Theory and
IACRCryptologyePrintArchive,vol.2016,p.665,2016.
Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-
30,2015,Proceedings,PartI,2015,pp.673–701. [23] E. Larraia, “Extending oblivious transfer efficiently - or - how to get
active security with constant cryptographic overhead,” in Progress in
[5] D.Beaver,“Correlatedpseudorandomnessandthecomplexityofprivate
Cryptology - LATINCRYPT 2014 - Third International Conference on
computations,” in Proceedings of the Twenty-Eighth Annual ACM
Cryptology and Information Security in Latin America, Floriano´polis,
Symposium on the Theory of Computing, Philadelphia, Pennsylvania,
Brazil,September17-19,2014,RevisedSelectedPapers,2014,pp.368–
USA,May22-24,1996,1996,pp.479–488.
386.
[6] G. Brassard, C. Cre´peau, and J. Robert, “All-or-nothing disclosure of
[24] Y. Lindell, “Fast cut-and-choose-based protocols for malicious and
secrets,” in Advances in Cryptology - CRYPTO ’86, Santa Barbara,
covertadversaries,”J.Cryptology,vol.29,no.2,pp.456–490,2016.
California,USA,1986,Proceedings,1986,pp.234–238.
[25] Y. Lindell and B. Pinkas, “An efficient protocol for secure two-party
[7] R. Canetti, “Universally composable security: A new paradigm for
computation in the presence of malicious adversaries,” J. Cryptology,
cryptographic protocols,” in 42nd Annual Symposium on Foundations
vol.28,no.2,pp.312–350,2015.
of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas,
Nevada,USA,2001,pp.136–145. [26] Y. Lindell and B. Riva, “Blazing fast 2pc in the offline/online setting
with security for malicious adversaries,” in Proceedings of the 22nd
[8] C. Dong, L. Chen, and Z. Wen, “When private set intersection meets
ACMSIGSACConferenceonComputerandCommunicationsSecurity,
bigdata:anefficientandscalableprotocol,”inProceedingsofthe2013
Denver,CO,USA,October12-6,2015,2015,pp.579–590.
ACMSIGSACconferenceonComputer&#38;communicationssecurity,
ser.CCS’13,2013,pp.789–800. [27] Y. Lindell and H. Zarosim, “On the feasibility of extending oblivious
transfer,”inTCC,2013,pp.519–538.
[9] S. Even, O. Goldreich, and A. Lempel, “A randomized protocol for
signingcontracts,”Commun.ACM,vol.28,no.6,pp.637–647,1985. [28] M.NaorandB.Pinkas,“Oblivioustransferandpolynomialevaluation,”
in Proceedings of the Thirty-first Annual ACM Symposium on Theory
[10] D. Fotakis, R. Pagh, P. Sanders, and P. G. Spirakis, “Space efficient
ofComputing,ser.STOC’99,1999,pp.245–254.
hashtableswithworstcaseconstantaccesstime,”inSTACS2003,20th
AnnualSymposiumonTheoreticalAspectsofComputerScience,Berlin, [29] ——, “Computationally secure oblivious transfer,” J. Cryptology,
Germany,February27-March1,2003,Proceedings,2003,pp.271– vol.18,no.1,pp.1–35,2005.
282. [30] J. B. Nielsen, “Extending oblivious transfers efficiently - how to get
[11] T. K. Frederiksen, T. P. Jakobsen, J. B. Nielsen, P. S. Nordholt, and robustnessalmostforfree,”IACRCryptologyePrintArchive,vol.2007,
C. Orlandi, “Minilego: Efficient secure two-party computation from p.215,2007.
generalassumptions,”inAdvancesinCryptology-EUROCRYPT2013, [31] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra, “A new
32ndAnnualInternationalConferenceontheTheoryandApplications approachtopracticalactive-securetwo-partycomputation,”inAdvances
of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Pro- inCryptology-CRYPTO2012-32ndAnnualCryptologyConference,
ceedings,2013,pp.537–556. SantaBarbara,CA,USA,August19-23,2012.Proceedings,2012,pp.
[12] O.Goldreich,S.Micali,andA.Wigderson,“Howtoplayanymental 681–700.
gameorAcompletenesstheoremforprotocolswithhonestmajority,” [32] J.B.NielsenandC.Orlandi,“LEGOfortwo-partysecurecomputation,”
in Proceedings of the 19th Annual ACM Symposium on Theory of in Theory of Cryptography, 6th Theory of Cryptography Conference,
Computing,1987,NewYork,NewYork,USA,1987,pp.218–229. TCC2009,SanFrancisco,CA,USA,March15-17,2009.Proceedings,
[13] O. Goldreich and R. Vainish, “How to solve any protocol problem 2009,pp.368–386.
- an efficiency improvement,” in Advances in Cryptology - CRYPTO [33] C. Peikert, V. Vaikuntanathan, and B. Waters, “A framework for
’87, A Conference on the Theory and Applications of Cryptographic efficientandcomposableoblivioustransfer,”inAdvancesinCryptology
Techniques, Santa Barbara, California, USA, August 16-20, 1987, - CRYPTO 2008, 28th Annual International Cryptology Conference,
Proceedings,1987,pp.73–86. SantaBarbara,CA,USA,August17-21,2008.Proceedings,2008,pp.
[14] D. Harnik, Y. Ishai, E. Kushilevitz, and J. B. Nielsen, “Ot-combiners 554–571.
via secure computation,” in Theory of Cryptography, Fifth Theory of [34] B. Pinkas, T. Schneider, G. Segev, and M. Zohner, “Phasing: Private
Cryptography Conference, TCC 2008, New York, USA, March 19-21, setintersectionusingpermutation-basedhashing,”inProceedingsofthe
2008.,2008,pp.393–411. 24thUSENIXConferenceonSecuritySymposium,ser.SEC’15,2015.
14[35] B.Pinkas,T.Schneider,andM.Zohner,“Fasterprivatesetintersection time it requires to execute the subprotocol implementing F
basedonotextension,”inProceedingsofthe23rdUSENIXConference is called the F-hybrid execution of Π and is denoted as
onSecuritySymposium,ser.SEC’14,2014. ΠF. The hybrid ensemble HYB (1κ,z) describes Z’s
ΠF,A,Z
[36] M.O.Rabin,“Howtoexchangesecretswithoblivioustransfer,”1981, output after interacting with A and the parties P , P running
0 1
harvard University Technical Report 81 talr@watson.ibm.com 12955 protocol ΠF. By UC definition, the hybrid ensemble should
received 21 Jun 2005. [Online]. Available: http://eprint.iacr.org/2005/
be indistinguishable from the real ensemble with respect to
187
protocol Π where the calls to F are instantiated with a
[37] A. Shelat and C. Shen, “Fast two-party secure computation with
minimalassumptions,”in2013ACMSIGSACConferenceonComputer realization of F.
andCommunicationsSecurity,CCS’13,Berlin,Germany,November4-
8,2013,2013,pp.523–534.
[38] A.C.Yao,“Protocolsforsecurecomputations(extendedabstract),”in
23rdAnnualSymposiumonFoundationsofComputerScience,Chicago,
Illinois,USA,3-5November1982,1982,pp.160–164.
[39] ——, “How to generate and exchange secrets (extended abstract),” in
27thAnnualSymposiumonFoundationsofComputerScience,Toronto,
Canada,27-29October1986,1986,pp.162–167.
APPENDIX
WeprovesecurityofourprotocolinthestandardUniversal
Composability (UC) framework of Canetti [7], with static
corruption. The UC framework introduces a PPT environment
Z thatisinvokedonthesecurityparameterκandanauxiliary
input z and oversees the execution of a protocol in one of
the two worlds. The “ideal” world execution involves dummy
parties P and P , an ideal adversary S who may corrupt
0 1
one of the dummy parties, and a functionality F. The “real”
world execution involves the PPT parties P and P and a
0 1
real world adversary A who may corrupt one of the parties.
The environment Z chooses the input of the parties and may
interact with the ideal/real adversary during the execution. At
the end of the execution, it has to decide upon and output
whether a real or an ideal world execution has taken place.
We let IDEAL (1κ,z) denote the random variable
F,S,Z
describing the output of the environment Z after interacting
withtheidealexecutionwithadversaryS,thefunctionalityF,
on the security parameter 1κ and z. Let IDEAL denote
F,S,Z
theensemble{IDEAL F,S,Z(1κ,z)} κ∈N,z∈{0,1}∗.Similarlylet
REAL (1κ,z) denote the random variable describing
Π,A,Z
the output of the environment Z after interacting in a real
execution of a protocol Π with adversary A, the parties, on
the security parameter 1κ and z. Let REAL denote the
Π,A,Z
ensemble {REAL Π,A,Z(1κ,z)} κ∈N,z∈{0,1}∗.
Definition A.1. For n ∈ N, let F be a functionality and let
Π be an 2-party protocol. We say that Π securely realizes
F if for every PPT real world adversary A, there exists a
PPT ideal world adversary S, corrupting the same parties,
such that the following two distributions are computationally
indistinguishable:
c
IDEAL ≈ REAL .
F,S,Z Π,A,Z
The F-hybrid model. In order to construct some of our pro-
tocols,wewillusesecuretwo-partyprotocolsassubprotocols.
Thestandardwayofdoingthisistoworkina“hybridmodel”
where both the parties interact with each other (as in the
real model) in the outer protocol and use ideal functionality
calls (as in the ideal model) for the subprotocols. Specifically,
when constructing a protocol Π that uses a subprotocol for
securely computing some functionality F, the parties run Π
anduse“idealcalls”toF (insteadofrunningthesubprotocols
implementing F). The execution of Π that invokes F every
15