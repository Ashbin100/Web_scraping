Show Me the Money! Finding Flawed
Implementations of Third-party In-app Payment
in Android Apps
Wenbo Yang, Yuanyuan Zhang, Juanru Li, Hui Liu, Qing Wang, Yueheng Zhang, Dawu Gu
Shanghai Jiao Tong Univeristy
{yangwenbo1990810, yyjess, jarod, ice wisdom, dabyto, shengdexinqing, dwgu}@sjtu.edu.cn
Abstract—The massive growth of transaction via third-party smartphone based transaction promotes the usage of third-
cashier has attracted numerous mobile apps to embed in-app party mobile payment services in mobile apps. Compared to
payment functionality. Although this feature makes the payment transaction processes with traditional payment channels (e.g.,
easy within apps, transactions via current third-party in-app via credit card), transaction with third-party in-app payment
paymentinvolvemoresophisticatedinteractionsbetweenmultiple
is settled within mobile app conveniently. Users can pay their
participants compared to those using traditional payments. The
billsdirectlywithoutswitchingtoanotherapporwebbrowser.
implementationsinmobileappsalsolacksecurityconsiderations.
Moreover, third-party cashiers are willing to provide such
Therefore,suchtransactionexposesnewattackvectorsandcould
functionality for popular apps to fulfill in-app payment. To
be exploited more easily, leading to serious deceptions such as
payment forging. help an app access their mobile payment service, cashiers
provide SDKs, leading a straightforward integration of in-app
To investigatecurrent third-party mobilepayment ecosystem mobilepaymentfunctionality.Asaresult,moreandmoreapps
and find potential security threats, we conduct an in-depth anal- are using third-party in-app payment as their major payment
ysis on world’s largest mobile payment market–China’s mobile
channel. Nonetheless, implementing secure in-app payment is
payment market. We study four mainstream third-party mobile
not easy. In-app payment is still in its incipient stage and is
payment cashiers, and conclude unified security rules that must
especiallyerror-proneduetoboththemisunderstandingofapp
be regulated by both cashier and merchant. We also illustrate
developers,theimproperdesignedservices,andtheambiguous
the serious consequences of violating these security rules, which
may cause up to four types of attacks against online and offline documents or code samples released by cashiers. It also
transactions.Besides,wedetectthesevensecurityruleviolations involves more participants and interaction steps compared to
to the payment in Android apps. Our detection result shows not traditional payment processes. Therefore, the potential attack
only the prevalence of third-party in-app payment, but also the surface is much wider.
awful status quo of its security. Over 37% Android apps with
at least 100,000 users embed third-party payment functionality.
Previous studies [25][27][22][18][21] mainly focus on the
Hundreds of them violate security rule(s) and face with various
security of e-commerce of web application other than mobile
potential security risks, allowing an attacker to consume almost
apps. Although numerous security flaws of e-commerce web
every aspect of commodities or services in life without actually
purchasingthemordeceivingotherstopayforthem.Ourfurther applications have been revealed when integrating services of
investigation reveals that the cashiers not only have improperly third-party cashiers. On mobile platform, however, the trust
designed SDK, which may expand the attack effects, but also boundaries are redefined. Client apps are considered untrusted
releaseambiguousdocumentsandevenvulnerablesamplecodes, since all the data handled by apps can be manipulated by
directlyleadingtothemistakescommittedbymerchants.Besides the attacker. Moreover, workflow of e-commerce in web ap-
the cashiers’ ignorance for security, our successful exploits to plications is unable to cover the entire transaction of in-app
several apps show that these flawed implementations can cause payment,sincetheintroducedmobileclientplaysanimportant
financial loss in real world. We have reported these findings to
role in this multi-party model. Thus, it is inadequate to
all the related parties and received positive feedbacks.
directly employ traditional flaw detection of web applications
on mobile apps.
I. INTRODUCTION
To the best of our knowledge, there exists neither unified
The past few years has witnessed the extraordinary de- specification to regulate in-app payment process nor assess-
velopments in mobile payment. The significant growth of ment approach to validate the security of them so far. Doc-
uments and samples of transaction provided by most in-app
payment cashiers are partial or even incorrect. Analysts must
Permission to freely reproduce all or part of this paper for noncommercial reverse-engineer the binary code of an app and its integrated
purposes is granted provided that copies bear this notice and the full citation
in-apppaymentSDKstoensuretheprocess.Beforefindingpo-
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author tentialsecurityflaws,itisrequiredtofirstsummarizethestatus
(for reproduction of an entire paper only), and the author’s employer if the quo of current third-party in-app payment. It’s also urgent to
paper was prepared within the scope of employment. conclude the basic security rules which should be obeyed by
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
bothcashiersandmerchantsthroughoutthetransactionprocess
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23091 as well as their violations detection methodology.To investigate how widespread is insecure in-app payment implementationvariationofin-apppaymentissignificant.Un-
in apps, in this paper we make a study of the world’s largest like well-developed multiple-party communication processes
smartphone and mobile payment market–China’s mobile mar- suchasOAuth[6],in-apppaymenthasnounifiedspecification
ket. A distinguishing feature in China’s mobile market is that to follow. Different third-party payment service providers
most apps support third-party in-app payments only. User (cashiers) regulate different in-app payment processes and
cannot use other payment channels such as credit card or release their own SDKs for app to integrate. Implementation
online bank to pay the bills in app. On the other hand, users aspects of third-party payment services such as used web
in China also prefer to choose these third-party cashiers to APIs, integration style of SDKs, and the parameters required
manage their finances because these cashiers provide more differ greatly from each other. Second, cashiers often release
servicesthantraditionalbanks.Userscannotonlydoshopping documentsandsamplestoappdevelopers.Developerrelieson
or make investment conveniently, but also transfer to each thosedocumentsandcodesamplestointegratein-apppayment
other for free through their accounts in cashiers. Once these SDKs and implements the payment process. However, our
third-party payments are vulnerable, every in-app transaction review illustrates that most of these documents are ambiguous
is inevitably suffering severe security threats. Our study tries andmayconfusetheappdevelopers.Somecodesampleseven
to answer the following questions for our research target: a) conflict with the process regulated by the documents. Only by
What exactly should be done to implement a secure in-app reading cashiers’ documents and studying their sample code
payment? b) Which kind of attack can be conducted and who is not adequate to conclude the exact payment process, and
suffersfinancialloss?c)Whatistheratioofappwithinsecure we will give our result in Section V-E. Third, testing the in-
in-apppaymentandhowtodetectthem?d)Whatfactorsaffect app payment not only involves actual payment with money
the insecure implementation? expending, but also requires some franchises and relevant
documents only granted to verified identity such as registered
Toanswertheabovequestions,wefirstconductanin-depth
companies. Many analysis efforts lack such qualifications are
analysis on services of four mainstream third-party cashiers.
therefore impeded.
The results of our analysis include: 1) we unveil the details of
their payment processes through reverse-engineering relevant Todemystifythedetailsofin-apppaymentprocess,wefirst
SDKs and apps; 2) we conclude a series of security rules give a brief description of participants involved in payment
which regulate the security requirement of in-app payment; process. Then, we choose four popular cashiers to analyze
3) we illustrate the severe consequence of violating these their documents and code samples. And we reverse-engineer
rules including four attacks against both online and offline popular apps with in-app payment to understand the details of
transactions. Besides, we develop the methodology to detect payment implementation. After this reverse engineering work,
the seven violations of our proposed security rules in Android we gain a panoramic view of in-app payment process: two
apps and their servers as well as the third-party payment representative payment process models that cover necessary
SDKs.Wefirstprovetheprevalenceofin-apppaymentthrough transaction steps for four cashiers are concluded.
scanning 7,145 Android apps with at least 100,000 users for
each and pinpointing at least one in-app payment SDK in A. Definitions
above one-third of the analyzed apps. We then detect the
In a typical in-app payment process, user browses, selects
flawed implementations of the 2,679 apps and find hundreds
and buys commodities in a merchant app (MA). Implemented
of them are vulnerable. Also none of the four cashier’s SDKs
by the merchant, the MA and the merchant server (MS)
reach the requirement regulated by our proposed security
interactwitheachother.Informationsuchasusersinformation,
rules. Though the improper designed SDKs do not directly
commodities provided, and order information are stored in
lead to vulnerabilities, they would expand the effects of user
databases on the MS.
deception attacks. Through combining these flaws, we can
perform various attacks targeting both merchants and users, To support payment in app, an MA integrates one or more
includingshoppingforfreeorwithothers’money.Theaffected third-party payment SDK (TP-SDK) released by the third-
area covers almost all aspects of daily life. partycashier.Inacheckoutprocess,userchoosesathird-party
cashier in the MA and makes a payment to the cashier. The
Finally, we analyze the root cause of the flawed imple- cashierserver(CS)recordsthepaymentinformationandstatus,
mentations of in-app payment. We find the documents and and informs the merchant the completion of the payment. The
sample codes provided by cashiers are often not examined complete payment information is then stored to the CS.
and confuse developers. Some of them are incorrect and even
vulnerable, which directly leads to these flaws of merchants. B. Unveiling Payment Process
Differentfrompreviouswork[25][27][22][18]whichfocuson
Tounveilthepaymentprocess,wefirstchoosefourpopular
the security analysis of merchants, our findings reveal that the
cashiers as our research targets: WexPay (in-app payment
cashiers also contribute to the flawed third-party payment on
service provided by Wechat Wallet) [9], AliPay (Alipay Wal-
mobile platform. We have reported all the problems to the
let) [1], UniPay (Unionpay Wallet) [8] and BadPay (Baidu
affected cashiers and obtained their credits.
Wallet) [4]. Each of them has at least 100 million users.
Merchant can register to all four cashiers as long as it owns
a legitimated company registered to the Chinese Commerce
II. IN-APPPAYMENTDEMYSTIFIED
and Industry Bureau. For every cashier, we get the TP-SDK
Although in-app payment is pervasive in Android apps, and auxiliary materials including code samples and relevant
the process of how an app fulfils a transaction via third-party documents.ThedocumentsdescribenotonlyinterfacesofTP-
payment service is often obscure due to several reasons. First, SDK but also the suggested payment process and Web APIs
2of cashier server. Code samples illustrate simplified imple- four essential parameters: order ID, merchant ID,
mentation for client app and server. We also download 7,145 total amount, notify URL address. Order ID refers to
apps with at least 100,000 users for each from Myapp [5], theidentifierofthepaymentorder.Itisusuallygener-
the largest Android APP market in China. Through studying atedbythemerchantandshouldbeunique.Merchant
the documents of four cashiers, reverse-engineering the TP- IDisusedbythecashierforuniquelyidentifyingthe
SDK and downloaded APPs with static and dynamic analysis, merchant. Total amount refers to the total amount of
monitoring the network traffic of the transaction process, and money involved in the payment that cashier receives
implementing sample code to real app and server, we have from user on behalf of the merchant. Notify URL is
two observations about the in-app payment: 1) how prevalent anURLaddressoftheMS.Afterapaymentfinishes,
is the in-app payment in Android APP; 2) which payment cashier needs to inform the merchant of the result by
process model does merchant need to comply with when sending the notification to the notify URL.
integrating third-party in-app payment function. We detail 3) After receiving and verifying the order , the CS
p
these observations in the following sections. will store payment information into its database,
and returns a signed message (TN) that contains
C. TP-SDK Identification a transaction number. Notice that the transaction
number identifiesthepaymentorderandisgenerated
In order to find out which app uses third-party in-app by the cashier. It does not contain any unnecessary
payment, we adopt feature based identification strategy to information of the order, such as the notify URL or
detect apps with TP-SDK. We reverse-engineer TP-SDKs of Total amount.
four cashiers and extract their unique features. We observe 4) After the MS receives and verifies TN, MS should
that if an MA uses a TP-SDK, it needs to invoke a specific sign TN and send it to MA. Notice that TN now
interface and passes parameters, hence we make use of these contains the merchant’s signature.
interfaces as the feature of TP-SDKs. For instance, if an 5) MA deals with received TN, and passes it as param-
MA uses TP-SDK of AliPay, it must pass the payment order eters to the interface defined in TP-SDK.
information to AliPay SDK through a certain interface 1. 6) TP-SDK prompts its payment UI (an Activity in
For other three TP-SDKs, there are also similar features. Android) to accept user’s confirmation. The payment
Notice that the name of interface is not always an available Activity in TP-SDK shows the detailed information
feature. Developers may use code obfuscation tools such as of the payment order acquired from the CS through
ProGuard[7]toobfuscatethefunctionnameinapp.Therefore,
its own network channel (omitted in the Figure).
we manually pick a combination of special strings in every After user confirms the payment order and enters the
TP-SDK that are seldom used elsewhere as extra features. account password, TP-SDK sends the pay request to
Utilizing those features, we build a static analysis tool based theCS.TheCScheckstherequest,andthenpaysfor
on AndroGuard [3] to scan all 7,145 apps. The result is listed the order with money in user’s account.
in Section V. 7) The CS sends a notification of payment to both TP-
SDK(thestepwithapostrophe)andtheMS(thestep
D. Process Analysis without apostrophe).
8) The MA shows payment result to user according to
After studying the documents and sample code of four
the notification received by TP-SDK.
cashiers, along with static and dynamic analysis to merchant
9) TheMSvalidatesthesignatureofthenotification,and
apps and servers, we find that the payment processes adopted
makes an extra query of the notified payment order
byfourcashiersaresomewhatdifferent.However,theycanbe
to the CS to confirm details of the order including
concluded as two in-app payment process models (in Figure 1
order ID, merchant ID, total amount, etc.
and Figure 2). Among the four cashiers, WexPay and UniPay
follow the process model I (in Figure 1), while AliPay and
After all the above steps, the transaction is settled and the
BadPay follow the other. We first choose process model I as
merchant can ship commodities or provide services to user.
anexampletoillustrateacompletethird-partyin-apppayment
process in detail. It is a simplified model only including When adopting process model I, WexPay and UniPay im-
essential steps and parameters of a transaction. The whole plementsimilarprocesswithnuancedifferences.Bothcashiers
process of the model contains nine steps in general. require different extra parameters for order p and order m.
Also, UniPay does not require the TN message to be signed
1) The MS receives a merchant order (order m) and the and does not include Step 8.(in Figure 1) as a necessary step
type of cashier after a user selects the commodities in its suggested process.
and chooses a third-party cashier in the MA. order
m
contains order information only related to merchant When adopting process model II, however, AliPay and
(e.g., the type and the amount of commodities user BadPay have relatively larger differences to WexPay and
wants to buy), since cashier has not involved yet by UniPay. The main difference occurs in Step 2. The MS just
now. sends the generated signed payment order (order p) back to
2) The MS generates a payment order (order ) accord- the MA other than to the CS after receiving the merchant
p
ingtoorder m,andsendsittothecashierbyinvoking order (order m) request from the MA. Compared with model
the Web API defined. The order should contain I, in which the MA can only receive TN, the MA in Figure 2
p
information about this payment, generally including receives the complete payment order information including
orderID,totalamountofthepayment,thenotifyURLaddress
1com.alipay.sdk.app.PayTask->pay() of the MS, etc. And it transfers all the information to the
3TP-SDK MA MS CS
1.order request
m
2.order
p
3.TN
4.TN
5.TN
6.pay request
7.order NTF
p
7'.order notification
p
8'.callback 8.order query
p
9.order status
p
Fig. 1: In-app Payment Process Model I adopted by WexPay and UniPay
TP-SDK MA MS CS
1.order request
m
2.order
p
3.order
p
4.pay request
5.order NTF
p
5'.order notification
p
6'.callback 6.order query
p
7.order status
p
Fig. 2: In-app Payment Process Model II adopted by AliPay and BadPay
integrated TP-SDK, which is responsible for dealing with all key as KEY.
the detailed parameters of the payment order in this process.
III. SECURITYANALYSIS
In Figure 1 and Figure 2, messages with bold and italics
We conduct further security analysis to the process mod-
textneedtobesignedbythesendertopreventbeingtampered.
els we concluded above in this section. The security of
So another important factor in the transaction process is the
third-party payment has been studied before in previous
signing method of messages adopted by cashiers. AliPay
work [25][18][27][21]. However, all of them focus on Web
and UniPay regulate the SHA1-RSA as their signing method.
service. In theprevailing mobile platform, the in-app payment
Merchant generates its RSA private key and public key, and
introducesnewmulti-partymodelsandthus,facesnewsecurity
sendsthepublickeytothecashier.Also,cashierinformsevery
challenge. The merchant client application and the embedded
merchant its public key. The MS verifies the received signed
TP-SDK play more significant roles which do not exist in
message with the cashier’s public key, and sends message
traditional Web model. So it’s necessary to re-consider the
signed with its private key to cashier or to the MA. However,
security threats of the in-app payment on mobile platform.
WexPay and BadPay adopt hash function (e.g., MD5) with a
secret key (as the salt of the hash function) to generate the Although the payment process models that regulated by
signature. The secret key is shared between the merchant and cashiershavebeenvettedbeforereleasingandaresupposedto
the cashier. In the later part of this paper, we denote both the besecure,suchmulti-partymodelsstillstruggleagainstvarious
secret key of hash function and the merchant’s RSA private unexpected security threats due to the information asymmetry
4in the transaction process. Moreover, the whole transaction 7) MS should make an extra query to confirm notified
process involves multiple parties, not only cashiers, but also payment’s details.
merchants and users. Due to the ambiguous documents and
There are four types of attack that the payment process may
confusingsamplecodereleasedbycashiers,developersofmer-
suffer if one or more violation of security rules occur, and the
chants often disobey the process model regulated by cashiers
victims involve normal users of MA and the merchant. Then
andimplementdiversifiedpaymentprocesses,whichmaylead
we will describe them in details.
to potential security flaws. Any mistake committed by any
party in the multi-party model may lead to the whole process
C. Order Tampering
vulnerable.Therefore,it’snecessarytoconcludesecurityrules
to regulate all parties in the model.
In this section, we first define the adversary model. Then TP-SDK MA/ATTACKER MS CS
we give the security rules which must be complied, and what
the cashier and the merchant should pay extra attention to 1.orderm request
throughout the entire transaction process of in-app payment. 2.orderpT
Finally,wedescribefourattacksindetailunderourreasonable 3.TN
adversarymodelifthecashierormerchantviolatesthesecurity
4.TN
rules, which may lead to the loss of multiple participants in
5.TN
the model.
6.pay request
A. Adversary Model
7.orderpT NTF
7'.orderpT notification
Before proposing security rules and the attacks caused by
8'.callback
ruleviolation,wefirstdefinetheadversarymodelasfollowed.
We assume that the attacker can reverse-engineer MA and the
embeddedTP-SDK,sinceitcanbeeasilyacquiredinAndroid
Fig. 3: Order Tampering Attack to Process Model I
Application market (even if the app is protected, techniques
havealreadydevelopedtocircumventit[28]).Whentheattack
targets cashier or merchant, the attacker plays the role of
a malicious user and is assumed to be able to manipulate
TP-SDK MA/ATTACKER MS CS
execution or data of local app and system, and to tamper
or forge the network communication. But when the attack
1.orderm request
involves other users of the MA, attacker is assumed only
to control the data transmission between them (e.g., perform
2.orderp
MITM attack with the ARP spoofing or deceive users to
3.orderpT
attacker’s malicious WiFi), but not to control other users’ 4.pay request
devices, i.e., not able to install malware or repackaged MA on 5.orderpT NTF
them by subterfuge. Though the attacker is not able to sniff 5'.orderpT notification
or tamper the network traffic between MS and CS under any
6'.callback
circumstances, it can forge request or message to either MS
or CS in our model.
Fig. 4: Order Tampering Attack to Process Model II
B. Security Rules
According to the two types of process model adopted In this type of attack, the attacker acts as a malicious user.
by four cashiers and the adversary model, we conclude the If the merchant fails to obey the Security Rule 1 and Rule
following security rules that must be obeyed throughout the 7, then attacker can cheat the merchant by sending a payment
whole process involving both cashiers and merchants, no order(order )tothecashierdifferentfromtheactualmerchant
p
matter how cashier regulates the process model or which order (order ). In this situation, the attacker could tamper
m
cashiers MA chooses to use. Otherwise, the process will be the content in the payment order such as the total amount and
breached. thus pay less money for the ordered commodities without the
merchant’s awareness.
1) Payment orders must be generated (Figure 1) or
signed (Figure 2) by the MS only. The attack for process model I is shown in Figure 3. In
2) Never place any secret (e.g., private key for signing) model I (Figure 1), the signed payment order is generated and
in the MA. sentbytheMStotheCS.Alocalattackercanonlyobtainthe
3) TP-SDKmustinformuserdetailedinformationofthe (TN)messagewhichdoesnotincludeanydetailedinformation
payment order. (e.g., the total amount of the payment) of the payment order.
4) TP-SDK must verify the transaction belonging to the Thus,it’simpossibletotamperthepaymentorderinformation.
MA. However, if the MA incorrectly implement the payment order
5) Always use secure network communication between generation step in the app rather than its server, the attacker
client and server. can succeed in tampering the payment information. Since the
6) Always verify the signature of received messages. attacker can take full control of local app and system, we
5mergetheattackerwiththeMAintheFigure3.TheorderT in from the MA, in which the merchant’s developers place this
p
the figure indicates that the payment order has been tampered shared secret key by mistake (Security Rule 2). Notice that
already and so does Figure 4. among four cashiers, only the notification of those who adopt
hash-function as their signing method (WexPay and BadPay)
InmodelII(Figure2),thoughthecompletepaymentorder
can be forged because the cashier and the merchant share the
information can be achieved by the attacker (order need to
p same KEY as their signing KEY. For those using SHA1-RSA
be returned to MA), he can not tamper it since the payment
to sign the messages, the RSA private key of cashiers can be
orderissignedbyMS.Apaymentorderwithwrongsignature
hardly leaked, thus, forging the cashier’s message with legal
willberejectedbythecashier.However,ifthemerchantsigns
signatureisquiteimpossible.Moreover,weobservethatsome
the payment order or leaks the KEY in the MA, then the
MSsevenignorethevalidationofthesignatureofthereceived
attacker with full control of the local app and system could
messages (Security Rule 6). Thus, the fake notification even
easily intercept all information appeared in the MA, and is
withwrongsignatureisunconditionallyaccepted.Finally,sim-
thencapableoftamperingthereceivedorderinformation(e.g.,
ilar to Order Tampering attack, notification forging also needs
modifying the price), and re-signing it as a legit one to TP-
theMStoignoretheorderre-confirmationstep.Otherwisethe
SDK (as shown in Figure 4).
merchant can find out that the notified payment order is still
To fulfil this attack, another implementation flaw is re- remain ’pending’ status in CS.
quired: the merchant fails to confirm the notified payment
In all, if the merchant 1) fails to check the signature of
order information to CS (Security Rule 7). Otherwise, MS
notification message at the MS or leaks the signing KEY, and
can get every details of the notified payment order including
2) misses notified payment confirmation at the MS, then the
total amount, merchant ID, etc after make the query to CS. It
attack will succeed.
can refuse the tampered order after verifying every details of
it and does not ship commodities.
E. Order Substituting
In all, the violation of Security Rule 1 and Rule 7 will
make the merchant become victim, and attackers as malicious Different from the two attacks above, the victim of order
users can buy commodities in any price. substituting attack becomes the normal user of MA rather
than the merchant. The cause of this type of attack involves
D. Notification Forging multi-parties’violationofsecurityrulesincludingbothcashier
(Security Rule 3 and 4) and merchant (Security Rule 5). In
If the merchant fails to obey the Security Rule 2 (or Rule
this attack, the attacker substitutes an order of one transaction
6), and Security Rule 7, then it suffers notification forging
toanother,andmisleadsavictimusertopayfortheattacker’s
attack, allowing attackers to purchase commodity without
order unconsciously.
payingit.Intheattack,anormalpaymentprocessisperformed
until the TP-SDK requires user to confirm the order and enter Figure 6 shows the order substituting attack to process
password to pay for it. At that time, an attacker does not pay model II (Figure 2). The attack is available when the message
for it, but instead sends a fake payment result notification to returned from MS is transferred with an insecure network
notify the MS that the order is paid successfully. The attack communication channel. Thus, the attacker can act as a man-
model to process model I (Figure 1), for example, is shown in-the-middle between MA and MS. Attackers can intercept
in Figure 5. If the order is not paid (Step 6. in Figure 1), the message and substitute signed payment order (order p)
it still remains ’pending’ status, and the MS will not receive with another one (orderA) of a legal transaction, and send
p
the notification from the CS (Step 7. in Figure 1). However, it to the MA on victim’s device. The victim will then pay for
afterwards attackers can forge the notification and send it to the attacker’s order rather than his own order. Notice that the
the MS (Step 6. in Figure 5). If the merchant trusts this fake attackerusesalegalpaymentordertoreplacetheoriginalone.
notification and does not confirm the order’s details to the CS This message usually belongs to a normal trade performed by
(Step 8. in Figure 1), the payment is successfully forged. The the attacker beforehand (steps between Step 2. and Step 2’. in
attack can also be performed to model II (Figure 2) with the Figure6),soitisreasonabletocheatthevictim’sTP-SDKand
same way, which we omit it here. finishthetransactionwiththismessagesuccessfully.Theattack
to process model I (Figure 1) is similar. The only difference
Attackers need to exploit several mistakes committed by
is that the attacker needs to substitute the TN message (Step
the merchant to make a forged notification available. First,
4. in Figure 1) rather than the order (Step 2. in Figure 2)
p
the notify URL address of MS that receives the payment
returned from MS.
notification from CS should be known beforehand. So the
attack requires MA to contain the notify URL address, which The root cause of this attack includes the lack of secure
would be placed by the developers accidently. Actually, as we communication channel as well as the inadequate prompt
illustrated before, MA who adopts process model II (AliPay informationshowedbyTP-SDK.Wediscoverthatthepayment
andBadPay)certainlycontainsthenotifyURL,sinceallorder Activity (Activity is a component of Android application,
information including notify URL is used as input of the acting as an user interface) of TP-SDK generally does not
TP-SDK (Step 3. in Figure 2). Second, the attack needs to show enough information about current payment order, thus
constructaforgedpaymentordernotificationofthecashierand the victim will confirm and pay for another order without
cheats MS to accept it. Attackers can obtain the data format being aware of it. For example, if the payment Activity only
of the notification message from documents released by the shows the total amount of the order, then the attacker could
cashier, and then forge it with a signature which labels the make an order with the same price of the victim’s order. Even
identity of the sender. The KEY used here is often extracted if some TP-SDKs show the commodities and the merchant
6TP-SDK MA MS CS ATTACKER
1.order request
m
2.order
p
3.TN
4.TN
5.TN
6.fake order NTF
p
Fig. 5: Notification Forging Attack to Process Model I
TP-SDK MA ATTACKER MS CS
1.order request
m
2.order
p
order A request
m
orderA
p
2'.orderA
p
3.orderA
p
4.pay request
5.orderA NTF
p
5'.order A notification
p
6'.callback 6.orderA query
p
7.orderA status
p
Fig. 6: Order Substituting Attack to Process Model II
name of the order, the attacker could make an order with the payment order on its payment Activity (Security Rule 3),
same commodities while modifying the consignee since it is attackers can perform MITM attack and deceive users to pay
not difficult for attacker to know what victim is going to buy for orders not belonging to themselves. Also, missing order
p
through eavesdropping the merchant order request (Step 1. in (orTN)verificationinTP-SDK(SecurityRule4)willexpand
Figure 6) via insecure network connection between the MA the impact of the attack.
and the MS. What’s worse, if the TP-SDK accepts the order
p
(or TN), whatever it is generated by the host MA or not, this F. Unauthorized Querying
attack can be expanded that even a transaction from another
If the merchant violates the Security Rule 2, leaking its
MA can be substituted to that from one MA. In other words,
KEY to attackers, it will also suffer the unauthorized querying
if attackers substitute the original order (or TN) with anther
p
attack. An unauthorized querying attack allows attacker to
order (orTN)ofmaliciousmerchantregisteredtocashierby
p
query every transaction recorded in CS, acquiring secret busi-
attackersthemselves,themoneypaidforthetransactionwillbe
ness information which should only be shared by cashier and
transferredtoattackersdirectly.Nevertheless,ourinvestigation
merchant.Therootcauseofthisattackisduetotheleakingof
indicates that some TP-SDKs do not verify TN carefully,
merchant’s authentication credential. Cashiers provide several
allowing attackers to substitute the original one easily.
Web APIs for merchant to query various information, such
In a word, as long as 1) MA adopts insecure network as every payment order’s status and details, the merchant’s
channel to communicate with MS (Security Rule 5), 2) and historybillofeveryday,etc.Furthermore,cashiersmakeuseof
the TP-SDK in MA does not display clear information about thesigningKEY toauthenticatetheidentityofeachmerchant.
7However,theKEY maybeaccidentlyplacedintheMAbythe string with a wx prefix, and the mch id is a 10-byte string
developers of the merchant. So the attacker could utilize the comprisedofdigitsonly,andbothtwoparametersareuniquely
leaked KEY to query transaction information illegally. allocated to merchant. We can first locate strings with similar
features in DEX file and resource file (strings.xml), and query
theWebAPIfortheidentityofthefoundparameters.Ifanyof
IV. DETECTINGFLAWEDIN-APPPAYMENTS
theinputparameterisincorrect,theresponseofthequerygives
Theviolationofthesevensecurityrulescausesexploitable a corresponding notification. For instance, if the first appid
attacks and leads to serious consequences. In this section, we parameter is incorrect, the Web API would directly return a
will describe how to convert these rules into detectable forms “wrong appid” notification without considering the following
in the payment process. Detecting these violations is helpful parameters. Thus we could check each parameter individually
tofindflawedin-apppaymentstoactualloss.Furthermore,we until its correctness is identified, which significantly improve
discuss the feasibilities and details of detecting such flaws. the efficiency. And if all three parameters are correct (which
means we find a leaked key in app), the Web API responds
A. Local Ordering either the merchant’s real bill data, or “no bill exists” if no
transaction happened on that day. Using this testing approach,
According to the Security Rule 1, MA is prohibited to wecaneffectivelyfindleakedWexPaykeyinanapp.Similarto
generate payment orders for those adopting process model WexPay,BadPayusesasharedsecretkeytosignitsmessages.
I. Local ordering refers to the incorrect ordering behavior However, no Web API is provided by BadPay for us to verify
implemented by the MA rather than the MS. It allows the the potential key candidates. Considering that far fewer MAs
attackers to tamper the payment order. Notice that this flaw useBadPay,wecouldconfirmthekeythroughmanualreverse
only appears to apps with WexPay or UniPay, since in their engineering.
regulations, placing the payment order must be enforced by
the MS. For AliPay, merchant uses an RSA private key within a
Based64-encoded standard ASN1 certificate to sign the order
To detect this violation of Rule 1, we search the existence information.Thecertificateformatcontainsremarkablefeature
of a relevant destination URL used by the merchant to place (A string with ’MI’ as prefix and at least 300 bytes long)
a payment order. In detail, app will visit destination URL2 and can be easily located. However, the app may also contain
for WexPay and UniPay, respectively. The visit indicates the such certificates to fulfil other functionalities. To confirm the
incorrect behavior of generating order locally. Therefore, we application of found certificates, we adopt the following two
first scan all strings in DEX file and resource file of an APK heuristics. We first check whether the variable name of the
to find whether the above two strings exist. If so, the app is candidate certificate contains ali or alipay. Second, we make
then manually tested to confirm the security flaw. use of the cross reference searching to find the Java class
that refers to the candidate certificate. Since the private key
B. KEY Leakage in a certificate is used to sign the order of AliPay, the order
information is often generated in the same class that uses
In the two payment process models, several messages
the private key. This generated order information contains
transmitted need to be signed. According to our proposed
specific feature strings (“&service=mobile.securitypay.pay”
Security Rule 2, sensitive information, especially the KEY is
for example) and can be easily identified. If a certificate
prohibited to appear in app. Otherwise, attackers can tamper
corresponds to one of the above properties, we regard it as
or forge messages with legal signature and camouflage to be
thesigningkeyofAliPay.SimilartoAliPay,UniPayalsouses
certain party and cheat others in the multi-party model.
RSA private key to sign its messages but the private key is
We combine pattern matching and dynamic testing tech- encapsulatedinaCERformat.Wealsoadoptsimilardetection
niquestodetectKEY leakageinapps.Wedevelopanautomatic methodology to UniPay.
detecting tool based on AndroGuard to search leaked KEY in
app adaptively against specific cashier. C. Incomplete Prompt
For WexPay, it adopts hash function with secret key to WhenanMAinvokestheTP-SDKandshowsthepayment
generate the message signature. The secret key for message Activitytousers(e.g.,betweenStep5.andStep6.inFigure1),
signing is a 32-byte string with arbitrary content shared with users need to confirm the order and decide whether to pay for
merchantandcashier.TheMAusesthiskeytosignmessageso it. As the Security Rule 3 implies, detailed order information
wewouldliketosearchsuchhard-codedkeyinapp.However, shouldbepromptedtouserinthepaymentActivitycompletely.
simply searching 32 bytes length string in an MA often gives Otherwise, user may suffer deception, resulting in an attack
a huge amount of candidates. To effectively determine the that what user pays is not what he/she really buys (Order
potentialkey,weutilizeaWebAPIprovidedbyWexPayasan Substituting Attack).
oracletosubstantiatethekeyidentityaccurately.TheWebAPI
We detect this security flaw by checking whether TP-SDK
offered by WexPay allows merchant to download the history
displays enough information about the payment order to user
billofonedaywiththreenecessaryparameters:appid,mch id,
duringthepayment.Indetail,thefollowingfieldsarechecked:
andsecretkey.Therefore,wecouldleveragetheappid andthe
1)paymentorderIDthatrepresentstheorderuniquelyinboth
mch id to help identify the secret key. Notice that the features
merchantandcashier.2)whatcommodityorservicethatusers
of these two parameters are apparent: the appid is a 18-byte
are going to pay. 3) user that the order belong to in merchant
2https://api.mch.weixin.qq.com/pay/unifiedorderforWexPay; app. 4) merchant that the order belongs to. 5) total money of
https://gateway.95516.com/gateway/api/appTransReq.doforUniPay the payment.
8D. Transaction Verification Missing transaction information accurately. Among a variety of URL
strings in apps, it’s quite impossible to decide which URL is
In a secure payment process, TP-SDK integrated in MA
responsible for transmitting the order/transaction information
need ensure that the received payment order (Step 3. in
onlybyname.Inaddition,itiscommonforappstojoinseveral
Figure 2) or TN (Step 5. in Figure 1) actually belongs to
substrings to the ultimate URL address, or even use code
the MA according to Security Rule 4. Otherwise, malicious
obfuscation to sensitive URL, which also raise the difficulty
merchantcanexpandtheOrderSubstitutingattackanddirectly
of automated detection. Previous work like MalloDroid [15]
get money from users as we mentioned in Section III-E.
only gave coarse detection result without identification of
We detect this security flaw through testing whether the target URL’s logic function, and [19] even indicated the
TP-SDK accepts a payment order that does not belong to the inaccuracy of such automated analysis, which further prove
MA. First, we place a order using a normal MA. Then we the difficulty of this work. Furthermore, finding the target
intercepttheorder /TN messagefromtheMSandsubstitute URL with dynamic analysis involves deep human interaction,
p
itwithorder /TN messagegeneratedfromanotherMA.And including registering and login account, clicking products,
p
we check whether the order belonging to another MA can be choosing in-app payment and paying for the order, which is
accepted successfully by the TP-SDK. If so, the violation of also impossible to be automated and large scale. As a result,
Rule 4 is confirmed. wecanonlydoitmanuallytoachieveaccuratedetectionresult.
F. Notified Payment Confirmation Missing
E. Insecure Communication
As Security Rule 6 implies, MS needs to make an extra
According to Security Rule 5, network communication
paymentorderquery(e.g.,Step8.ofFigure1)toconfirmevery
between MS, CS, and MA (including its integrated TP-SDK)
details of the payment order, even if it receives the payment
should adopt secure transmission (e.g., via TLS channel).
notification. Since this part of implementation is on MS, we
Otherwise, attackers can intercept, eavesdrop or tamper what
can only apply an indirect detection approach to detect the
users want to buy (e.g., in Step 1. of Figure 1), the payment
violation.Wetrytotamperapaymentorderinformationwhich
order information (e.g., in Step 2. of Figure 2), or the trans-
is different from the original payment order but with legal
action information (e.g., in Step 4. of Figure 1). It can also
signature, and pay for it. If the MS accepts the payment order
directly cause the Order Substituting attack, as we mentioned
and ships the commodities, then we can conclude that the MS
in Section III-E.
does not re-confirm the notified payment order. Notice that
According to the adversary model, we mainly concern the tampered order message should be with correct signature,
how to detect the insecure network communication employed which means the samples here need to be based on the result
between the MA (including TP-SDK) and the remote server. ofKEYLeakage.Weperformthedynamicdetectionmanually,
We set a proxy to conduct MITM attack against HTTP and because the process involves much human interaction such as
HTTPS connection to detect the potential flaw. The insecure placing orders and checking the payment’s status.
communicationbetweenTP-SDKandCSmaycausewideand
serious consequence. Since TP-SDK is integrated by a large G. Signature Validation Missing
number of APPs, all the MAs with this kind of TP-SDK will
Security Rule 7 implies that MS is supposed to check
suffer vulnerabilities (such as payment information leakage,
the integrity of every received message (e.g., in Step 3., Step
transaction interception and tampering, etc), if the network
7., and Step 9. in Figure 1). Otherwise, MS would accept
communication is insecure. So we adopt a refined policy to
messages even with incorrect signature. To detect this flaw,
detect the flaw in TP-SDK. We try to sniff and attack the
we try to place an order but without actually paying for it,
networkcommunicationduringamanuallyconductedpayment
and then forge an order notification to the MS with incorrect
process. If the connection between TP-SDK and CS is an
signature.Ifthemerchantacceptsthepaymentorder,Thenwe
HTTP connection, we regard it as insecure. Furthermore, if
can conclude that MS fails to check the signature properly.
the connection is HTTPS, we will check whether it verifies
Here the samples are based on the apps that commit Notified
the SSL/TLS certificate properly, or implements the certificate
Payment Confirmation Missing. Because we need to exclude
pinning. If the TP-SDK uses private protocol communicating
the negative result caused by successfully confirming the
with its server, we further audit the security of this protocol
notified payment.
(since there are only four TP-SDKs, we could audit it manu-
ally).
V. EMPIRICALSTUDY
For the communication between MA and MS, we only
We make an empirical study of the world’s largest smart-
consider the situations of HTTP, insecure HTTPS (without
phone and mobile payment market–China’s mobile market.
certificate validation), and secure HTTPS. Our purpose is to
We choose it as a representative example for the following
find out the network connection of the exact step when MS
reasons: First, nearly 400 million users in this market use
returns order / TN to MA is secure. Since our result needs
p mobile devices to purchase goods and services (by the end of
high accuracy, we manually trigger the MA to the step and
2015, according to research from the China Internet Network
monitor the network traffic.
InformationCenter).Inthefirstquarterof2016,China’sthird-
The limitations of automated analysis methodology to party mobile payment tools handled transactions worth more
detect the security flaw is so serious that lead to high in- than 5.9 trillion yuan (885.8 billion us dollar). Second, unlike
accuracy. The key difficulty is that how to find the URL the mobile payment market in the U.S., where most mobile
connection related to the step that MA and MS transmit the transactionissettledviacreditcardthroughweborApplePay,
9However, there may be false negatives because our large scale
TABLE I: TP-SDK Distribution
application analysis is mainly based on static analysis, which
means this is even an underestimated result. If the KEY or
Cashier Number
the URL is encrypted in the MA, or sent by the MS through
WexPay 2260 network to app, then we can not detect it with the string
AliPay 1299 feature. The result of detecting WexPay destination URL is
over 130. However, after our manually confirmation, 104 of
UniPay 574
them really do Local Ordering, and the rest just hard-code
BadPay 34 the URL without invoking it. All the Local Ordering apps
of WexPay leak the KEY since they generate and sign the
Total 2679
payment order in MA. However, another 51 apps either use
Sample 7145 the KEY to sign the received TN message or just hard-code
the KEY without actually use it, both violating the security
Cashier KEY leakage Local Ordering rules. Also we detect that nearly 500 apps integrated AliPay
contain strings with RSA private key features. Among them,
WexPay 155 104
we find out that 398 apps actually leak their AliPay private
AliPay 398 / keysusingthelocatingtechniquesmentionedinSectionIV-B,
and the rest are the keys of other SDKs. Since only 34 apps
UniPay 0 0
integratedBadPay,wedotheKeyLeakagedetectionmanually.
BadPay 7 /
Among seven flawed apps, five of them hard-code its KEY.
One of them encrypts the KEY and stores it in MA. However,
TABLE II: Flaws in Merchant Apps
it uses symmetric encryption and hard-codes the key, so the
KEY of its BadPay can be decrypted and retrieved. And one
app receives its KEY of BadPay from its server after it places
in China’s market most popular apps mainly use in-app third- itsmerchantorder,whichisunnecessaryandalsoleadstoKEY
party payment services. Third, instead of a single payment leakage. In addition, we find out that several apps share the
standard, a variety of payment schemes are provided by same KEY of WexPay and AliPay, which means that they are
different third-party cashiers. Each payment scheme is unique either using the same checkout account or developed by the
and one app may support many schemes simultaneously. To same company.
investigate the flawed in-app payment implementations, we
first conduct our TP-SDK identification to the 7,145 most B. Flaws in TP-SDK
popular apps from Myapp market. As Table I shows, 2,679
SinceTP-SDKsareprovidedbythecashiersandintegrated
apps integrate at least one TP-SDK, and most of them contain
by the MA, flaws in specific TP-SDK directly affect the host
morethanoneTP-SDK.Theproportionofappssupportingin-
MA.WeevaluatethefourmostpopularTP-SDKsprovidedby
apppaymentisashighas37.5%,whichprovestheprevalence
AliPay, WexPay, UniPay, and BadPay, respectively. The result
of third-party in-app payment.
is shown in Table III. Only WexPay verifies TN correctly. TN
Then we detect each security flaws we mentioned in Sec- accepted by WexPay SDK includes parameters of merchant
tion IV. We classify these flaws into four categories involving ID, transaction number, etc. WexPay SDK achieves the MA
MA, TP-SDK, MS and network communication. Besides, we certificatethroughsystemAPIinAndroid,andchecksthecon-
further investigate the official documents and analyze sample sistencyoftheAPKcertificateandmerchantID.Italsochecks
codes released by four cashiers in-depth and gain some in- whetherthetransactionnumberbelongstothemerchantID.In
teresting and unexpected findings, which may imply the root contrast, we succeed in invoking the other TP-SDKs (AliPay,
causeoftheseflaws.Thenwechooserepresentativevulnerable UniPay,BadPay)integratedintheMAbythetransactionorder
apps based on the result of detection and then exploit their of another MA. Also, we find that both WexPay and AliPay
securityflawstoprovethevalidityofouranalysis.Weprovide require the registered merchants to submit their certificates
themas casestudiestoillustratethe complexityofconducting of MA, while UniPay and BadPay do not. Obviously, only
concrete attacks against real world transactions. After our WexPay makes use of the certificate to verify TN.
detection, we find that hundreds of the merchants violate at ForIncompletePrompt,wemanuallycheckeveryelements
least one security rule and none of the four TP-SDKs strictly
presented on the payment Activity of every TP-SDK. We
obey these security rules.
find out that all four TP-SDKs do not present the order’s
owner in the Activity, leading to the risk of phishing. BadPay
A. Flaws in MA only shows the total amount of the payment order, which is
obviouslyinsufficient.WexPayandAliPaybothshowtheorder
Wefirstdetectthoseflawsinthe2679MAs.Thedetection
description submitted by merchants. But they do not require
result is shown in Table II. We can see that hundreds of
the merchant to submit necessary information about the order
the merchants leak their KEYs in MAs. Nearly one hundred
suchastheorderID,theorderowner,etc.UniPayandWexPay
merchants using WexPay generate and send payment order in
showthemerchantnameoftheorderwhileAliPayandBadPay
MAs.
do not. Also for UniPay, order ID and payment time will be
Notice that our KEY Leakage result of WexPay has no shown to users only if a spinner on the Activity is clicked. In
false positive since it is based on the response messages all, every TP-SDK lacks necessary information more or less
from WexPay’s Web API as we mentioned in Section IV-B. on payment Activity, which may lead users to be deceived.
10Information Prompt
Cashier Transaction Verification Network Communication
orderID commodity owner merchant money
WexPay × × secure private protocal
AliPay × × × × HTTPS pinning
(cid:8) (cid:8) (cid:8) (cid:8)
UniPay × × HTTPS pinning
(cid:8) (cid:8)
BadPay × × × × × HTTPS validation
(cid:8) (cid:8) (cid:8) (cid:8)
(cid:8)
TABLE III: flaws in TP-SDKs
We manually check the implementation of network com- Thoughwedidnottestallthe2679appsduetotheinaccu-
munication of four TP-SDKs. SDKs of AliPay and UniPay racyofautomaticanalysis,theresultofthe87samplesthrough
use HTTPS to connect to their servers and adopt certificate manual work shows that a large proportion of merchants are
pinning. WexPay SDK use a proprietary protocol to commu- stillnotcautiousinimplementingsecurenetworkcommunica-
nicate with its server. After we reverse-engineer it, we find tion. It is an astonishing result that even in 2016 there are still
that it implements its key agreement algorithm based on ECC somanypopularappsuseinsecureHTTPchannelevenifallof
with hard-coded secure parameters in the SDK. The protocol them are related to financial transaction. Notice that the tested
is then audited manually and is proved to be secure enough samples are the most popular apps with larger user amount
against MITM attack. The SDK of BadPay validates the SSL and stricter security audit. We believe that those samples
certificate properly, thus, is secure. However, compared to the with less user amount may perform worse on building secure
other three TP-SDKs, BadPay does not adopt SSL-pinning, communication. Moreover, we find that cashiers only request
which means it can not be protected against a compromised the merchant to adopt HTTPS communication in the MA as
CA. an optional requirement rather than a mandatory enforcement.
So merchants may ignore the request and implement insecure
network communication.
C. Flaws in MS
We tampered the payment order of 15 KEY leaked apps
E. Root Cause Inquiry
withcorrectsignatureandpaidforittoseewhetherMSwould
accept them. Since the action need really exploit the KEY As we mentioned above, cashier is mainly to be blame
Leakage vulnerability, involving a lot human interactions like for the various mistakes committed by merchant. They release
MA account registration, placing a merchant order, tampering ambiguous, confusing and self-contradictory documents and
the payment order, and paying for it, it’s unrealistic to be samplecodes,whichdirectlyresultinthesecurityflawsinMA.
automated and large-scale. So we did it manually and found Contrary to common sense, we find out that even the official
that 9 of the 15 apps that finally accepted the tampered sample code violates several security rules and is apparently
order, which means that their MSs miss the notified payment vulnerable. Merchants who follow these samples codes suffer
confirmationtoCS.Amongtheninevulnerableapps,thereare our proposed attacks.
MA that use WexPay, AliPay or BadPay.
After reviewing the sample codes as well as manually
WefurthercheckedwhethertheMSsofthenineappsverify checking the documents of the four TP-SDKs, we have some
the signature properly. We got the notification message format interesting findings. Even though all of the four TP-SDK
according to cashiers’ documents, forged the message with documents claim that the KEY needs to be kept in secret,
incorrect signature and sent it to the Notify URL address of their sample codes implement the process of message signing
the MS. The result is that two of the nine apps’ servers still in their client apps, leading to the KEY leakage, except
accept the payment. It indicates that even if the KEY is not UniPay. It can be used to explain that so many MAs commit
leaked, attackers can still buy products without paying for it. vulnerabilities when using WexPay, AliPay or BadPay (while
become secure using UniPay). For example, the sample code
released by WexPay directly commits Local Ordering, which
D. Flaws of Network Communication
obviously conflicts with its official process. We also find that
We manually test 87 most popular MAs chosen from the the figure describing the process of the payment released by
2,679 apps with embedded TP-SDKs to evaluate the security AliPaydefinesthattheordershouldbesignedinclientappand
of their connections to the MS during the payment. The result so does the sample code, but the code comment in the sample
is that 45 apps use HTTP connection and 42 apps use HTTPS says that the signing step should be in MS. We hypothesize
connection. Among 42 apps who use HTTPS connection, that the contradiction between documents and sample code
four of them fail to validate SSL certificate properly. In confused merchant developers a lot, leading those developers
addition, although we do not find proprietary protocol used who follow the sample during their development to commit
by MA to communicate with the MS, some apps adopt home- these mistakes. Only the sample code of UniPay implemen-
brewed encryption schemes to protect the content in HTTP tation keeps consistent to their documents, making the order
connection. Since those encryption schemes generally lack a generating and signing in the MS code, so in our detection
mature session key management, we regard them as insecure none of the APPs are flawed when using UniPay. It shows
without further investigating the security of their encryption. that the cashier is the key factor to the security of merchant
In all, these 49 vulnerable apps increase the risk of suffering implementation.AlsoUniPaySDKdoesnotneedthesignature
Order Substituting attack. of TN as parameters, while others need. So some MAs of the
11three TP-SDKs just sign the payment and send it to TP-SDK, a popular function hooking framework. After we finished
also leading the KEY Leakage. The correct implementation, ordering and entered the table number in the app, we chose
by contrast, is that the signature of TN or payment order to pay the order via AliPay. The app violated the Security
should be received directly from MS. In addition, since the Rule 1, signing the order information in client app. So before
KEY of WexPay can be modified to any string as long as the invoking of the AliPay SDK in the MA, we hooked the
merchantnotifiescashier,wefindthatsomeleakedkeys,which Java function used to executeSHA1-RSA signing of the order
are supposed to be random strings, are modified to a weak information in the MA with the help of Xposed. We have
keysuchas12345678912345678912345678912345,orjustthe implementedanXposedmoduletotamperthepriceparameter
name of merchant, which may suffer brute-force dictionary to only one yuan (CNY, Chinese Yuan, about 0.16 US Dollar)
attack, or social engineering. in the order information and re-signed the message. Then
the TP-SDK successfully accepted the order information and
We also try to discover the incentive of flawed MSs.
prompted its payment Activity, asking for paying this order
We find that not all cashiers release the sample code of
with one yuan. After we paid this order, the order Activity
MS, thus merchant needs to implement it without example
in the MA showed that the order is successfully paid with
by themselves. Even if there is sample code for MS, server
the original price. And the waiter served the dishes to us
implementationvariesalotcomparedwiththeclient.Merchant
after a while without any doubts. Even after our dinner, our
mayimplementtheirserversbyusingJava,PHP,.NET,Python
“less paid” bill did not attract any awareness (we informed
orevennativelanguage,whichareoutofthelanguagescopeof
the restaurant later and paid for the meal in the original price,
samplecodereleasedbycashier.Eventhoughcashierssuggest
and informed the vulnerabilities to the app developer), which
merchants to do these validations in documents or some even
indicates that the merchant fails to confirm the notified order
implement them in sample code if it has, merchant may also
details.
ignoreit duringthecode transplantorwithout existingcorrect
codeexamples.Besides,theincompletepromptandtransaction For the second app, we leveraged the flaws similar to
verificationmissinginTP-SDKaremainlycausedbybusiness that in the first app. The only difference is the app leaks its
convenience,userexperienceorUIdesign.Eveniftheseflaws Badpay shared secret key instead of the private key of AliPay.
donotdirectlyleadtoattack,theywillexpandtheattackeffect We observed that this app allowed user to charge for his/her
along with other flaws in MS or MS. account beforehand, and each time the user wanted to order
the service, he/she could directly pay a certain amount of fee
Although the third-party in-app payment involves financial
for each clothes using the pre-charged cash. So this time our
transaction and should have high security level, none of the
penetration test aimed at the transaction of charging. Like the
cashiers emphasize the security in particular. Some cashiers
pentest in restaurant, we used the similar way to perform the
just mention it (e.g., suggesting the merchant to implement
attack and successfully charged one hundred yuan into the
the network communication in HTTPS in the end of the
account with only one yuan paid from our Badpay account.
documents), which is easy to be ignored by merchants. Not
Andthenwespentthemoneyintheaccounttoplaceanorder
to mention the fact that improper designed TP-SDK and in-
and succeeded in washing our clothes without the merchant’s
correctdocuments/samplecodesreleasedbycashiers.Previous
awarenessordoubts.Afterthat,weinformedthemerchantthe
work [25][27][22][18] mainly focus on the the security of
vulnerabilities and paid for the real price of the order.
the merchant. And [11] ascribes Android code insecurity to
informaldocumentationsuchasStackOverflow,whileofficial Theattacksagainstthosetwoappsprovethatordertamper-
API documentation is secure but hard to use. However, our ing causes money loss and makes influence not only to online
work shows that when it comes to the third-party in-app e-stores but also to offline store in real life. Also, we find that
payment on Android, even official documents/sample code the security flaws of the two apps (leaking their keys in app,
released by cashiers lead to the code insecurity, which may failing to re-confirm the details of notified order to CS) are
be helpful to improve the security of the whole ecosystem of pervasive in many other MAs. In other words, such attacks
third-party payment. can be performed to many other merchants.
2)Order Substituting: We proved that Order Substituting
F. Case Studies attack can be automated and let user pay for the attacker’s
orderwithoutawareness.Weemployedtheattackonawireless
We choose several flawed merchant apps to perform real
router of our local area network. Since we control the router,
attacks.Itshowsthatthesedetectedviolationsofsecurityrules
wecanconductMITMattacktothedevicesinthesameLAN.
can directly lead to serious consequence including financial
We set a MITM proxy on the router to replace self-signed
loss in real world.
HTTPS certificate to the original one and decrypt the content
1)OrderTampering: Weconductedethicalhackingagainst of HTTPS connection.
twoappstoshowhowattackertamperstheorderandpurchases
The victim app in this case is a popular e-Book Reader
any commodities with an arbitrary price. The first case is an
with over 20 million downloads. Users can purchase non-
app used by several restaurants in China to display electronic
free e-books in this app via payment channels of all four
menutocustomersandallowsthemtopayforwhattheyorder
cashiers. We take the BadPay for the case. The app use HTTP
in app via WexPay or AliPay. The second case is an app for
connections when users browse book lists in the app. When
customer to order laundry pickup and delivery service.
users want to pay for a book then the connection will turn
For the first app, we went to a local restaurant and to HTTPS but the app fails to check the HTTPS certificate
downloadedtheapptoorderfoodanddrinks.Weinstalledthe correctly. So our proxy can intercept, eavesdrop and tamper
app on our penetration test Android phone with Xposed [10], the connection. Once a user orders a book and is about to
12pay, our proxy extracts from the network traffic which book a particular value to one yuan. Thus we pay for it via WexPay
theuserwanttobuyandtheorderinformationincludingprice withonlyoneyuan(orevencheaperifwewish).Inthesecond
(10 yuan in the case). Then our proxy places a new order attack, we do not tamper the order but follow all the normal
request using another app (a take-out food order app) to buy step until the app invokes the WexPay’s payment Activity to
a burger which is also 10 yuan, and get the order information askusforthepaymentpasswordtopayingfortheticket.Then
from the MS without paying for the burger in the latter step. we terminate the following steps and directly forged a legal
Instead, the proxy intercepts the payment order response of payment notification of the WexPay to it server. In the third
the book and substitutes it with the attacker’s burger order. attack, we repeat the second attack but just send a forged
As a result, the MA receives the replaced order response and notification message with incorrect signature to the MS and
prompts the user with its payment Activity of the TP-SDK. the server accepts it. All attacks lead us to available ticket-
Notice that information on the payment Activity of BadPay codes successfully. We did use the acquired ticket-codes to
only including price, are exactly the same as the price of fetch the physical tickets at different cinemas and watched the
the book. User cannot distinguish this replaced order and is movie.
cheatedtopayforit.Thusafterthepayment,theburgerispaid
Moreover, before informing the merchant and repaying
anddeliveredtouswhilethee-bookisstillkeptunpaid.When
the tickets we have bought, we wait for a certain period
they paid for the attacker’s order and found their own orders
(thus the merchant could check the collection of all past
are still unpaid, they just believe it is the delay of the CS that
orders periodically sent from the cashier) to check whether
leadstoatemporaryunpaidstatus.Imaginethatifthetake-out
the merchant verifies it. In spite of this, until we explain our
food order app here becomes a malicious MA controlled by
behavior to the merchant, they still have no idea about what
the attacker, then the attacker can easily generate an order in
has happened. It proves that the attacks can be performed
arbitrarypriceaccordingtothevictim’sorderandsubstituteit.
repeatedly without the merchants’awareness by an intentional
Thus, after user pay for it, the money is directly transferred to
attackers in real life.
the attacker’s account. Even with those TP-SDKs that display
themerchantname(WexPayandUniPay),theattackercanstill
VI. ETHICALCONSIDERATION
cheat users to pay for attacker’s order in the same app.
We carefully designed our experiments to avoid ethical
3)Unauthorized Querying: KEY Leakage directly leads to
problem. First, we reported all our findings and the behaviors
Unauthorized Query attack to merchants as we describe in
weperformedduringtheexperimentstotherelatedpartiesand
Section III-F. A typical case is the unauthorized querying of
did what we could do to help them improve the systems. Our
arbitrary orders. We take WexPay as an example. Hundreds of
effort was appreciated by these organizations. In detail, we
MA leak their secret keys, and we make use of the leaked key
reported the mistakes in documents/sample codes to WexPay,
to download all bills of each day of the merchant by simply
AliPay and BadPay. All of them have fixed and updated it.
making a request to a specific URL address3 provided by
For instance, [2] shows the updated payment process figure.
WexPay, along with traversing the ’bill date’ parameters. Our
Theoriginalfiguretoldthedeveloperstogenerateandsignthe
resultincludesvariousmerchantswhosecashflowofeveryday
paymentorderinclientapp(aswementionedinSectionV-E),
ranging from millions of yuan (online luxury goods store) to
which is obviously insecure. All the three cashiers expressed
tens of yuan (social network app). The bill also contains the
their gratitude to us. Also we detected flaws (such as missing
detailsofeverytransactioninthatday,includingpayer,paying
order signature validation) of several merchant servers de-
bank,discount,etc.Obviously,alltheseinformationshouldbe
scribedinSectionV-C.Wereportedtheseflawsandexplained
confidential to any unauthorized visitors.
our behaviors to these influenced merchants as soon as we
carried out our experiments, and helped them to fix these
4)App with Multiple Vulnerabilities: Merchant may vi-
vulnerabilities. Since hundreds of merchants suffer flaws in
olate multiple security rules and the relevant transaction is
their APPs as we mentioned in Section V-A, it would be too
vulnerabletonotonlyasingletypeofattack.Toillustrate,we
muchworkforustoinformallofthemerchants.Wedecidedto
demonstratehowtoacquirefreemovieticketsindifferentways
report the vulnerable MA list to the Security Response Center
byexploitingamovieticketorderingappwithanapproximate
of Tencent, Ant Financial and Baidu, who are responsible
10 million users. The chosen app allows users to select the
for the security of their whole payment ecosystem (WexPay,
cinema, the movie, and the seats they want, and then buy the
AliPay, and BadPay). They informed all the related merchants
movie tickets online via in-app payment. After the payment
oftheirsecurityrisks,revokedleakedKEY andrenewedthem.
users will get a ticket code and when they get to the cinema,
We use a Web API provided by WexPay as oracle to help
they can enter the ticket-code on an automated ticket machine
finding the leaked KEY in MA, which need to brute-force the
to get the physical movie tickets.
parameters of the API and may induce potentially heavy load
Severalsecurityflawsaredetectedinthisapp.Theproblem to WexPay’s server. We did restrict the frequency and times
occurs when users pay for tickets via WexPay in the app. The ofinvokingtheAPItoavoidpotentialdeniedofserviceattack
app commits Local Ordering mistake and thus, also exposes against the server. Also if the candidates of three parameters
the secret key and notify URL in app. Moreover, the app is (mentioned in Section IV-B) are too many, we first filtered
also proved to miss the notified payment confirmation and it manually to reduce the test set. After we described our
signature validation. We perform three kinds of attacks to buy detecting method to WexPay, they confirmed the issue and
movietickets.Inthefirstattack,wehooktheorder-generation planned to impose some constraints to invoking the API in
function based on Xposed in the app and tamper the price to future. They even expressed their appreciation to our effective
and efficient KEY Leakage detection method for large-scale
3’https://api.mch.weixin.qq.com/pay/downloadbill APPs. Second, we ensure no financial damage was inflicted
13uponthemerchantsbyreturningitemsorre-payingtheunpaid summarizedbasicrulesinusingcryptographiclibraries.Fahlet
orders,etc.ForthevictimuserintheOrderSubstitutingattack al.[15]revealseveraltypesofflawsintheuseofSSL/TLSby
(describedinSectionV-F2),welaterpaidforthee-bookorder Android application and detect potential SSL vulnerabilities.
forhim,whoisactuallyacolleagueofus.Wemadeuseofthe SMV-Hunter [20] combined static analysis and dynamic vali-
resultofdownloadedhistorybillsofmerchantstoevaluatethe dation to improve the precision of detecting unsafe SSL use.
feasibility of Unauthorized Query attack, and help to detect Reaves et al. [19] performed security analysis on SSL/TLS
KEY Leakage in MA using WexPay. We not only described certificate verification,non-standard cryptography,access con-
our detecting method in detail to merchants, but also deleted trol and information leak of branchless banking applications,
all these data at once to avoid further exposures. andfoundsignificantvulnerabilities.Differentfromallofthese
work,ouranalysisofsecurityflawscausedbyappsintegrating
VII. DISCUSSION third party in-app payment libraries. We reveal that these
flaws during in-app payment caused both by merchant apps
Although our large scale analysis reveals that the ratio
and third-party payment SDK providers. Among these flaws,
of flawed in-app payment implementations is surprising, we
KEY Leakage has been studied before. Both PlayDrone [23]
have to point out that we underestimate the actual danger.
and CredMiner [29] try to detect token exposure of AWS
During the TP-SDK identification, our methodology is based
and OAuth in Android applications. However, we adopt a
on static code feature. We classify many apps protected by
more efficient and accurate methodology, combining local
code packing techniques as not using any TP-SDK, while
program analysis and a remote Web API, to detect such
they do integrated TP-SDKs. In the detection of flaws in MA,
flaws in third-party payment. Besides, our work covers the
we adopt static analysis mainly focusing on analyzing DEX
security threats and flawed implementations throughout the
and resource files in APK. Those implementations with native
whole payment process, rather than focusing on a particular
.so are not analyzed. Since our work presents a systematic
type of vulnerability detection.
approachtodetectthosevulnerabilities,webelievetheanalysts
of merchants and cashiers could adopt our approach to audit
C. E-Commerce Vulnerabilities
their products before releasing.
The security analysis of e-commerce and payment has
Our security analysis mainly focuses on the interfaces of
attracted the attention of researchers in recent years, since
multi-party involvement in the third-party in-app payment.
vulnerabilities may cause great impact and financial loss. As
We pay less attention to the attacks or flaws only involving
farasweknow,theonlysimilarworkisimplementedbyVirtu-
single party (traditional user-to-merchant payment model), for
alSwindle[17],whichcanperformanautomaticattackagainst
instance, the merchant order tampering, or denied-of-service
in-appbillingservice.However,itseemstobejustasmallpart
attack on order ID or transaction ID.
of our work. First, the in-app billing service described in the
paper is just one scenario of the in-app third-party payment.
VIII. RELATEDWORK
The service is simpler and less popular compared to our
A. Insecure Android Third-party SDK research targets. Second, VirtualSwindle can only launch one
typeofattackandtheadversarymodelassumedinthepaperis
Meanwhile, vulnerabilities or threats introduced by third-
too limited. However, our work describes four types of threats
party SDKs in Android applications have also been studied
and attack model is more diversified. Third, only 85 Android
by many researchers. Chen et al. [13] studied on potentially-
appswerestudiedinthepapercomparedwiththethousandsof
harmful libraries across Android and iOS through clustering
samples in our work. Overall, we perform a more large-scale
similarpackagestoidentifylibrariesandanalyzingthemusing
and systematic analysis to third-party in-app payment. Our
AV systems to find those libs. Wang et al. [26] identified
workfocusesonfindingallflawedimplementationsthroughout
serious authentication and authorization flaws in applications
the whole payment process, not only launching one type of
that integrate Single-Sign-On SDKs. Li et al. [16] aims to
attack.
understand and analyze the security hazards imported by Push
service in Android applications. Wang et al. [24] and [12] Wangetal.[25]arethefirsttoanalyzelogicvulnerabilities
demystifiedandassessedthevulnerabilitiesofOAuthprotocol in Cashier-as-a-Service based web stores, and found several
on mobile platform, which often introduced by third-party logic flaws manually. Sun et al.[22] propose to detect logical
providers as SDKs in Android applications. However, the vulnerabilities in e-commerce application through static anal-
payment SDK in Android applications has never been studied ysisofavailableprogramcode.Pellegrinoetal.[18]proposed
before. We propose a comprehensive methodology to detect the idea of black-box detection of logical vulnerabilities in
various security rule violations in those apps who embed e-shopping applications Sudhodanan et al. [21] propose an
third-party payment SDKs. All of these flaws lead to serious automatic technique based on attack patterns for black-box,
consequence and result in financial loss for different parties securitytestingofmulti-partywebapplications.InteGuard[27]
involved. offers dynamic protection of third-party web service integra-
tions including cashier service in merchants’ websites.
B. Android App Vulnerabilities
All of the work mainly target on e-commerce in web
ThesecurityanalysisofvulnerabilitiesinAndroidapplica- application,whilewefocusonmobileplatform.Ourdetection
tion has also become hot spot these years, with the dramatic object is mainly flawed implementations in Android applica-
growth in mobile users. It’s common that misuse of security tions using third-party in-app payment SDKs, since apps in
libraries leads to flaws in apps. Egele et al. [14] studied mobile OS redefine the trust boundaries. Different from third-
the misuse of cryptographic API in Android applications and party payment of Web service, client application with TP-
14SDK embedded plays an important role in mobile payment [14] M. Egele, D. Brumley, Y. Fratantonio, and C. Kruegel. An empirical
scene. Thus our work involves large scale detection on flawed study of cryptographic misuse in android applications. In Proc. of
app according to mobile application’s characteristics. while the2013ACMSIGSACConferenceonComputerandCommunications
Security(CCS),2013.
previousworkfocusonserverflawdetecting,whichcanhardly
[15] S. Fahl, M. Harbach, T. Muders, L. Baumga¨rtner, B. Freisleben, and
be large scale. Besides, we also present security rules to every
M.Smith.Whyeveandmalloryloveandroid:Ananalysisofandroidssl
partyofin-apppaymentscene,analyzeandquestionthecause (in)security.InProceedingsofthe2012ACMconferenceonComputer
of these payment flaws in-depth. andcommunicationssecurity,2012.
[16] T. Li, X. Zhou, L. Xing, Y. Lee, M. Naveed, X. Wang, and X. Han.
IX. CONCLUSION Mayhem in the push clouds: Understanding and mitigating security
hazardsinmobilepush-messagingservices. InProc.ofthe21stACM
Insecure In-app payment is becoming a main threat to SIGSACConferenceonComputerandCommunicationsSecurity,2014.
mobile ecosystem as more and more online transactions are [17] C.Mulliner,W.Robertson,andE.Kirda.Virtualswindle:Anautomated
transferring from website to app. Different from traditional attackagainstin-appbillingonandroid.InProceedingsofthe9thACM
web payment, in-app payment involves more sophisticated symposium on Information, computer and communications security,
2014.
implementation details and the process is often obscure. To
[18] G. Pellegrino and D. Balzarotti. Toward black-box detection of logic
demystify processes of popular in-app payments and reveal
flawsinwebapplications. InNDSS,2014.
potential security risks, we conduct a comprehensive analysis
[19] B.Reaves,N.Scaife,A.Bates,P.Traynor,andK.R.Butler. Mo(bile)
onmainstreamthird-partyin-apppaymentschemesinAndroid
money,mo(bile)problems:analysisofbranchlessbankingapplications
Apps.Ouranalysisinvestigatesimplementationsoffourin-app inthedevelopingworld.In24thUSENIXSecuritySymposium(USENIX
payments and concludes a series of security rules that should Security15),2015.
be obeyed. We not only pinpoint the serious consequence of [20] D. Sounthiraraj, J. Sahs, G. Greenwood, Z. Lin, and L. Khan. Smv-
violating security rules, but also detect these flawed imple- hunter: Large scale, automated detection of ssl/tls man-in-the-middle
vulnerabilities in android apps. In Proc. of the 21st Annual Network
mentations. Our statistics paint a sobering picture–hundreds
andDistributedSystemSecuritySymposium(NDSS,2014.
of apps integrated with third-party in-app payment SDKs are
[21] A. Sudhodanan, A. Armando, R. Carbone, and L. Compagna. Attack
vulnerable. Besides, our further investigation indicates that
patternsforblack-boxsecuritytestingofmulti-partywebapplications.
cashier is mainly blame for these flawed implementations. InProc.ofthe23rdNetworkandDistributedSystemSecuritySympo-
We hope our study can remind and guide developers of both sium(NDSS),2016.
merchants and cashiers to build more secure in-app payments. [22] F.Sun,L.Xu,andZ.Su.Detectinglogicvulnerabilitiesine-commerce
applications. In Proc. of the 21st Network and Distributed System
SecuritySymposium(NDSS),2014.
ACKNOWLEDGMENT
[23] N. Viennot, E. Garcia, and J. Nieh. A measurement study of google
We would like to thank our shepherd, Kevin Butler, and play. InACMSIGMETRICSPerformanceEvaluationReview,2014.
the anonymous reviewers for their insightful comments that [24] H.Wang,Y.Zhang,J.Li,H.Liu,W.Yang,B.Li,andD.Gu. Vulner-
greatly helped improve the manuscript of this paper. This ability assessment of oauth implementations in android applications.
In Proceedings of the 31st Annual Computer Security Applications
work is partially supported by the Technology Project of
Conference,2015.
Shanghai Science and Technology Commission under Grants
[25] R. Wang, S. Chen, X. Wang, and S. Qadeer. How to shop for free
No.15511103002, and the Key Program of National Natural
online–security analysis of cashier-as-a-service based web stores. In
Science Foundation of China (Grants No. U1636217). The Proc.ofIEEESymposiumonSecurityandPrivacy,32nd,2011.
corresponding author of this paper is Yuanyuan Zhang. [26] R. Wang, Y. Zhou, S. Chen, S. Qadeer, D. Evans, and Y. Gurevich.
Explicatingsdks:Uncoveringassumptionsunderlyingsecureauthenti-
REFERENCES cationandauthorization. InUSENIXSecurity,2013.
[27] L.Xing,Y.Chen,X.Wang,andS.Chen. Integuard:Towardautomatic
[1] AliPay. https://open.alipay.com.
protectionofthird-partywebserviceintegrations. InProc.ofthe20th
[2] AliPaypaymentprocess. https://doc.open.alipay.com/doc2/detail? NetworkandDistributedSystemSecuritySymposium(NDSS),2013.
treeId=59articleId=103658docType=1.
[28] W.Yang,Y.Zhang,J.Li,J.Shu,B.Li,W.Hu,andD.Gu. Appspear:
[3] AndroGuard. https://github.com/androguard/androguard. Bytecodedecryptinganddexreassemblingforpackedandroidmalware.
[4] BadPay. https://b.baifubao.com. InResearchinAttacks,Intrusions,andDefenses.2015.
[5] MyappAndroidMarket. http://android.myapp.com/. [29] Y. Zhou, L. Wu, Z. Wang, and X. Jiang. Harvesting developer
credentialsinandroidapps.InProceedingsofthe8thACMConference
[6] OAuth. http://oauth.net/.
onSecurity&PrivacyinWirelessandMobileNetworks,2015.
[7] ProGuard. http://proguard.sourceforge.net/.
[8] UniPay. https://merchant.unionpay.com/join/index.
[9] WexPay. https://pay.weixin.qq.com.
[10] Xposed. http://repo.xposed.info/.
[11] Y.Acar,M.Backes,S.Fahl,D.Kim,M.L.Mazurek,andC.Stransky.
Yougetwhereyourelookingfor:Theimpactofinformationsourceson
code security. In Proc. of IEEE Symposium on Security and Privacy,
37nd,2016.
[12] E.Y.Chen,Y.Pei,S.Chen,Y.Tian,R.Kotcher,andP.Tague. Oauth
demystified for mobile application developers. In Proceedings of the
2014 ACM SIGSAC Conference on Computer and Communications
Security,2014.
[13] K.Chen,X.Wang,Y.Chen,P.Wang,Y.Lee,X.Wang,B.Ma,A.Wang,
andY.Zhang. Followingdevil’sfootprints:Cross-platformanalysisof
potentially harmful libraries on android and ios. In Proc. of IEEE
SymposiumonSecurityandPrivacy,37th,2016.
15