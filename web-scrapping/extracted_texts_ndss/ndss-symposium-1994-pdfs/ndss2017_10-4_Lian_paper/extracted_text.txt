A Call to ARMs: Understanding the Costs and
Benefits of JIT Spraying Mitigations
Wilson Lian Hovav Shacham Stefan Savage
UC San Diego UC San Diego UC San Diego
wlian@cs.ucsd.edu hovav@cs.ucsd.edu savage@cs.ucsd.edu
Abstract—JIT spraying allows an attacker to subvert a Just- of JIT compilation to improve JavaScript performance and
In-Timecompiler,introducinginstructionsequencesusefultothe thus require data pages be writable and executable (and for
attacker into executable regions of the victim program’s address reasons we will explain, typically allow pages to be in both
space as a side effect of compiling seemingly innocuous code in states simultaneously for extended periods of time). Thus,
a safe language like JavaScript.
by combining this implicit ability to create new executable
We present new JIT spraying attacks against Google’s V8 code (implicitly bypassing W ⊕ X) with the heap spraying
and Mozilla’s SpiderMonkey JavaScript engines on ARM. The techniquecommonlyusedtobypassASLRdefenses,attackers
V8 attack is the first JIT spraying attack not to rely on can still inject new code and blindly redirect to it. While a
instruction decoding ambiguity, and the SpiderMonkey attack
rangeofdefensesagainstsuch“JITspraying”attackshaveben
usesthefirstARMpayloadthatexecutesunintendedinstructions
proposed, modern browsers typically only implement versions
derived from intended instruction bytes without resynchronizing
of those mitigations that have extremely low overhead (e.g.,
to the intended instruction stream. We review the JIT spraying
occasionally blinding large constants).
defenses proposed in the literature and their currently-deployed
implementations and conclude that the current state of JIT In this paper we explore the practical import of these
sprayingmitigation,whichprioritizeslowperformanceoverhead, choices. Our first contribution is to demonstrate the feasibility
leaves many exploitable attacker options unchecked.
of two new JIT spraying attacks affecting web browsers on
We perform an empirical evaluation of mitigations with low Android phones, the first of which provides practical code
butnon-zerooverheadinaunifiedframeworkandfindthatfull, injection against the Chrome V8 JIT on ARM and the second
robust defense implementations of diversification defenses can of which provides Turing-complete malicious computation
effectively mitigate JIT spraying attacks in the literature as well
against Mozilla’s SpiderMonkey JIT on ARM. Thus, taken
as our new attacks with a combined average overhead of 4.56%
together with recent work by Lian et al. [17] showing JIT
on x86-64 and 4.88% on ARM32.
spraying vulnerabilities in Webkit (i.e., Apple phones), all
major smartphone browsers (almost 2 billion computers) are
I. INTRODUCTION
vulnerable to this style of attack. Our second contribution is a
Web browsers are complex programs and continue to collectionofopensourceimplementationsofexistingproposed
exhibit soundness errors in their memory access patterns that JIT spraying mitigations for SpiderMonkey on both ARM32
form the basis for a broad array of exploits. The combination and x86-64 and empirical evaluations of their performance
of the large legacy software footprint and performance over- overhead on a consistent testing platform. We find that en-
head concerns have limited the practical effect of proposals abling constant blinding—which incurs the highest overhead
to rewrite browsers in memory-safe languages or with tight of any single mitigation that we implemented—can reduce
runtime control flow integrity checks. Instead, most industrial the probability of landing a JIT spray exploit by a factor of
browserdevelopersfocusontheuseofmitigationsthatprevent 2.41×10462 with an overhead of just 1.39% and 3.99% on
control flow violations from being reliably exploited (e.g., x86-64 and ARM32, respectively. We argue that the value of
stack cookies, W ⊕ X, Address Space Layout Randomization mitigation justifies the small performance penalty and that JIT
(ASLR), safe memory management functions, pointer encryp- developers should implement register randomization, constant
tion,MicrosoftEMET,etc.)Whilenoneofthesearefoolproof, blinding, call frame randomization, random NOP insertion,
taken together they have been highly effective at complicating andbaseoffsetrandomization(withcombinedaverageruntime
the exploitation of vulnerabilities. overheads of 4.56% and 4.88% on x86-64 and ARM32,
respectively) to close this remaining code reuse loophole.
However,onemajorloopholeremainsintheformof“Just-
In-Time” (JIT) compilation. All of today’s browsers make use
II. BACKGROUND
When a JIT compiler compiles code in a high level
Permission to freely reproduce all or part of this paper for noncommercial language into native instructions, the opcodes and operands it
purposes is granted provided that copies bear this notice and the full citation
emits are heavily influenced by the potentially-untrusted high
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author level code. Furthermore, the high level code can create new
(for reproduction of an entire paper only), and the author’s employer if the nativecodeat-willbydynamicallycreatingandevaluatingnew
paper was prepared within the scope of employment. code. This grants the untrusted party who wrote the high level
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
code unprecedented influence over large swaths of executable
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23108 memory in the language runtime’s address space. Blazakis [7]construct ROP gadgets that are exploited with the aid of a
B8 90 90 90 3C 35 90 90 90 3C 35 90 90 90 3C
memory disclosure vulnerability [4], [18]. With the exception
of [18], all past incarnations of JIT spraying have relied on
mov eax, 3c909090h xor eax, 3c909090h xor eax, 3c909090h constantvaluessuppliedbytheattackerinhighlevelcode;and
withoutexception,allpastJITsprayingattackshavemadeuse
NOP NOP NOP cm 3p 5 hal, NOP NOP NOP cm 3p 5 hal, NOP NOP NOP ofmaliciousinstructionsencodedatinstructionboundariesnot
intendedbytheJITcompiler.Theseattackswouldbethwarted
Fig. 1: Illustration of a NOP sled encoded in the bytes imple- by a robust implementation of constant blinding (cf. §IV). In
menting the statement x = 0x3c909090 ˆ0x3c909090 §III-B,wewillintroduceanewJITsprayingattackagainstV8
ˆ0x3c909090; on ARM which is the first JIT spraying attack that does not
rely on the execution of JIT code at unintended instruction
boundaries and, like [18], does not abuse the translation of
was the first to publicize an attack which leveraged these
untrusted constants into instruction operands in JIT code.
propertiesofaJITcompilertoperformcodeinjectiononx86.
In the attack, the adversary encodes a NOP sled and shellcode
inaseemingly-innocuoussequenceofbitwiseXORoperations
III. NOVELJITSPRAYINGTHREATSAGAINSTARM
resembling the following: In this section, we present two novel JIT spraying threats
against ARM. The first (§III-B) is a proof of concept end-to-
x = 0x3c909090 ˆ 0x3c909090 ˆ 0x3c909090; end attack against Chrome’s V8 JavaScript enginethat applies
Lian et al.’s gadget chaining technique [17]. Its novelty rests
When compiling the above, the ActionScript JIT compiler
in the distinction that, unlike all prior JIT spraying attacks,
produces the bytes shown in dashed boxes in Figure 1, which
this one does not rely on the improper disassembly of JIT
encodethex86instructionsshowninthesolid-borderedboxes
code. Afterwards, we describe a method for encoding a “self-
below them. However, since x86 instructions have variable
sustaining” JIT spraying payload which, in contrast to prior
lengthsandcanbedecodedatanybytealignment,analternate
JIT spraying payloads for ARM, can execute an arbitrary
decoding of the bytes can be observed by disassembling from
number of malicious instructions without resynchronizing to
any unintended instruction boundary, as shown in the bottom
the intended instruction stream (§III-C). We used this method
rowofFigure1indouble-linedboxes.Thisalternatedecoding
to implement a proof of concept payload against Mozilla’s
functions as a NOP sled which lands at 4 out of 5 byte offsets
SpiderMonkey JavaScript engine which interprets instructions
and can be extended without resynchronizing to the intended
for a One Instruction Set Computer.
instruction stream as long as the opcode bytes for XOR (the
0x35bytes)continuetobeconsumedasinstructionoperands.
A. Instruction sets on ARM
In an actual attack, the NOP sled would be lengthened
The discussion of our new threats hinge on an under-
by extending the chain of XORed 0x3c909090 constants,
standing of certain low-level details of the ARM architecture.
and eventually the 0x90 bytes would be replaced with the
Therefore,webrieflyintroducerelevantaspectsoftheinstruc-
encodings for shellcode instructions, with the limitation that tion sets supported by 32-bit ARM chips1. Recent ARM chip
eachshellcodeinstructionfitintothreeconsecutive0x90byte
designs (ARMv6T2 and later) have mandatory support for
slots. The attacker would place the XOR chain statement in a
at least two instruction sets. These are the original “ARM”
functionthenrepeatedlydeclareandinvokeitinordertocause
instruction set, and the newer “Thumb-2” instruction set. The
theJITcompilertofillasmanypagesaspossibleofexecutable
ARMinstructionsetiscomposedoffixed-width32-bitinstruc-
memorywiththehiddenNOPsledandshellcode.Byspraying
tionsstoredinmemoryas32-bit-alignedwords.TheThumb-2
NOP sleds that are much larger than the shellcode, execution
instruction set, on the other hand, is designed for improved
beginning at a random address in sprayed code has nearly an
code density and contains both 16-bit and 32-bit wide instruc-
80% chance of successfully executing the shellcode.
tionsstoredinmemoryasasingle16-bitalignedhalfwordand
More generally, the opportunities for exploitation intro- two consecutive 16-bit aligned halfwords, respectively.
duced by JIT compilers are code reuse (e.g., the attack
At any given time, a 32-bit ARM core is said to be exe-
described above) and code corruption, wherein the attacker
cutingineither“ARMmode”or“Thumbmode.”Interworking
abuses the fact that JIT code memory must, at some point in
betweenARMcodeandThumb-2codeispossiblethroughthe
time (or for many JITs, at all times), be writable. Writable
use of unprivileged interworking branch instructions, which
code memory—once thought to be a relic of the bygone
either unconditionally toggle the processor between modes
pre-W ⊕ X era—is necessary not only for the JIT to create
or derive the desired execution mode of the branch target
and delete code, but also for the frequent patching many
from the least significant bit of the branch target address.
JIT implementations undertake to support inline caching, a
Since both ARM and Thumb-2 instructions are aligned to at
performance optimization employed by nearly all JavaScript
least 16-bit boundaries, the least significant bit of any valid
JIT compilers to ease the burden of the dynamic type system.
instructionaddressisunused.Interworkingbranchinstructions
Since Blazakis first brought JIT spraying into the public take advantage of this by repurposing the bit. If the bit is set,
eye, it has been extended to JavaScriptCore’s non-optimizing thetargetisexecutedinThumbmode;otherwiseitisexecuted
JIT for x86 [26], Mozilla’s JaegerMonkey and TraceMonkey in ARM mode.
JITs [25] for x86, the Tamarin ActionScript JIT for ARM [6],
1Supportfora64-bitinstructionsetcalledA64wasintroducedinARMv8-
and JavaScriptCore’s optimizing JIT for ARM’s Thumb-2
A.However,sincesupportforA64isnotmandatoryinARMv8-A,andmany
instruction set [17]. JIT compilers have also been abused to
32-bitARMchipsremainonthemarket,wedonotconsideromissionofA64
asignificantlimitation.
2B. JIT spraying on ARM without improper disassembly It is necessary to inject a return instruction rather than
allowingcontrolflowfallthroughintotheenclosingfunction’s
In this subsection, we describe a new proof of concept
epilogue and return instruction because the epilogue performs
attack against Chrome’s V8 JavaScript engine on ARM which
stack cleanup and loads the return address from the stack,
demonstrates—for the first time against any architecture—the
both of which would prevent a proper return to high level
feasibility of carrying out a JIT spraying attack that uses JIT-
language (HLL) code given our decision to use an injected
emitted instruction bytes without exploiting ambiguity in the
controlflowvulnerabilityintheformofahijackedvirtualhost
decoding of those instructions. In fact, this attack relies on
function call. When control flow arrives at the gadget under
neitheruntrustedconstantsappearinginJITcodeasimmediate
those circumstances, the stack is not setup properly for a JIT
operands nor execution of JIT code at unintended instruction
functionepiloguetocleanitup,andthereturnaddressresides
boundaries. Since V8’s JIT compiler emits fixed-width 32-bit
inthelinkregister(LR)ratherthanonthestack.However,once
ARM instructions, the latter non-dependency is trivial, pro-
thestoreinstructionhaswrittenitsreturninstructionduringits
videdthattheJITsprayingpayloadisexecutedinARMmode.
first invocation, the gadget is a reusable primitive that can be
The V8 attack uses the gadget chaining technique intro- called repeatedly to overwrite arbitrary words in memory.
duced by Lian et al.[17]; gadget chaining is a technique in
The sprayed store instruction is str r2, [r11,
which an attacker’s high level language (HLL) code (e.g.,
#-20], where r11 is used as a frame pointer register in
JavaScript) is able to treat unsafe computation performed by
V8’sJITcode.TheJavaScriptfunctionwhoseJITcompilation
reusedcodeasthoughitwereasubroutine.Theattacker’sHLL
results in the emission of a spray gadget defines numerous
codeinvokesacontrolflowvulnerabilitytobranchtoareused
variableswhichareusedinthecomputationofthereturnvalue.
code snippet, which performs unsafe computation then returns
By defining more such variables than there are allocatable
control flow back to the HLL code. Each reused snippet is
registers, V8’s optimizing JIT will begin spilling values onto
referred to as a “gadget,” and each gadget may or many not
the stack. The sprayed store instruction is one such spilling
take arguments or return values to the HLL code. The use of
instruction.Weeval()thedefinitionandrepeatedinvocation
gadget chaining gadgets differs from ROP gadgets, however,
of the sprayed function to trigger optimized compilation and
inthatcontrolflowafteragadgetchaininggadgetreturnsdoes
thesprayingofastoregadget.Optimizedcompilationisneces-
not continue directly to another gadget, but rather back to the
sary because only the optimized compiler allocates and spills
language runtime where the HLL code resumes execution.
registers, which are necessary to create the store instruction
Thehighlevelstructureoftheproofofconceptattackisas and the subsequent memory-access-free padding instructions.
follows. After JIT spraying a particular store instruction (the
store gadget) into memory, the attacker clears the victim’s i- 2)Artificial control flow vulnerability: For our proof of
cache of the sprayed store gadgets by calling numerous DOM concept attack, we simulated a memory corruption vulnera-
functions. She then guesses the address of a store gadget and bility that could be used to hijack the virtual function table
uses a hijacked virtual host function call2 to simultaneously pointerofaDOMobject.WeaddedaJavaScripthostfunction
branch to that address and control the contents of the input hijackVTableintoV8thatperformsthedesiredcorruption.
registers used by the store gadget. The first invocation of Hijacked virtual functions are especially useful for a gadget
the store gadget writes a return instruction (bx lr) into JIT chaining because they can serve two purposes: subverting
code a short distance after the store instruction. Subsequent control flow and controlling the gadget’s operands, which in
invocations are made in order to write 4 bytes at a time the case of the store gadget are two registers. We make use of
of shellcode into the memory following the injected return the DOM’s Blob class and its slice() method, which is
instruction. The victim’s i-cache is cleared once more, and implementedasaC++virtualfunctionandacceptstwolongs
a final invocation of the store gadget overwrites the injected as arguments that can be controlled by a JavaScript caller. We
return instruction with a NOP instruction and the execution of were fortunate that both arguments eventually reside in the
the shellcode. The details of gadget layout and creation, the registers used by the store gadget (R2 and R11), despite the
artificial control flow vulnerability, and failure-tolerant gadget fact that one of the long arguments is actually passed on the
invocation are described below. stack.Thisoccursbecausethevarioustrampolinesexecutedto
shuffle values between the JavaScript calling convention and
1)Gadget layout and creation: The sprayed store gadget
thearchitectureABIcallingconventionhappentoleaveacopy
consists of an intended store instruction used to spill a live
of the stack-passed argument in R11.
value onto the stack followed by at least one i-cache line (128
bytesonourtestmachine)ofpaddinginstructionsthatperform 3)Failure-tolerant invocation: In order to use the store
bitwise operations over caller-saved registers. The injected gadget,ourcontrolflowvulnerabilitymustbeabletoprecisely
return instruction will be written after the one i-cache line targetthegadget’sstoreinstruction;ifexecutionbeginsbefore
padding so that it will be executed during the same gadget the store instruction, the intended instructions before it could
invocationthatitisinjected.Thepaddinginstructionsmustnot clobber the source register operand. If execution begins after
accessmemorybecausetheyarelikelytocauseasegmentation it, the new return sequence cannot be patched in during the
fault or clobber critical machine state. They must also operate gadget’s first invocation, most likely leading to a crash. To
only on caller-saved registers because they will execute as solvethisproblem,weplacethegadgetata(semi-)predictable
intendedandmustpreservethevaluesofcallee-savedregisters offset within each coarse-grained memory allocation chunk.
for when the gadget returns.
V8’s code memory allocator maps a new 1MB chunk of
RWX memory if it can’t fulfill an allocation request from the
current pools of free JIT code memory. Allocation requests
2ThiswasavulnerabilitywhichweartificiallyinjectedintoV8. are then satisfied starting at the low-addressed end of the
3new chunk. If we could coerce V8 into placing a copy of the function sprayMe(x) {
optimized function containing the store gadget as the first unit …
if (x == -1)
ofcodecompilationineachfresh1MBcodechunk,wewould return A;
need to guess only which 1MB chunk contains a sprayed …
gadget (i.e., the most significant 12 bits of a 32-bit address).
// Trigger gadget production.
var R3 = R2a ^ 0x1098;
…
Unfortunately, due to the nature of V8’s JIT compilation
return B;
pipeline, it is not possible to guarantee that the store gadget }
will be the first unit of code compilation placed in each 1MB
chunk. During a single function instance’s lifetime from dec-
laration to optimized compilation, V8 produces four different Δ return A
pieces of code which contend for the coveted first slot. They return A gadget start
are the anonymous function that declares the function being
unusable gadget
sprayed, the unoptimized JIT code for the function being
return B
sprayed, a second copy of the unoptimized JIT code (which is
produced once more after V8 decides to compile the function Optimized sprayMe()
return B
with the optimized compiler), and the optimized JIT code for
the function being sprayed. Unoptimized sprayMe()
For reasons which will become apparent, it is essential
Fig. 2: Illustration of how a return instruction in unoptimized
that these four pieces of code are emitted in that exact order,
JIT code is aligned to the same function offset ∆ as a gadget
with no interleaving between parts of consecutively-sprayed
in optimized JIT code.
instances of the function. Our spraying procedure ensures this
by invoking each instance of the sprayed function in a loop
1MB Chunk Start
a sufficiently-large number of times in order to cause V8
to consider the function “hot” and optimize it. The number θ
of loop iterations was tuned to be large enough that the Δ
invocation loop for a particular instance of the function would return
still be running when the optimized code (which is compiled ψ
asynchronously) is finally emitted.
Legend Δ
If the first piece of code in each 1MB chunk were chosen return
Chunk Header
uniformly at random from the four possibilities, 25% of the
ψ
time it would be the anonymous declaration function, over Unoptimized fxn
whose size and contents we exert very little control. However, Δ
Optimized fxn gadget start
due to the various space requirements of the different pieces
of code—384 bytes for the declaration, 2912 bytes for each
Fig. 3: Illustration of the beginning of a 1MB chunk that can
copyoftheunoptimizedcode,and672bytesfortheoptimized
be probed for the location of a gadget in a failure-tolerant
code—anew1MBchunkismostlikelytobeallocatedforthe
manner. An incorrect guess of θ or θ+ψ will only execute
large unoptimized spray code. Indeed, measurements of V8
a harmless return instruction. ∆ is the common offset of both
embedded in Chrome show that the probabilities that the first
the return instruction and the gadget in both the unoptimized
copyofoptimizedspraycodeina1MBchunkwillbepreceded
and optimized code.
by 0, 1, and 2 copies of the unoptimized spray function are
0.391%, 49.2%, and 48.4%, respectively; and the probability
gadget will reside at one of the following offsets in a given
that the anonymous declaration function will take the first slot
1MB chunk: θ, θ+ψ, or θ+2ψ. The values of both θ and
is only 1.17%.
ψ are deterministic and known. The value of θ is the size of
Although the optimized spray function is not likely to be the fixed-sized header at the start of each 1MB chunk plus ∆;
sprayed at any single location near the beginning of all 1MB and ψ is the size of the unoptimized spray function. Figure 3
chunks, in over 98% of chunks, the only code preceding it illustrates an example memory layout at the beginning of a
in a chunk are unoptimized spray functions, whose size and 1MB allocation chunk in which two copies of the sprayed
contents we control. We take advantage of this fact and craft function produced by the non-optimizing JIT precede a copy
the spray function in such a way that an intended return of the sprayed function produced by the optimizing JIT. The
instructionisemittedatthesameoffset(∆)fromthebeginning optimized copy contains the store gadget, which resides at the
of the function in unoptimized code as the store gadget in offset θ + 2ψ from the start of the chunk. Observe that if
optimized code. This makes it safe to accidentally branch into there were zero or one copies of the unoptimized function
an unoptimized spray function with a hijacked function call code before the optimized copy, the gadget’s offset from the
since execution will immediately return rather than crashing. chunk’s start would be θ and θ+ψ, respectively.
Figure 2 illustrates how we accomplished this by placing
This meticulously-crafted memory layout enables us to
a conditional return early in the sprayed function to take
probeforthegadget’saddressinafailure-tolerantmanner.The
advantage of the fact that V8’s unoptimized JIT code is less
firsttimetheattackertriggersthecontrolflowvulnerability,she
dense than its corresponding optimized code.
guessesa1MBchunkandtargetsthecommonoffsetinthefirst
With the spray function’s unoptimized and optimized code function in the chunk (θ). In the unlikely event that the first
laid out as described, there is >98% probability that the store
431 2019 1615 1211 0 function sbnz(a, b, c, d)
ARM 111000100000 Rn Rd imm12 Mem[c] = Mem[b] - Mem[a]
D C B A if (Mem[c] != 0)
// branch to instruction at address d
Raw bytes A B C D else
// fallthrough to next instruction
15 1211 015 43 0 Listing 1: Pseudocode for the sbnz instruction.
Thumb Rd imm12 111000100000 Rn
B A D C
Weimplementedaproofofconceptself-sustainingpayload
Fig.4:Illustrationofhowtheimmediate-operandbitwiseAND
which executes an interpreter loop for a One Instruction Set
instruction from the ARM instruction set can be decoded as
Computer (OISC) [19], an abstract universal machine that has
two 16-bit Thumb-2 instructions.
only one instruction. There are many options for the single
instruction; we implemented Subtract and Branch if Non-
functioninthe1MBchunkisadeclaration(1.17%probability, Zero (SBNZ). Listing 1 shows the pseudocode for the sbnz
assuming spray code is monopolizing JIT code memory), the
instruction. In the remainder of this subsection, we describe
attack will fail. However, with high probability, it will be a
in detail our technique for constructing a self-sustaining JIT
copyofthesprayedfunction’soptimizedorunoptimizedcode.
spraying payload capable of Turing-complete computation, a
In those cases, either the gadget or a return instruction will
NOP-sled construction method, the means by which a self-
execute. If it is the former, the attack succeeds; otherwise,
sustaining payload may be invoked, and the limitations of the
the hijacked virtual function call will immediately return.
technique and our proof of concept payload.
Eventually, the attacker’s script will expect an invocation of
the store gadget to result in shellcode execution, and when
1)Payload-building technique: We first describe our
that fails to occur, it can be concluded that the control flow
method for encoding an unintended Thumb-2 instruction
vulnerability was targeting a return instruction rather than a
stream among the intended ARM instructions emitted by
storegadget.Thescriptcanthenincreasethetargetaddressof
Mozilla SpiderMonkey’s optimizing JIT compiler IonMonkey
the control flow vulnerability by the size of the unoptimized
and orchestrating the proper flow of control through the un-
spray function (ψ) and try again.
intended instructions. Our technique makes use of the bitwise
V8 limits the amount of JIT code memory at 256MB. If ANDinstruction,whichcomputesthebitwiseANDofa12-bit
the attacker is able to monopolize these 256MB, her odds of immediate value (imm12) and the contents of a register (Rn)
success depend mostly on her ability to guess which 1MB andstorestheresultintoanarbitraryregister(Rd).Bycarefully
chunks contain JIT code. On a 32-bit system, a conservative structuring our JavaScript code, we are able to control both 4-
estimate is 6.125% (256/4096 × 0.98); however, a more bitregisteroperandsandthe12-bitimmediateforatotalof20
realistic estimate might take into account that the location of outof32bits.ThebytesintheencodingofARM’simmediate-
JITcoderegionscanbenarroweddowntohalfoftheavailable operand bitwise AND instruction form two consecutive 16-bit
address space, giving a probability of 12.25%. Thumbinstructions,asshowninFigure4.Fromtoptobottom,
the rows show the layout of the ARM AND instruction, the
C. Constructing a self-sustaining ARM JIT spraying payload in-memorylayoutofthosebytes,andthelayoutofthosesame
PriorJITsprayingattacksagainstARMfailedtorepurpose bytes when decoded as Thumb-2 instructions.
JIT code to form a “self-sustaining” JIT spraying payload that The observant reader may be curious as to why the
executesinitsentiretyonceexecutionbranchestoit.3 Instead, unintended Thumb-2 instruction stream will decode to 16-
Lian et al. [17] introduced the gadget chaining technique, bit instructions rather than 32-bit Thumb-2 instructions. The
which we borrowed in the attack we presented in §III-B. Lian reasonisthat32-bitThumb-2instructionsmustbeginwiththe
et al. studied JavaScriptCore, which emits Thumb-2 instruc- bit prefix 11101 or 1111 , but IonMonkey only allocates live
2 2
tions, and considered the viability of self-sustaining payloads valuestoregistersintherange0000 –1011 ,inclusive.Neither
2 2
that encode an unintended instruction stream—be it a stream byte B nor byte D in this particular instruction can contain
of ARM or Thumb-2 instructions—using intended Thumb-2 this prefix, and therefore Thumb-mode decoding beginning at
instructions; they found such payloads to be infeasible. either halfword can only yield 16-bit Thumb-2 instructions.
In this section, we describe a method for encoding an Why not choose an ARM instruction whose byte B or byte D
unintended Thumb-2 instruction stream using ARM instruc- can include 32-bit Thumb-2 instruction prefixes? The reason
tionsemittedbytheMozillaSpiderMonkeyJavaScriptengine’s isthatitisdifficultforanadversarytocoercetheJITcompiler
optimizing JIT compiler IonMonkey. Our technique can be intoproducingsuchinstructions;andveryfewbitswithinthose
used by an attacker to achieve arbitrary Turing-complete instructions are easily influenced by the attacker.
computation while executing only instructions decoded from In addition to the constraints on the Rd register, the first
intended instruction bytes. Whereas the proof of concept JIT Thumb-2 instruction is also constrained by the set of valid
spraying attacks against ARM described in [17] and §III-B 12-bit immediate operands to the ARM AND instruction. The
use the JIT spraying payload to launch a JIT code corruption 12-bit immediate is meant to be interpreted as an 8-bit value
attack, the technique described in this section is effective even with a 4-bit rotation field, but valid encodings must use the
in the presence of non-writable JIT code. smallest possible rotation value. Therefore, it is impossible to
induce the JIT compiler into emitting certain bit patterns in
3Beck [6] demonstrated a spraying technique against the Tamarin Action- the imm12 field. Taking these constraints into account, the
Script JIT on ARM that would enable the encoding of a self-sustaining
halfword formed by bytes C and D can still encode a broad
payload,butitleveragesconstantpools—datavaluesinlinedwithJITcode—
ratherthanmaliciously-repurposedinstructions. range of 16-bit Thumb-2 instructions.
5} TABLEI:TableofinstructionsimplementingtheSBNZOISC
pair_0: mov r6, pc b vpc_update_0
abstractmachineasaself-sustainingpayload.Horizontalrules
pair_1: shellcode_insn_1 b vpc_update_1 BB lr oa cn kc h 1 indicate branch block boundaries where padding is inserted.
pair_2: shellcode_insn_2 b vpc_update_2
UnintendedThumb IntendedARM
} # Label instruction instruction
vpc_update_0: add r6, #0 b loopback_0
1 vpc init addr6,pc,#36 andr10,r1,#9437184
vpc_update_1: add r6, #4 b loopback_1 BB lr oa cn kc h 2 2 add,r7,#1 andr3,r1,#262144
vpc_update_2: add r6, #4 b loopback_2 3 oisc pc init movr5,sp andr4,r1,#114294784
4 interpreter loop top ldrr1,[r5,#0] andr6,r1,#2686976
5 ldrr2,[r5,#4] andr6,r1,#6946816
} 6 ldrr3,[r5,#8] andr6,r1,#11206656
loopback_0: mov pc, r6 7 ldrr1,[r1,#0] andr6,r1,#589824
loopback_1: mov pc, r6 BB lr oa cn kc h 3 8 9 l sd ur br r2 2, ,[ rr 22 ,, r# 10] a an ndd rr 16, ,r r1 1,,# #1 31 37 59 86 74 28
loopback_2: mov pc, r6 10 strr2,[r3,#0] andr6,r1,#26
11 cbzr2,#104(zero) andr11,r1,#-2013265918
12 non zero ldrr5,[r5,#12] andr6,r1,#15532032
13 subsr6,#162 andr3,r1,#2592
Fig. 5: Illustration of using a virtual PC (in this case R6) to 14 zero addsr5,r5,#13 andr3,r1,#54525952
more efficiently utilize the space skipped over by branches. 15 addsr5,r5,#3 andr3,r1,#12582912
16 subsr6,#215 andr3,r1,#3440
1 incr init movsr7,#35 andr2,r1,#9175040
The second Thumb-2 instruction must be an unconditional
2–12 vpc advance(×11) addsr6,r7 andr4,r1,#1040187392
PC-relative forward branch of at least 512 halfwords. The Rn 13 non zero loopback subsr6,#162 andr3,r1,#2592
14–15 vpc advance(×2) addsr6,r7 andr4,r1,#1040187392
field forms the least-significant 4 bits of the branch distance
16 zero loopback subsr6,#217 andr3,r1,#3472
in units of halfwords. The self-sustaining payload works by
1–16 branch vpc(×16) movpc,r6 andr4,r1,#191889408
chaining together pairs of unintended 16-bit Thumb-2 instruc-
tions with these unconditional branches. The first Thumb-2 function sprayMe(r0, R10, FP, r8, R7, R5) {
// Statements to define additional variables and
instructionperformsusefulworkfortheadversary;thesecond
// populate their values into registers go here
branches to the first Thumb-2 instruction in a subsequent pair. if (R10 == 0) {
For this branch to target the first instruction in a pair, the R10 = R1 & 9437184; // and r10, r1, #9437184
} else if (R10 == 1) {
branchoffsetmustbeanoddnumberofhalfwords,soRnmust
R3 = R1 & 262144; // and r3, r1, #262144
be an odd-numbered register. The value of the PC in Thumb } else if (R10 == 2) {
mode is the address of the current instruction plus 4 (i.e., 2 ...
}
halfwords). Consequently, the closest we can place the next // Return statement using all variables goes here
pairofunintendedThumb-2instructionsis(512+1+2)×2= }
1030bytesafterthestartoftheunintendedbranchinstruction.
Listing 2: The structure of the JavaScript function sprayed to
Na¨ıvely chaining 1030-byte forward branches would produce the self-sustaining SBNZ OISC payload.
require an exorbitant amount of memory to encode even a
simple payload. To reduce the space requirements of our bitwiseAND;forexample,bitwiseXORandORwouldresult
self-sustaining payload, we designate a general purpose inbranchblocksthatare64and768byteslonger,respectively.
register as a virtual PC which we use to loop execution
Using the virtual PC method, we implemented the inter-
back into the branched-over space, where another unintended
preterloopforanSBNZOISCabstractmachine.Wedesignate
instruction pair has been placed. We define a branch block
ageneral-purposeregisterastheOISCPCanduseunintended
as the largest block of unintended instruction pairs whose
instructions to perform the subtraction and update the OISC
first unintended instruction pair skips over all subsequent
PC according to its outcome. Our implementation expects the
unintended instructions pairs in that branch block. Figure 5
firstinstruction,composedoffourconsecutive32-bitaddresses
shows the virtual PC method with 3 branch blocks under
correspondingtothefourinstructionoperands,toresideatthe
simplified conditions. Note how execution flows through each
top of the stack when it begins executing. The instructions
unintended instruction pair in each branch block (with the
used to build the interpreter are shown in Table I. Note that
exception of branch block 3, which only executes the first
instructions 1 and 2 within each branch block are 40 bytes
unintended instruction in the pair), then through the second
apart,whereasallotherinter-instructionspacingwithinbranch
instruction pair in each branch block, etc. In our proof of
blocks is 36 bytes. When tracing control flow through the
concept payload, 12-bit immediate encoding rules require
table, remember that instructions sharing a common number
us to populate a register with the virtual PC advancement
in the first column will be executed consecutively with one
amount and perform register-register addition rather than
another with the exception of instruction 11 in the first branch
register-immediate addition. Furthermore, in order to prevent
block(cbz),whichmaybranchtothezerolabel.Thisproof
dead store elimination, the JavaScript statements that produce
of concept demonstrates the feasibility of performing Turing-
unintended instruction pairs reside in separate mutually-
complete computation with unintended Thumb-2 instructions
exclusive conditional blocks, resulting in a larger virtual
decoded from intended ARM instruction bytes that are exe-
PC advancement amount of 36 bytes (Listing 2). Note that
cuted as a self-sustaining payload.
although Figure 5 shows only three branch blocks, longer
payloads can be encoded by inserting branch blocks before
2)Encoding a NOP sled: It is possible to construct a
the “vpc update” block. Another option is to increase the size
NOP sled by placing n+k branch blocks prior to the branch
of branch blocks by using an intended instruction other than
blocks containing shellcode. The unintended instruction pairs
6in the initial n branch blocks exist only to direct control in the intended ARM instruction. We were fortunate that
flow forward to the final k branch blocks. The unintended IonMonkey’s allocates live values to R11 because it enabled
instructions in the final k branch blocks of the NOP sled use us to encode the “Compare and Branch on Zero” (cbz)
their statically-predetermined offset within the branch blocks instruction, which is crucial for Turing-completeness. V8, on
to construct a branch to the first unintended instruction in the the other hand, does not allocate live values to register R11,
first shellcode branch block. For example, the first unintended significantly complicating the encoding of a Turing-complete
instruction in the final NOP sled branch block must effect a payload. However, even if it were not possible to encode
large forward branch to skip the entire branch block, but the Turing-complete computation in the self-sustaining payload,
lastunintendedinstructioninthesamebranchblockneedonly thetechniqueallowsfortheconstructionofmoresophisticated
skip any remaining tail in its own branch block and whatever gadgets for use in gadget chaining.
short head exists at the beginning of the next branch block.
The success rate of correctly landing in the NOP sled IV. JITSPRAYINGMITIGATIONS
depends on how densely unintended instruction pairs can Researchersandpractitionershaveproposednumerousmit-
be packed in the final k branch blocks. The only way to igationsagainstthesecurityrisksintroducedbyJITcompilers.
both achieve a high density of unintended instruction pairs Themitigationsvarywidelyinpeformanceoverhead,difficulty
and avoid dead store elimination is to use the the desti- of integration into an existing JIT compiler, and defensive
nation register of the intended AND instruction as one of effectiveness. We organize these efforts into the following
theinputoperands.Forexample,and r1, r1, #10; and
three categories: capability confinement, memory protection,
r1, r1, #10 is okay, but and r4, r1, #10; and and diversification. In order to place our own defense imple-
r4, r1, #10 is not because the first instruction can—and mentations and the performance evaluations thereof (§V) into
will—be eliminated. Recall that the register must also be context, we provide an overview of JIT spraying mitigation
odd-numbered in order for the unintended branch instruction proposals in these three classes and their adaptations (when
in each pair to correctly target the beginning of the next applicable) in real world JIT implementations.
unintended instruction pair. We were unable to devise a NOP
sled whose unintended instructions are derived from only
A. Capability confinement
intended instructions operating on odd-numbered registers.
We must therefore sacrifice density in the same manner as The objective of capability confinement defenses is to
described in §III-C1 and place unintended instruction pairs in make JIT code an unattractive reuse target in general by
theNOPsled36bytes(9ARMinstructions)apart.Thesuccess reducingthesetofcapabilitiesthatJITcodecanpossess.More
rate of correctly landing in such a NOP sled is therefore 1/9. sophisticated capability confinement defenses also prevent JIT
code from corrupting itself. The least sophisticated capability
3)Executing the payload: Static code for the ARM archi-
confinement defenses employ simple heuristics to detect sys-
tectureiscompiledwiththeexpectationthatcalleesandcallers
temcallsfromJITcode[11]ortheemissionoflongsequences
might need to be executed in a different instruction set mode;
of consecutive instructions taking 32-bit immediate operands,
therefore,interworkingbranchesabound.Anattackerwillmost
where those sequences begin with mov reg, imm32 [5],
likely only need to ensure that the control flow vulnerability
which was the hallmark of Blazakis’ original attack. Though
sheexploitstargetsanaddresswhoseleastsignificantbitisset,
the performance overhead of [11] is not prohibitive at 1.84%
which will cause her payload to be executed in Thumb mode.
ontheSPECCPU2000Integerbenchmark([5]doesnotreport
4)Limitations: Amajorlimitationofthepayloadencoding on its performance overhead), the two heuristic defenses can
methoddescribedinthissectionisthatweareunabletoencode be easily circumvented by reusing statically-compiled system
an unintended system call instruction. In order to do so, we calls and avoiding the creation of the initial mov instruction,4
wouldneedtobeabletocontrolanintendedinstructionwhose respectively. The next two capability confinement defenses
destination register (or source register in the case of a store offer much stronger security benefits through sandboxing.
instruction) is the stack pointer; we are not aware of such a
1)NaCl-JIT: NaCl-JIT [3] is a system that extends the
capability against IonMonkey. However, the Turing-complete
Native Client (NaCl) sandbox [34] so that a language run-
computation that this type of payload is able to construct can
time running in the sandbox can dynamically install, invoke,
be used to orchestrate a code reuse attack against static code
modify, and delete code within the sandbox on the fly. The
which contains system call instructions.
sandbox provides the following three high level guarantees
OurproofofconceptSBNZOISCimplementationrequires about sandboxed code execution: (1) it cannot read or write
the operands to the sbnz instruction to contain absolute outside of a contiguous region of data memory; (2) it contains
addresses. This requires the attacker either to learn where her only instructions drawn from a whitelist, and they reside in
SBNZ instructions will reside via an information leak or to a contiguous region of sandboxed code memory; and (3)
heap spray them. Unfortunately, heap spraying SNBZ instruc- aside from API calls into the NaCl runtime, its control flow
tions competes with JIT spraying. A more practical SBNZ only executes instructions decoded at intended instruction
OISC implementation might use stack pointer offsets rather boundaries within the aforementioned code memory region.
thanabsoluteaddressesforsbnzoperands.Theattackercould Thus, even a malicious JIT-compiled program that is able to
even devise an SBNZ NOP sled to place on the stack before completely commandeer the sandboxed language runtime and
her SBNZ shellcode to mitigate an unpredictable stack layout.
4Rather than writing high-level code of the form var x =
As we mentioned above, the set of unintended Thumb-2
(imm32ˆ...ˆimm32);, one can write var x = (yˆ...ˆimm32);
instructionsthatwewereabletoencodewasconstrainedbythe
where y is not defined as a constant, which will not require moving a
set of registers that could be chosen as the destination register constantintoaregister.
7issue arbitrary NaCl-JIT API calls still cannot access memory codewiththeaimofpreventingcorruptionofJITcode.When
outside of the sandbox or directly execute non-whitelisted the defense is enabled, JIT code is RX by default, and when
instructions such as system calls or cache flushes. While the runtime needs to modify a unit of code compilation, that
this may allow a malicious JIT-compiled program to access unitistemporarilyreprotectedRW.Theperformanceoverhead
sandboxmemoryinwaysthatthesandboxedlanguageruntime of this change is less than 1% on the Kraken and Octane
did not intend for it to access, the underlying system outside JavaScript benchmark suites and no more than 4% overhead
the sandbox remains safe. on the SunSpider benchmark suite. SpiderMonkey’s imple-
mentation of inline caches inherently favors low-overhead
The NaCl sandbox is implemented via code verification,
W ⊕ X protection, as it requires far less-frequent patching
instruction bundling, and (for most architectures) software
(and therefore fewer memory reprotection system calls) and
guards, which incur a high overhead. The runtime overhead
stub compilation than other compilers such as V8. Reducing
of the NaCl-JIT port of the V8 JavaScript engine on the V8
the need for patching in V8 is a non-trivial matter. In fact, the
JavaScript benchmark suite ranges from 28%-60% on x86-32
V8teamhasexplainedtousthatalthoughtheyareundergoing
and x86-64. While NaCl-JIT’s security properties are indeed
efforts to eliminate patching for some types of ICs, others are
alluring, performance regressions on this order are unlikely to
still considered too performance-sensitive. Unfortunately, this
be considered acceptable for a mainstream JavaScript engine
means that transient W ⊕ X protection will likely remain too
actively engaged in the benchmark wars.
expensive for V8.
2)RockJIT: RockJIT [23] offers a platform similar to
JITScope [35] is a proposed defense that provides
NaCl-JIT with considerable performance improvements due
normally-RX protection similar to SpiderMonkey’s W ⊕ X
to more efficient JIT code validation and a more efficient
defense, but it reprotects memory more frequently and there-
mechanism for protecting control flow (fine-grained control
fore incurs a higher overhead (1.6%-6.0%). Although these
flow integrity (CFI) [2] (without a shadow stack) in the lan-
defenses offer protection against code corruption in single-
guageruntimeandcoarse-grainedCFIonJITcode).RockJIT’s
threadedenvironments,Songetal.[28]demonstratedthatWeb
authors ported the V8 JavaScript engine to use RockJIT; and
Workers [31]—which enable JavaScript programs to spawn
on the same set of benchmarks over which NaCl-JIT showed
multiple threads that can communicate with one another—
a 51% overhead, RockJIT had just 9.0% overhead. Over the
couldbeusedtocircumventsuchtransientmemoryprotections
entire Octane 2 JavaScript benchmark suite, RockJIT incurred
by creating a race condition. While one thread coerces the
a 14.6% average overhead.
language runtime into making a particular memory region
However, these performance gains come with security
writable (e.g., by triggering an inline cache patch), another
risks. Notably, RockJIT allows the (untrusted) language run-
thread exploits a vulnerability that corrupts the writable JIT
time to directly make system calls (excluding memory repro-
code memory. This attack does, however, require that the
tection),andittruststhelanguageruntimetoannounceindirect
attackerbeabletopredicttheaddressoftheJITcodememory
branch targets within JIT code so that RockJIT can update the
thatwillbemadewritablebytheformerthread,whichisanas-
CFI policy. A control flow bending [8] attack would enable
sumptionthatdoesnotgohandinhandwithasprayingattack.
an attacker to abuse the lack of a shadow stack and issue any
JITDefender[9]andJITSafe[10]takeadifferentapproach
system call present in the language runtime.
and seek to prevent malicious code reuse; they allow JIT code
B. Memory protection to be writable at all times and enable executability only when
the language runtime enters it. JITSafe and JITDefender incur
A vulnerability commonly introduced by JavaScript JIT
<1% overhead, but they do not protect against JIT spraying
compilers is permanent RWX permissions on JIT code pages,
when the control flow vulnerability is triggered by JavaScript.
evenonsystemsthatenforceW ⊕ Xonnormalcodeanddata
For example, each JIT sprayed function containing the JIT
pages.Thispracticeisdoneinthenameofperformance;inline
spraying payload could call another instance of the function
caching (IC) [12]—a performance optimization popular [30],
in order to make all copies simultaneously executable; the
[20], [1] among JavaScript implementations—often requires
last callee in the chain would then trigger the control flow
the frequent compilation of short code stubs during JIT code
vulnerability.
execution as well as the patching of calls to those stubs into
existing code. Leaving JIT code pages RWX at all times
2)Dualmapping: Aswesawin§IV-B1,varyingJITcode’s
eliminates memory reprotection system calls during inline
writability and executability over time can be vulnerable to
cacheinstallationandmaintenanceaswellasthosethatwould
raceconditionattacks.Furthermore,togglingbetweenRWand
be necessary during the compilation of normal program code.
RX protections is not even possible on all systems. SELinux
RWX memory poses a significant threat to JIT security. prohibits processes from adding executability to memory if it
Lianetal.’sattackagainsttheJavaScriptCoreJITonARM[17] has ever been writable in the past [13] in order to thwart code
as well as the new attack we introduced in § III-B rely injectionattacksthatattempttograntexecutabilitytoshellcode
on always-RWX JIT code pages in order to perform self- injected into a data buffer.
modification of JIT code. Memory protection defenses seek to
A proposed alternative to transient memory protection is
rid JIT code of its always-RWX memory protection status by
creating separate virtual memory mappings with immutable
adapting W ⊕ X to dynamically-generated code. Two popular
RW and RX protection status for physical JIT code pages.
approaches to memory protection for JIT code are transient
These mappings are either contained within a single process
protection and dual mapping.
or split between two processes. The SpiderMonkey team
1)Transient protection: A recent addition to the Spider- experimentedwithasingle-processdualmappingscheme[22]
Monkey JavaScript engine [21] is W ⊕ X protection for JIT and found that it incurred about a 1% slowdown, but it
8was not deployed to production because an information leak instruction, but neither of the new immediate operands are
vulnerability could reveal the locations of both mappings and predictable. The overhead of constant blinding comes in the
eliminate the defense’s effectiveness. Other research efforts form of both increased code footprint and increased execution
address the shortcomings of single-process dual mapping by time.Athanasakisetal.[4]estimatethatconstantblindingcan
separating the RW and RX mappings of JIT code across result in up to 80% additional instructions.
process boundaries. A trusted process holds either the RW
Lian et al. [17, §VI.A] found that JavaScriptCore employs
or RX mapping, and an untrusted process holds the comple-
a very weak form of constant blinding; it only blinds a subset
mentary mapping. However, introducing this separation into
of constants and each with only 1/64 probability, which was
an existing language runtime requires invasive process re-
insufficient to prevent a JIT spraying attack on ARM. In our
architecting as well as runtime overhead in the form of inter-
study of V8, we found that it only blinds constants >0x1ffff
process communication. Lobotomy [16] and SDCG [28] take
that are being moved into a register or pushed onto the stack.
oppositeapproachesandallowtheuntrustedprocesstohandle
This implementation fails to protect against even Blazakis’
the RW and RX mappings, respectively. Overhead for these
originally-publicized JIT spraying attack and only applies to
dual mapping defenses is high. Lobotomy suffers a mean
x86-32 and x86-64. Athanasakis et al.’s [4] investigation into
overheadof 387%,andSDCG takesa16.6% performancehit.
Internet Explorer’s Chakra JITuncovered that it always blinds
constants >0xffff, but this was not enough to prevent them
C. Diversification from using untrusted constants to encode ROP gadgets.
The cornerstone of all attacks that reuse JIT-emitted code c) Call frame randomization: Call frame randomiza-
for malicious purposes [7], [26], [27], [25], [17], [4] is the tion [32] scrambles the instructions that are used to access
assumption that, for a given input program, a particular JIT values such as arguments, local variables, spilled temporary
compiler will always emit the same sequence of machine in- values, etc. in a function’s call frame. These instructions usu-
structions (modulo memory addresses embedded in the code). allyaccessmemoryatpredictableimmediateoffsetsrelativeto
Diversification defenses seek to invalidate this assumption, the stack pointer or a call frame register, which as we show in
thereby undermining the utility of JIT-emitted code for ma- §III-B, can provide an attacker with a convenient predictable
licious reuse. Diversification defenses can be organized into memory access instruction for reuse.
the following two categories: intra-instruction randomization
2)Codelayoutrandomization: Predictablearenotonlythe
and code layout randomization. Because most diversification
contents of JIT code, but also the layout of its instructions
defense proposals in the literature combine various flavors of
relative to one another and the boundaries of coarser-grained
diversification defenses and evaluate them on varying plat-
memory allocation units. Nearly all JIT spraying attacks we
forms and benchmarks, rather than report the overheads found
have seen so far rely on predictable code layout either to
intheliterature,wereferthereaderto§V-Fwhereinwereport
preventanunintendedinstructionstreamfromresynchronizing
the overheads of our own implementations of diversification
to the intended stream or to predict the relative or absolute
defenses, evaluated under a unified testing framework.
locations of instructions. Two strategies have been proposed
1)Intra-instruction randomization: Intra-instruction ran- to diversify JIT code layout at both fine and coarse granu-
domization defenses invalidate an attacker’s assumption that larity: random NOP insertion and base offset randomization,
particular instruction encodings will appear in JIT code mem- respectively.
ory. The three types of intra-instruction randomization that
a)Random NOP insertion: Random NOP inser-
appear in the literature are register randomization, constant
tion [14], [15], [32], [25], [33] involves injecting semantic
blinding, and call frame randomization.
NOP instructions at random in JIT code. Its effect is both
a)Registerrandomization: Registerrandomizationper- to randomize the offset of any given instruction from the
mutes register assignment during compilation, resulting in beginning of the unit of code compilation and, more gen-
instructions whose register operands are unpredictable [32], erally, to randomize the relative offset between any given
[33] and can often be performed with nominal overhead at pair of instructions. Like constant blinding, the overhead of
compile time, though some runtime overhead may be added random NOP insertion comes from increased code footprint
due to instructions that require longer encodings for certain (leading to increased i-cache pressure) and wasted cycles at
register operand values. runtime; however the overhead for random NOP insertion
scales with code size rather than the number of untrusted
b)Constant blinding: Immediate operands can con-
constants compiled. Lian et al.’s [17] study of JavaScriptCore
sume a large percentage of an instruction’s encoding and are
revealed that JSC’s non-optimizing JIT avoids the scaling
oftenderivedfromuntrustedvaluesprovidedinthecodebeing
overhead problem by only randomly inserting a single NOP
compiled. This grants attackers a large amount of control over
instruction at a fixed location at the beginning of certain units
thecodeproducedbytheJITcompiler,enhancingitsutilityfor
ofcodecompilation,whichprovidesverylittlesecuritybenefit.
malicious code reuse. Indeed, predictable immediate operands
Athanasakis et al. [4] report that Internet Explorer’s Chakra
have been a cornerstone of many JIT spraying attacks. Con-
JIT employs random NOP insertion, but they omit details of
stantblinding[32],[25],[33],[10],[14]seekstoeliminatethis
its implementation.
predictability. A typical implementation of constant blinding
splits each instruction that contains an untrusted immediate b)Base offset randomization: Base offset
operand into two instructions whose respective immediate randomization [25] places a random amount of “dead”
operands are functions of the untrusted immediate and a space before the beginning of each unit of code compilation,
random secret value. The side effect of the composition of either in the form of NOP instructions or free space. This
the two new instructions is the same as that of the original perturbs both the offset of the first unit of code compilation
9when the JIT compiler maps a fresh region of executable A. Register randomization
memory and the relative offsets between consecutively-
Implementing register randomization for IonMonkey is
compiled units of code compilation. The absence of base
extraordinarily non-invasive. IonMonkey compiles scripts to
offsetrandomizationiscriticaltotheheapfengshui[29]used
anintermediaterepresentation(IR)andperformsanalysesover
to pinpoint gadget addresses in gadget chaining attacks such
the IR in order to run a register allocator. We simply permute
as [17] and our V8 attack (§ III-B). Base offset randomization
the order in which the allocator considers physical registers to
would have drastically reduced the reliability of these attacks
satisfyallocationrequirements.Thechangesforourimplemen-
with less overhead than random NOP insertion.
tation span 6 lines of code and randomize both floating point
and general purpose register allocations. Some IR instructions
areassignedfixedsourceordestinationregisterswhichcannot
V. EVALUATIONOFDIVERSIFICATIONMITIGATIONS
be randomized at the level of the register allocator; however,
As we saw in § IV, very few JIT spraying mitigations thesefixedassignmentsdonotbindtoactualphysicalregisters,
that have been proposed have been deployed in production but rather “abstract registers” which are mapped to physical
browser releases, and those like constant blinding and random registers. Fortunately, randomizing registers for the Baseline
NOP insertion that are deployed have been severely limited JIT involves randomizing the mappings from these same
to the point that they have lost their effectiveness. We argue abstract registers to physical registers.
that JIT code reuse can be effectively mitigated via fully-
SpiderMonkey’s Baseline JIT does not use a register allo-
functional diversification defenses with only modest, but ul-
cator; instead it emits statically-defined instruction sequences
timately worthwhile, overhead. However, the answers to the
for bytecode instructions for a stack-based virtual machine.
questions of how much performance overhead diversification
The instruction sequences implementing bytecodes are de-
defenses incur and to what extent they improve security are
fined by C++ code that allocates abstract registers as source,
muddled. Various incarnations of the diversification mitiga-
destination, and temporary registers used by each bytecode’s
tions described in § IV-C are mixed and matched to compose
implementation. To the C++ programmer, using an abstract
manydifferentdefensesystemsmentionedintheliterature[3],
register “feels” like using a physical register, but they are
[4],[10],[14],[15],[32],[33].Manyoftheseimplementations
simply variables named after the physical registers that hold
are not fully specified, and what descriptions exist often vary
an integer value identifying an actual physical register.
considerably. Moreover, performance evaluations of diversi-
fication mechanisms are often reported as aggregates with Randomizing registers for the Baseline JIT (and indirectly,
each other and other unrelated mitigations; and the hardware IonMonkey) involves permuting the underlying values that
and benchmarking suites on which the implementations are are assigned to the abstract register variables named after
evaluated vary by author. physical registers. Any uses of these variables will propagate
therandomizedphysicalregistermapping.However,additional
Thus, there has been no clear source in the literature pro-
complexity must be introduced at the call and return control
vidingdetailedimplementationdescriptionsandmeasurements
flow edges between statically-compiled native code and JIT
of their associated runtime overheads on consistent hardware
code since certain values are expected to be passed between
andbenchmarks.Thepurposeofthissectionistoprovidethat
nativeandJITcodeinspecificphysicalregistersinaccordance
information so that JIT compiler authors considering adopting
with the architecture’s ABI. To ensure that JIT code—which
these defenses can more comfortably weigh the costs and
is defined in C++ under the assumption that abstract registers
benefits of diversification defenses. To better understand the
named after physical registers actually refer to those physical
benefits of each defense, we also analyze each defense with
registers—is able to conform to the architecture ABI, we
respect to concrete JIT spraying attacks to quantify the factor
introduce a sequence of pushes and pops into the trampolines
by which the probability of a successful attack is reduced.
that execute at the boundaries between native and JIT code;
To this end, we implemented all five diversification de- the pushes and pops have the effect of permuting registers or
fense techniques described in § IV-C on the SpiderMonkey inverting the permutation as needed.
JavaScript engine for both its non-optimizing (Baseline) and
In addition to the interoperability issues with native code,
optimizing (IonMonkey) JIT compilers on the ARM32 and
there were other cases where assumptions regarding the bind-
x86-64 architectures.5 Our implementations are by no means
ings between abstract registers and specific physical registers
highly optimized; instead, our priority is to avoid creating
caused no small number of headaches. In these corner cases,
cornercasesthatcanbeexploitedbyawilyattackertoimprove
violating these assumptions via randomization leads to incor-
her chances of defeating the mitigation. During development,
rectbehavioranddatacorruptionthateventuallycausesahard-
we found that random design decisions in the JIT backend
to-debug crash much later than the misbehavior itself. These
greatly impacted the difficulty of integrating defenses into
corner cases were very difficult to track down because the
the existing system. That is not to say that these decisions
assumptions relied on very low level details that were not
were made carelessly, but rather that they were perhaps not
documentedinanycentrallocation.Forexample,ARMisable
madewiththoughttowardsthegeneralitynecessarytosupport
toloadtwo32-bitvaluesfrommemoryintotwoconsecutively-
mitigations. The source code for our mitigations is available
numbered general purpose registers as long as the lower-
as a public fork of Mozilla’s GitHub repository; our work is
numbered register is even. If C++ code used abstract registers
based on top of commit ce31ad5.6
namedafterqualifyingregistersforsuchaload,randomization
can easily invalidate the consecutivity, parity, and ordering
5Wedidnotimplementregisterrandomizationforx86-64’snon-optimizing assumptions.
compilerforreasonsdescribedlater.
6Theforkcanbefoundathttps://github.com/wwlian/gecko-dev.
10Floatingpointregisterrandomizationisunnecessaryforthe
Baseline JIT because it does not generate code that operates
on floating point registers (with the exception of IC stubs,
which are shared and cannot be sprayed). Instead, floating
Previous Frame
pointvaluesinBaselineJITcodearestoredingeneralpurpose Info
registers and passed to IC stubs or host functions which
Saved FP
perform the desired floating point operations. Frame
Pointer Bookkeeping
Special care must also be taken to maintain abstract reg- data
isters’ volatility; in other words, we only permute volatile
Local Vars
(a.k.a. caller-saved) registers with other volatile registers and
Body-level likewisefornon-volatile(callee-saved)registers.Thisisneces-
Lexical-scoped
sary because there are instances where code using an abstract Block-level
registerassumesthatitmapstoanon-volatileregisteranddoes Lexical-scoped
notsavethatregister’svaluepriortocallingasubroutine.This
limitation only applies to the abstract-to-physical remapping;
inIonMonkey,valuesthatarenotboundtoanabstractregister
are free to be allocated to any register.
Because of the many intricacies of permuting the mapping
from abstract registers to physical registers, we limited our
remapping implementation to the ARM architecture. We also
limit randomization to registers that SpiderMonkey consid-
ers “allocatable,” which excludes the program counter, stack
pointer,linkregister,andaregisterusedinternallybythecom-
piler for very short-lived scratch values. Although it presents
a significant weakness to our implementation, we do not
randomizetheabstractregistermappingthatreferstothearchi-
tecture ABI’s integer return register, as a considerable amount
ofcodeassumesthatitisnotrandomized.Itshouldabsolutely
be randomized, but this is presently left for future work.
The probability that an attacker’s payload will be emitted
as expected if it requires k out of n randomized registers to
be correctly mapped is (n−k)!/n!.
B. Constant blinding
Most constant blinding implementations observed in real-
world code only blind a limited subset of instructions or
untrusted constants, presumably under the rationale that some
instructions and constants are harmless and therefore rep-
resent unnecessary overhead if blinded. Our implementa-
tion blinds every untrusted (meaning that it appears in the
JavaScript code) integer and floating point constant. Un-
trusted constants only appear in Baseline JIT code as val-
ues that are loaded into registers; we protect Baseline JIT
code by blinding those load instructions using the canoni-
cal mov reg, blinded_val; xor reg, secret in-
struction sequence, where secret is an immediate with a
unique7 32-bitrandomvalue,andblinded_valisanimme-
diate whose value is secret ⊕ untrusted_constant.
We implement constant blinding for IonMonkey by in-
jecting blinding instructions into the architecture-independent
intermediate representation (IR) called MIR. MIR is compiled
fromSpiderMonkey’sinterpreterbytecode,optimized,lowered
toanarchitecture-dependentIR,thenfinallycompiledtonative
code. During construction of the MIR code, we tag constants
found in the bytecode as untrusted so that we avoid blinding
constants generated by the compiler that were not present
in the JavaScript. After the MIR has been optimized, we
7Unlikesomeconstantblindingimplementations(e.g.,V8)whichsharethe
same secret value among constants within the same compilation unit, ours
generatesafreshsecretforeachconstant.
gnimocnI sgrA }
Previous Frame
Info
Saved FP
Random
Padding
Bookkeeping
data
Local Vars
Stack
Pointer
(a)Unrandomized
gnimocnI sgrA Offsets
blinded
}
Offsets
blinded
Frame
Pointer
Permute
Body-level Permute Lexical-scoped
Block-level Permute
Lexical-scoped
Stack
Pointer
(b)Randomized
Fig. 6: Baseline JIT call stacks with and without call frame
randomization. Stacks grow downward.
replace untrusted constants that remain with a sequence of
MIRinstructionsthatimplementconstantblindinginthesame
XOR-based manner as the Baseline JIT’s constant blinding. It
isimportanttoapplyconstantblindingonlyafteroptimizations
have completed to avoid potential constant folding optimiza-
tions, which would undo the blinding.
Inordertopredictthecodesequencesthatwillbegenerated
for any given untrusted k-bit constant, the attacker must guess
each corresponding secret bit, for which she has a success
probabilityof2−k.Sinceallconstantsareblindedwithunique
secrets,theattacker’sprobabilityofpredictingthecodeforthe
n untrusted constants, each k bits long, needed for her JIT
spraying payload is 2−kn.
C. Call frame randomization
SpiderMonkey’sBaselineJITandIonMonkeyJITusevery
different call frame conventions requiring different treatment
to randomize. The Baseline JIT uses a frame pointer relative
to which all call frame elements are accessed and pushes
outgoing function arguments onto the stack as part of its
implementation of a stack-based virtual machine. IonMonkey,
on the other hand, performs frame pointer omission (i.e., call
frame elements are accessed relative to the stack pointer)
and pre-allocates enough stack space during each function
prologue to fit the maximum number of outgoing function
call arguments across all calls within that function. For both
Baseline and IonMonkey call frames, we randomly shift the
frame pointer and stack pointer, respectively, relative to the
call frame elements. Whenever possible, we also permuted
call frame elements of the same type, and when neither of the
abovewaspossible,weperformedaprocesssimilartoconstant
blindingtotheload/storeinstructionsaccessingthecallframe.
1)Baseline JIT: Figure 6a illustrates the layout of an
unrandomizedBaselineJITcallframe.Allelementsshownare
accessed at statically-computed frame pointer-relative offsets.
Baseline JIT code stores three types of local variables on the
stack above the frame pointer, and we randomize their offsets
by permuting their orders within each type and randomly
increasing the size of the bookkeeping data structure pushed
onto the stack before them, shown as the dotted box in
11Figure6blabeled“RandomPadding.”Thesizeofthispadding
is determined for each function at JIT compile time and is
between 0 and 15, inclusive, units of stack alignment (the
size of which is 8 bytes for ARM32 and MIPS32 and 16
Previous Frame
bytes otherwise). Because that does not change the frame Info
pointer’s relative offset to the incoming function arguments
and“PreviousFrameInfo,”wemodifyinstructionsthataccess Spilled values
them in a manner similar to constant blinding. Rather than
accessing those elements at fixed offsets relative to the frame
pointer, each access site populates a scratch register with the
value of the frame pointer minus a unique random multiple of
4 in the range [0,64)8 and performs the access using a new
offset that corrects for the shifted base register value.
We do not shift the incoming arguments by injecting stack
padding between them and the frame pointer location because
thegreatcomplexityofthecodethattraversesandunwindsthe
call stack makes doing so very difficult. Similarly, we do not
permuteincomingargumentsonthestackbecauseofthecom-
plexinteractionsbetweentheirstackpositionsandSpiderMon-
key’s implementaion of JavaScript features like rest parame-
ters,defaultparameters,andtheargumentsobject.However,
permuting call frame elements is secondary to shifting their
offsets since permutation without shifting is vulnerable to the
corner case where there is only one element to permute.
Anattackerisonlyabletopredicttheblindingoffsetofan
incoming argument access site with probabiity 1 . Therefore,
16
ifanattackreliesonreusingnincomingargumentaccesssites,
there is only a 1 chance that she will be able to predict all
16n
necessaryaccesssiteoffsets.Thedeviationoftheframepointer
offset of a local variable or body/block-level lexically-scoped
variablefromitsunrandomizedvaluecanbeinterpretedasthe
linear combination of independent discrete uniform random
variables. In particular, if there are n variables of a certain
type(local,body-levellexical,orblock-levellexical),theoffset
shift of the ith (0 ≤ i < n) variable of that type, is given by
Z = −(X +Y), where X is the shift due to permutation i i i
and is distributed as X ∼ 8 · (U{0,n−1}−i); and Y is i
the shift due to padding the bookkeeping data structure and is
distributed as Y ∼ a·U{0,m−1}, where a is the size of a
unitofstackalignmentinbytes(whichvariesbyarchitecture),
and m is the number of possible padding amounts (m = 16
for our implementation).
2)IonMonkey JIT: Figure 7a shows the IonMonkey call
frame layout. Since IonMonkey performs frame pointer omis-
sion, and all call frame elements are below the stack pointer,
we can shift all call frame accesses by pushing a random
amount of padding—whose size is determined once for each
compilationunitatJITcompiletime—ontopofthecallframe.
The size of the padding is between 0 and 15, inclusive, units
of stack alignment (the size of which is 8 bytes for ARM32
and MIPS32 and 16 bytes otherwise). IonMonkey does not
store local values on the stack unless they must be spilled due
to register contention; we permute the order that these spilled
values are allocated to stack slots. Figure 7b illustrates the ap-
plicationoftheserandomizationstoanIonMonkeycallframe.
Sincethestackpointer-relativeoffsetofallnon-spillvalues
is shifted by a common value, an attacker’s probability of
8We use a multiple of 4 because the ARM code generation backend can
compileanoptimizedinstructionsequenceforcertaincaseswheretheoffset
isamultipleof4.
gnimocnI
gniogtuO
sgrA
sgrA
Previous Frame
Info
Stack
Pointer Random
Padding
(a)Unrandomized
gnimocnI
gniogtuO
sgrA
sgrA
Spilled values Permute
Stack
Pointer
(b)Randomized
Fig. 7: IonMonkey call stacks with and without call frame
randomization. Stacks grow downward.
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0. 10 00 101 102 103
Number of instructions (log)
ytilibaborP
Fig. 8: Probability that attacker’s best guess correctly predicts
the number of random NOPs inserted in n instructions.
guessinganynumberofnon-spillvalueoffsetsisreducedbya
factorof16.Spilledvalueshavetheirvaluesshiftedaccording
toadistributionsimilartotheonedescribedaboveforBaseline
JITlocalsandlexically-scopedvariables.Onedifferenceisthat
spilled values may have varying sizes that are a multiple of 4
bytes, so the permutation distribution is not uniform.
D. Random NOP insertion
Our implementation of random NOP insertion places a
single NOP instruction before each intended instruction with
probability p = 1. There is a small handful of exceptions
8
whererandomNOPinsertionmustbedisabledduetoassump-
tions in the JIT’s implementation regarding the precise layout
of a section of emitted code.
Random NOP insertion’s security benefit depends on the
attacker’s needs. If the attacker needs to predict the offset
of the nth instruction from the beginning of its unit of code
compilation,shemustpredictthenumberofNOPsthatwillbe
insertedbeforeit,givenbytherandomvariableX ∼B(n,1).
8
The attacker’s best guess is the mode of X; the probability
that this best guess will be correct as a function of n is shown
in Figure 8.
Alternately, an attacker might require n consecutive in-
structions with no random NOPs inserted between them (e.g.,
when the payload uses instructions decoded at unintended
instructionboundariesasin[7]),whichoccurswithprobability
(1−p)n−1 =(cid:0)7(cid:1)n−1 .
8
12G. Code size increase
TABLE III: Geometric mean of code size increases incurred
by diversification defenses when executing benchmark suites To measure the impact of our mitigation implementations
on the memory demands of the JIT, we instrumented Spi-
x86-64 32-bitARM derMonkey to emit the file name, line number, and number
of JIT code bytes used each time unit of code compilation
Registerrandomization -0.008% 1.01%
is compiled and executed the three benchmark suites once
Constantblinding 0.433% 1.56%
on each binary variant. Let v¯ be the average code size of
i
Callframerandomization 2.79% 1.31%
the ith file name-line number pair, as emitted by a binary
RandomNOPinsertion 2.67% 12.58% variant implementing a one or more diversification defenses;
Baseoffsetrandomization 2.39% 2.52% let u¯ represent the average code size for the ith file name-
i
All 8.57% 18.15% line number pair, as emitted by an unmodified SpiderMonkey
binary. We compute the increased memory usage for each
E. Base offset randomization variant as (cid:112) n (cid:81)n (v¯/u¯)−1. Table III shows the code size
i=1 i i
WheneverSpiderMonkeyneedstofindspacetoplaceaunit increases for each mitigation, broken down by architecture.
of code compilation, it rounds up the size of the JIT code to
an architecture-specific alignment granularity G and searches H. Concrete security analysis
memory pools of allocated code memory for free space to
Inordertogiveconcretenesstothesecuritybenefitsoffered
accomodate the rounded size. We randomize the base offsets
by our diversification defense implementations, we report on
of each unit of code compilation by randomly increasing the
our analysis of the estimated relative success probability of
size of its allocation request by rG where r ∈{0,1,2,...,15}
four concrete JIT spraying attacks when launched against
and shifting the code rG bytes further into the allocation. The
individual diversification mitigations. The results are shown
attacker’s probability of guessing the base offset shifts for n
consecutive units of code compilation is (cid:0) 1 (cid:1)n . in Table IV. Remember that since some defenses may interact
16 with one another, these relative probabilities may not neces-
sarily be combined by multiplication.
Our estimates are conservative; in order to make the
relative probabilities concrete, we have made assumptions in
F. Benchmark results
theattacker’sfavorwhennecessary.Forexample,randomNOP
Weevaluatedtheperformanceoverheadsofourimplemen- insertion can disrupt Blazakis’ JIT spray by causing its NOP
tations on x86-64 and 32-bit ARM using the SunSpider 1.0.1, sledtoresynchronizetotheintendedinstructionstream,butthe
Kraken1.1,andOctanev.2benchmarkssuites.Resultsforx86- probabilityofatleastoneNOPinterruptingexecutiondepends
64 were gathered on a quad-core Intel Core i7-870 2.93GHz on how many uninterrupted instructions the attacker requires,
processor with 16GB RAM running Ubuntu 14.04.2 LTS including the NOP sled. This in turn depends on where in the
withkernelversion3.13.0-49-generic.Resultsfor32-bitARM NOP sled the attacker’s control flow vulnerability happens to
were gathered on an octa-core AppliedMicro APM883208-X1 divert control. Therefore, we conservatively assume that the
ARMv8 2.4GHz processor with 16GB RAM running 32-bit attacker’s control flow vulnerability directs execution to the
Debian 8.0 in a chroot jail on APM Linux with kernel version head of the shellcode and only compute the probability that
3.12.0-mustang sw 1.12.09-beta. a NOP will not be inserted into the sequence of instructions
needed to encode a very short 10-instruction shellcode. We
To evaluate our implementations, we built an unmodified
consider minor adaptations to the existing attacks that allow
version of SpiderMonkey and a separate binary for each
them to use the most likely diversification outcome when
diversification mechanism. We also built a binary that de-
possible, but we do not claim to have considered the most
ploys all implemented defenses. We executed each benchmark
optimized versions of each attack. Lastly, the values shown in
suite 100 times for each binary and computed the arithmetic
Table IV only reflect the relative success of a single instance
meansforeachgroupof100benchmarkscores.Wecomputed
of the sprayed function.
the overhead imposed on the results of “smaller-is-better”
benchmarks (SunSpider and Kraken) as v¯/u¯ − 1, where v¯ Constant blinding, which incurs the greatest runtime over-
is the arithmetic mean of the 100 benchmark scores for a head among the surveyed diversification defenses, performs
particularmodifiedbinary,andu¯ isthearithmeticmeanofthe tremendouslywelltomitigate[7],[17],andtheself-sustaining
100 benchmark scores for the unmodified binary. Octane is a ARM payload (§III-C), which rely on attacker-chosen con-
“bigger-is-better” benchmark whose scores are derived from a stants appearing in JIT code. We also observe that register
“smaller-is-better” measurement by dividing a constant value randomization andcall frame randomizationcomplement con-
bythemeasurement,sowecomputetheoverheadonitsresults stantblindingbydiversifyingcompiler-chosenoperands,relied
as u¯/v¯−1. upon heavily by our V8 attack.
Themeasuredoverheadsofourimplementationsareshown We were surprised to find that register randomization
in Table II. We used Welch’s unequal variances t-test to test provided little defense against [7]. Blazakis’ attack is able to
the mean benchmark score from each variant’s 100 execution fare well against register randomization because the attacker’s
sample against the mean benchmark score from the unmodi- payloadisanunintendedinstructionstream(cf.§II)thatskips
fied binary’s 100 execution sample and indicate statistically- over intended instruction opcodes (the XOR opcode, in the
significant (p <0.05) changes to the mean by printing the cor- case of Blazakis’ attack) as long as the number of bytes to
responding overhead with boldface type. Note that overheads be skipped is correctly predicted. The x86 XOR instruction’s
are not independent and cannot necessarily be added. opcode is either 1 byte long when XORing against %eax or
13TABLEII:Diversificationperformanceoverheads.Boldtypefaceinnon-geometricmeancolumnsdenotesstatistically-significant
impact on the mean benchmark score of each 100-execution sample (Welch’s unequal variances t-test, p <0.05); and negative
overheadsindicateimprovedperformance.*Registerrandomizationoverheadforx86-64onlyincludesIonMonkeyrandomization.
x86-64 32-bitARM
SunSpider Kraken Octane G.Mean SunSpider Kraken Octane G.Mean
Registerrandomization* -1.94% -0.829% -0.404% -1.06% 1.62% 0.456% 0.265% 0.777%
Constantblinding -1.36% 2.65% 2.93% 1.39% 1.62% 6.02% 4.39% 3.99%
Callframefrandomization -1.68% -0.199% 0.324% -0.523% 0.138% -2.26% -1.05% -1.06%
RandomNOPinsertion -0.762% 2.12% 1.44% 0.922% 1.67% 1.76% 1.35% 1.59%
Baseoffsetrandomization -2.38% -0.207% -0.846% -1.15% 0.498% 0.302% 0.223% 0.341%
All 1.71% 5.70% 6.33% 4.56% 4.44% 5.48% 4.71% 4.88%
TABLE IV: Estimated relative success probabilities for concrete attacks against single diversification defenses. Lower values
indicate better mitigation.
Register Constant Callframe RandomNOP Baseoffset
randomization blinding randomization insertion randomization
Blazakis2010[7](x86-32) 92.9% 6.84×10−47% 100% 30.1% 100%
Lianetal.2015[17](ARM) 1.79% 1.53×10−3% 100% 3.74% 0.391%
ARMV8gadgetchaining(§III-B) 0.909% 100% 6.25% 3.70% 0.229%
SpiderMonkeyself-sustainingARMpayload(§III-C) 2.51×10−5% 4.15×10−461% 100% 7.95×10−21% 100%
2 bytes long when XORing against any other register. The insertion,itsconstantblindingimplementation,whichdoesnot
attacker can therefore assume with highest probability that the blind constants ≤0xffff, can still be bypassed to create ROP
XOR opcode will be 2 bytes long and adjust her payload to payloads[4].Itisapparenttotheseauthorsthatcraftyattackers
skip over a 2-byte intended instruction opcode. canandwilldiscoverandexploitanycornerscutintheimple-
mentations of JIT spraying defenses. For this reason, we urge
RandomNOPinsertionprovidesgoodprotectionacrossthe
JIT developers to consider deploying defenses at full strength,
board by both disrupting the unintended instruction streams
even at the expense of non-trivial performance overhead.
usedbyBlazakis’attackandtheself-sustainingARMpayload
aswellasdiversifyingthelocationofusefulcodegadgetsused By reducing the predictability of instruction operands and
by [17] and our new V8 attack. Base offset randomization, on code layout, JIT code reuse can be mitigated. Rather than
the other hand, only defends against the latter pair of attacks. selecting a subset of the diversification defenses evaluated in
Base offset randomization offers better defense than NOP §V,werecommendall5bedeployedsimultaneouslyinorder
insertion against a hypothetical attack in which the attacker to leave no stone unturned. If a JIT were to omit a particular
needs topredict theoffset of aninstruction near thebeginning defense, that undiversified area would eventually become a
of a unit of code compilation. If the instruction is one of the valuable piece of a future attack. This observation is merely a
first 3729 in a unit of code compilation, the attacker has a corollarytoourassertioninthepreviousparagraphthatpartial
greater probability of predicting the number of random NOPs implementations of defenses do not go unpunished.
inserted before it (and by proxy its offset) than predicting the
Our measurements in §V indicate that most diversification
base offset randomization of a unit of code compilation.
defenses can be deployed at full strength with only modest
performance and memory overhead. A noteworthy exception
VI. DISCUSSION is random NOP insertion for the ARM instruction set. Since
our implementation inserts a NOP between each instruction
The opportunities for both code corruption and code reuse
with 12.5% probability, and all ARM instructions have the
made possible by JIT compilers have been shown to be ex-
same size, we observe a ≈12.5% code size increase. The x86-
ploitableagainstrealJITimplementationstimeandtimeagain
64 architecture, in contrast, is able to achieve a much lower
[7], [27], [26], [6], [25], [24], [28], [4], [17]. Unfortunately,
memory overhead thanks to its 1-byte NOP instruction encod-
the community developing arguably the most prominent and
ing and variable-length instructions. JIT developers may wish
vulnerable JITs—those found in web browsers—has been
to consider carefully lowering the probability of random NOP
slow to react to effectively mitigate these threats in their
insertion on platforms with limited memory and fixed-width
JavaScript JITs. SpiderMonkey has taken the lead in code
instructions. To establish a lower bound on memory overhead
corruptionmitigationbydeployingW ⊕ XJITmemory,butit
when random NOP insertion is dialed back, we measured
still lacks effective code reuse mitigations. Similarly, although
the memory overhead for ARM32 when all diversification
Internet Explorer’s Chakra deploys a form of random NOP
defenses except random NOP insertion are enabled and found
it to be 6.15%.
9ThisfigureisafunctionoftheprobabilityofrandomNOPinsertionand
thenumberofpotentialbaseoffsets.
14A potential objection to diversification defenses is that an [9] CHEN,P.,FANG,Y.,MAO,B.,ANDXIE,L. JITDefender:Adefense
attacker with arbitrary memory read capabilities can avoid against JIT spraying attacks. In Future Challenges in Security and
failure by spraying until her payload is emitted as desired. PrivacyforAcademiaandIndustry.Springer,2011,pp.142–153.
[10] CHEN,P.,WU,R.,ANDMAO,B. Jitsafe:aframeworkagainstjust-in-
While this is true, we argue that diversification defenses
timesprayingattacks. IETInformationSecurity7,4(2013),283–292.
mitigatetheentireclassofblindJITsprayingattacksandraise [11] DE GROEF, W., NIKIFORAKIS, N., YOUNAN, Y., AND PIESSENS, F.
the bar for malicious reuse of JIT code by mandating that a JITSec:Just-In-Timesecurityforcodeinjectionattacks.InProceedings
memory disclosure accompany the control flow vulnerability. ofWISSEC2010(Nov.2010),pp.1–15.
[12] DEUTSCH,L.P.,ANDSCHIFFMAN,A.M. Efficientimplementationof
Very recently-published work [18] demonstrates the cre- thesmalltalk-80system. InProceedingsofPOPL1984(1984).
ation of unintended instructions from the offset field in x86’s [13] DREPPER,U. SELinux memory protection tests. http://www.akkadia.
PC-relativebranchandcallinstructions.Tomitigatethisthreat; org/drepper/selinux-mem.html,Apr.2009.[Online;accessed3Novem-
ber2015].
the authors of [18] implemented blinding of the implicit
[14] HOMESCU, A., BRUNTHALER, S., LARSEN, P., AND FRANZ, M.
constants in relative branches. At submission time, our diver- Librando: transparent code randomization for just-in-time compilers.
sification implementations do not include this new mitigation, InProceedingsofCCS2013(2013),ACM,pp.993–1004.
andwerecognizethatfutureworkwillneedtocorrectthisflaw. [15] JANGDA,A.,MISHRA,M.,ANDDESUTTER,B. Adaptivejust-in-time
codediversification. InProceedingsofACMMTD2015(2015).
[16] JAUERNIG,M.,NEUGSCHWANDTNER,M.,PLATZER,C.,ANDCOM-
VII. CONCLUSION PARETTI,P.M. Lobotomy:Anarchitectureforjitsprayingmitigation.
InProcedingsofARES2014(2014),IEEE,pp.50–58.
As JIT compilers continue to blanket the landscape of
[17] LIAN, W., SHACHAM, H., AND SAVAGE, S. Too LeJIT to Quit:
language runtimes, so do attacks that abuse their predictabil-
ExtendingJITSprayingtoARM.InProceedingsofNDSS2015(2015).
ity and unique memory protection model, as evidenced by [18] MAISURADZE, G., BACKES, M., AND ROSSOW, C. What Cannot
the new threats against ARM JITs introduced in this paper. Be Read, Cannot Be Leveraged? Revisiting Assumptions of JIT-ROP
Implementations of mitigations have appeared in production Defenses. InProceedingsofUSENIXSecurity2016(2016).
JITs,buttheirpotentialhasbeenartificiallylimitedinorderto [19] MAVADDAT, F., AND PARHAMI, B. Urisc: the ultimate reduced in-
structionsetcomputer. InternationalJournalofElectricalEngineering
boostperformance,resultinginafailuretoprovidesatisfactory Education(1988).
protection.Theempiricalevaluationsandanalysesinthispaper [20] MILLIKIN,K. V8: High Performance JavaScript in Google Chrome.
demonstrate that diversification defenses are effective and can https://www.youtube.com/watch?v=lZnaaUoHPhs, 2008. [Online; ac-
cessed2November2015].
be implemented in full with only modest overhead. We en-
[21] MOOIJ,J.D. WˆX JIT-code enabled in Firefox. http://jandemooij.nl/
courage JIT developers to take our experiences implementing
blog/2015/12/29/wx-jit-code-enabled-in-firefox/,Dec.2015.
diversificationdefensesandusethemtoguideimplementations [22] MOZILLA. Bug 506693 - SELinux is preventing JIT from changing
on their own systems. memorysegmentaccess. https://bugzilla.mozilla.org/show bug.cgi?id=
506693,2009. [Online;accessed3November2015].
[23] NIU,B.,ANDTAN,G.Rockjit:Securingjust-in-timecompilationusing
ACKNOWLEDGMENT
modularcontrol-flowintegrity. InProceedingsofCCS2014(2014).
We would like to thank Eric Rescorla for thoughtful [24] PIE,P.MobilePwn2OwnAutumn2013-ChromeonAndroid-Exploit
Writeup,2013.
feedback. We also thank Jan de Mooij, Eric Faust, JF Bastien,
[25] ROHLF, C., AND IVNITSKIY, Y. Attacking Clientside JIT Com-
and Michael Stanton for helpful discussions. This material
pilers. http://www.matasano.com/research/Attacking Clientside JIT
is based in part upon work supported by the U.S. National Compilers Paper.pdf,2011.
Science Foundation under Grants No. 1228967, 1410031, and [26] SINTSOV, A. JIT-Spray Attacks & Advanced Shellcode.
1514435, and by gifts from Mozilla and Google. Presented at HITBSecConf Amsterdam 2010. Online:
http://dsecrg.com/files/pub/pdf/HITB%20-%20JIT-Spray%20Attacks%
20and%20Advanced%20Shellcode.pdf,July2010.
REFERENCES
[27] SINTSOV, A. Writing JIT Shellcode for fun and profit. Online:
[1] Property cache. https://developer.mozilla.org/en-US/docs/Mozilla/ http://dsecrg.com/files/pub/pdf/Writing%20JIT-Spray%20Shellcode%
Projects/SpiderMonkey/Internals/Property cache. [Online; accessed 2 20for%20fun%20and%20profit.pdf,Mar.2010.
November2015]. [28] SONG, C., ZHANG, C., WANG, T., LEE, W., AND MELSKI, D. Ex-
[2] ABADI,M.,BUDIU,M.,ERLINGSSON,U.,ANDLIGATTI,J. Control- ploiting and protecting dynamic code generation. In Proceedings of
flowintegrity.InProceedingsofCCS2005(2005),ACM,pp.340–353. NDSS2015(2015).
[3] ANSEL,J.,MARCHENKO,P.,ERLINGSSON,U.,TAYLOR,E.,CHEN, [29] SOTIROV,A. Heapfengshuiinjavascript. BlackHatEurope(2007).
B.,SCHUFF,D.L.,SEHR,D.,BIFFLE,C.L.,ANDYEE,B.Language- [30] STACHOWIAK, M. Introducing SquirrelFish Extreme. https://www.
independentsandboxingofjust-in-timecompilationandself-modifying webkit.org/blog/214/introducing-squirrelfish-extreme/, 2008. [Online;
code. InProceedingsofPLDI2011(NewYork,NY,USA,2011). accessed2November2015].
[4] ATHANASAKIS, M., ATHANASOPOULOS, E., POLYCHRONAKIS, M., [31] W3C. Web workers. http://www.w3.org/TR/workers/, 2015. [Online;
PORTOKALIDIS,G.,ANDIOANNIDIS,S. Thedevilisintheconstants: accessed3November2015].
Bypassing defenses in browser jit engines. In Proceedings of NDSS [32] WEI, T., WANG, T., DUAN, L., AND LUO, J. Secure dynamic code
2015(Feb.2015). generationagainstspraying. InProceedingsofCCS2010(2010).
[5] BANIA, P. JIT spraying and mitigations. arXiv preprint [33] WU,R.,CHEN,P.,MAO,B.,ANDXIE,L. Rim:Amethodtodefend
arXiv:1009.1038(2010). fromjitsprayingattack. InProceedingsofARES2012(2012).
[6] BECK, P. JIT Spraying on ARM. https://prezi.com/ih3ypfivoeeq/ [34] YEE, B., SEHR, D., DARDYK, G., CHEN, J. B., MUTH, R., OR-
jit-spraying-on-arm/,2011. MANDY,T.,OKASAKA,S.,NARULA,N.,ANDFULLAGAR,N. Native
[7] BLAZAKIS, D. Interpreter exploitation: Pointer inference and JIT client:Asandboxforportable,untrustedx86nativecode. InProceed-
spraying. PresentedatBlackHatDC2010,Feb.2010. ingsofIEEES&P(Oakland)2009(2009).
[8] CARLINI,N.,BARRESI,A.,PAYER,M.,WAGNER,D.,ANDGROSS, [35] ZHANG,C.,NIKNAMI,M.,CHEN,K.Z.,SONG,C.,CHEN,Z.,AND
T. R. Control-flow bending: On the effectiveness of control-flow SONG,D. JITScope:Protectingwebusersfromcontrol-flowhijacking
integrity. InInProceedingsofUSENIXSecurity2015(Aug.2015). attacks. InProceedingsofINFOCOM2015(2015).
15