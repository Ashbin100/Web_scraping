An Evil Copy: How the Loader Betrays You
Xinyang Ge Mathias Payer Trent Jaeger
Microsoft Research Purdue University The Pennsylvania State University
xing@microsoft.com mathias.payer@nebelwelt.net tjaeger@cse.psu.edu
Abstract—Dynamic loading is a core feature used on current thevaluethatisbeingwritten.Despitesignificantinvestmentin
systems to (i) enable modularity and reuse, (ii) reduce memory bugfindingtechniques,memorycorruptionisstillanimportant
footprint by sharing code pages of libraries and executables problem, as 745 individual CVEs for 2015 and 692 CVEs for
among processes, and (iii) simplify update procedures by elim- 2016 are reported. While not all these vulnerabilities allow an
inating the need to recompile executables when a library is
attackertocompromiseasystemwitharbitrarycodeexecution,
updated.TheExecutableandLinkableFormat(ELF)isageneric
many do.
specificationthatdescribeshowexecutableprogramsarestitched
togetherfromobjectfilesproducedfromsourcecodetolibraries
Without any defense, attackers inject and execute code to
andexecutables.Programminglanguagesallowfine-grainedcon-
take control of a system through memory corruption vulner-
trol over variables, including access and memory protections, so
abilities. Over the past decade, a set of defense mechanisms
programmers may write defense mechanisms assuming that the
have been deployed on commodity systems. Data execution
permissionsspecifiedatthesourceand/orcompilerlevelwillhold
at runtime. prevention [5] is a common defense that enforces code in-
tegrity.Codeintegrityprohibitsanattackerfrominjectingnew
Unfortunately, information about memory protection is lost code into a running process and is usually enforced by hard-
during compilation. We identify one case that has significant
ware(e.g.,throughthenon-executeflagonaper-pagebasison
security implications: when instantiating a process, constant
x86).Withtheriseofcode-injectionprotection[32],[39],[22],
externalvariablesthatarereferencedinexecutablesareforcefully
attackers have moved towards code-reuse attacks. In a code-
relocated to a writable memory segment without warning. The
reuse attack, the attacker combines existing code fragments
loadertradessecurityforcompatibilityduetothelackofmemory
protectioninformationontherelocatedexternalvariables.Wecall (calledgadgets)toachievearbitrarycomputation.Whilecode-
this new attack vector COREV for Copy Relocation Violation. reuse attacks are Turing complete, they are generally used
An adversary may use a memory corruption vulnerability to to disable code integrity and to allow an attacker to execute
modifysuch“read-only”constantvariableslikevtables,function injected code. Two other deployed defense mechanisms, stack
pointers, format strings, and file names to bypass defenses (like canaries [25] and address space layout randomization [40],
FORTIFY SOURCE or CFI) and to escalate privileges. protect against some control-flow hijack attacks and make it
We have studied all Ubuntu 16.04 LTS packages and found harder for an attacker to find suitable gadgets. Unfortunately,
that out of 54,045 packages, 4,570 packages have unexpected as the list of CVEs shows, these defenses are often mitigated
copyrelocationsthatchangeread-onlypermissionstoread-write, by an attacker.
presenting new avenues for attack. The attack surface is broad
with 29,817 libraries exporting relocatable read-only variables. New defenses like Control-Flow Integrity (CFI) [3], [11]
The set of 6,399 programs with actual copy relocation violations are on the verge of being widely adopted. Several proposed
includes ftp servers, apt-get, and gettext. We discuss the cause, mechanisms are highly practical, have low overhead, and are
effects,andasetofpossiblemitigationstrategiesforthe COREV suitable for production (i.e., they support common features
attack vector. like modularity and do not require source code annotations,
changes, or blacklisting) [41], [43], [30], [20], [21], [16],
I. INTRODUCTION [26], [10], [29], [31], [34]. CFI verifies that the target address
observed at runtime is feasible according to a statically con-
Software written in C/C++ is prone to memory corruption structed control-flow graph. Individual CFI mechanisms differ
vulnerabilities through memory safety violations and type in the underlying analysis of the control-flow graph and in the
confusions,allowinganattackertocorruptbothdataandcode enforcement mechanism.
pointers. A generic memory corruption vulnerability allows
an attacker to overwrite an arbitrary memory address with Current programs rely on dynamic loading (e.g., through
attacker-controlled data. Each memory corruption is different the ld.so dynamic loader on Linux) to support shared
andsomeonlyallowpartialcontrolofthetargetaddressand/or libraries, position independent code, and defense mechanisms
like address space layout randomization (ASLR). Dynamic
loadingiscentraltohowcurrentsystemsexecuteapplications.
Permission to freely reproduce all or part of this paper for noncommercial Through clever design, dynamic loading enables sharing of
purposes is granted provided that copies bear this notice and the full citation
code across multiple processes, thereby reducing memory
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author usage. As most pages of a library are read-only code, they
(for reproduction of an entire paper only), and the author’s employer if the caneasilybesharedacrossprocessesthatusethesamelibrary
paper was prepared within the scope of employment. as long as the pages do not contain hard-coded addresses.
NDSS ’17, 26 February - 1 March 2017, San Diego, CA, USA
Sharedlibrariessolvethisproblembyusingrelativeaddressing
Copyright 2017 Internet Society, ISBN 1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23199 that redirects accesses through a set of per-process pages thatare writable for each library. In ELF binaries, these pages are future defenses that protect against control-flow hijacking by
referredasGlobalOffsetTables(GOT).Aspartoftheloading overwriting code pointers that are assumed to be read-only
process,thedynamicloaderhastoallocatespaceforindividual and therefore not checked. In total, we have found 69,098
shared objects and resolve references among them. copy relocations that change the original memory protection.
These include 24 format strings, 44 file and path names, 711
Dynamiclibrariesaregenerallycreatedbylinkingposition
function pointers and 28,497 vtables. Our evaluation under
independent code. All references are either relative to the
approximatesthetotalattacksurfaceandshowstheseverityof
current module or use indirection through a set of tables such
COREV. These dangerous copy relocations may not directly
as GOTs. These tables are then updated at runtime whenever
lead to successful exploitations, however, because adversaries
the code is placed at a certain location. Dynamic executables
must additionally find a memory corruption vulnerability to
(as opposed to static executables or executables located at a
modifytherelocatedvariables,buttheprevalenceof COREVs
fixed address) on the other hand are generally not created
provides adversaries with more opportunities for bypassing
frompositionindependentcode.Anyreferencetoexternaldata
defenses and/or launching attacks.
would therefore have to be resolved and patched at runtime.
TheELFstandarddefinesdifferenttypesofrelocationsforthis We propose a set of three mitigations against COREV.
purpose,allowingonlinepatching.Whilerelocationsgenerally First, for existing binaries, the best we can do is to detect
patchthelocationofthereference(i.e.,theypatchthelocation such malicious relocations and prohibit execution (or at least
with the correct address used at runtime), modifying read- warn the user). Second, if compiler flags can be changed, we
only regions should be avoided. If the code region in the proposetorecompiledynamicexecutablesusing-fPICwhich
executable contains external references, then all such code compiles dynamic executables using the same indirection for
pages would have to be modified, making it harder to share referencesasusedfordynamiclibraries,removingtheneedfor
code among processes. Copy relocations fill this gap and copy relocations. Third, if the binary cannot be compiled as
enable dynamic executables to relocate the target object. The positionindependentcode,weproposetochangethetoolchain
executable allocates space for the target object in its .bss to make the constraints that are only available at the source
sectionandtheloaderwillthencopytheobjectfromthesource code and compiler level explicit and preserved along the
shared library to the .bss section of the executable. As all toolchain,sothatbothlinkerandloaderareawareoftheread-
sharedobjectsuseindirectreferencestoaccessthisobject,the only nature of individual symbols. The loader can then update
loader then modifies all these pointers to point to the copy in the permissions accordingly after initial relocation.
the executable.
This paper presents the following contributions:
Such copy relocations may result in severe security viola-
tions because the loader is unaware of the protection flags of
1) Discussion of a new attack vector called COREV
based on copy relocations that allow attackers to
theoriginalsymbolandcanthereforenolongerenforcemem-
violate memory integrity assumptions.
ory protection. The original symbol may be allocated in read-
only memory, but if the dynamic executable references this
2) An evaluation of the prevalence of COREV by ex-
amining copy relocations for all packages of Ubuntu
object, the loader will copy it to a writable memory location.
16.04.Weshowthat4,570packageshaveunexpected
An attacker can now use a memory corruption vulnerability
copy relocations that change memory protections.
to modify the presumed read-only symbol. This has security
3) A presentation of three possible mitigations of this
implicationsifdefensesdependonassumedread-onlymemory
new attack vector.
permissions. Format string protections [27] assume that the
format string is in a read-only section. Modifying the format
string allows an attacker to read or write arbitrary memory II. BACKGROUND
and to execute Turing-complete code [12]. For CFI, many
A. Dynamic Linking and Loading
mechanisms [41], [10], [26] assume that C++ vtables are in
read-only memory, as guaranteed by the compiler, but these Modern operating systems adopt dynamic linking and
guarantees are broken by the linker and the dynamic loader. loading to enable modularity. Dynamic linking has two major
Asvtablesareassumedtobeimmutable,theyarenotchecked, advantages over the traditional static linking. First, the library
and an attacker may circumvent any CFI or other control-flow code can be shared among processes, so that a system needs
hijackingmechanismthatassumesimmutablevtables.Wecall only one physical copy in memory per binary. Second, once a
this attack vector COREV for Copy Relocation Violation. bug is found in a library implementation, fixing the bug and
distributing the updated library suffices if it is dynamically
COREV is not just a theoretic attack vector, but such dan-
linked;otherwise,rebuildingeverysinglebinarythatstatically
gerous relocations actually exist in current software. We have
linked the vulnerable library is required. As a result, all major
examined all 54,045 Ubuntu 16.04 packages and found that
operating systems (e.g., Windows, Linux, and macOS) rely
6,339binariesfeaturesuchrelocations.Weclassifyvulnerable
on dynamic linking by default. For the rest of the paper, we
relocations into the following seven categories: (i) vtables, (ii)
focus, without loss of generality, on the dynamic linking im-
function pointers, (iii) generic pointers, (iv) format strings,
plementationinGNU/Linux.InSectionVII-E,wediscusshow
(v) file and path names, (vi) generic strings, and (vii) others.
other operating systems implement dynamic linking regarding
Writableformatstringsallowanattackertomitigateanyprintf-
COREV attacks.
based defenses and enable printf-oriented programming [12]
while writable file and path names allow an attacker to, MostLinuxsystemsuseaunifiedformatcalledExecutable
e.g., redirect input and output. Writable vtables and function and Linkable Format (ELF) for executables, dynamic libraries
pointers on the other hand allow an attacker to mitigate (*.so) and object files (*.o) [19]. Conceptually, an ELF file
2a.c a.o a.out
a.out
b.c b.o
x.c x.o
libtest.so libtest.so
y.c y.o ld.so
source file object file executable/library running process
compile linking loading
Fig. 1: An overview of compilation, static linking and dynamic loading.
contains a set of sections. Some sections are required for in practice, which creates security issues.
executionandwillbemappedintotheprocessaddressspaceat
We present an overview of how a program is compiled,
runtime (e.g., code and data), while others may store optional
linked, and loaded in Figure 1. A program often consists
descriptive information (e.g., symbol table and debug infor-
of multiple source files. First, the compiler compiles each
mation). Each mapped section is associated with a memory
source file into an object file. A typical object file contains
permission. For example, code sections and read-only data
acodesection,multipledatasectionsandnecessaryrelocation
sections are mapped as non-writable while the other data
information. Second, the static linker takes as input the object
sectionsaremappedaswritable(butnotexecutable).Aspecial
files, resolves references that can be done statically based on
section called the relocation section stores a list of unresolved
therelocationinformation,allocatesGOTentriesforreferences
references(i.e.,absolute/relativeaddresses)thatrequirefurther
thatneedtoberesolvedbythedynamicloaderatruntime,and
attention at a later time (i.e., link time and/or runtime). For
outputs an executable or a library. Third, when executing a
example, an object file may have a relocation entry on the
program, the dynamic loader loads its dependent libraries into
operandofadirectcallinstruction.Atlinktime,therelocation
the process, performs dynamic linking by resolving remaining
entrywillberesolvedsothatthecallgoestotherightfunction.
references that require runtime relocation (e.g., filling GOT
Each relocation entry contains necessary information to help
entries of each module), and transfers the control to the
determine how it should be resolved.
entry point (i.e., main function) of the program. Note that
Dynamically-linked programs require runtime support to dynamiclinkingcanbedonelazily,resolvingindividualtargets
reference code and/or data that reside in different modules whenever first needed.
(e.g.,alibrary).Aprogramdoesnotstaticallyknow(1)which
B. The Importance of Read-Only Data
module provides the required code/data and (2) where in the
address space of the process the module is loaded at runtime. It is now widely accepted that code sections must be
Consequently, modern systems rely on a small runtime called read-only and executable while data sections must be non-
dynamic loader (ld.so) to handle both issues. The dynamic executable to prevent attacks. Solutions like PaX [32] and
loaderisresponsibleforloadinglibrariesintotheaddressspace DEP [5] prevent the execution of writable memory to prevent
and resolving necessary inter-module references so that the code injection attacks. If adversaries find a way to modify
program runs correctly. executable code, then they can attack the process by injecting
and executing code of their choosing. PaX and DEP aim
In addition, dynamically-linked programs require coopera-
to partition the process into immutable and executable code
tionfromthecompilertoolchain(includingthestaticlinker)so
sections and mutable but non-executable data sections to
thatthedynamicloadermayresolveinter-modulereferencesat
preventsuchattacks.Researchersevenarguethatcodesections
runtime without modifying their code sections. On Linux, this
should be execute-only [7], [15].
is achieved through the use of another level of indirection: the
Global Offset Table (GOT). Each module has its own GOT In addition, processes often include a variety of data
section. The GOT contains the addresses used for external that must be read-only. To enable the memory protection,
references needed by the module. Each address is filled by the compiler toolchain produces the information necessary to
the dynamic loader at runtime, as a result of resolving the inform the dynamic loader that certain program data should
corresponding relocation entry. For example, to invoke the be restricted to read-only memory. Typically, an ELF file
printf function in libc, an executable first makes a direct oftenincludesasectionforread-onlydata,namely.rodata.
call to a local trampoline in the Procedure Linkage Table When the compiler detects constant variables in the program
(PLT), which in turn jumps to the actual address of printf source, it adds those variables to the .rodata section of
stored in the corresponding GOT entry. However, as we will the generated object files. The linker then combines individ-
show in Section III, not all external references use the GOT ual .rodata sections of the object files to form a single
3.rodatasectionfortheexecutableorlibrarybinary.Finally, main.c Makefile
thedynamicloadermapstheELFfile’s.rodatasectioninto
extern const int foo; all: main.c test.c
read-only memory to enable memory protection.
gcc -fPIC -shared test.c \
int main() { -o libtest.so
The security of the processes often depend on the read-
int *p = (int *)&foo; gcc main.c -L. -ltest
only memory protection. The read-only data section in an *p = 100; // page fault!
ELF file consists of static constants and variables that are return 0; run: a.out libtest.so
} LD_LIBRARY_PATH=. ./a.out
used by the program. Note that the compiler may also choose
to place such read-only data in the code section to reduce
test.c
the number of required memory pages. Such constants may
include fixed strings (e.g., format strings or filenames), fixed const int foo = 10;
data values (e.g., structured data, arrays, or IP addresses), and
fixed code information (e.g., arrays of function pointers, C++
virtualtables,orjumptables).Programmersassumethevalues
Fig. 2: An example program for problem demonstration.
ofstaticconstantvariablesarestoredinread-onlymemoryand
remain immutable after initialization. Failing to adhere to the
assumption can lead to security breaches [42].
data data
Program security often leverages read-only data. While foo = 10
normal program data may be maliciously modified when a GOT
memory corruption error is exploited by an adversary, read-
address of foo
only data cannot be modified. As a result, security experts GOT
encourage the use of read-only data to prevent attacks and rodata
sometimesapplyread-onlydataintheirdefenses.Forexample, foo = 10
researchers have proposed that a solution to format string
vulnerabilitiesistohard-codeformatstrings[14],[27].Ifprintf
code code
invocations leverage adversary-controlled format strings, then
the call can be used to create a Turing-complete exploit envi-
ronment[12].Asanotherexample,somecontrol-flowdefenses
for C++ programs depend on an adversary not being capable executable library
of modifying virtual tables [41]. These defenses assume the
integrity of virtual tables and simply check if an intended Fig. 3: Copy relocation for the example program. The dotted
virtual table is used during a virtual method invocation to arrowshowsthevariablecopy,andthedashedarrowindicates
restrict the possible targets and prevent code reuse attacks. the points-to relationship. Solid arrows indicate data accesses
While using the C++ virtual table to identify targets is not the in the program.
onlywaytorestrictcontrolflowtargetsforC++virtualmethod
invocations, it presents performance advantages, as discussed
in Section IV-A.
A. Example Scenario
Programs may also leverage read-only data to prevent
ConsideranexampleprograminFigure2.Inthisexample,
attacks on system calls. One problem is that adversary input
themainexecutablereferencesaconstantvariablefoodefined
may be used to construct resources names, such as file names
in a library and tries to change its value. Presumably, this will
and IP addresses. However, if such resource names are hard-
trigger a page fault because the constant variable foo resides
codedin theprogram, thenthe programcannotbe trickedinto
in the library’s read-only data section.
serving as a confused deputy [24]. Further, even if there is a
memory corruption error in the program, as described above, Counterintuitively, this access does not trigger a page
adversaries cannot maliciously modify such resource names fault in practice (the example program was tested on Ubuntu
when they are read-only data. 16.04). When an executable references a constant variable
defined in a library, the dynamic loader “relocates” (moves)
the constant variable from the library’s read-only data section
III. PROBLEMDEFINITION to the executable’s writable .bss section (which typically
contains uninitialized data of a program). This action removes
The loader may fail to maintain the implicit requirement
theread-onlymemoryprotectionofthevariablefoo,allowing
that data in the .rodata section of an ELF file must always
the variable to be written in the example program. Other
be protected read-only. When a program references read-
types of read-only variables defined in a library, but used by
only data that is defined in a library, the loader moves the
an executable, are relocated in a similar way. As described
data into a data section of the program that is writeable,
in Section VII, 6,339 out of 34,291 programs exhibit this
enabling adversaries to modify such data. Since programmers
behavior, making them vulnerable to unexpected exploits.
and defense mechanisms depend on such data being read-
only, this loader behavior introduces a new attack vector for Such variable movement is initiated by a special reloca-
adversaries to exploit. We call the new attack vector COREV tion type called copy relocation applied to variables in the
forCopyRelocationViolation.Next,wedescribehowandwhy executable. We show its effects in Figure 3. Basically, a copy
current loaders enable COREV. relocation instructs the dynamic loader to move a variable to
4the address specified by the relocation entry. The dynamic insufficient to encode an eight-byte address of an arbitrary
loader not only copies the variable value (shown as the dotted libraryvariable.Second,thelinkercancolludewiththeloader
arrow), but also redirects the references in other libraries by allocating a local copy within the executable as if it were
(including the one which actually defines the variable, e.g., locallydefined.Specifically,thelinkerallocateszero-initialized
libtest.so in our example) to the new location by set- space for the external variable in the .bss section of the
ting up the variable’s corresponding GOT entries accordingly executable, and updates the placeholder to reference the local
(shown as dashed arrow). This ensures the old copy in the copy when linking. The dynamic loader then copies the value
library can be safely discarded. oftheoriginallyreferencedlibraryvariabletothelocalcopyat
runtime as shown in Figure 3. After moving the variable from
the library to the executable, all libraries that are using this
B. The Purpose of Copy Relocation
variablemustupdatetheirreferencesfromtheoriginallocation
Copy relocations are an artifact of the process imple- in the library to the location in the executable by updating
mented by the compiler toolchain to unify how references their GOT sections. The library that hosts the original copy
to external variables are resolved between static and dynamic of the variable must update its location to the executable as
linking. Modern compiler toolchains split the build process well. This ensures a consistent program state for all libraries.
into multiple stages as shown in Figure 1. In particular, the Therefore, the linker is able to resolve the relocation entry
separation between the compilation and linking steps makes for the placeholder statically. As a result, the current compiler
separate compilation possible, enabling program modules to toolchainadoptsthesecondsolutionbyusingcopyrelocations.
be produced independently and linked either with other object
However, as shown in the example in Figure 2, copy relo-
files or libraries to run the executable. This feature improves
cations move an external variable to the executable’s writable
buildefficiency,encouragescollaborationsonthesameproject,
datasectionregardlessofitsoriginalmemoryprotection.There
and simplifies code management. However, such a design
aretworeasonsforthisdesign.First,thelinkercannotreliably
limits the information available at each stage. As we will
determine the original memory protection set on the moved
show, the current practice of separate compilation for read-
library variable. This is because dynamic linking allows the
only variables is the root cause of COREV.
overriding of symbols based on the order in which libraries
As shown in Figure 1, the compiler takes a source file and areloaded,whiletheactualloadingordermaynotbestatically
generates an object file. When the source code references an known.Second,makingaread-onlyvariablewritabledoesnot
external symbol (e.g., a variable or a function), the compiler break program functionality, while the opposite assumption
creates a placeholder for its address in the emitted instruction couldtriggerpagefaultsandcrashtheprogram.Compatibility
and allocates a relocation entry for the placeholder. Conse- is of paramount priority in software engineering practice and
quently, the generated instructions do not go through GOT the current design of the dynamic loader favors compatibility
by default. The implicit assumption made by the compiler over security.
here is that the placeholder can always be updated with the
How the change of memory protection affects security
actual address by resolving the relocation entry when the
depends on the availability of memory corruption vulnera-
program is eventually linked. While this assumption may hold
bilities and the type of the copied variables. Intuitively, if a
for statically-linked programs, it is not always the case for
program’s security relies on the read-only protection of the
dynamically-linked programs where the referenced symbol
movedvariables,thencopyrelocationswillincreasetheattack
may be externally defined in a library (e.g., the variable foo
surfaceand/orevennegateexistingdefenses.Copyrelocations
in Figure 2) and hence its address is not known until runtime.
increase the program’s attack surface because the adversary
There are two kinds of external references, and the linker couldpotentiallymodifymoreprogramdatathanwithoutcopy
handles them in different ways. In the first case, the exe- relocation through memory corruption. As program defenses
cutable references external code by calling library functions. depend on the immutability of such data, adversaries may
To resolve the relocation statically and hence satisfy the be able to circumvent defenses like control-flow integrity
compiler’sassumption,thelinkercanrelaythecontroltransfer. (e.g., based on vtables [41]), format string protection [14], or
Specifically, it updates the placeholder (e.g., a call operand) confused deputy mitigation [42].
to point to a linker-generated trampoline in the Procedure
Linkage Table (PLT), and makes the trampoline perform a IV. COREVIMPLICATIONS
GOT-based indirect jump to redirect the control to the actual
Unintended copy relocations that change memory protec-
library function.
tion are a new attack vector that enables several classes of
In the second case, the executable references external data attacks. Code pointers, format strings, and other static data
by using library variables. Unlike external code references, assumed to be read-only by a defense or the program may
the linker cannot effectively relay data accesses. Thus, the suddenly be writable. We discuss these classes by examples.
linker has two choices. First, it can leave the placeholder
to the dynamic loader and let it resolve the relocation entry A. Virtual Method Tables
at runtime. Unfortunately, since the placeholder resides in C++ programs use a special data structure called virtual
the program’s code section, this implies that the loader has method tables (or vtables) to dispatch virtual functions for
to modify the program’s instructions at runtime. Thus, the polymorphism. We show the conceptual memory layout of
same binary cannot be shared among concurrent processes. vtabledatastructuresandtheassemblycodethatmakesvirtual
Furthermore, on x86-64 Linux, the placeholder generated method calls in Figure 4. An object with virtual methods
by the compiler only has four bytes by default, which is stores the pointer to the vtable at its beginning. The vtable is
5class A {
int m_a; obj_a int A::a1(void) { main:
virtual int a1(void); A::a1 return m_a; ...
vtable_ptr
… A::a2 } // NOW obj_b is in %rdi
virtual int aN(void); m_a …
}; // load vtable ptr in %rbx
A::aN
movq (%rdi),%rbx
class B: public A { // load a1 to %rax
int m_b; movq (%rbx),%rax
virtual int b1(void); B::a1 int B::a1(void) { // obj_b->a1()
… obj_b B::a2 return m_a + m_b; callq *%rax
virtual int bN(void); vtable_ptr … }
}; // vtable ptr remains in %rbx
m_a B::aN // load a2 to %rax
void main() { m_b B::b1 movq 0x8(%rbx),%rax
A *obj_a = new A; B::b2 // obj_b->a2()
B *obj_b = new B; callq *%rax
…
obj_b->a1();
obj_b->a2(); B::bN
}
(a) source code (b) object memory layout (c) vtables (d) methods (e) assembly of virtual method calls
Fig. 4: vtable memory layout and virtual call sites.
InFigure5,weshowtwotypesofinstrumentationsforvirtual
main: main: callsitesshowninFigure4(e).Bothtypesofinstrumentations
... ...
// NOW obj_b is in %rdi // NOW obj_b is in %rdi aim to ensure that only valid methods can be targeted at
each virtual call site. The first type of instrumentation directly
// load vtable ptr to %rbx // load vtable ptr to %rbx
movq (%rdi),%rbx movq (%rdi),%rbx checks the target function address obtained from the vtable.
// load a1 to %rax // load a1 to %rax Alternatively, the second type of instrumentation assumes
movq (%rbx),%rax assert %rbx is a valid vtable
vtablesarewriteprotected,andchecksifthereferencedvtable
// obj_b->a1() movq (%rbx),%rax
assert %rax is valid target // obj_b->a1() is legitimate based on the object’s static type.
callq *%rax callq *%rax
There are two advantages of the second-type instrumen-
// vtable ptr remains in %rbx // vtable ptr remains in %rbx
// load a2 to %rax // load a2 to %rax tation compared to the first type. First, given that a vtable
movq 0x8(%rbx),%rax movq 0x8(%rbx),%rax commonlycontainsmultiplefunctionpointers,therearefewer
// obj_b->a2() // obj_b->a2()
vtables than actual targets, making checking vtables more
assert %rax is valid target callq *%rax
callq *%rax efficient. Second, if a program continuously makes virtual
method calls on the same object and the compiler keeps the
vtablepointerinacallee-savedregister(e.g.,%rbx),onlyone
Fig. 5: Two types of instrumentations for protecting virtual check is necessary when checking the vtable, while the first
method calls. typeofinstrumentationneedstocheckoneveryvirtualmethod
call.Asaresult,researchersproposetocheckthevtablepointer
toachievebetterperformance[41],[10].Notethatmechanisms
using the second type of instrumentation must consider the
essentiallyanarrayoffunctionpointerstotheimplementations
securityimplicationsofspillingtheregistertothestackwhere
of the virtual functions declared by its class (or its ancestor
it could potentially be overwritten [4].
classes). Objects of different classes along the inheritance
chain can have different implementations of the same virtual However, vtables are not always read-only because of
method (e.g., A::a1 vs B::a1). Therefore, by embedding unintendedcopyrelocations.Thiswillrenderthedefensesthat
the vtable pointer into every object, the vtable can dispatch are based on the second type of instrumentation ineffective,
the virtual method calls based on the object’s runtime type. suchas[41].Forinstance,ifanadversarycorruptsthefunction
Vtables are not supposed to change at runtime, thus they are pointers in the vtable but leaves the vtable pointer untouched,
statically initialized at compile time and allocated from read- she can potentially redirect control flow to arbitrary code
only memory. locations without detection.
Attackers have demonstrated successful exploits by hi- To trigger vtables being moved to writable memory, a
jacking virtual method calls [38]. Broadly speaking, these program must satisfy the following two invariants:
attackseithercorruptthevtableinplaceoroverwritethevtable
pointer stored in some object so that it points to something • A class having virtual methods is implemented in a
undertheattacker’scontrol.Currentdefenses[41]focusonthe dynamic library and its vtable is in the library’s read-
latter because the defenses (wrongly) assume that the vtable only region.
is allocated in a read-only section and cannot be modified by
• The constructor of the same class is implemented in
the attacker.
the executable. This is possible when a class does
Furthermore,currentdefensesleveragetheread-onlynature not have an explicit constructor or its constructor is
ofvtablestooptimizetheirchecksforbetterperformance[41]. defined in a header file.
6We revisit the cause of copy relocations to illustrate why victim, but not to the adversary (e.g., password files or secret
the two invariants lead to writable vtables. A copy relocation key files). Alternatively, such attacks may enable an adversary
occurs when the executable references a symbol defined in to direct the victim to use an adversary-controlled resource
an external dynamic library. In the case of vtables, the first instead(e.g.,adversary-definedconfigurationorIPaddress).In
invariant ensures that vtables are externally-defined symbols. theseattacks,adversariesgainunauthorizedaccessovervictim
Thesecondinvariantfurtherensuresthatthereexistsasymbol resources or control inputs the victim depends upon.
referencetothevtablesintheexecutablebecausetheconstruc-
Current defenses to prevent such attacks focus on filter-
torneedstoinitializetheobject’smemoryincludingthevtable
ing adversary-controlled file names [8] or restricting system
pointer (Figure 4 (b)). On the other hand, if the constructor is
calls that use adversary-controlled input in constructing file
implemented as an external library function, the executable
names [13], [35], [42]. For example, one recent defense iden-
simply makes an inter-module call into the constructor for
tifiesthedatadependencebetweenadversary-controlledinputs
initializingobjects,whicheliminatesthevtablereferencefrom
and the system call arguments that use them to restrict the
the executable.
resources accessible to system calls [42]. This approach uses
adynamicanalysistodetectwheresystemcallsuseadversary-
B. Format Strings controlled input in file names. However, such a dynamic
analysis is unlikely to detect how to craft inputs necessary
Functions like printf use format strings as templates
to overwrite file names that were thought to be immutable.
to direct outputs. Researchers have long known that such
As a result, when copy relocations make file names and other
functions may be vulnerable if an adversary controls the
system resource names writeable, these will go undetected by
format string input or the program uses directives that enable
such defenses.
unauthorized memory accesses, which have become known as
format string vulnerabilities [6]. More recently, researchers
have shown that, by controlling the format string used in V. MITIGATION
printf, an adversary can basically use the function as
The presented COREV attack vector has existed for
an interpreter and achieve Turing-complete computation [12]
decades.Weproposethreefundamentalmitigationapproaches:
that evades control-flow defenses that they call printf-oriented
(1) detection through a simple checker, (2) recompiling the
programming.
underlying software as position independent code which does
One obvious defense against such vulnerabilities is to use not require copy relocations (i.e., enabling a compiler switch),
static format strings. While such a defense may not always be or (3) changing the toolchain to include additional informa-
possible,itissimpleandencouragedwhereitispossible[14]. tion about the memory permissions of external symbols to
When enabled, the fortify gcc patch [27] enforces read-only enable permission-aware copy relocations. In addition, it is
formatstringsatthecompilerlevel.Thecompiler-basedcheck also possible to leverage source code annotations to eliminate
assumes that format strings allocated from read-only sections copy relocations. We discuss the annotation approach in detail
remain immutable (which is not true for COREV). For exam- in Section VII-E when we evaluate other operating systems.
ple, printf-oriented programming requires that the adversary
be able to modify the format string at runtime to implement A. Detecting Permission Violations
branches in their attack. Thus, the current assumption is that
A straightforward mitigation simply refuses execution of
theuseofstaticformatstringswillpreventattacksonfunctions
programs that violate the intended memory protection during
that use format strings.
copyrelocations.Thekeyideaistodetectcopyrelocationsthat
Unfortunately, copy relocations can make format strings violate permissions for any given executable. Our approach
writable, enabling such attacks. Specifically, if a format string consists of three steps. First, we identify a list of symbols
(i.e., a constant char array) is defined in a library and ref- that are copied at runtime. This information is collected by
erenced from the executable, the loader will copy the entire parsingtherelocationsectionsandidentifyingcopyrelocations
string to writable memory and make it susceptible to memory fromtheprogramexecutable.Second,welocatetheoriginsof
corruption. Then, an adversary can implement printf-oriented those symbols. In this step, we parse the .dynamic section
programming simply by modifying the value of a supposedly and follow the search order to enumerate dependent libraries.
static format string. Finally, given a relocated symbol and a dependent library, the
third step is to identify (i) whether the library defines the
C. Other Static Data symbol and (ii) whether the symbol is in the library’s read-
only data section. If both are true, we report this memory
Programs use a variety of other static data, such as static protectionviolationandmarktheprogramaspotentiallyunsafe
filenamesandIPaddressestoutilizesystemresourcesuncon- for execution.
ditionally,suchasprogramconfigurationfilesandwell-known
IP addresses like “127.0.0.1”. Researchers have long been
B. Recompiling Software
concerned about adversaries modifying the names of system
resources accessed by programs. In general, various types Given that the static linker may not know the memory
of confused deputy attacks [24], such as link traversal [17] protection of referenced symbols in a dynamic library, a
and Time-Of-Check-To-Time-Of-Use (TOCTTOU) [9], [28], principled way to mitigate corruptions on read-only variables
enable an adversary to direct a vulnerable program to a is to eliminate copy relocations. Therefore, the executable ref-
resource of the adversary’s choosing. Such an attack may erencesexternalvariablesthatresideintheiroriginallocations
enableanadversarytoaccessaresourcethatisavailabletothe with untampered memory protections.
7(i) access library variables as position independent does come with additional perfor-
// load GOT entry to %rax, // load GOT entry to %rax mance costs compared with copy relocations. First, accessing
// 0x0 requires link-time movq GOT_ENTRY(%rip),%rax all library variables (including mutable variables that are not
// relocation // load var to %rax affectedbyCOREV)nowrequiretwomemoryaccesses,while
movq 0x0(%rip),%rax movq (%rax),%rax
// load var value to %rax copy relocations only need one. Second, relative addressing
movq (%rax),%rax modecanbecostlyespeciallyfor32-bitx86architecturewhere
(ii) access executable variables
such a mode is not natively supported [33].
// load var address to %rax
lea VAR_ADDR(%rip),%rax
// load var value to %rax
C. Adapting the Toolchain
movq (%rax),%rax
The mapping between protection modifiers at the source
(a) assembly of object file (b) assembly of executable code level and the protection enforced at runtime is crude.
The protection modifiers change between languages and are
Fig. 6: Object files compiled with -fPIC and the resultant mapped to read and write permissions at the linker and
executable that accesses (i) library’s globals and (ii) its own loader level. Especially for externally defined variables, this
globals. mapping can be imprecise. In the example shown in Figure 2,
the declaration of variable foo has the keyword const. A
dynamic library often has a header file that declares exported
read-only variables in such a way, so that executables can
Recall that the motivation of copy relocations is to enable reference them after including the header file.
GOT-unaware code to reference external library variables.
Unfortunately, source-level protection information is lost
Therefore, to eliminate copy relocations, such references must
go through the GOT, which is designed for serving inter-
when a source file is compiled into an object file (*.o),
primarily due to how ELF specifies the memory protection
module references. To do so, we propose to change the
compiler flags and add the -fPIC flag. This flag instructs for variables. Recall that ELF sets memory protections at the
granularity of sections (see Section II). Thus, the way ELF
the compiler to generate object files that are suitable for use
specifies a variable as read-only is to allocate the variable
in a dynamic library. It has two effects on the generated code.
from a read-only section (e.g., .rodata), so that the linker
First, the code uses IP-relative addressing mode to access
canpreservetheintendedmemoryprotectionwhencombining
global variables. Second, the code accesses global variables
these sections into a single read-only section at link time.
through the GOT. We rely on the second effect to eliminate
copy relocations. The -fPIE flag, which is typically used However, the compiler does not actually allocate externally-
defined variables in object files. Instead, the compiler marks
for creating position-independent executables (e.g., to support
ASLR) as opposed to the -fPIC flag for creating dynamic them as undefined. An undefined reference is insufficient
for the linker to determine the originally intended memory
libraries, cannot be used to eliminate copy relocations. This is
because, the -fPIE flag only ensures the use of IP-relative protection settings for these variables.
addressing mode (the first effect), but does not force global
Our proposed solution is to adapt the current toolchain to
variable accesses to go through the GOT (the second effect),
preserve such information along the compiler toolchain from
which is key to avoiding copy relocations.
source code to object files. To be compatible with the current
ELF specification, we allocate a separate section (referred as
Weshowthegeneratedinstructionsatthecompilationstage
in Figure 6 (a) to explain how the -fPIC flag helps eliminate
COREV section) in the object file to store memory protection
information for each externally-defined variable. Specifically,
copy relocations. For each symbol access, the compiler emits
two memory accesses, where the first retrieves the address of
each entry in the COREV section contains a permission flag
to specify the intended memory protection (i.e., read-only
the symbol from the GOT and the second actually loads its
or read-write), as well as an ELF symbol index to specify
value.Consequently,atlinktime,thelinkercanallocateaGOT
the variable for which the permission flag applies. Therefore,
entry for variables that are externally defined in a dynamic
based on the added information, the linker can create variable
library. This saves the linker from creating a copy relocation
copies in corresponding data sections with respect to the
to cover the “mistake” of the clueless compiler.
originally intended memory protection.
One concern of this mitigation is the cost for accessing
Finally, we also adapt the dynamic loader so that it
a global symbol. It seemingly incurs an unnecessary memory
can perform copy relocations on read-only data sections by
load operation for accessing globals that are defined within
mapping them as writable during startup and protecting them
the executable, since their locations are statically known and
as read-only afterwards. This process is similar to how the
hence do not require GOT indirections. In fact, on x86, the
current dynamic loader handles the .data.rel.ro section
static linker can optimize the code sequence to save one
as mentioned in Section VI. This approach requires changing
memory access by changing the first instruction to be an
the entire toolchain (i.e., compiler, linker, and loader), and we
LEA instruction, which simply computes the effective address
leave its prototype implementation to future work.
insteadofactuallyfetchingthevaluefromthememory(shown
in Figure 6 (b)). This is possible because the LEA instruction
hasthesamebytesequenceasthecorrespondingMOVinstruc- VI. COREVINVESTIGATION
tion except for the second byte in their opcodes.
We have implemented two mechanisms to assess the new
However, despite this optimization, compiling executables attackvector.BothtoolsareimplementedinPython,usingthe
8PyELF library to handle object files, with a total of 174 lines Function pointers: ifthevariableisapointerandthepointer
of code. references a code segment;
Generic pointers: if the variable is a pointer into the current
The first tool takes an executable as parameter and gen-
libraryorrelocatedtoadifferentlibraryandnotafunction
erates a list of copy relocations that may alter the memory
pointer (i.e., references data);
protection set on the imported library variables. It has two
Format strings: ifthevariableisastringandcontainsatleast
components. The first part identifies all exported, read-only
one format specifier (%);
variables in a given dynamic library. Specifically, for each
File names and paths: ifthevariableisastringandcontains
exported library variable, we check whether it resides in a
at least one path separator (/);
read-only data section (e.g., .rodata). One subtlety here
Generic strings: if the variable is a string and is neither a
is that some writable data sections (e.g., .data.rel.ro
format string nor a filename/path;
and GOT) can be reprotected as read-only at runtime through
Other variables: all other variables.
the RELRO program header [2]. The dynamic loader imple-
ments functionality to handle relocations on read-only data While the current prototype uses simple heuristics, they
by (1) grouping them into a dedicated section so that the work well in practice. We currently restrict automatic type
other read-only data without relocations can still be shared discovery through heuristics and binary analysis as debug
among processes, and (2) resolving the relocations during information is not always available. In future work we will
startup and then remapping the writable section to read-only evaluate further heuristics and approaches for identifying a
afterwards. We treat those sections as read-only (ignoring broader set of data types, e.g., by using debug information
the small window for a TOCTTOU attack during startup). (whenever available).
The second component enumerates all copy relocations in an
executable. For each copy relocation, we iterate through each VII. EVALUATION
of the executable’s dependent libraries (i.e., extracted from
the executable’s .dynamic section) and check whether the A. Attack Surface
copied variable is present and read-only in the library. If so,
In this section, we study the distribution of read-only
we report this copy relocation as potentially unsafe.
variables in dynamic libraries of a real Linux distribution.
Specifically,wecollectallpackagesavailabletoUbuntu16.04
The second tool infers the data type for a given library
LTS and identify the exported read-only variables for each
variable.Toenableourtooltoanalyzearbitrarylibraries,wedo
dynamic library. In theory, all these variables can be relocated
notrequiresourcecodeordebuginformation.Instead,weinfer
into writable data memory at runtime if they are referenced
data types using binary analysis. We classify the symbols into
by an executable; however, in practice, not all of them may
seven categories: (i) C++ vtables, (ii) function pointers, (iii)
be accessed. First, not all read-only variables in dynamic
generic pointers, (iv) format strings, (v) file and path names,
libraries are equally likely to be referenced by executables.
(vi) generic strings, and (vii) other variables.
For example, if the constructor of a C++ class is implemented
First, we broadly infer pointers and strings in the dynamic in the library (see Section IV-A), it is highly unlikely for the
libraries. To discover pointer variables, we rely on relocation executable to directly reference the vtable of the particular
informationinthelibrary.Specifically,givenadynamiclibrary class. Second, if a library is used by an executable that
can be loaded at an arbitrary address at runtime, a pointer in is compiled with -fPIC and hence does not have copy
the data sections must be properly patched to run. That said, relocations, the read-only variables in the library will not be
each pointer in the dynamic library will have a corresponding relocated at runtime. Thus, we treat the set of exported read-
relocation entry. For example, an R_X86_64_RELATIVE onlyvariablesasatheoreticalupperboundoftheattacksurface
entry instructs the loader to add the loading base address to for COREV attacks, and evaluate the actually relocated read-
a pointer variable so that it points to the correct location at only variables in Section VII-B.
runtime. Furthermore, for the discovered pointers, we check
We analyzed 58,862 libraries from 54,045 packages.
whether they point to code or data, and classify them into
Among them, 29,817 libraries export read-only variables. In
functionpointersanddatapointersaccordingly(seebelow).A
total, we found 5,114,127 exported read-only variables across
pointer can be part of a composite variable such as a structure
these libraries, making an average of 86.9 such variables
or an array. For simplicity, we classify the entire variable into
per library (including those that do not export any read-only
the pointer category as long as one of its fields is a pointer.
variable).Weshowthenumberofexportedread-onlyvariables
To determine strings, we check whether the variable con- in each dynamic library in Figure 7 (sorted from low to
tains only ASCII characters and if it is NULL-terminated. We high). There are 55 libraries with over 10,000 exported read-
further identify format strings and file names from discovered only variables. For example, the main library (libxul.so)
string variables (see below). We highlight format strings and used by Firefox browser has over 40,461 exported read-only
file names because memory corruption on them could lead to variables.Fortunately, theFirefox executableis compiledwith
security breaches. -fPIC and has no copy relocations. However, a broad attack
surfaceforpotentialCOREV-basedmemorycorruptionattacks
Next, we discuss how we infer and classify the types of
remains should another executable uses the same library but
exported library variables in detail:
is not compiled as PIC.
C++ vtables: if the variable contains a set of code pointers Wefurtherclassifytheseread-onlyvariablesbasedontheir
andisnamedthroughstandardnamemanglingrules(e.g., inferred data types. In our analysis we distinguish between
if the variable name starts with _ZTV); C++vtables,functionpointers,genericpointers,formatstrings,
9Attack Surface Vulnerable
Variable Type
# variables # libraries # packages # variables # executables # packages
C++ vtables 714,617 14,563 3,692 28,497 4,291 1,609
function pointers 115,071 1,054 541 711 105 78
generic pointers 694,846 12,118 3,830 33,057 4,910 2,082
format strings 874 161 107 24 14 12
file names 6,822 454 252 44 20 10
generic strings 654,429 13,220 4,145 1,347 197 108
others 2,927,468 19,437 5,185 5,418 1,890 671
TABLE I: Potential attack surface and vulnerable subset of variables for all available Ubuntu 16.04 packages. Under the Attack
Surface column, we list the number of exported read-only variables, involved libraries and packages. Similarly, under the
Vulnerable column, we list the number of actually copied read-only variables, involved executables and packages.
105 350
300
104
250
103
200
150
102
100
101
50
100 0
0 5000 10000 15000 20000 25000 30000 0 1000 2000 3000 4000 5000 6000 7000
Fig. 7: Number of exported read-only variables in each dy- Fig.8:Numberofactuallycopiedvariablesperexecutablethat
namic library from all Ubuntu 16.04 packages (sorted from are vulnerable to COREV from all Ubuntu 16.04 packages
low to high). X-axis denotes each individual library and Y- (sorted from low to high). X-axis denotes individual executa-
axis indicates the number of exported read-only variables. bles and Y-axis indicates the number of COREVs.
file names, generic strings, and other variables. We single out adversary can then corrupt the constant pointer to point to a
vtables, function pointers, format strings, and file names due maliciousformatstringtotriggerprintf-orientedprogramming.
to the security implications if their permissions are changed As mentioned in Section VI, our current type inference does
through a copy relocation. not follow generic pointers, and we leave a more proactive
type discovery to future work.
We show the results in the “attack surface” column in
Table I. For the exported read-only variables with inferred Formatstringsandfilenamesarealsoexportedbylibraries,
types, C++ vtables are the majority – 32.68% of all the although many fewer are relocated in comparison to other
variableswithinferredtypes.Functionpointersoccupyanother types. Writable format strings allow an attacker to execute
5.26%.Thesecodepointersareoftenofinteresttoanadversary arbitrary computation and file names allow an attacker to
becausecorruptingcodepointersmaygiveherarbitrarycontrol possibly change the input and output of the program.
of the program execution [37], [38], [23], [18]. In the case of
COREV, these attacks are possible despite strong defenses as B. Real-World Permission Violations
we show in Section VII-D.
In this section, we study the real-world programs that
Generic pointers have the second largest population have unsafe copy relocations in Ubuntu 16.04 LTS. We have
(31.78%). Programs use generic pointers to access memory examined 34,291 executables across 54,045 packages. 6,339
indirectly.Therefore,ifaconstantpointerbecomesmodifiable, of these executables have 166,543 copy relocations in total,
an adversary could trick the program to access something amongwhich,69,098alterthememoryprotection.InFigure8,
vastly different that is under her control. The security impli- we display the number of COREVs for each executable in all
cation depends on what the constant pointer points to. For Ubuntu 16.04 packages. There are 54 executables that have
example, if the constant pointer points to a format string, an more than 100 COREVs (with a maximum of 345 COREVs).
10Variable # Copies
gettext-0.19.7
(V) cxxabiv1:: si class type info 3,676
(V) cxxabiv1:: class type info 2,988 struct catalog_input_format {
void (*parse)(…);
(V) std::basic ios(cid:104)char, std::char traits(cid:104)char(cid:105)(cid:105) 1,842
bool produces_utf8;
(V) std::basic streambuf(cid:104)char, std::char traits(cid:104)char(cid:105)(cid:105) 1,819 };
(V) cxxabiv1:: vmi class type info 1,641
(V) std:: cxx11::basic stringbuf(cid:104)char, 1,319 const struct catalog_input_format
input_format_properties = {
std::char traits(cid:104)char(cid:105), std::allocator(cid:104)char(cid:105)(cid:105)
properties_parse,
(T) std::exception 1,169 true
(T) std::runtime error 1,020 };
(V) std::basic filebuf(cid:104)char, std::char traits(cid:104)char(cid:105)(cid:105) 953
(V) std:: cxx11::basic ostringstream(cid:104)char, 894
std::char traits(cid:104)char(cid:105), std::allocator(cid:104)char(cid:105)(cid:105) Fig.10:Asystemlibrarywithread-onlyfunctionpointersthat
are relocated to various executables.
TABLEII:Thetenmostcommonlycopiedread-onlyvariables
in Ubuntu 16.04. They are all from the libstdc++ library.
(V) denotes vtable and (T) denotes typeinfo. The “copies”
column list the number of executables that actually copy the
1)C++ Vtable (mysql-workbench): We use mysql-
corresponding variable.
workbench,acomplex,GUI-based,network-facingC++appli-
cation, as an example of of C++ vtable relocations. Note that
we have found many other C++ applications with such unsafe
mysql-workbench: library/forms/mforms/container.h relocations that are not listed here. The mysql-workbench is
class Container : public View { a unified visual tool for database management that divides its
public: functionality into multiple dynamic libraries. As a result, it
Container() {} relocates19vtablesfrom5differentlibrariesintotal.Weshow
virtual void set_padding(...);
one of them in Figure 9.
virtual void set_back_image(...);
};
Container is a class implemented in the libmform library
and serves as a base class for graphic components such as
Fig. 9: An example of C++ vtable that is copied to mysql- MySQL table. It defines two additional virtual functions, thus
workbench executable. the Container class has a corresponding vtable for dispatching
virtualmethodcalls.Inaddition,giventhattheContainerclass
does not have an explicit constructor, the mysql-workbench
executable will define a default one. The default construc-
This experiment shows that COREVs do commonly exist in tor will need to reference Container’s vtable for initializing
real-world programs and present a real threat to the ELF- object memory. Consequently, the vtable is relocated to the
based dynamic linking procedure. However, an unsafe copy executable’s .bss section and becomes writable, potentially
relocation is not exploitable by itself. Instead, it provides an mitigating vtable-based defenses.
adversary with more potential corruption targets to launch
attacks and/or bypass existing defenses. 2)C++ Vtable (apt-get): We found that apt-get also con-
tainsasetoffivevtablesthatarecopyrelocatedfromlibstdc++
We list the types of these unsafe copy relocations in Ta-
and libapt-pkg.so.5.0. Four of them overlap with the already
ble I in the “vulnerable” column. In particular, 44.75% of
mentioned vtables in Table II, the last one is the vtable of
all relocated read-only variables with discovered types are
class OpTextProgress in libapt-pkg. Assuming that apt-get is
C++ vtables. This is proportional to the exported C++ vtables
compiledwithanupcomingcontrol-flowhijackingdefenselike
listedintheattacksurface,andmakes COREV anunignorable
VTV [41] and that a memory corruption vulnerability exists,
problem because it enables attacks that can potentially evade
the adversary may use COREV to bypass such defenses.
current defenses as shown in Section VII-D.
Finally, we study the common COREVs in these exe- 3)Function Pointer(gettext): We usethe gettext libraryto
cutables. Surprisingly, the top 10 most commonly copied show how constant function pointers are copied in a typical
variables are all from libstdc++. We list them in Table II. program. The gettext library is in the gettext-base package
Among the 10 COREVs, 8 of them are actually vtables whichisinstalledoneveryUbuntu16.04machine.Itexports6
of widely used classes. For example, the vtable of class read-onlyfunctionpointersandaffects15built-inexecutables.
__cxxabiv1::__si_class_type_info are copied by We show one of its exported function pointers in Figure 10.
3,676executablesinUbuntu16.04.Giventheprevalentuseof The exported function pointer is actuallya field of a structure.
libstdc++, it is likely that future C++ programs can also be Each structure corresponds to an input stream format and the
susceptible to COREV-based attacks. function pointer points to an internal library function that
parses the format. Thus, a program can leverage it to process
the input stream based on its own needs. Similarly, these
C. Case Study
constant data structures defined in gettext become modifiable
Inthissection,westudyhow COREVsoccurinreal-world due to copy relocation and hence susceptible to memory
programs. corruption attacks.
11Defenses check fptr check vtable CoReV?
libow-3.1: src/c/error.c
VTrust [43] (cid:88) (cid:88) ×
const char mutex_unlock_failed[] = VTV [41] × (cid:88) (cid:88)
"mutex_unlock failed rc=%d [%s]\n"; vfGuard [36] (cid:88) × ×
Interleaving [10] × (cid:88) (cid:88)
libow-3.1: src/include/ow_mutex.h SafeDispatch [26] (cid:88) × ×
extern const char mutex_unlock_failed[]; SafeDispatch (2) × (cid:88) (cid:88)
RockJIT [30] (cid:88) × ×
#define my_pthread_mutex_lock(mutex) \
do { \
TABLEIII:Evaluationofvtabledefenses,whethertheycheck
/* skip some code here */
mrc = pthread_mutex_lock(mutex); \ function pointers, vtables, or both. Three defenses [41], [10],
if (mrc != 0) { [26] assume vtables are write-protected and only check the
vsprintf(buf, mutex_unlock_failed, ...); \ vtable pointer, thus are affected by CoReV and may allow
} \
vtable corruption attacks.
} while (0)
Fig. 11: An example of format string that is susceptible to
COREV in libow-3.1. Recent research proposals on control-flow integrity (CFI)
focus on protecting forward edges (i.e., indirect call-
s/jumps) [41], [43], [44], [10]. In particular, given the preva-
main.cpp A.hpp lence of virtual method calls in C++ programs (see Sec-
tionIV-A),researchershaveproposedmanydefensestoprotect
#include <stdio.h> class A {
#include "A.hpp" public: these dynamic calls. To evaluate how they are affected by
virtual int a1(); unsafecopyrelocations,wecomeupwithasimpleexploitation
// hardcoded symbol for class A’s vtable };
extern unsigned long _ZTV1A[]; test as shown in Figure 12.
void hijack(void) { A.cpp The test program has two parts. The first part is a library
printf("vulnerable!\n"); which defines a class A with a virtual method (A.hpp and
} #include "A.hpp"
A.cpp). The second part is an executable which allocates
int main() { int A::a1() { an instance obj of the class and invokes the virtual method
// corrupt A’s vtable slot for return 1;
// method a1 as if an attack happens } (main.cpp). In the executable, we hard-code the symbol
_ZTV1A[2] = (unsigned long) hijack; name used for A’s vtable (_ZTV1A) and perform an emulated
Makefile memory corruption on the function pointer of the virtual
// allocate an object and make
// the virtual call all: main.cpp A.cpp method A::a1 in A’s vtable and see if it is accepted by the
A *obj = new A(); g++ -fPIC -shared \ evaluated defense deployed on this program.
obj->a1(); A.cpp -o libA.so
g++ -L. -lA \ We evaluate a set of six CFI defenses and show the results
return 0;
} main.cpp in Table III. We choose these defenses because they apply to
C++ programs on Linux. An effective defense must check the
pointer to the vtable to defend against COOP attacks [38] but
Fig. 12: A test program for vtable defenses. must also check the actual value of the function pointer in the
vtable to defend against COREV. Only defenses that check
both targets protect against COREV and COOP.
Among the defenses, three are vulnerable to unintended
4)Format String (libow): We identified a dynamic library
copy relocations because they assume read-only protection for
(libow-3.1 [1]) that exports a set of 22 format strings, causing
vtables and only check if the vtable pointer points to a valid
three different executables (owftpd – an ftp server, owserver –
vtable (see Section IV-A). Interleaving [10] does not currently
a backend server for 1-wire control, and owexternal) to copy
supportdynamiclinkingsoweevaluateitsvulnerabilitybased
them into writable memory at runtime. These format strings
ontheirproposedinstrumentation.SafeDispatch[26]proposes
are for debugging purposes, and we show one of them in Fig-
twodifferentinstrumentationswherethefirstchecksthevirtual
ure 11. The format string mutex_unlock_failed is de-
method target and the other checks the vtable pointer. It
fined in the libow-3.1 library and exported in a header file. As
claimsthelatterprovidesbettersecurityregardingCOOP-style
aresult,anexecutablethatincludestheheaderfileandusesthe
library-provided macro my_pthread_mutex_lock will
attacks[38].However,thelatterisvulnerabletoCOREV-based
vtable corruption attacks.
causetheformatstringtoberelocated.Ifanadversarycorrupts
the relocated format string and exploits a concurrency bug
to cause the mutex lock operation to fail, she can potentially E. Other Platforms
launchprintf-orientedprogrammingandachievearbitrarycode
Dynamic linking is enabled by default on major operating
execution.
systems such as Windows and macOS. We evaluate COREV
implications on the dynamic linking implementations on both
D. Affected Defenses Windows and macOS.
In this section, we evaluate how unsafe copy relocations Recall that the cause of copy relocations is due to the
affect current defenses. ambiguity in declaring external variables at source level (see
12Figure 2). Compilers cannot know whether these variables are strips the const attribute specified by the programmer. As
defined by another object file in the same binary or in a dy- a result, this enables an adversary to modify “read-only”
namic library. How compilers handle this ambiguity results in variables when exploiting a memory corruption vulnerability.
performance or security implications. To understand COREV We call this attack COREV for Copy Relocation Violation.
on other platforms, we compile the program in Figure 2 and This attack vector has existed for decades and, as we show
examine the generated instructions that access the external for Ubuntu 16.04, is widespread. The attack surface is broad
variable foo. with29,817librariesexportingrelocatableread-onlyvariables.
Thesetof6,399programswithactualunsafecopyrelocations
1)Windows: The MSVC linker on Windows refuses to
includesftpservers,apt-get,andgettextoutof4,570packages.
build the example program. This is because the MSVC com-
piler requires the program to explicitly specify an external An attacker can use COREV to escalate her privileges,
library variable using the __declspec(dllimport) at- leveragingamemorycorruptionvulnerabilitytomodifyformat
tribute in addition to the extern keyword. Otherwise, the strings, file names, vtables, code pointers, or other supposedly
declared external variable is assumed to be defined in another read-only data. We discuss three possible mitigation strategies
objectfilethatlinkstothesamebinary.Ifthelinkercannotfind that (i) detect the attack vector by analyzing binaries and
the symbol definition when performing static linking, it will libraries – as a fast mitigation, (ii) mitigate the attack through
report an error rather than creating a copy relocation. Thus, recompilation (if possible), or (iii) change the toolchain to
Windows removes the ambiguity by forcing declarations to make the linker and loader aware of source level permissions
be explicit, removing the need for copy relocations. Through even for externally defined variables.
theseannotations,theMSVCcompilercanachievehighperfor-
mance for symbols in the same module and keep permissions
ACKNOWLEDGEMENT
for symbols in other modules. Hence COREV does not affect
Windows. We thank our shepherd, Engin Kirda, and the anonymous
reviewers for their constructive feedback on this work. The
2)macOS: macOS handles the ambiguity by making the
work was supported, in part, by the National Science Foun-
opposite assumption of Linux, trading performance for safety.
dation under grants number CNS-1408880, CNS-1513783,
The compiler assumes all variables declared as external are
and CNS-1657711. The research reported here was supported
potentially from dynamic libraries, and generates instructions
in part by the Defense Advanced Research Projects Agency
in Figure 6 (a) for external variables. This is the mitigation
(DARPA) under agreement number N66001-13-2-4040. The
approach we proposed in Section V-B. Naturally, accesses to
viewsandconclusionscontainedhereinarethoseoftheauthors
library variables use the GOT indirection. Consequently, copy
and should not be interpreted as necessarily representing the
relocationsdonotexistonmacOSandCOREVdoesnotaffect
official policies or endorsements, either expressed or implied,
macOS either.
ofanyoftheaboveorganizationsoranypersonconnectedwith
However, memory corruption over “read-only” data is still them.
possible on macOS. Specifically, based on our observation,
the compiler allocates read-only data that potentially requires
REFERENCES
runtime relocation from the __DATA.__const section. For
example, code pointers in vtables may require adding the [1] libow-3.1.http://packages.ubuntu.com/xenial/libow-3.1-1.
module loading base at runtime, and thus are allocated from [2] RELRO - a memory corruption mitigation technique. http://tk-blog.
the __DATA.__const section. This supposedly read-only blogspot.com/2009/02/relro-not-so-well-known-memory.html.
section is, however, mapped as read-write at runtime. We [3] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-flow
integrity,” in Proceedings of the 12th ACM conference on Computer
testedtheexampleprograminFigure12andexaminedseveral
andcommunicationssecurity. ACM,2005,pp.340–353.
system libraries such as libc++.dylib on macOS 10.12.
[4] M.Abadi,M.Budiu,U.Erlingsson,andJ.Ligatti,“Atheoryofsecure
This design simplifies the implementation of the dynamic
control flow,” in Proceedings of the 7th International Conference on
loader. If the relocated data (i.e., the code pointers) resides on FormalMethodsandSoftwareEngineering,ser.ICFEM’05,2005.
writable pages, the loader can freely patch relocations at any
[5] S. Andersen and V. Abella, “Data execution prevention. changes to
timewithoutworryingaboutpagefaults.Unfortunately,similar functionalityinmicrosoftwindowsxpservicepack2,part3:Memory
tothesecurityconcernsraisedbyCOREV,thisdesignweakens protectiontechnologies,”2004.
the security of applications by exposing memory corruption [6] S.V.Archives,“Wu-ftpdremoteformatstringstackoverwritevulner-
targets to an adversary, enabling her to launch attacks and/or ability,”2008.
bypass defenses. [7] M.Backes,T.Holz,B.Kollenda,P.Koppe,S.Nu¨rnberger,andJ.Pewny,
“You can run but you can’t read: Preventing disclosure exploits in
executablecode,”inProceedingsofthe2014ACMSIGSACConference
VIII. CONCLUSION onComputerandCommunicationsSecurity. ACM,2014,pp.1342–
1353.
Dynamicloadingenablesmodularityandreducesthemem- [8] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic, E. Kirda,
ory footprint of applications. Due to the incomplete mapping C.Kruegel,andG.Vigna,“Saner:Composingstaticanddynamicanal-
between source level primitives (like extern const) and ysis to validate sanitization in web applications,” in IEEE Symposium
onSecurityandPrivacy(Oakland2008). IEEE,2008,pp.387–401.
imported and exported symbols on the ELF/binary level,
[9] M. Bishop and M. Digler, “Checking for race conditions in file
memory protection information is inadvertently lost. When
accesses,”ComputerSystems,vol.9,no.2,Spring1996.
an executable references a read-only variable exported from a
[10] D.Bounov,R.Kici,andS.Lerner,“Protectingc++dynamicdispatch
library, the dynamic loader ld.so relocates this variable into
throughvtableinterleaving,”inNetworkandDistributedSystemSecu-
thewritable.bsssectionoftheexecutable,whicheffectively ritySymposium(NDSS),2016.
13[11] N. Burow, S. A. Carr, J. Nash, P. Larsen, M. Franz, S. Brunthaler, [34] M. Payer, A. Barresi, and T. R. Gross, “Fine-grained control-flow
andM.Payer,“Control-FlowIntegrity:Precision,Security,andPerfor- integrity through binary hardening,” in Detection of Intrusions and
mance,”ACMComputingSurveys,2017. Malware,andVulnerabilityAssessment. Springer,2015,pp.144–164.
[12] N.Carlini,A.Barresi,M.Payer,D.Wagner,andT.R.Gross,“Control- [35] M.PayerandT.R.Gross,“ProtectingApplicationsAgainstTOCTTOU
flow bending: On the effectiveness of control-flow integrity,” in Pro- RacesbyUser-SpaceCachingofFileMetadata,”inVEE’12:Proc.8th
ceedings of the 24th Usenix Security Symposium (USENIX Security), Int’lConf.VirtualExecutionEnvironments,2012.
2015. [36] A.Prakash,X.Hu,andH.Yin,“vfGuard:Strictprotectionforvirtual
[13] S. Chari, S. Halevi, and W. Venema, “Where do you want to go functioncallsincotsc++binaries.”inNetworkandDistributedSystem
today? escalating privileges by pathname manipulation.” in Network SecuritySymposium(NDSS),2015.
andDistributedSystemSecuritySymposium(NDSS),2010. [37] R.Roemer,E.Buchanan,H.Shacham,andS.Savage,“Return-oriented
[14] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman, M. Frantzen, programming: Systems, languages, and applications,” ACM Transac-
and J. Lokier, “Formatguard: Automatic protection from printf format tions on Information and System Security (TISSEC), vol. 15, no. 1,
stringvulnerabilities.”inUSENIXSecuritySymposium(USENIXSecu- p.2,2012.
rity),vol.91. Washington,DC,2001. [38] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
[15] S.Crane,C.Liebchen,A.Homescu,L.Davi,P.Larsen,A.-R.Sadeghi, T. Holz, “Counterfeit object-oriented programming: On the difficulty
S.Brunthaler,andM.Franz,“Readactor:Practicalcoderandomization of preventing code reuse attacks in C++ applications,” in 2015 IEEE
resilienttomemorydisclosure,”in2015IEEESymposiumonSecurity SymposiumonSecurityandPrivacy(Oakland). IEEE,2015,pp.745–
andPrivacy(S&P2015),18-20May2015,SanJose,California,USA, 762.
2015. [39] A.Seshadri,M.Luk,N.Qu,andA.Perrig,“SecVisor:Atinyhypervisor
[16] J. Criswell,N. Dautenhahn, and V.Adve, “KCoFI: Completecontrol- to provide lifetime kernel code integrity for commodity OSes,” ACM
flowintegrityforcommodityoperatingsystemkernels,”in2014IEEE SIGOPSOperatingSystemsReview,vol.41,no.6,pp.335–350,2007.
SymposiumonSecurityandPrivacy(SP). IEEE,2014,pp.292–307. [40] P. Team. (2003) Address Space Layout Randomization (ASLR).
http://pax.grsecurity.net/docs/aslr.txt.
[17] CWE,“CWE-59:ImproperLinkResolutionBeforeFileAccess,”http:
//cwe.mitre.org/data/definitions/59.html. [41] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U´. Erlingsson,
L.Lozano,andG.Pike,“Enforcingforward-edgecontrol-flowintegrity
[18] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose, “Stitching the
ingcc&llvm,”inUSENIXSecuritySymposium,2014.
gadgets:Ontheineffectivenessofcoarse-grainedcontrol-flowintegrity
protection,” in 23rd USENIX Security Symposium (USENIX Security). [42] H.Vijayakumar,X.Ge,M.Payer,andT.Jaeger,“JIGSAW:Protecting
SanDiego,CA:USENIXAssociation,Aug.2014,pp.401–416. resourceaccessbyinferringprogrammerexpectations,”in23rdUSENIX
SecuritySymposium(USENIXSecurity),2014,pp.973–988.
[19] U.Drepper,“Howtowritesharedlibraries,”RetrievedJul,vol.16,p.
2009,2006. [43] C.Zhang,S.A.Carr,T.Li,Y.Ding,C.Song,M.Payer,andD.Song,
“VTrust:Regainingtrustonvirtualcalls,”inNetworkandDistributed
[20] X. Ge, W. Cui, and T. Jaeger, “GRIFFIN: Guarding control flows
SystemSecuritySymposium(NDSS),2016.
using intel processor trace,” in Proceedings of the 22nd International
ConferenceonArchitecturalSupportforProgrammingLanguagesand [44] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song, “VTint:
OperatingSystems(ASPLOS). ACM,2017. Protectingvirtualfunctiontables’integrity.”inNetworkandDistributed
SystemSecuritySymposium(NDSS),2015.
[21] X. Ge, N. Talele, M. Payer, and T. Jaeger, “Fine-grained control-flow
integrityforkernelsoftware,”inIEEEEuropeanSymposiumonSecurity
andPrivacy(EuroSP). IEEE,2016.
[22] X.Ge,H.Vijayakumar,andT.Jaeger,“Sprobes:Enforcingkernelcode
integrityonthetrustzonearchitecture,”inProceedingsofthe3rdIEEE
MobileSecurityTechnologiesWorkshop(MoST2014),May2014.
[23] E. Goktas, E. Athanasopoulos, H. Bos, and G. Portokalidis, “Out of
control:Overcomingcontrol-flowintegrity,”inProceedingsofthe35th
IEEESymposiumonSecurityandPrivacy,May2014.
[24] N.Hardy,“Theconfuseddeputy,”OperatingSystemsReview,vol.22,
pp.36–38,1988.
[25] E. Hiroaki and Y. Kunikazu, “ProPolice: Improved stack-smashing
attackdetection,”IPSJSIGNotes,pp.181–188,2001.
[26] D.Jang,Z.Tatlock,andS.Lerner,“Safedispatch:Securingc++virtual
calls from memory corruption attacks.” in Network and Distributed
SystemSecuritySymposium(NDSS),2014.
[27] J. Jelinek, “FORTIFY SOURCE,” https://gcc.gnu.org/ml/gcc-patches/
2004-09/msg02055.html,2004.
[28] W.S.McPhee,“OperatingsystemintegrityinOS/VS2,”IBMSyst.J.,
1974.
[29] B.NiuandG.Tan,“Modularcontrol-flowintegrity,”inProceedingsof
the35thACMSIGPLANConferenceonProgrammingLanguageDesign
andImplementation. ACM,2014,p.58.
[30] B.NiuandG.Tan,“RockJIT:Securingjust-in-timecompilationusing
modularcontrol-flowintegrity,”inProceedingsofthe2014ACMSIG-
PLANConferenceonComputerandCommunicationsSecurity. ACM,
2014,p.58.
[31] B.NiuandG.Tan,“Per-inputcontrol-flowintegrity,”inProceedingsof
the22ndACMSIGSACConferenceonComputerandCommunications
Security. ACM,2015,pp.914–926.
[32] PaXTeam,“DocumentationforthePaXproject-overalldescription,”
https://pax.grsecurity.net/docs/pax.txt,2008.
[33] M.Payer,“ToomuchPIEisbadforperformance,”ETHZurichTech-
nicalReporthttp://nebelwelt.net/publications/files/12TRpie.pdf,2012.
14