SPL: An access control language for security policies with complex constraints
CarlosRibeiro,Andre´ Zu´quete, PauloFerreiraand PauloGuedes
IST /INESC Portugal
E-mail: (cid:0) Carlos.Ribeiro,Andre.Zuquete,Paulo.Ferreira,Paulo.Guedes
(cid:1)
@inesc.pt
Abstract different environments, which makes understanding and
managingglobalpoliciesoforganizationsmuchmoredif-
ficult.
Mostorganizationsuseseveralsecuritypoliciestocon- The cooperation between MAC (Mandatory Access
trol different systems and data, comprising in this way a Control) and DAC (Discretionary Access Control) poli-
global complex policy. These security policies are often cies to achieve DAC flexibility and MAC resistance to
scattered over different environments, each one with its Trojan Horse attacks, is one of the earliest examples of
own security model and domain of administration, mak- cooperation between policies. However, there are many
ing them difficult to administer and understand. More- other useful forms of cooperation between policies with
over, some applications (e.g. workflow), often need to differentobjectives.
cross several of these security domains and satisfy each Forinstance, anorganizationmaywishtogivetoeach
oneoftheirpolicies,whichisverydifficulttoaccomplish employee the control over the documents they produce
whenthesepoliciesarescatteredovertheorganization,in but, for payment orders, the organization may want to
conflictwitheachotherandfrequentlyexpressedindiffer- denytherighttoapprovethemtothosewhohavewritten
entmodels. thepaymentorders. ThiscanbeaccomplishedbyaDAC
This work presents a security policy language that al- policycombinedwithasimpleseparationofdutypolicy.
lows organizations to express and keep their global se- Anotherorganizationmaywishtohaveaveryloosepol-
curitypoliciesinonesingledescription.Althoughflexible icyonmostofitsdepartments,inwhichonlyafewactions
enoughtoexpresssimultaneouslyseveraltypesofcomplex areforbidden,butinoneofthemhaveaverystrictpolicy
securitypolicies,thislanguagecanbeeasilyimplemented inwhichonlyafewactionsareallowed. Thisisacombi-
byaneventmonitor. nationofanopenpolicywithaclosedone.
Theproposedlanguagecanexpresstheconceptsofper- Unfortunately,it is not possible to predict which com-
mission and prohibition, and some restricted forms of binationsaregoingtobeusefuloneverysituationoreven
obligation. We showhowtoexpressandimplement obli- thepoliciesthataregoingtobeneeded.
gationusingthetransactionconcept,andhowtouseobli- Latelytherehasbeenaconsiderableinterestinenviron-
gation to express information flow policies together with ments that support multiple and complex access control
othercomplexsecuritypolicies.Wealsoaddresstheprob- policies, [3, 4,11, 12,19, 22,24, 27,39]. Ourwork fol-
lem of conflicting policies and show how to efficiently lowsthatpathandtriestoprogressintermsofexpressive-
enforce the security policies expressed by the language nessandfunctionality.
withasecurityeventmonitor,includinghistory-basedand Thispaperdefinesasecuritypolicylanguage(SPL)that
obligation-basedsecuritypolicies. isflexibleenoughtoexpresssimultaneouslyseveraltypes
ofcomplexauthorizationpolicies,andneverthelessiscon-
structed with simple elements that can easily be imple-
1. Introduction mentedbyasecurityeventmonitor.
Oneoftheproblemsofputtingtogetherseveralpolicies
Overtheyears,severalaccesscontrolpolicieshavebeen
on the same environment is the conflict that arises from
proposed in the literature. Although these policies cover
contradictorydecisionsproducedbythedifferentpolicies.
many different situations and data types, they are often
SPL solves this problem by forcing security administra-
considered in isolation. This is not suitable for organi-
tors to take priority decisions on every policy composi-
zations with complex structures and several data types,
tion.
which requires the simultaneous use of different access
Most multi-policyenvironments support several forms
control policies. Moreover, policies are scattered overofdiscretionaryandmandatoryaccesscontrolpoliciessi- 2.1.Entities
multaneously.Somesupportrolesandhistory-basedpoli-
cieslike the Chinese wallpolicyand severalother forms SPLentitiesaretypedobjectswithanexplicitinterface
of separation of duty. However, to our knowledge, none bywhichtheirpropertiescanbequeried. Entities canbe
allowsthecombinationofgeneralinformationflow poli- internalorexternaltothesecurityservice. Queriesonthe
cies with other policies. In this paper, we present an in- interfaceofexternalentitiesaretranslatedintomethodor
formation flow policyexpressed in SPL, that can coexist function callsontheobjectsorservicesofthoseentities.
withotherpoliciesandmakeuseofthem.Thisisachieved Ideally, these queries should not have secondary effects.
throughadifferenttypeofrulethatcomprisestheobliga- Inpractice,thiscanonlybeassuredbythesecurityservice
tionconcept. if each of those methods and functions has been verified
Theobligationconceptisaverypowerfulconcepttoex- andannotatedasstateless.
press security policies, howeverit is very difficult to en- Queryingexternalentitiesisnotusuallyconsideredsafe
force within a security monitor. We show that by using in security services, due to the covert channels that may
thetransactionconcept,anaccesscontrolservicebasedin result. For instance, an unclassified user can become
SPLmayenforcesomeformsofobligation. awareofclassifieddatabyexecutinganactionwhoseac-
Wealsoshowhowtoefficientlyimplementbothobliga- ceptability depends on that data and verifying if the ac-
tionandhistory-basedpolicies,bybuildinganSPLcom- tion fails or not. Nevertheless, this technique is essen-
pilerabletooptimizetheinformationnecessarytoimple- tialtoachievetheflexibilityandexpressivenessnecessary
mentthosepolicies. to some systems and applications [16]. To minimize the
Theremainderofthepaperisorganizedasfollows.Sec- risk,anSPLpolicyshouldbeverifiedbeforebeingimple-
tion2presentsSPLstructureandbasicblocks(rules,en- mented, to assurethateveryoperationwhich dependson
tities,setsandpolicies). Section3showshowtoexpress propertiesofexternalentitiesisallowedonlyifthequery
three special types ofconstraints: history,obligation and ofthosepropertiesisallowed.However,itshouldbenoted
invariantconstraints. Section4showssomepolicyexam- thatthisdoesnotpreventimplicitflow[13],ortimechan-
ples,includinganinformationflowpolicy. Section5dis- nels.
cusses implementation notes and shows performance re- Some of the entities manipulated by SPL are internal
sults. Section6discussesrelatedwork. Finally,insection to SPL, like sets and policies, but most are external, like
7weconcludethepaper. users,files,andevents.Thepropertiesofeachexternalen-
titydependsheavilyontheplatformthatimplementsthose
entities. Forexample,ausermayhavejusttheproperties
2. SPLStructure & Basic Blocks
nameandhome-host,orhecanhavethoseandaclearance
level, a signature ID and many others. This means that
SPL is a policy-oriented constraint-based language. It SPL does not restrict the properties of entities to a fixed
iscomposedoffourbasicblocks: entities,sets,rulesand set,insteadittakesadvantageofeverypropertyavailable
policies. The fundamental block of the language is the toincreasethepowerofpolicies.
rule. Rules express constraints in terms of relations be- OnmanySPLtargetplatforms, theSPLentitysetmay
tween entities and sets. Policies are complexconstraints formapolymorphichierarchy,whereeachentityisaspe-
thatresultfromthecompositionofrulesandsetsintolog- cialization of some other entity. In Figure 1, it is shown
icalunits. Policiescanalsobecomposedintomorecom- theentitytypehierarchyusedintheexamplesofthenext
plexpoliciesuntilitformsaglobalandsinglepolicy. sections. Ontherootofthishierarchyisthe“object”en-
Policies are a key concept of SPL, they provide the tity type. The remaining entitytypes aredefined byspe-
structure needed to build complexaccess control models cializationofthisbasetype.
(e.g.RBAC,DAC,TRBAC).Infact,SPLgoesbeyondthe
simpleenumerationofrules. Itallowsfortheassociation 2.2.Sets
ofrulesandsetsintopoliciescomprisingthelogicalunits
of the desired model (see section 4.3). Therefore SPL is Entitiescanbeclassifiedintosets. Setsareessentialin
model-independent but not model-less, it allows for the anypolicyconsideringthattheyprovidethenecessaryab-
definition of complex RBAC models with parameterized stractiontoachievecompactness,generalizationandscal-
roles[20,26]andcomplexroleconstraints. Italsoallows ability.Withoutsets,eachrulehadtoberepeatedforeach
for the definition of several forms of multilevel security entitytowhichtheruleapplies.
[1]andrelaxedformsofinformationflowsecurity. Sets, like any other entity, may be internal or exter-
In this section we present in detail each of the basic nal. Some external sets are very useful to the definition
blocks comprising SPL and show how they are used in of policies. For instance the sets of all users and all ob-
writingSPLsecuritypolicies. jectsknowntothesystem(Figure2).type object
(cid:2)
string name; // The name of the object
user owner; // The owner of the object
string type; // A string identifying the type
object set groups;// The sets containing the object
string homeHost; // The host where the user
(cid:3) // is defined
type user extends object
(cid:2)
rule set userPolicy; // User private policies
(cid:3)
type operation extends object
(cid:2)
number ID; // operation Id
(cid:3)
type event extends object
(cid:2)
user author; // The author of the event
object target; // The target of the event
operation action; // The performed action
object set parameter;// The set of parameters
number time; // The time instant
object task; // The task to which the event
(cid:3) // belongs to
Figure 1. Example of an entity type hierarchy
definition.
external string localhost; // An external entity
external user set AllUsers; // All the users
// in the system
external object set AllObjects; // All the objects
external operation set AllActions; // All the actions
external event set AllEvents; // All the events,
// past and future
Figure 2. Examples of external entities and
sets.
SPLsupportstwotypesofsets: categoriesandgroups.
Categoriesaresetsdefinedbyclassificationofentitiesac-
cording to their properties, e.g. all users logged in ma-
chineA,andgroupsaresetsdefinedbyexplicitinsertion
and removal of their elements. Insertion and removal of
membersintoagroupcanonlybedonebyexternalevents
since SPL should not perform operations on external or
internalentitiesthatresultinchangesofstate. Bothcate-
goriesandgroupsaredeclaredassets,butareinstantiated
differently.
// Example of use of the restriction operator
// A category of all users that are defined locally
user set localUsers =
AllUsers@
(cid:2)
.homeHost = localhost (cid:3) ;
// A group defined as empty
user set ActiveGroup =
(cid:2)
(cid:3) ;
Figure3.Exampleofacategoryandagroup.
Categories are defined by restricting the elements of
other sets to the ones with particular properties. This is
done by the SPL restriction operator (myset@
(cid:4)
logical-
expression
(cid:5)
tion2.3,forrestrictiononrules). Therestrictionoperator
has two operands, one is the set that it wants to restrict,
andtheotherisalogicalexpressionthatmustbesatisfied
by the elements in the set in order to belong to the re-
strictedset. Thelogicalexpressionusespropertiesofthe
elementsinthesettodefinewhichmembersareselected.
Thesepropertiesarewrittenwithadotbeforethename.
SPLdefinesfivemoresetoperators: theindexoperator
(
), which is a polymorphic operator that can
beusedonanytypeofsetorrule(Figure3)(seealsosec-
(cid:6)(cid:8) (cid:7)(cid:10) (cid:9)(cid:12) (cid:11)(cid:12) (cid:13)(cid:15) (cid:14)(cid:16)(cid:17) (cid:13)(cid:19) (cid:18)(cid:10) (cid:20)
),thatappliedtoasetreturnsthenthelement
of the set; the membership operator (element IN myset);
thecardinaloperator(
(cid:21)(cid:22) (cid:6)(cid:8) (cid:7)(cid:23) (cid:9)(cid:12) (cid:11)(cid:24) (cid:13)
)thatreturnsthenumberof
elementsin a set; the joinoperator(
(cid:6)(cid:8) (cid:7)(cid:23) (cid:9)(cid:24) (cid:11)(cid:12) (cid:13)(cid:26) (cid:25)(cid:28) (cid:27)(cid:29) (cid:6)(cid:30) (cid:7)(cid:23) (cid:9)(cid:12) (cid:11)(cid:12) (cid:13)(cid:19) (cid:31)
);
andthemeetoperator(
(cid:6)(cid:30) (cid:7)(cid:23) (cid:9)(cid:12) (cid:11)(cid:12) (cid:13)(cid:26) (cid:25)! " (cid:6)(cid:8) (cid:7)(cid:23) (cid:9)(cid:24) (cid:11)(cid:12) (cid:13)(cid:19) (cid:31)
).
2.3.Constraintrules
SPL is a constraint-based language. Constraint lan-
guages arewidely usedtoexpresssystems, plans[38] or
accesscontrolpolicies[4].
The language is composed of individual rules, which
arelogicalexpressionsthatcantakethreevalues:“allow”,
“deny”,and“notapply”.Theirgoalistodecideontheac-
ceptability of each event under the control of the access
control service that implements the language. To make
thisdecision,ruleshaveanimplicitparameterthatrepre-
sentstheeventuponwhichtheruleisdeciding. Because
thiseventisusuallythecurrentevent,itisreferredas“ce”.
A rule can be simple or composed. A simple rule is
comprisedoftwologicalbinaryexpressions,onetoestab-
lish the domainofapplicabilityand another to decide on
theacceptabilityoftheevent.
[label :] domain-expression :: decide-expression
Figure4.SyntaxofasimpleSPLrule.
The SPL syntax for a simple rule (Figure 4) has two
parts: an optional label and two logic expressions sepa-
rated bya specialmarker(’::’), representingthedomain-
expressionandthedecide-expressionrespectively.
The domain and decide expressions are simple binary
expressions with the logic operators ’
#
’, ’
$
’ and ’
%
’,
respectively for the conjunction, disjunction and nega-
tion,theequality/inequalityoperators’
&
’,’!
&
’,’
’
’,’
(
’,
’
() &
’,’
&* ’
’,andthespecialvalues“true”and“false”.
Thedomain-decideconstructionshouldnotbeconfused
with a simple binary implication. If a binary implica-
tion was used, every rule would be implicitly open, i.e.
it would allow every event not in the domain, which is
contrary to SPL design principle of being a model inde-
pendentlanguage.
Figure5,showstwosimplerules,labeled’OwnerRule’
and’DutySep’respectively.Thefirstonestatesthatevents// Every event on an object owned by the
// author of the event is allowed
OwnerRule: ce.target.owner = ce.author :: true;
// Payment order approvals cannot be done
// by the owner of payment order
DutySep: ce.target.type = "paymentOrder" &
ce.action.name = "approve"
:: ce.author != ce.target.owner;
Figure5.Simpleruleexamples.
actingonatargetobjectownedbytheauthoroftheevent
(ce.target.owner = ce.author) is always allowed (decide-
expressionalways true). Thesecondrulestatesthatpay-
mentorderapprovalsareonlyallowediftheauthorisnot
theownerofthepaymentorder.
The domain-decide type of construction described
aboveissimple, yet itismore powerfulthan the permis-
sionandprohibitionconstruction[23],inwhicheachrule
is exclusively a permission or a prohibition. A permis-
sion/prohibition rule just identifies the eventsthat are al-
lowed/denied from others. It cannot identify simultane-
ously the events that are allowed, the events that are de-
nied, and the events that are neither allowed nor denied.
Moreover,apermissionoraprohibitioncanbeexpressed
quitesimplywiththedomain-decideconstructionbymak-
ing the decide-expression true or false, respectively, for
everyeventwherethedomain-expressionistrue.
+ , + AND , + OR , NOT +
Allow Allow Allow Allow Deny
Deny Allow Deny Allow Allow
NotApply
- - -
NotApply
Allow Deny Deny Allow
Deny Deny Deny Deny
-
NotApply
- -
Table1.Tri-valuealgebraoperationsdefinition:
AND, OR and NOT.
.
// Implicit deny rule.
deny: true :: false; // Implicit deny rule.
allow: true :: true; // Implicit allow rule.
// Simple rule conjunction, with default deny value
OwnerRule AND DutySep OR deny;
// Simple rule conjunction, with default allow value
OwnerRule AND DutySep AND allow;
// DutySep has a higher priority then OwnerRule
DutySep OR (DutySep AND OwnerRule);
Figure6.Composingruleswithatri-valuealge-
bra.
being “allow” or “deny” in conjunction/disjuntions as
shownin Figure6. Anotherinteresting constructionpre-
sented in Figure 6, shows how to express priorities be-
tween rules. The result of the composition is the result
of the “DutySep” rule, except when this rule is not ap-
plicable, in which case the result isequal to the result of
“OwnerRule”.
// Universal quantifier syntax
FORALL var IN set
stands for a variable
whichcanassumeanyvalue.
A rule can be composed of other rules through a spe-
cifictri-valuealgebrawiththreelogicoperators:conjunc-
tion(’AND’); disjunction(’OR’); and negation(’NOT’).
These operators behave as their binary homonyms if the
“notapply”valueisnotused(withthe“allow”and“deny”
being equal to“true” and “false”, respectively). The pri-
mary characteristic of this logic is that the “notapply”
valueistheneutralelementofeveryoperation(Table1).
This tri-value logic allows some interesting constructs
for access control expressiveness. For instance, a de-
faultvaluecanbe expressedusing specialrules inwhich
the domain-expression is always true and the decide-
expressionistrueorfalsedependingonthedefaultvalue
(cid:2)
ruleskeleton(var) (cid:3)
// Existential quantifier syntax
EXIST var IN set
(cid:2)
ruleskeleton(var) (cid:3)
Figure 7. Universal and existential quantifiers
syntax.
Inordertoincreasetheflexibilityofcomposition,SPL
defines universal and existential quantifiers over rules.
These quantifiers aredefined asthe tri-valueconjunction
or disjunction of all the rules resulting from the replace-
mentoftheenumerationvariableintheruleskeleton, by
eachvalueintheset(Figure7).
// Apply all rules in the userPolicy set restricted
// to targets of the same owner
FORALL r IN u.userPolicy (cid:2) r @
(cid:2)
.target.owner = u
(cid:3)
(cid:3)
Figure 8. Example of the restriction operand
appliedtorules.
Rulesdonothavetobewrittenatthesametimebythe
sameauthor,infacttheyareusually writtendynamically
byseveralauthors. Oftenitisnecessarytorestrictthedo-
main of applicability of a rule previously written, by the
same author or by a different one, without removing it
completely. Forinstance,arulemaystatethattheprivate
rules of users can only apply to target objects belonging
tothem. InSPLthisisachievedbyapplyingthepolymor-
phicrestrictionoperator(presentedinsection2.2)torulesand policies, in order to restrict their domain of applica-
bility(Figure8).
Therestrictionoperatorcanbeappliedtobothrulesor
policies.Itactsbyrestrictingtheeventstowhichtherules
or policies apply to those satisfying a specified logical
expression, e.g. given a rule
/
defined by the expres-
sions “
0(cid:30) 12 (cid:11)(cid:12) 34 (cid:11)(cid:12) (cid:16)(cid:17) (cid:13)(cid:19) 57 686(cid:22) 9: 1; (cid:11)(cid:12) 34 (cid:11)(cid:12) (cid:16)(cid:17) (cid:13)(cid:19) 5
and a logical expression
<
1; (cid:11)(cid:12) 3= (cid:11)(cid:12) (cid:16)(cid:17) (cid:13)(cid:19) 5
than the rule restriction “
/(cid:10) >
< may be repre-
sented by “
0(cid:30) 1; (cid:11)(cid:12) 3= (cid:11)(cid:24) (cid:16)(cid:17) (cid:13)(cid:19) 5(cid:19) #
<
1; (cid:11)(cid:12) 3= (cid:11)(cid:24) (cid:16)(cid:17) (cid:13)(cid:19) 5: 6?6@ 9: 1; (cid:11)(cid:12) 34 (cid:11)(cid:12) (cid:16)(cid:17) (cid:13)(cid:19) 5
, where
#
standsforthelogicalconjunction.
2.4.Policies
AnSPLpolicyisagroupofrulesandsetsthatgoverna
particulardomainofevents. Eachpolicyhasone“Query
Rule”(QR)identifiedbyaquestionmarkbeforethename
oftherule,thatrelatesalltherulesspecifiedinthepolicy.
Thisruleusesthealgebradefinedbeforetospecifywhich
rules should be enforced and how. Thedomain of appli-
cability of a policy is the domain of applicability of the
QR.
InaSPLpolicysomeofthesetscanbeparametersthat
are passed to the policy whenever it is instantiated (or,
more correctly, activated). This allows for the construc-
tion of several abstract policies, which may be activated
severaltimeswithdifferentparameters. Forinstance,itis
possible to havea generic DACpolicy, a generic separa-
tionofdutypolicy,orasimplegenericACLpolicy(Figure
9).
policy ACL(
user set AllowUsers, // Users that are allowed to
// perform restricted actions
object set ProtObjects, // The protected objects
interface RestrictActions) // The restricted actions
(cid:2)
?Psimple:
ce.action IN RestrictActions & // if event action
// is restricted
ce.target IN ProtObjects // and target object
// is protected then
::ce.author IN AllowUsers// the event is allowed
// if the author is allowed
(cid:3)
policy InvoiceManag
Figure 9. Generic policy implementing an ACL
tuple.
When instantiated, a policy acts as a rule and can
be included into another policy by composing it with
other rules through the tri-value algebra. As in several
object-oriented languages, instantiation is performed by
the “new” keyword. Figure 10 shows a security policy
(’InvoiceManag’)that activates an ACL policyand dele-
gatesintoitthedecisiononeventacceptability.
Theabilitytocomposepoliciesintomorecomplexpoli-
cies, using the tri-value algebra, is one of the important
(cid:2)
// Clerks would usually be a role
// but for simplicity here it is a group
user set clerks ;
// Invoices are all objects of type invoice
object set invoices =
AllObjects@ (cid:2) .doctype = "invoice" (cid:3) ;
// In this simple policy clerks can
// perform every action on invoices
DoInvoices: new ACL(clerks, invoices, AllActions);
?usingACL: DoInvoices;
(cid:3)
Figure 10. A simple example of policy instanti-
ation.
featuresofSPL,becauseitallowsforthedevelopmentof
librariesofcommonsecuritypolicies.Thesesecuritypoli-
ciescanthenbeusedasbuildingblocksformorecomplex
securitypolicies,thussimplifyingthespecificationofse-
curitypoliciesforcomplexorganizations.
The natural SPL policy sharing mechanism is delega-
tion,butSPLalsosupportspolicyinheritancetosimplify
some sharing situations. For example, defining a policy
similartoanotherpolicywithjustoneruleslightlydiffer-
ent is much more difficult with delegation than with in-
heritance. IntheexamplepresentedinFigure11itisde-
finedapolicythatextendsthe“InvoiceManag”policyby
restricting the domainof therule“DoInvoices”to events
withwriteactions.
Policy RestrictInvoiceManag extends InvoiceManag
(cid:2)
// Now only write actions are allowed
DoInvoices:
super.DoInvoices@ (cid:2) .action.name = "write" (cid:3) ;
// The query rule is inherited from the super
(cid:3)
Figure11.Exampleofpolicyinheritance.
SPLpoliciesareactiveonlyifinstantiatedandinserted
intoanotherpolicy,exceptforthemasterpolicy,whichis
activated implicitly by the security service. The result is
a hierarchical tree of activepolicies with the master pol-
icy on top. This structure has several advantages over a
flatone[4,23,39]. First,itclearlyidentifieswhichrules
arerelatedwitheachother,simplifyingtheglobalunder-
standingofthepolicy. Second,itallowsthedynamicac-
tivation and deactivationof policies, by inserting and re-
movingthemfromotherpolicies.Third,itpartiallysolves
theproblemofconflictingpolicies.2.5.ConflictSolving 3. SpecialConstraints
The language described in the previous section can be
used to express several types of constraints, including
SPLsupportsnon-monotonicpolicies,inthesensethat complex constraints that require special implementation
itisabletoexpressbothpositiveandnegativeconstraints considerations. In this section we show how to express
at the same time. The ability to express non-monotonic andimplementwithaneventmonitor,threespecialtypes
policies has long been recognized as very important for of constraints: history based constraints, obligation con-
the expressibility of security policies [24, 25]. Notably strainsandinvariantconstraints.
theC2levelofTCSECstandard[14]includesthisexplicit
requirement. 3.1.Historyconstraints
The increased expressibility added by non-
Severalsecurity policiesrequireeventstobe recorded,
monotonicity does not come without cost as it leads
in order to implement constraints with dependencies on
topotentialconflictsbetweencontradictoryrules.Usually
thepast.Amongthem,theChineseWallpolicy[10]isone
these conflicts are solved by the introduction of implicit
ofthebestknown. Butmanyotherformsofseparationof
priority algorithms that choose which rule overrides the
duty [34] and informationflow policies[28] also require
other. Some of these algorithms are very simple (e.g.
eventrecording.
negative rules overrides positive ones) others are more
The importance of history-based polices has been rec-
complex and use not only the rules type but also the
ognized by several authors [15, 32, 40], however to our
authorityoftherules’issuers(i.e. rulesissuedbyahigher
knowledge none was able to simultaneous express con-
authority manager override others), the specificity of the
ciselyandimplementefficientlyhistory-basedpolicies.
rules (often more specific rules should override more
In SPL history-based policies are expressed by simple
generic ones), and the issuing time of the rules (more
quantification rules over the abstract set PastEvents.
recentlyrulesoverrideolderones)[2,25]. Thisapproach
Eachoftheserulesdeclaresandquantifiesoneeventvari-
is very intuitive and natural, but it has some drawbacks.
able, used to classify each type of past event monitored
Itisnotunusualforahighauthoritativemanagertoissue
by the event monitor. Thus, to monitor a sequence of
a rule which may be overridden by a low authoritative
eventsinSPL,itisnecessarytocascadeseveralquantifi-
manager, or to express a mandatory general rule which
cationrulesoverthePastEventsset,oneforeachtype
shouldnotbeoverridden.
of event. Figure 12 shows a history-based policy which
Anotherstrategyistostratifythesecurityrulesandin-
denies any eventwith an action different from “read” on
cludeaspeciallayerofrulestodecidewhichrulesshould
a targetwhich has been “verified” and “approved”in se-
overridetheothers [3, 23]. SPLfollowsthisstrategybut
quence.
instead of creating a special layer of rules to solve con-
flicts, SPL forces the security administrator to combine
policiesintoauniquestructurewhichisbydefinitionfree policy HistorySequence
of conflicts. In SPL, every active security policy must
be in the hierarchical delegation tree of policies. There-
fore, if two active policies give conflicting results to the
sameevent(onedenyingit,andtheotherallowingit),then
somewhereupthehierarchicaltreetheymustbecombined
inonetri-valueexpressionthatinherentlysolvesthecon-
flict. If the two policies are combined using a tri-value
“AND”theeventisdenied. Iftheyarecombinedusinga
tri-value“OR”theeventisallowed.
However,this solutioncannot beapplied toeverytype
of security policy inconsistency, because (i) some types
of inconsistencies are not conflicts, and (ii) some should
not be solvedbyan automatic process. Forinstance, the
securityconflictsproducedbydesignerrorsshouldnotbe
implicitly solvedbecause that would masquerade thede-
signerror. In[31]wedescribeatoolthatisabletodetect
severaltypesofinconsistencies inSPLandcanbeeasily
expanded to check for inconsistencies between the secu-
ritypolicyandotherspecifications.
(cid:2)
?HistorySequence:
FORALL e1 IN PastEvents (cid:2)
FORALL e2 IN PastEvents
(cid:2)
ce.target = e1.target &
ce.target = e2.target &
e1.time < e2.time &
e1.action.name = "verify" &
e2.action.name = "approve"
:: ce.action.name = "read"
(cid:3) ;
(cid:3)
(cid:3)
Figure 12. A history-based policy with se-
quenceevents.
Thisapproachmakesitverysimpletoexpresshistory-
based policies based on simple sequences of events, but
slightlyhardertoexpresshistory-basedpoliciesbasedon
state machines. To express this type of polices it is nec-
essarytodefineoneeventvariableforeacheventleaving
each state and write constraints expressing the temporaldependenciesbetweenthoseevents. Neverthelesswebe-
lievethatmosthistory-basedpoliciesareofthefirsttype,
thusanystatemachinebasedapproachwouldbeunneces-
sarilycomplex.
3.2.Obligationconstraints
SPLisabletoexpresstheconceptsofpermission,pro-
hibition and obligation. While the first two are usually
supported by access control services, the last one is not.
Oneexceptionis[12],whichdefinesamodallogic,based
ondeonticlogictoexpresssecuritypolicies. However,al-
thoughitpresentsa cleardefinitionofobligation,itdoes
notproposeasolutiontoimplementitbyasecuritymon-
itororanyothertypeofsecurityservice.
3.2.1.Enforceableobligations
To act upon rules, a security monitor must know when
there is an attempt to violate them and what to do then.
On most security monitors the attempts of violation of
rulesbasedontheprohibitionconceptaredetectedwhen
an event requesting an action occurs, in which case, the
action requested is denied. With rules based on obliga-
tion the time at which a violation attempt occurs (viola-
tion attempt time) and the action to perform (default ac-
tion) when that happens are not so easy to define. First,
becauseagenericobligation(Statement1)doesnotneed
tohaveadeadline;andsecond,becausethereisnogeneric
actiontoperformincaseofviolationattempt.
Principle OmustdoAction O (1)
SPLdoesnotallowgenericobligations. Insteaditsup-
ports,withsomerestrictions,anotherusefulformofobli-
gationthatcomprisesatriggeraction(Statement2).
Principle OmustdoAction O
(2)
ifPrinciple ThasdoneAction T
Thisformofobligationhasamuchmoresimpledefini-
tionfor defaultaction thanthegenericobligation. While
with the generic type of obligation a system is in an un-
stable state until the obligation is fulfilled, with the trig-
geredobligationasystemhastwostablestates,onebefore
thetriggeraction andoneaftertheobligationisfulfilled.
Thus, when the trigger action is executed but the corre-
spondingobligationisnotfulfilled,thenaturaldefaultac-
tionforasystem,withthistypeofobligation,istoreturn
tothestablestatebeforethetriggeraction.
However, defining a default action does not by itself
solve the problem. Using simple logic it is possible to
rewritestatement2intostatement31,
1 AC BE D(cid:30) FC G= D(cid:30) BH GI A
Principle TcannotdoAction T
(3)
ifPrinciple OwillnotdoAction O
whichspecifiesaconstraintwithadependencyonafuture
action. Schneider[36]statesthatwithamonitorlikecon-
struction it is not possible to enforce a security policyin
which the acceptability of an execution depends on pos-
sible future executions. Informally his argumentis quite
simple. Given the sequences of executions
J(cid:23) K
and
J
, in
which
J
istheprefixofsomeexecutionof
J(cid:23) K
,itisnotpos-
sibletoallow
J
onthebasisthatoneofitsextensions
J(cid:23) K
is
allowed bythe security policy,because the system could
stopbefore
J(cid:23) K
.
Thekeyissueisthenotionofexecution. ToSchneider,
an execution is simultaneously the unit by which the se-
curity policy governs the execution of a system and the
only atomic unit present in the system. We believe that
thereareadvantagesinseparatingthesetwoconcepts. In
fact,itisnotunusualforatomicrequeststobecomposed
of several actions which are themselves subjected to the
security policy. Here atomic means in the sense of the
transaction ACID properties: either all happens or none
happens. Insidetheseatomicrequestsitispossibletode-
finesecuritypolicieswithdependenciesinfutureactions,
because it is not possible for a system to stop execution
beforethecompletesequencebeingexecuted.
Therefore,securitypolicieswithdependenciesinthefu-
ture are enforceable but only if they are confined to the
boundsofanatomicexecution. Thus, inorderforatrig-
gered obligation policyto be enforceable, it is necessary
thattheviolationattempttimebelessorequal totheup-
per bound of an atomic execution. Albeit restricted to
the bounds of atomic executions, this type of constraint
(triggeredobligation)isusefulinmanysituations. Forin-
stance,auserisobligedtoregisterafterstartusingasoft-
ware, orthe informationflowpolicypresentedin section
4.5.
In most situations it is possible to find a trigger action
foranobligation,howeveritisnotalwayspossibletoper-
formboth thetriggeractionandthe obligatoryaction in-
sideanatomicexecution,becausesomeactionscannotbe
undone, e.g. sending a document to a printer or show-
ingsometextonthescreen. Theseactionsarecalledreal
actions on transactionmanagement systems [21] and are
already knownto require special treatment by those sys-
temsinordertoachieveatomicity.Usuallysystemsdelay
theexecutionofsuchactionsuntilalltheotheractionsare
executed,butiftheseactionscannotbereorderedthesys-
temisnotabletoensureatomicity.
The problem is slightly more complex than in usual
transaction management systems because the set of ac-
tions identified as real actions must include actions that
change human knowledge state (e.g. showing some textonthescreen),whicharenotoftenconsidered.
3.2.2.Expressingobligations
ExpressinganobligationconstraintinSPLisassimpleas
expressingahistory-basedconstraint. Aswaspreviously
shown in section
L
3.2.1 the kind of obligations enforced
by SPL can be expressed as constraints with a depen-
dencyinthefuture.Therefore,bysymmetrywiththecon-
straints withdependenciesinthe past, thenatural wayto
expressanobligationconstraintin SPLisusing quantifi-
cationrulesoveraspecialabstractsetFutureEvents.
Asinthesymmetricsituation,eachofthoserulesdeclares
and quantifies one event variable, used to classify each
typeoffutureeventmonitored. Figure13showsanobli-
gation based policy which states that if someone exe-
cutesthegoodiesapplicationhe/shemusteventually
(inthenearfuture)registeritselfasauser. Anotherexam-
pleispresentedinFigure20, whereobligationisusedto
expressarelaxedformofinformationflowpolicy.
policy Register
(cid:2)
?Register:
EXIST fe IN FutureEvents (cid:2) ce.action.name = "execute" &
ce.target = "goodies" ::
ce.author = fe.author &
fe.action.name = "register" &
fe.target.name = "RegisterServer"
fe.parameters[0] = "goodies"
(cid:3) ;
(cid:3)
Aruleexpressedasstatedhasasimilarconstructionof
statement3,thusitcanbeexpressedandimplementedas
an“obligationtocomplywiththeinvariantcondition”.
4. Examples
In this section, we present some security policyexam-
ples expressed in SPL to show how SPL copes with dif-
ferenttypesofsecuritypolicyparadigms.
4.1.DAC
Although therearemanydifferentpoliciesintheDAC
categorytheyallshareacommonbasethatcomprisesthe
essentialofDAC.Thiscommonbasecanbeimplemented
by an SPL policy, that can later be used to build several
DACpolicies.
policy DAC
Figure13.Anobligation-basedpolicy.
3.3.Invariantconstraints
Aninvariantruleisaveryusefultypeofrule. Itspeci-
fiesthataconditiononsomeobjectpropertiesshouldhold
before and after every event. These rules are a special
typeofamoregeneralgroupofrulesthatareexpressedin
termsofresultsofactions,insteadofactionsthemselves.
SPLisanevent-orientedlanguageinthesensethatthe
goal of each rule is to decide if an event should be al-
lowedordenied;thus,invariantrulescannotbeexpressed
directly in SPL because their goal is not an event in it-
selfbuttheresultofthatevent. Asystemwitharulethat
allowseveryevent,ifaconditionholdsanddeniesitother-
wise,couldendupinadeadlock,becausetheeventwhich
caused the condition to be broken was already allowed
whenthesituationisdetected. However,iftherulestates
thataneventisallowed,ifforallthefollowingeventsthe
condition holds, and is denied otherwise, the system de-
niestheeventthatwouldhavebrokenthecondition, pre-
ventingit.
(cid:2)
// Owner can do everything to his objects
authorRule: ce.target.owner = ce.author :: true;
// User policies are applied restricted to their
// own objects
userPolicyRule:
FORALL u IN AllUsers (cid:2)
FORALL r IN u.userPolicy
(cid:2) r @ (cid:2) ce.target.owner = u (cid:3)M (cid:3) (cid:3) ;
// The policy denies any event not allowed by any
// of the rules
?DAC: authorRule OR userPolicyRule OR deny;
(cid:3)
Figure14.AnexampleofageneralDACpolicy.
ADACpolicyhastwoconstraints(Figure14). Thefirst
constraint states that the owner of an object can perform
everyactiononit. Thesecond,statesthateveryuserpol-
icyshouldberestrictedtothetargetsownedbytheowner
ofthepolicy. TheQRrulestatesthatifanyofthesecon-
straints allows an event to happen the event is allowed,
otherwiseitisforbidden.
SPL can express several types of separation of duty
policies. One of the simplest may be implemented with
therule“DutySep”presentedinfigure5. Thisrulestates
thatpaymentorderscannotbeapprovedbythesameusers
whowrotethem.
The combination of the “DutySep” rule with the DAC
policy presented in Figure 15, implements the policy
statedintheintroduction, where anorganizationgivesto
each employee the control over the documents they pro-
duce,withtheexceptionofpaymentordersthatcannotbe
approvedbythesomeuserthatwrotethem.
4.2.ChineseWall
TheChineseWallpolicyisamonotonicsecuritypolicy,
designed for open systems. Briefly the policy states thatpolicy DACSepDuty
(cid:2)
// A DAC instantiation
myDAC: new DAC;
// Payment order approvals cannot be done
// by the owner of payment order
DutySep: ce.target.type = "paymentOrder" &
ce.action.name = "approve"
::ce.author != ce.target.owner;
// Events are allowed only if both
// rules do not deny it
?DACSepDuty: myDAC AND DutySep;
(cid:3)
Figure 15. Combination of a DAC policy with a
separationofdutypolicy.
objects are classified into classes of conflicting interests,
andausercanaccesseveryobject,butonlyonefromeach
classofinterest.
There aremanyways to writethe ChineseWall policy
inSPLterms. Oneofthesimplestispresentedin Figure
16, in which only one class of interest is defined. The
policydefinesonesetandonerule. Thesetcontainsallthe
objectswiththesameconflictofinterests. Therulestates
that the current event is denied if the target of the event
isinthe“interestclass”andexistsapasteventperformed
bythesameuseronadifferenttargetthatbelongstothat
“interestclass”.
policy ChineseWall
(cid:2)
object set InterestClass;
?ChineseWall:
FORALL e IN PastEvents (cid:2)
ce.target IN InterestClass &
e.target IN InterestClass &
ce.author = e.author &
ce.target != e.target &
:: false
(cid:3) ; (cid:3)
4.3.Roles
Althoughtheydonotalwaysagreeonthedefinitionof
role[23]mostsecuritysystemsandservicessupportsome
formofrole-basedaccesscontrol(RBAC).
Roles can be very complex entities comprising con-
straintsonrolemembership,constraintsonroleactivation,
andconstraintsonroleuse[18,35,37]. Toallowallthese
constraintsandpossiblyothers,SPLrolesarethemselves
policiesthatcanbedefinedasrequiredandusedinother
policieswhenevernecessary.
Rolescanbecomposedofseveralsetsandconstraints.
However,thesimplerformofrolehasonlytwosets,one
withtheusersthatareallowedtoplaytheroleandanother
with the users who are playing the role. Obviously only
theusersinthefirstsetshouldbeallowedtobeinsertedin
thesecondset(Figure17).
policy simpleRole (user set Authorized,
user set Active)
Figure16. A specification for the Chinese Wall
policy.
Usually an organization implementing a Chinese Wall
policy has several classes of conflicting interests. The
above policy has just one class, but can be instantiated
severaltimes,oneforeachclassofinterest.
Thedecide-expressionoftherulehasaconstantvalue,
whichisconsistentwiththemonotonicityoftheChinese
Wall definition. This definition specifies which events
should be denied, but leaves for complementary policies
thedecisionupontheonesthatareaccepted.
(cid:2)
// Events inserting a user into
// the Active set are allowed only if
// that user is in the Authorized set
?simpleRole: ce.action.name = "insert" &
ce.target = Active
:: ce.parameter[1] IN Authorized ;
(cid:3)
Figure 17. The figure represents a simple role
policy.
In this model only the users who are in the active set
shouldhavethenecessaryauthorizationstoplaytherole.
Theseauthorizationsarenotincludedintheroletypedefi-
nitionbecausetheyaredifferentforeachspecificrole,but
theyareincludedinthedefinitionofeachspecificrole.
policy Clerk
(cid:2)
// All users of localhost are members of RoleUsers user set RoleUsers = AllUsers@ (cid:2) .host = localhost (cid:3) ;
// Invoices are all objects of type invoice
object set Invoices =
AllObjects@
(cid:2)
.doctype = "invoice" (cid:3) ;
// The set of users playing the role starts empty.
user set ActiveGroup =
(cid:2)
(cid:3) ;
// Members of RoleUsers may play the Clerk role
ClerkRule: new simpleRole(RoleUsers,ActiveGroup );
// All members of ActiveGroup may access Invoices
InvoiceRule:
new ACL(ActiveGroup, Invoices, AllActions);
?Clerk: ClerkRule AND InvoiceRule;
(cid:3)
Figure 18. Example of a specific policy instan-
tiation.Figure18,showsaspecificroledefinitionpolicy,which
states that users of “localhost” may assume the “Clerk”
roleandthatevery“Clerk”mayaccessinvoices.Thepol-
icy has two rules. One rule (“ClerkRule”) is an instan-
tiation of the “simpleRole” policy and defines the com-
ponents of the role. The other (“InvoiceRule”) is an in-
stantiationoftheACLpolicyanddefinesthespecificau-
thorizations of the role. The link between the two rules
isthe“ActiveGroup”set,whichissimultaneouslytheset
of users playing the role and the set of users allowed to
performactionsoninvoices.
4.4.ClosedandOpenpolicies
Security policies can be open or closed. Closed poli-
cies denyeverythingthat is not specifically allowed, and
openpoliciesalloweverythingthatisnotspecificallyde-
nied. Closed policies are generally considered safer but
openpoliciesareconsideredmoresuitableforlooseenvi-
ronments,suchastheonesusedincooperativework[16].
// A close policy
?Clerk: ClerkRule AND InvoiceRule OR deny
// An open policy
?Clerk: ClerkRule AND InvoiceRule AND allow
Figure 19. Different QR to transform the Clerk
policyintoaclosedoranopenpolicy.
The“Clerk”policydefinedinfigure18isneitherclosed
nor open. To be one or the other the domain of applica-
bility must be universal. Hence to make the “Clerk” an
openorclosedpolicyallisneededistomodifytheQRto
allow or deny the events not belonging to the domain of
theoriginalpolicy(Figure19).
4.5.Informationflowpolicy
AlthoughSPLisaconstraint-basedlanguage,itispos-
sible to express some relaxed forms of information flow
policieswithit.
Asoriginallyexplainedin[13],andformallyprovedin
[36],informationflowpoliciescannotbefullyenforcedby
eventmonitorsbecauseeventmonitorsdonotknowabout
otherallowedsequencesofexecutionsofthesameappli-
cation and thus they cannot know about implicit flows.
Implicitflowsresultfromtheknowledgeofthesequences
ofexecutionsallowedbyanapplication. Ifsomeapplica-
tion requires that variable
N
takes the value
O
whenever
variable
P
is greater than
Q
than there is a flow of infor-
mationfrom
P
to
N
althoughthereisnoexplicitstorage
pathforinformationonvariable
P
tovariable
N
rityrisk,whetherbecausetheinformationonvariablesde-
termining the sequenceofexecutionispublic orbecause
itisnotpossibletoinferthesequenceofexecutionsfrom
theresultsofthatsequence. Forthesesituationsitispos-
sible to define information flow policies enforceable by
securitymonitorsbecausetheregulationofexplicitinfor-
mationflowfromstoragetostoragecanbeperformedwith
justtheknowledgeofpastexecutions.
Nevertheless,SPLcannotenforceorevenexpresssuch
restricted form of information flow policybased only on
information from past executions. Because SPL is an
event-orientedlanguage,andeveryhistoryinformationis
event-baseditwouldbenecessarytoexpressapolicythat
recursivelyverifiesthe source ofeverypieceofinforma-
tion writtenbyinformation-flowevents,which are inthe
storage-path of the informationbeing written by the cur-
rentevent. ExpressingsuchapolicyinSPLitisnotpos-
sible both because SPLdoes notallow recursivepolicies
andbecauseitwouldincuronahighperformancepenalty.
Toexpresssuchinformationflowpolicies,SPLusesthe
obligation concept to force the application to summarize
theinformationflowintotheexistingSPLrules. Thepol-
icy in figure 20 states that each object that receives in-
formationfromanotherobjectshouldbesubjectedtothe
samesetofrulesastheoriginatorobject. Thisisachieved
by an obligation rule that forces the receiving object to
belongtothesamegroupsoftheoriginatorobject.
policy InfoFlow ()
.
However, in some situations [16] the information leak
resultingfromimplicitflowdoesnotposeaserioussecu-
(cid:2)
interface ReadFlowActions;
interface WriteFlowActions;
object set ProtObjects;
?InfoFlow:
FORALL pe IN PastEvents
(cid:2)
FORALL g IN pe.target.groups
(cid:2)
EXISTS fe IN FutureEvents
(cid:2)
ce.action IN WriteFlowActions &
pe.target IN ProtObjects &
pe.action IN ReadFlowActions &
ce.task = pe.task &
:: ce.target IN g
(cid:3)R (cid:3)S (cid:3) ;
(cid:3)
Figure20.Aninformationflowpolicy.
The?infoFlowruleoffigure20tracesindirectinfor-
mationflowbetweenreadandwriteeventsperformedby
thesametask. Therulestatesthatiftheactionofthecur-
rent event is a write action and the current task has read
a protected object (i.e. one of the events that has read
a protected object was done in the context of the task of
the current event), than there is a time in the future (i.e.
a future eventexists) in which allthe sets containing theprotected object also contain the target object. This rule
assures that every rule that applies to a protected object
which wasread by that task also applies to the receiving
object, including the rule itself, i.e. the receiving object
becomesaprotectedobjecttoo.
It should be noted that it is the application obligation
to ensure that all the sets are updated properly. The ap-
plicationcanperformthistaskeitherbyitselforbyusing
a security library created for that purpose. The security
monitor duty is to ensure that that obligation is fulfilled.
Thesecuritymonitorcannotupdateitselfthesetsbecause
itcannotperformoperationswhichresultinstatechanges.
Unlike other models where information flow policies
are defined, the SPL model allows non-monotonic poli-
cies. Thispropertymayproduceanuncommonresulton
someinformationflowpolicies. Whenthere isa permis-
sion rule that supersedes a prohibition rule, an object to
whichtheaccesswasrestrictedmaybecomeunrestricted
just because it receivedinformation from an unrestricted
object. Althoughuncommon,theresultiscorrectbecause
denying may not always be the safer action. For exam-
ple,anorganizationmaystatethatthepresidentshouldbe
able to access every document containing organization’s
classified data, but he does not need to be able to access
employer’s private data. If an employer includes classi-
fied data into a private document, that document should
becomeaccessibletothepresident.
5. Implementationand Results
Oneoftheproblemsofexpressivesecurityframeworks
like SPL, is the low efficiency of their implementations.
Whileusualframeworksbuiltuponaccesscontrollists,la-
belsorunixpermissionbitsweredesignedtobeefficient,
SPLwasdesignedtobeexpressive.
Inthissectionweshowthatusingamixtureofcompila-
tionandquerytechniquesitispossibletoachieveaccept-
ableperformanceresults,evenforpolicieswiththousands
of rules. We have designedand implemented a compiler
forSPL(whichgeneratesstandardjava)thatisabletode-
tectspecialSPLconstructionsandgeneratethemosteffi-
cientcodetoimplementthem.
GiventheresemblanceofSPLstructurewithjavastruc-
turemostofthecompileractionsaresimpletranslations:
each SPL policy is directly translated into a java class;
eachruleistranslatedintoatri-valuefunctionwithoutpa-
rameters (with theexception ofthe queryrule which has
one parameter – the current event); each entity is trans-
lated into a java interface; and each set variable is trans-
latedintoajavavariableoftypeSplSet,whichdefines
aninterfacetoaccessseveralkinds ofsets(externalsets,
subsetsofexternalsets,internalsets).
Asdefinedin
L
can bea compositionofother rules. Thus, functionsim-
plementing rules can range from simple if-clauses with
twologicalexpressions(oneforthedomain-andanother
for the decide-expression) to complex combinations of
other functions (e.g. simple combination using tri-value
operators;quantificationofrulesoversets; quantification
overhistoryevents;quantificationoverfutureevents).
Whereverapolicyinstanceisusedinplaceofarule,the
compilerexecutesanautomaticcastoperation consisting
in making explicit the call to the query rule of the pol-
icy. Thus,theoverallstructureofthegeneratedcodecan
beseenasatreeoftri-valuefunctionscallingotherfunc-
tions,inwhichtherootisthefunctionresultingfromthe
translation of the queryrule of themaster policyand the
leavesarethefunctionsresultingfromsimplerules.
AlthoughmostSPLconstructscanbeefficientlyimple-
mentedinjavabydirecttranslation, someconstructsand
structural problems require a deeper analysis. In the re-
maining of this section we address those problems, and
show some performance measurements that validate the
solutions.
5.1.Scalability
OneofSPLmajordesignproblemsisscalability.While
in common ACL based systems only the access control
entries(ACE)belongingtotheACLofeachtargetobject
areevaluatedoneachaccess,inSPLpotentiallyeveryrule
hastobeevaluatedforeveryaccess. Thisisaproblemin
systemswiththousandsofrules,usersandobjects.
SPL is a logical-based language, thus it is possible to
applysomeevaluationoptimizations. Inaconjunctionof
rules(tri-valueconjunctionasdefinedin
2.3,rulescanbesimplerulescomprised
of a domain-expression and a decide-expression or they
L
2.3)ifonerule
evaluatesto“deny”thanitisnotnecessarytoevaluatethe
remaining rules (similar for disjunction of rules and “al-
low” values). Unfortunately these optimizations are not
veryuseful, because disjunction ofrules are rareand the
optimizationapplicabletoconjunctionscanonlyoptimize
thedeniableofevents.
Anothermoreusefuloptimizationcanbeappliedtothe
restrictionoperation(rule@expression(event)). The“re-
strictionoperation”restrictsthedomainofapplicabilityof
a ruleto the setofeventssatisfying a logical expression.
Thus if that expression evaluates to “false” it is not nec-
essarytoevaluatetherule. Thisoptimizationisveryuse-
fulonthosesituationswhererulesareexplicitlyorganized
in domains of applicability (e.g. rules that apply only to
targetsproducedbyonebranchofanorganization).How-
ever,itisnotenoughtopreventtheunnecessaryevaluation
ofnotapplicablerulesinsidethesamedomain. Wherever
the restriction operation is not used, to reach the conclu-
sionthatonebranchoftheevaluationtreeisnotapplica-
ble to a particular event it is necessary to evaluate each
domainexpressionofeveryleafruleinthatbranch.Onesolutionwouldbetobuildavirtualrestrictionop- Inthissectionweshowthatitispossibletoimplement
eration in which the restriction expression would be the efficientlythelogsolution,bothintermsofmemory-space
logical disjunction of each domain expression2 of every andperformance. Themainachievementisobtainedbya
leafruleinthebranch. Althoughveryefficientindetect- compilationalgorithmthatoptimizestheamountofinfor-
ingnotapplicablebranchesthis solution penalizes appli- mationtobesavedandthewaythatinformationshouldbe
cable branches with redundant evaluation of domain ex- queried. We show that although this algorithm does not
pressionsineachnodeoftheevaluationtree. obtain the best results for all history-based policies, the
The solution used in SPL is based on the assumption resultsobtainedformostcommonpoliciesareequivalent
that most expressed rules are target-limited, in the sense tothoseobtainedbylabel-basedimplementations[33].
thattheyareappliedtoonlyalimitedsetoftargets. SPL The goal of this algorithm is three-folded. First, the
isabletoexpressrulesnottarget-limited(e.g. allactions securitymanagershouldselectivelylogjusttheeventsre-
performed by some user); nevertheless, we believe that quired by the history-based policies specified, e.g. if a
most security policies expressed in SPL will be target- policy needs to know if a document was signed, there is
limited. Thisassumptionisbasedontheobservationthat no need to recordeventsthat are not“signevents”. Sec-
most current security policies are target-limited, e.g. all ond, the security manager should selectively log just the
ACLbasedpolicies,chinesewallpolicies,DACpolicies. fieldsoftheeventsrequiredbythehistorypoliciesspeci-
RBACisnottarget-limitedbutisusedinconjunctionwith fied, e.g. policywantstodecidebasedonwhetherornot
ruleswhicharetarget-limited. theauthorofthecurrenteventhassignedadocument,itis
Based on this assumption we have designed a simple notnecessarytorecordthe“parameters”fieldofsignature
target-based index for rules, which allows for quick cuts events. Third, security manager should use the best pos-
on branches of the rule evaluation tree. The system cre- sible query for each history-based policy (equality terms
atesanindexforeachtarget.Eachindexismaintainedon can be searched in
thecorrespondingtargetasalabelandkeepstheinforma-
tionofeveryrulethatmaybeapplicabletoaneventwith
thattarget. Therepresentationofthatinformationonthe
current prototype is kepton a bit stream with one bit for
eachruleinthesystem. However,giventhesparsenature
oftheinformation(weexpectthatonlyafewrulesareap-
plicabletoeachtargetasincurrentACLbasedsystems)it
ispossibletodevelopmorecompactstructures.
Onthetestsdonesofarthisindextechniquehasproved
tobeefficient,showingonaverageaspeed-upofoneorder
ofmagnitude(see5.4).
5.2.History-basedpolicies
A monitor-like security service has to decide for each
eventwhetheritshouldallowtheeventtohappenornot.
The decision must be taken at the time the event is re-
questedwiththeinformationavailableatthattime. Thus,
inordertoimplementhistory-basedpoliciesanymonitor-
likesecurityservicehastorecordinformationaboutpast
events.
Somesecurityservicesrecordeventsimplicitlyintheir
own data structures [28] (mostly using labels) others
recordthemexplicitlyintoaneventlog[4]that canlater
bequeried forspecific events. Thelatersolution ismore
flexible than the former but if the event log becomes too
big, the memory space required to keep that log may be
unlimited and the time required to execute each query
couldhaveasignificantimpactontheperformanceofthe
system.
2Obviouslyareducedcanonicalform.
TR 1(cid:19) (cid:25)(cid:12) 5
and are preferred to inequality
terms) and the best information structure to support that
query(ahashtableispreferredforanequalitysearchbut
foraninequalitysearchabalancedtreemightbebetter).
The main drawback of this algorithm is that history-
based policies cannot decide on events prior to their ac-
tivation, i.e. the system only records events for each
history-basedpolicyafterthepolicyexists.
Instead of building a log for every history-based poli-
ciesthecompilerbuildsaspecificandfinedtunedlogfor
each history-based policy. This solution has several ad-
vantages. First,itdividestheproblemreducingthenum-
berofeventsrequiredtobesearched.Second,itallowsfor
abetteradaptationofthebasestructuretoeachquery,be-
causeeachlogcanbekeptbyadifferentstructure. Third,
itsimplifiesinsertionand removalofpolicies. Theprob-
lem of this solution is the potential for maintaining re-
dundantinformationinseverallogs. However,giventhat
the information kept by each log is the minimum infor-
mation necessary to that policy, the level of redundancy
expected is similar to the one of label-based implemen-
tations, where the labels used by different policies may
alsoberedundant. Nevertheless,thisproblemcanbefur-
therlimitedbysharinglogswiththesamesignature(same
eventstolog,samefieldsofthoseeventstolog,samebase
structure)betweenpolicies3.
Figure21showsasimplifiedversionofthecodegener-
ated by the compilation of a history-based rule. The ex-
pressionMyRule(e, ce)representsagenericrulethat
maybecomposedofotherrules.
Thealgorithmhasfourphases.Thefirstphaseisjustthe
3Thisfeatureisnotimplementedinthecurrentprototype.MyPolicy: FORALL e IN PastEvents MyRule(e, ce)
(a)
triVal MyPolicy(event ce) {
triVal policyResult = notapply;
if( !invariantConditionals(ce) ) return notapply
while( MySpecialLog.hasMoreElements(ce) )
x = stripped_MyRule( MySpecialLog.next(ce) );
if( x == deny ) return deny;
if( x == allow ) policyResult = allow;
}
return policyResult;
}
class MySpecialLog {
HashTable Log;
void insert(event e) {
if( PastDependentTermsOfRule(e) )
log.insert(new RequiredFieldsOf(e))
}
boolean hasMoreElements(event ce) {
return log.find(new indexFieldsOf(ce));
}
RequiredFieldsOf nextElement(ce) {
return log.next(new indexFieldsOf(ce));
}
}
(b)
Figure21.Translationofhistoryrules. (a)isthe
SPL representation of a generic history-based
rule. (b)isasimplifiedversionofthejavacode
resultedfromcompilation.
removaloftheinvariantconditionalsfromtheloop.Inthis
phasethecompilertriestobuildalogicalexpression(re-
ferredas“invariantConditionals”inFigure21)withterms
fromthedomainexpressionofMyRulewhicharemanda-
toryfortheapplicabilityoftheruleandarenotdependent
of variable
(cid:11)
. This expression is then used to perform a
preliminarytestofapplicabilityoftherule.
Thesecondphasealsobuildsalogicalexpressionwith
terms from the domain expression of MyRule, but with
termsdependentonvariable
(cid:11)
andnotdependentoncur-
rentevent. Thegoalofthisexpression(“PastDependent-
TermsOfMyRule”) is to filter the events that need to go
intothelog.
Thethirdandfourthphasesbuildrespectivelyoneclass
object with the fields of variable
(cid:11)
used in MyRule (re-
ferred as “RequiredFieldsOf”)and one class object with
the fields of
(cid:11)
Toillustratethealgorithmresultswewillshowhowan
SPL policy expressing the Chinese Wall policy (Figure
16) is enforced bya monitor generated bythe SPLcom-
piler.
Thefirstandsecondphaseofthealgorithmtriestoiden-
tifylogicalexpressionsbuiltformtermsofthedomainex-
pressionwhicharemandatorytruefortheapplicabilityof
the policy. In this policy(Figure 16) the domain expres-
sioniscomposedbyaconjunctionofsimpleterms. Thus,
any term can be used independently for the construction
ofthoseexpressions.Theproblemismorecomplexwhen
the domainexpressionis composedof bothconjunctions
anddisjunctions,inwhichcasemaynotalwaysbepossi-
bletocompletelyunfoldthelogicalexpression5.
For the Chinese wall policy the “invariantCondi-
tionals” logical expression is composed of just one
termce.target IN InterestClass,thusaccord-
ingwithfigure21thepolicyreturns“notapply”ifthetar-
get of current event is not in the class of interest, which
is conformable with the expected behavior. The “Past-
DependentTermsOfRule”logical expressionis also com-
posed by only one term e.target IN Interest-
Class, thus only the events over objects in the interest
classarelogged.
The “RequiredFieldsOf” object for this Chinese wall
policyiscomposedbythe“author”and“target”fieldsof
the “event” class object, and the “indexFieldsOf” object
is composedofjust the“author” field. Thus, thelogjust
keepsinformationaboutthetargetandtheauthorofeach
recordedeventanditisqueriedbyeventswith aspecific
author.
Because thelog does nothave to keeprepetitions, and
the specific nature of the Chinese Wall policy disallows
theexistenceofmorethanoneelementwiththesameau-
thor,themaximumlengthofthelogisthenumberofdif-
ferent users in the system. Usually the length of the log
ismuchlessthenthenumberofusers,becausenotevery
useraccessatargetinthe“interestclass”.However,ifthe
lengthofthetablesupportingthelogisequaltothenum-
ber of users, then the query can be performed by direct
addressingtheuserfield,followedbyacomparisonofthe
targetfield.
This is much similar to the classic label implementa-
tion [33] where each user has one label for each interest
class, which contains nil if the user did not access any
by which events are indexed, initialized targetinthe“interestclass”ortheidentificationofthetar-
with logical expressions dependent on the current event getaccessed. However,thedescribedimplementationre-
(referredas“IndexFieldsOf. Theformerisusedtorecord
only the information on past events which are useful to tables,thusitdoesnothandleeffectivelypolicieswhereatleastonefield
thesecuritypolicy. Thelaterisusedtosearchthelogfor of
events with the index fields equal to the ones in the “In-
dexFieldsOfobject4.
4Thecurrentcompilerprototypecanonlyimplementlogswithhash
U isnotequallycomparedwithalogicalexpressiondependentonthe
currentevent.
5Thisisusuallythecasewhenseveralrulesarecombinedwithtri-
logicaloperations,becausetheoveralldomain-expressionisthedisjunc-
tionofthedomain-expressionofeachruleandthedomain-expressionof
eachbasicruleisusuallyaconjunctionoftermssultsfrom the“compilation” ofa language which isable
to express simultaneously several other policies, includ-
ingotherhistorydependentpolicies,whiletheclassicla-
belimplementationishardcodedintheusermanagement
structures.
This technique can be applied to other history-based
policieswhich areusuallyimplemented withlabels. The
reasonwhythesepoliciescanbeimplementedefficiently
byanSPLcompilerliesonitsabilitytokeeptheirrelevant
historyinformationinsmallpiecesofdata(thelabels),di-
rectlyaddressedbyoneentity(users,objects,etc.).There-
fore, an SPL compiler which is able to detect exactly
which historyinformationisrelevantto thepolicyandis
able to index the resulting table by the most appropriate
entity (or entity property) can achieve similar efficiency
resultsaslabel-basedimplementations.
5.3.Obligation-basedpolicies
Asexplainedin
L
policy HistoryInfoFlow ()
3.2theobligation-basedsecuritypoli-
ciesenforceablebyeventmonitorsareonlytheonesthat
can be completely resolved inside an atomic execution.
ThemonitorgeneratedbytheSPLcompilerdoesnotpro-
vide code to make those sequences of actions to behave
atomically,insteaditreliesonapplicationstodefinethose
sequences ofactionsand ona transactionmonitor to im-
plement it. Thus, the problem of enforcing obligation-
based security policies is reduced to allowing or not the
event that instruct the transaction monitor to commit a
transaction, whether or not all the obligations were ful-
filledatthetimeofthatevent.
A security policy that allows or denies an event (the
commit event)depending onwhetherornotsome events
wereexecuted(theobligations)isa history-basedpolicy.
Thus,theenforcementofanobligation-basedpolicycon-
trollingaparticulartypeofeventcanbedonebyahistory-
basedpolicycontrollingtheeventthatcommitsthetrans-
actiononwhichtheoriginaleventwasexecuted.
The transformation from obligation-based policy to
history-based policy can be achieved in two steps. The
first step called “aging”, consists of replacing references
to events by older references. References to the current
event are replaced by references to a past event called
“trigger-event”. Referencesto pasteventarereplacedby
referencestoapasteventbutwithanadditionalconstraint
specifyingthatthis eventoccursbeforethetrigger-event.
References to futureeventsare replacedby referencesto
pasteventswiththeadditionalconstraintofoccurringaf-
terthetrigger-event.Thesecondstepconsistsofinserting
in this policy an explicit reference to the event that re-
quests the transaction-commit. This event becomes the
current event of the new policy and is related with the
trigger-eventbymeansof thetransaction idin which the
trigger-eventwasperformed.
(cid:2)
interface ReadFlowActions;
interface WriteFlowActions;
object set ProtObjects;
?InfoFlow:
FORALL te IN PastEvents (cid:2)
FORALL pe IN PastEvents
(cid:2)
FORALL g IN pe.target.groups
(cid:2)
EXISTS fe IN PastEvents (cid:2)
ce.action.name = "commit" & // New
fe.time > te.time & // New
te.transaction = ce.parameter[0] & // New
te.action IN WriteFlowActions &
pe.time < te.time & // New
pe.target IN ProtObjects &
pe.action IN ReadFlowActions &
pe.task = te.task &
:: te.target IN g
(cid:3)R (cid:3)S (cid:3) ;
(cid:3)
Figure 22. The transformation of the informa-
tionflowpolicyoffigure20intoahistory-based
policy.
Figure 22 shows the history-based version of the
obligation-basedpolicyshowninfigure20. Inthecurrent
prototypethistransformationismixedwiththetranslation
tojava,thustheSPLrepresentationofhistory-basedver-
sionsofobligation-basedpoliciesnevertakeplace.
5.4.Results
Access control monitors are used in several environ-
ments. Althoughtheyareusedasserviceswhicharesel-
dom queried by other services [29]. They are also used
at the center of systems being queried by every element
in the system for almost every action, thus their perfor-
mancehasanimportantimpactontheoverallperformance
ofthesystem. Allmeasurementspresentedinthissection
were taken on a personal computer with a Pentium II at
333MHzrunningtheSunJava1.2.2virtualmachineover
WindowsNT4.0.
The performance of an access control monitor is mea-
suredbythetimeittakestorespondtoaquery. However
more important than knowingthe absolute value of time
taken by the monitor to solve a query,which varies with
theplatformandtheintermediatecompilerused,isthedy-
namicbehaviorofthemonitorwithpolicyandlogscala-
bility,i.e. “Howisthequerydelayaffectedbythenumber
ofqueriesansweredwhenhistory-basedpoliciesareused
?” or“Howdoesthequerydelayevolveswiththesizeof
thepolicy?”.
To answer the first question we have developed a test
basedontheChineseWallpolicy.Inthistestwemeasured
the time to solve a query for the acceptability of eventsproduced by 100 different users by a monitor enforcing
a Chinese Wall policy with 10 interest classes, with 10
objectsperclass. Thetimeforeachquerywastakeneach
100 events to verify the effect of event logging over the
queryperformance.
The events were chosen such that their targets would
always be in one class of interest and that the expected
answer to the query would always be positive (“allow”).
This is the most common behavior (in normal systems
mostactionsareallowed) andunfortunatelyitisalso the
worst case for this and most policies expressed in SPL.
This behavior is shared by every policy which uses con-
junctions astheirpredominant composition construction.
In this situation the Chinese Wall policy is composed by
aconjunctionof10policiesshowedinFigure16,onefor
eachinterest class. Ifone ofthose tenpolicies deniesan
eventthenthereisnoneedtoevaluatetheremainingpoli-
cies. However,for eventswhichareallowedallthe poli-
ciesareevaluated.
}
(cid:128)
(cid:127)
z|}~
yz{|x
_Z
^Z
](cid:24)
\Z
[Z
YZ
WX
V
V
V
V
V
V
V
V
WX VZ VZ V‘ Ya ](cid:24) Vb Vc \Z VZ
hj
VZ Vd
iZ km lb
]Z
np
](cid:24)
oI
Vb
q(cid:15)
Ve
r4 n(cid:19) sb
_Z
np
Vb VZ
t(cid:15) uwv
Ve fZ ](cid:24) Vb Vg WX VZ VZ VZ V
Figure 23. Chinese Wall dependency with the
numberofeventsqueried
The results presented in Figure 23 show that the time
takentosolveaquerytotheChineseWallpolicydoesnot
dependonthenumberofeventsqueried,thusprovingthat
thesolutionusedtominimizetheimpactofloggingonthe
overallperformanceofthemonitoriseffective.
The time needed to solve a query to the Chinese Wall
policy is also not affected by the number of users or the
numberofobjectsineachclassofinterest. Butitissever-
ally affectedby the numberof classes ofinterest (Figure
24). Thisresultisadirectconsequenceofthenumberof
rulesusedtobuildtheChineseWallpolicywithdifferent
numbersofclassesofinterest. TheChineseWalldefined
in Figure 16 requires the definition of one rule for each
classofinterest,thusforChineseWallpolicieswithmore
classesofinterestthemonitorneedstoevaluatemorerules
foreachquery.
ƒ£
¢¥
(cid:160) ¢£⁄
(cid:158)(cid:159)(cid:160)¡
(cid:134)(cid:24)
(cid:134)(cid:24)
(cid:132)(cid:133)
(cid:132)(cid:133)
(cid:130)(cid:131)
(cid:129)(cid:131)
(cid:130)(cid:131)
(cid:129)(cid:131)
(cid:130)(cid:131)
(cid:129)(cid:24)
(cid:129)(cid:24)
(cid:129)(cid:24)
(cid:129)(cid:24)
(cid:129)(cid:24)
§'
(cid:129)
(cid:129)
(cid:129)
(cid:129)
(cid:129)
(cid:129)
¤“‹«(cid:15) ›(cid:131)
(cid:132)(cid:133)
fi(cid:133)
(cid:129)(cid:135)
“fl ¤(cid:176)(cid:26)
(cid:134)(cid:131) (cid:129)(cid:135)
–(cid:24) †(cid:133) ‡
(cid:136)(cid:131) (cid:129)(cid:135) (cid:137)(cid:24)
(cid:144)(cid:146)
§·
(cid:129)(cid:138)
(cid:145)(cid:24) (cid:147)"
¤“‹«(cid:181)
(cid:130)(cid:24) (cid:129)(cid:135)
(cid:148)(cid:131) (cid:149)p (cid:150)(cid:146)
¤(cid:176)(cid:26) –(cid:24)
(cid:139)(cid:131) (cid:129)(cid:135)
(cid:151)(cid:26) (cid:152)b (cid:153)(cid:146)
†(cid:133) ‡
(cid:154)(cid:156)(cid:155)(cid:133)
(cid:140)(cid:131)
(cid:157); (cid:157);
(cid:129)(cid:135)
(cid:149)p (cid:157)
¤¶!
(cid:141)(cid:24) (cid:129)(cid:138)
•(cid:24) ‚„›(cid:133) ”X †(cid:26)
(cid:142)(cid:24)
–"
(cid:129)(cid:143)
¤(cid:176)(cid:26) –(cid:24)
(cid:132)X (cid:129)(cid:131)
†(cid:133) ‡
(cid:129)
Figure 24. Chinese Wall scalability with the
numberofclassesofinterest.
The indexsolution presented in
L
5.1 can minimize the
problemasshownbyFigure24. Howeveritisnotenough
for policiessuchasthe ChineseWalloranyotherpolicy
withonesinglelargeconjunctionofrules. Onthesepoli-
ciestheindexeffectivenessissmallbecausethebranches
in the evaluation tree of those policies are small. Thus
thecutswhichtheindexisabletoperformarenecessarily
small. These type ofpolicies require better indexes. For
instance, indexes with several layers of indexes over in-
dexes.Thissolutionisnotimplementedinthecurrentpro-
totypebutitseffectcanbemeasuredbecauseitwouldbe
similartorearrangethepoliciesinordertohaveadeeper
evaluationtree. Forinstance,thebigconjunctionofrules
of theChinese Wall policycanbe rearranged intoa con-
junctionofconjunctionsusingtheassociativepropertyof
conjunctions. The results of Figure 24 shows the effec-
tivenessofsuchapproach.
Non Indexed
indexed normal optimized
»‰ … ( »‰ … ) ( »(cid:190) … )
ChineseWall10 56 1.5( 37) 1.3( 43)
ChineseWall100 1992 3.3(597) 31.6( 63)
Global 303 7.6( 40) -
Table 2. Speedup results, with respect to non
indexed queries, for queries with normal index
andwithindexoverrearrangedpolicies.
Table 2 shows some examples of index effectiveness.
TwoChineseWallpolicieswith10and100classesofin-
terest,weretestedwithoutindex,withindexandwithin-
dex over rearranged forms of the policies. Although the
index speedup is not very sensible for the Chinese Wall
policy with 10 classes of interest it becomes importantfor the Chinese Wall with 100 classes of interest. The
otherexampleshowninTable2isthe“Global”policyde-
scribedinappendixA,whichisapolicywith41206rules
dividedinto100domainsover5continents.Albeitsimple
forarealpolicyofanorganizationthispolicyiscomplex
enoughtorepresentthetargetpoliciesofSPL.Thepolicy
wastestedfor5000usersand12000targets,exhibitinga
¿a (cid:192)´ `
(cid:9)
rules areclassifiedintotwo categories: strongand weak.
The strong rules may override weak rules, but not other
strongrules. Thismeansthatconflictsmaystillarisebe-
tweenstrongrulesandhavetobesolvedbyothermeans.
Jajodia et al [23] define a logical language with ten
predicatesymbols. Threeofthoseareauthorizationpredi-
cates(dercando,cando,do),usedtodefinetheallowedac-
delay for each query, which is an acceptable value tions. Althoughnotexplicitthese predicatesdefine three
forthesizeofthepolicyandtheunderlyingplatformused. levelsofauthorization,withdercandoastheweakestand
do as the strongest. However, the problem remains, be-
6. RelatedWork causeconflictsmaystillarisebetween“do”rules[24].
Anotherapproachtoconflictresolution,presentedin[2]
Much work has been done on multi-policy environ-
and[25]useselementslikeruleauthorshipauthority,rule
ments, primarily to solve the conflict raised by having
specificity and rule recencyto prioritize rules. Although
different policies governing the same subject. Some of
simple and natural this approach may lead to undesired
thisworktriestosolvetheproblemusingspecificsystem
behavior. Itisnotuncommonforhighauthoritymanager
mechanisms[11,19],butmostdefineunifiedframeworks
toissuearulewhichmaybeoverriddenbyalowauthority
inwhichdifferentpoliciescanbeexpressed[3,4,12,22,
manager, or to express a mandatory general rule which
24,27,39].
shouldnotbeoverridden.
MinskyandUngureanu[27]defineaformalismandan
In[8,9]Blazeatalproposedadifferentconceptcalled
environment to specify and enforce security policies in
“Trust Management”. Their work starts by identifying
distributed systems. Their environment assumes a mes-
thatinservicesreceivingsignedrequests,theprincipalsis-
sage monitor that intercepts every message sent or re-
suingtherequestsarethekeyssigningtherequests. Thus
ceived, and runs security policies. A security policy is
ifthepolicymaintainedbytheauthorizationserviceisor-
composed of a set of clauses, each one defining the ac-
ganized in terms of keys instead of names (user names,
tionsthatthemonitorshouldtakewheninterceptingeach
rolenames,servicename,etc.) itisnotnecessarytoper-
message. Theauthors showthat theformalismispower-
formtheextrastepofcheckingtheauthenticityofthere-
fulenoughtoexpresscomplexpolicies,butitisnotclear
quest.
howtheydealwithconflictingpolicies.
They propose a tool, the PolicyMaker trust manage-
WooandLam[39]showhowdefaultlogiccanbeused
mentsystem,whichisabletoexpressinasinglecommon
toexpressauthorizationrules. Roughly,eachruleiscom-
languageauthorizationpolicies,certificatesandtrustrela-
posed by three binary formulas (g, f, f’): formula g de-
tionships,thusintegratingwholetheseconcepts.
finestheactionsallowedbytherule;formulafdefinesthe
Thetrustpolicyenginerepliestoarequestbasedonthe
actions that must be allowed by other rules in order for
localpolicyandtrustassertionsandonthecertificatespro-
this rule to be active; and formula f’ defines the actions
vided by the requester. The engine checks if the request
thatmustnotbeallowedbyotherrules. Thisconstruction
is authorized by the local policy assertions, or if there is
is very powerful for relating rules with each other, pro-
a path of trust assertions from a local assertion to a key
ducingveryexpressivepolicies. Nevertheless,webelieve
signing a policy certificate that allows the request. This
that the algebra for security rules proposed by us is able
solutionclearlyscalesbetterthanaglobalstaticpolicy.
toexpressmostsecurity policiesusing simplerand more
KeyNote [6] and SPKI [17] are two other examples
compactrules.
of systems comprising the notion of trust management.
Adage [4] authorization rules are very similar to our
KeyNote derives from PolicyMaker and shares the same
own. They both have a domain of applicability function
principals. However, KeyNote was designed to simplify
andadecisionfunction. However,Adagedoesnotspecify
theintegrationoftheservicewiththeclientapplications.
analgebraforrulesandpolicies,whichmakesthemmuch
Thus KeyNote has a built-in credential verification sys-
moredifficulttocomposeintocomplexpoliciesandtoex-
tem and a simple notation to express authorization pred-
pressdefaultbehavior. Furthermore,itdoesnotprovidea
icates. SPKI (Simple Public Key Infrastructure) on the
conflictresolutionmechanismoranefficientimplementa-
other hand, results from the extension of the certificates
tionofhistory-basedpolicies[40].
kept by a Public Key Infrastructure to allow authoriza-
ConflictresolutionapproachesdefinedbyBertinoetal
tion certificates. Although slightly more restrictive than
[3] and Jajodia et al [23] have some similarities. In [3],
KeyNote, SPKI shares the same fundamental features of
6Only 1690 rules can be directly counted from SPL specification. KeyNote and PolicyMaker. SPKI also (i) uses keys as
The remaining rules are inserted into the “userPolicy” group of each principals, (ii) allows trust to be delegated from one key
user.toanother(iii)allowspoliciestobeinserteddynamically policies.
intheformofcertificate. This work is just a first step towards a security frame-
Although with similar results each of these trust- work, which also includes the specification and enforce-
managementsystemshaveadifferentcompliancecheck- mentofauthenticationpolicies,toolstoverifytheconsis-
ing engine. The one from PolicyMaker is the most gen- tency of both specification and tools to verify the cross
eral,inthesensethatitcanusearbitraryfunctionstoex- consistency of both specifications with other systems in
pressassertions,providedthattheyaremonotonic. Onthe theorganization. Namelywe havealreadydefineda tool
otherhandthecompliancecheckingenginefromSPKIal- thatverifiesthecrossconsistencyofanauthorizationpol-
lowsalimitedtypeofassertionsbutitallowsnegativeas- icydescribedinSPLandaworkflowspecification[30].
sertions.
In [5] Blaze at al shows that checking the compliance References
forthegeneralproblemisNP-hardandgivesseveralalter-
nativeswithdifferentlevelsofexpressivenessandusabil- [1] D.BellandL.LaPadula.Securecomputersystems:Math-
ity.However,thebestbalancebetweenexpressivenessand ematicalfoundations.TechnicalReportMTR-2547,Vol1,
MITRECorp.,Bedford,MA,Nov.1973.
usabilityisstillanopenissue. We believethat theSPL’s
[2] E.Bertino,F.Buccafurri,E.Ferrari,andP.Rullo. Alog-
compliancecheckingengineisafairalternative,because
icalframeworkforreasoningondataaccesscontrolpoli-
although it is harder to dynamically insert policies (poli-
cies. InProceedingofthe12thIEEEComputerSecurity
ciescanonlybeaddedatspecificpointsintheglobalpol-
Workshop.IEEEComputerSocietyPress,July1999.
icy)ithasagoodperformance,anddoesnotcompromise
[3] E.Bertino,S.Jajodia,andP.Samarati. Supportingmulti-
inanywayexpressiveness.
pleaccesscontrolpoliciesindatabasesystems. InIEEE
Mostoftheseenvironmentscanstatebothpositiveand SymposiumonSecurityandPrivacy,pages94–109,Oak-
negativeauthorizationrules.In[12]itisshowedthatobli- land,CA,1996.IEEEComputerSocietyPress.
gationcanalsobeaverypowerfulconcepttoexpressse- [4] W.R.BevierandW.D.Young. Aconstraintlanguagefor
curity policies, howeverit is not clear how can it be im- adage. Technicalreport,ComputationalLogic,Inc.,Apr.
plemented. 1997.
Althoughexpressiveenoughtohandlemostoftheusual [5] Blaze,Feigenbaum,andStrauss. Compliancecheckingin
policies,includingtheoneswithhistorydependence,like thepolicymakertrustmanagementsystem. InFC:Inter-
national Conference on Financial Cryptography. LNCS,
theChineseWallandseveralotherseparationofdutypoli-
Springer-Verlag,1998.
cies, noneoftheaboveenvironmentssupportsobligation
[6] M.Blaze, J.Feigenbaum, andJ. Ionnidis. TheKeyNote
constraintsorinformationflowpoliciesasSPLdoes.
trust-managementsystemversion. Technicalreport,Inter-
netRFC2704,September1999.
7. Conclusion
[7] M.Blaze,J.Feigenbaum,andA.D.Keromytis.KeyNote:
Trustmanagementforpublic-keyinfrastructures. Lecture
We have defined an access control language that sup-
NotesinComputerScience,1550:59–63,1999.
portssimultaneouslymultiplecomplexpolicies,andhasa
[8] M.Blaze,J.Feigenbaum,andJ.Lacy. Decentralizedtrust
higherexpressivepowerthan othermulti-policyenviron-
management. InProceedingsoftheIEEESymposiumon
ments. The language uses its hierarchical based, policy-
Research in Security and Privacy, Research in Security
oriented structure to solve conflicts between simultane-
andPrivacy,Oakland,CA,May1996.IEEEComputerSo-
ouslyactivepolicies. ciety,TechnicalCommitteeonSecurityandPrivacy,IEEE
The language was designed to be easily enforced by a ComputerSocietyPress.
security monitor. We have shown how index techniques [9] M.Blaze,J.Pigenbaum,andA.D.Keromytis. Keynote:
can be applied to the policy structure to implement ef- Trustmanagementforpublic-keyinfrastructures. Lecture
ficiently most security policies. Special care was taken NotesinComputerScience,1550:59–??,1999.
ontheenforcementofhistory-basedconstraints. Wehave [10] D. F. Brewer and M. J. Nash. The chinese wall secu-
shown that by generating specific and special tuned logs ritypolicy. InSympSecPr, ResearchinSecurityandPri-
vacy, pages 206–214, Oakland, CA, May 1989. IEEE,
for each history-based policy it is possible to implement
IEEECSP.
SPL history-based policies as efficiently as handcoded
[11] M. Carney and B. Loe. A comparison of methods for
label-basedimplementations.
implementingadaptive securitypolicies. In Proceedings
The language goes beyond the permission/prohibition
ofthe7thUSENIXSecuritySymposium(SECURITY-98),
concepts of security and shows how to express and im-
pages1–14,Berkeley,Jan.26–29,1998.UsenixAssocia-
plement the obligation concept. It uses this concept to
tion.
expressarelaxedformofinformationflowpolicy,thereby [12] F.CuppensandC.Saurel. Specifyingasecuritypolicy:A
showingthatsomeformsofinformationflowpoliciescan casestudy. InIEEEComputerSocietyComputerSecurity
beexpressedinSPLand thattheycancoexistwith other FoundationsWorkshop(CSFW9),pages123–135,1996.[13] D.E.Denning.Alatticemodelofsecureinformationflow. [28] M.J.NashandK.R.Poland. Someconundrumsconcern-
CommunicationsoftheACM,20,July1977. ingseparationofduty. InProceedingsofthe1990IEEE
[14] DoD. Dod trusted computer system evaluation criteria. ConferenceonSecurityandPrivacy(SSP’90),pages201–
TechnicalReport5200.28-STD,DoD,Dec.261985. 209.IEEE,May1990.
[15] G.Edjlali,A.Acharya,andV.Chaudhary. History-based [29] H.packardPublicationServices. HPpraesidium/autho-
access controlformobile code. In5thACMConference rizationserverwhitepaper. PublishedinInternet,1998.
[30] C.RibeiroandP.Guedes. Verifyingworkflowprocesses
onComputerandCommunicationsSecurity,pages38–48,
against organizationsecurity policies. InProceedings of
SanFrancisco,California,Nov.1998.ACMPress.
the8thIEEEInternationalWorkshopsonEnablingTech-
[16] W. K. Edwards. Policies and roles in collaborative ap-
nologies: Infrastructure for Collaborative Enterprises,
plications. InProceedingsoftheACM1996 Conference
pages 190–191, Standford, California, June16-18 1999.
on Computer Supported Work, pages 11–20, New York,
IEEEComputerSociety,IEEEComputerSociety.
Nov.16–20,1996.ACMPress.
[31] C.Ribeiro,A.Zu´quete,P.Ferreira,andP.Guedes. Secu-
[17] C. M. Ellison, B. Frantz, B. Lampson, R. Rivest, B. M.
rity policy consistency. Technical Report RT/03/00, IN-
Thomas,andT.Ylonen. SPKIcertificatetheory. Internet
ESC,2000.
RFC2693,Sept.1999.
[32] R. Sandhu. Separation of duties in computarized infor-
[18] D.F.Ferraiolo,J.F.Barkley,andD.R.Kuhn.Arole-based
mation systems. In Proceedings of the IFIP WG11.3
accesscontrolmodelandreferenceimplementationwithin
WorkshoponDatabaseSecurity,Halifax,UK,Sept.18–21
a corporate intranet. ACM Transactions on Information
1990.
andSystemSecurity,2(1):34–64,Feb.1999. [33] R.S.Sandhu. Lattice-basedaccesscontrolmodels. IEEE
[19] T.Fraser andL.Badger. Ensuringcontinuityduringdy- Computer,26(11):9,Nov.1993.
namicsecuritypolicyreconfigurationindte. InProceed- [34] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E.
ingsofthe1998IEEEConferenceonSecurityandPrivacy Youman. Role-basedaccesscontrol:Amulti-dimensional
(SSP’98),pages15–26.IEEE,May1998. view. In 10th Annual Computer Security Applications
[20] L.GiuriandP.Iglio. Roletemplatesforcontent-basedac- Conference,pages54–62,1994.
cesscontrol.InProceedingsofthe2ndACMWorkshopon [35] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E.
Role-Based Access Control (RBAC-97), pages 153–159, Youman. Role-based access control models. Computer,
NewYork,Nov.6–71997.ACMPress. 29(2):38–47,Feb.1996.
[21] J. Gray and A. Reuter. Transaction Processing: con- [36] F.B.Schneider. Enforceablesecuritypolicies. TheACM
ceptsandtechniques.DataManagementSystems.Morgan Transactions on Information and System Security, 3(1),
KaufmannPublishers,Inc.,SanMateo(CA),USA,1993. February2000.
[37] SimonandZurko. Separationofdutyinrole-basedenvi-
[22] J. A. Hoagland, R. Pandley, and K. N. Levitt. Security
ronments. InPCSFW:ProceedingsofThe10thComputer
policy specification using a graphical approach. Techni-
SecurityFoundationsWorkshop. IEEEComputerSociety
cal report, Department of Computer Science, University
Press,1997.
ofCaliforniaDavis,July1998.
[38] A. Tate. Representing plans as a set of constraints - the
[23] S.Jajodia,P.Samarati,andV.S.Subrahmanian. Alogi-
callanguageforexpressingauthorizations.InSympSecPr,
Research in Security and Privacy, Oakland, CA, May
1997.IEEECSP.
[24] S. Jajodia, P. Samarati, V. S. Subrahmanian, and
E. Bertino. A unified framework for enforcing multiple
access control policies. SIGMOD Record (ACMSpecial
InterestGrouponManagementofData), 26(2):474–485,
June1997.
[25] N. Li, J. Feigenbaum, and B. N. Grosof. A logic-based
knowledge representation for authorization with delega-
tion. InProceedingofthe12thIEEEComputerSecurity
Workshop.IEEEComputerSocietyPress,July1999.
[26] E.C.LupuandM.Sloman. Reconcilingrole-basedman-
agement and role-based access control. In Proceedings
ofthe2ndACMWorkshoponRole-BasedAccessControl
(RBAC-97), pages 135–142, New York, Nov. 6–7 1997.
ACMPress.
[27] N. H. Minsky and V. Ungureanu. Unified support for
heterogeneous security policies in distributed systems.
In Proceedings of the 7th USENIX Security Symposium
(SECURITY-98), pages 131–142, Berkeley, Jan. 26–29,
1998.UsenixAssociation.
ˆ I-N-OVA
˜
model.InB.Drabble,editor,Proceedingsof
the3rdInternationalConferenceonArtificialIntelligence
PlanningSystems(AIPS-96),pages221–228.AAAIPress,
1996.
[39] T.Y.C.WooandS.S.Lam. Authorizationindistributed
systems: Aformalapproach. InProceedingsofthe1992
IEEEComputerSocietySymposiumonSecurityandPri-
vacy(SSP’92),pages33–51.IEEE,May1992.
[40] M.E.Zurko,R.Simon,andT.Sanfilipo. Auser-centered,
modularauthorizationservicebuiltonanrbacfoundation.
InProceedingofthe12thIEEEComputerSecurityWork-
shop.IEEEComputerSocietyPress,July1999.
A. Appendix
package Global;
import SplInterfaces;
alias object set collection;
alias user set team;
policy Group {
team UserGroup;
?Group: ce.action.name = "read" &
ce.target.owner IN UserGroup &
ce.author IN UserGroup :: true;} china3: new ChineseClass;
china4: new ChineseClass;
policy AclDomain { china5: new ChineseClass;
collection DomainTargets; china6: new ChineseClass;
owner: ce.author = ce.target.owner :: true; china7: new ChineseClass;
given: china8: new ChineseClass;
FORALL r IN ce.target.owner.userPolicy {r}; china9: new ChineseClass;
group0: new Group; ChineseWall: china0 AND china1 AND china2 AND
group1: new Group; china3 AND china4 AND china5 AND
group2: new Group; china6 AND china7 AND china8 AND china9;
group3: new Group; LocalChina: ChineseWall@{.author IN broker.Active};
group4: new Group; Inpection: ce.author IN inspector.Active ::
group5: new Group; ce.action.name = "read";
group6: new Group; total: {LocalChina AND Inpection} OR deny;
group7: new Group; ?ChineseRBAC: total@{.target IN DomainTargets };
group8: new Group; }
group9: new Group;
groups: group0 OR group1 OR group2 OR policy Continent {
group3 OR group4 OR group5 OR acl0: new AclDomain;
group6 OR group7 OR group8 OR group9; acl1: new AclDomain;
total: {groups OR owner} AND given OR deny; acl2: new AclDomain;
?AclDomain: total@{ .target IN DomainTargets }; acl3: new AclDomain;
} acl4: new AclDomain;
acl5: new AclDomain;
policy ACE(object target, operation action, acl6: new AclDomain;
user author, boolean result) { acl7: new AclDomain;
?ACE: ce.target = target & ce.action = action & acl8: new AclDomain;
ce.author = author :: result; acl9: new AclDomain;
} acls: acl0 AND acl1 AND acl2 AND
acl3 AND acl4 AND acl5 AND
policy ChineseClass acl6 AND acl7 AND acl8 AND acl9;
{ rbac0: new ChineseRBAC;
collection InterestClass; rbac1: new ChineseRBAC;
?ChineseClass: rbac2: new ChineseRBAC;
NOT EXIST e IN PastEvents { rbac3: new ChineseRBAC;
ce.target IN InterestClass & rbac4: new ChineseRBAC;
e.target IN InterestClass & rbac5: new ChineseRBAC;
e.author = ce.author & rbac6: new ChineseRBAC;
e.target != ce.target :: true rbac7: new ChineseRBAC;
}; rbac8: new ChineseRBAC;
} rbac9: new ChineseRBAC;
rbacs: rbac0 AND rbac1 AND rbac2 AND
policy Role { rbac3 AND rbac4 AND rbac5 AND
team Authorized; rbac6 AND rbac7 AND rbac8 AND rbac5;
team Active; ?Continent: acls AND rbacs;
?Role: ce.action.name = "insert" & }
ce.target = Active ::
ce.parameter[0] IN Authorized; policy Global {
} europe: new Continent;
america: new Continent;
policy ChineseRBAC { asia: new Continent;
collection DomainTargets; africa: new Continent;
broker: new Role; oceania: new Continent;
inspector: new Role; ?Global: europe AND america AND
china0: new ChineseClass; asia AND africa AND oceania;
china1: new ChineseClass; }
china2: new ChineseClass;