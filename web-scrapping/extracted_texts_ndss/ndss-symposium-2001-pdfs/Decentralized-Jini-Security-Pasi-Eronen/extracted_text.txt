Decentralized Jini Security
PasiEronenandPekkaNikander
HelsinkiUniversityofTechnology
{pasi.eronen,pekka.nikander}@hut.fi
Abstract
The fundamental differences become especially appar-
entwhenconsideringthefutureadhocnetworksandother
Amongthedifferentapproachestodistributedcomputing, looselycoupledsystems. Thesesystems,bynature,arenot
the Jini technology provides a number of very promising only distributed but also decentralized. That is, a genuine
methods for attacking the fundamental problems involved. adhocnetworkdoesnothaveanycentralizedservicesbut
ProgramsbuiltaccordingtotheJiniprincipleswillbeable all the network services are configured and created on the
tofunctionandsurviveinhighlydynamicnetworkenviron- fly. In the security area, the underlying mechanisms stay
ments, allowing applications to adapt their behaviour to more or less the same to what is used in centralized sys-
therequirementsofthecurrentcontext. Unfortunately,the tems, but the trust and infrastructure assumptions change
securityproblemsthatareboundtobepresentinanylarge altogether,requiringdifferentkindsofsolutions(cf. [29]).
scale deployment of Jini are not adequately addressed by
Inthispaper,wepresentafullydecentralizednetworkse-
either the current revisions of Jini technology or the un-
curityarchitectureforJini,anddescribeaprototypeimple-
derlying Java security solutions. In particular, the solu-
mentationofthearchitecture. Thearchitecturebuildsupon
tions proposed so far are either bound to a specific com-
ourearlierworkontrustmanagement[25]anddistributed
munication protocol—thereby hampering the protocol in-
Jini security [12]. The implementation is integrated to the
dependenceofJini—orrelyoncentralizedsecurityservers,
Java 2 security model, augmenting and utilizing the secu-
therebylosingthebenefitsoftheadhocnatureofJini.
rity services provided by the Java 2 security architecture
Inthispaper,wepresentresultsofourresearchthatact
[15] and the Java Socket Security Extension (JSSE) [33].
assteppingstonestowardsafullydecentralized, complete
Inthefuture,weplantolookathowtointegrateourexten-
Jini security architecture. In particular, we describe our
sionstotheJavaAuthenticationandAuthorizationService
experimentalimplementationthatseparatestheJava2ac-
(JAAS)[21]andtotheRMISecurityExtension[32]. Our
cess permissions of Jini clients, service proxies, and ser-
solution is fully compatible with the Jini architecture and
vices, whileallowingnaturaldelegationofJava2permis-
assumptions,anddoesnotrequireanycentralizedsecurity
sionsbetweenJinienableddevices.Oursolutionintegrates
services. It makes a clean distinction between the access
seamlesslytotheunderlyingJava2security,andallowsall
rights of client applications and service proxies, and pro-
ofJini’sbenefitstobeutilizedinasecureway.
videsameansofdelegatingJava2securitypermissionsbe-
tweenJiniclients,servicesproxies,andservices.Theseand
otheraspectsofoursolutionarediscussedindetaillaterin
1 Introduction
thispaper.
Distributedcomputingisfundamentallydifferentfromcen- Therestofthispaperisorganizedasfollows.First,inthe
tralizedcomputing. Theusuallymentionedfourmajordif- restofthissection,webrieflydescribethecentralconcepts
ferences include latency, memory access, partial failures, oftrustmanagementandtheJiniarchitecture. Afterthat,in
and concurrency (e.g. [35]). Security should definitely be Section 2, we provide a brief taxonomy of Jini related se-
addedtothislist, sinceadistributedsystemrequirescryp- curityrequirementsandanumberofrelateddesignaspects.
tographytobeusedwhileacentralizedsystemmaysurvive Section3discussesourdesignchoicesandoutlinesthear-
without it. While many of the approaches to distributed chitecture of our solution, and Section 4 describes the im-
computingattempttomaskoutsomeoftheseproblems,the plementation, includingsomeperformancemeasurements.
Jiniapproachmostlydoesnot. Instead,itaimsatproviding RelatedworkisbrieflydiscussedinSection5,andSection
toolsandmethodsforeffectivelybuildingsoftwarethatad- 6 evaluates our approach in the light of the alternative so-
equately addresses these differences and is able to survive lutions. Wealsogivesomeideasforfuturework. Finally,
inthefaceofproblemscausedbydistribution. [1] Section7containsourconclusionsfromthisresearch.1.1 Decentralizedtrustmanagement devicedrivers.
Allcommunicationgoesthroughproxies,whicharelocal
Traditionally,securityhasbeenbasedonidentityauthenti-
objectsthatimplementsomewell-knowninterface(suchas
cationandlocallystoredaccesscontrollists(ACLs). This
“Printer”). ProxiescanbesimpleRemoteMethodInvoca-
has been the case even in distributed systems. However,
tion(RMI)stubswhichmarshallmethodcallsoverthenet-
that approach has a number of drawbacks, including, for
work,ortheycanimplementpartofthefunctionalityinthe
example, theproblemofprotectingtheoperationsthatare
proxyitself(forexample,convertingthedatatothecorrect
needed for managing access control lists remotely. In [5]
format for this printer). Also, some services don’t neces-
Blaze et al. argue that “the use of identity-based public-
sarilyrequirenetworkcommunicationatall,inwhichcase
key systems in conjuction with ACLs are inadequate so-
theproxyaloneimplementstheservice.
lutions to distributed (and programmable) system-security
Protocolindependenceandtheabilitytoimplementpart
problems.”
of the intelligence on the client side give Jini tremen-
Analternativesolution,termedtrustmanagement,usesa
dous flexibility. For example, proxies can communicate
setofunifiedmechanismsforspecifyingbothsecuritypoli-
with devices which don’t have a Java virtual machine; ei-
cies and security credentials. Basically, trust management
therlegacydeviceswithproprietaryprotocols,orresource-
usuallyinvolvessignedstatements(certificates)aboutwhat
strippedembeddeddevices.Ontheotherhand,Jinirequires
principals (users) are allowed to do, instead of traditional
thattheclientshavetheirownJavavirtualmachines.
name certificates which just bind a public key to a name.
ExamplesoftrustmanagementsystemsincludethePolicy-
1.3 Proxiesandsecurity
Maker,whichoriginallyintroducedthetermtrustmanage-
ment[6],itscontinuationsKeyNoteandKeyNote2[4],and Protocol independence presents also some new security
insomerespects,SPKI[11]anditsapplications,including challenges. The Jini architecture doesn’t include any se-
TeSSA[23]. curityinadditiontothenormalJavasecurityfacilities(for
protectingtheclientJVMfrommaliciousproxycode),and
thesecurityaspectsofRMIintheircurrentstateareinsuf-
1.2 IntroductiontoJini
ficientforthetask(seeSection4.7).
The Jini programming model provides a set basic build- Since all communication goes through downloaded
ing blocks for distributed applications: distributed events, proxyobjects,securitymethodsusedinenvironmentswith
transactions, leases, and downloadable proxies. These fixed protocols can’t usually be used without some adap-
don’t try to hide the fact that networks are unreliable, and tation. For example, the Transport Layer Security (TLS)
the approach, in general, encourages building more fault- protocol supports authentication of both the client and the
tolerantapplications[26,35]. serverusingX.509certificates[10]. Thisdoesn’t,however,
The building blocks are used in the centerpiece of Jini, helpusindeterminingwhetheraspecificproxyistrustwor-
the lookup service, which is a directory where service thy. Theclientcertainlydoesn’twanttogiveitsprivatekey
providers register themselves and clients search for what to the proxy (since it might use it to access a completely
they need. For example, when a service registers itself differentservice).
withalookupservice,itreceivesaleaseontheregistration, Wefeelthesituationresemblestheconceptofdelegation,
with an expiration date. If the service doesn’t renew the and therefore a trust management system which supports
leasebeforeitexpires—forexample,theserviceisdiscon- delegationcouldbeappliedtotheproblemelegantly.
nectedfromthenetwork—theregistrationisautomatically
cleanedfromthelookupservice.
2 Requirements for Jini security
Thelookupserviceissomewhatsimilartootherservice
location protocols, such as Salutation [28], Service Loca-
WhentalkingaboutJinisecurity,wemustfirstdecidewhat
tionProtocol[16],andUniversalPlugandPlay[34],except
securityfunctionalityisneeded. Thisnaturallydependson
thatmatchingisbasedinJavainterfacetypes. Thecentral
whatweareusingJinifor,andwhattrustrelationshipsare
differencebetweenJiniandtheotherservicelocationproto-
involved. In this paper, we are focusing on the client ac-
colsisprotocolindependence:thatis,Jinidoesnotmandate
cessingaserverthroughaproxy,andleavethesecurityas-
any specific communication protocol between the clients
pects of distributed events, leases, and transactions for fu-
andtheservices(exceptforbootstrappingthesystem),but
turework.
relies on dynamic Java class loading instead. Since the
Sofar,wehaveidentifiedthefollowingrequirements.
proxies are written in Java, the system also claims oper-
ating system independence; this in contrast with the other • Principalauthentication. Theclientshouldbeableto
service location protocols which usually use non-portable verifythatitisactuallytalkingtotherightserviceandthroughtherightproxy. Likewise, theserviceshould certainlyaffectthesituationswherethesolutionisapplica-
beabletoverifywhoistryingtoaccessit. ble. Inthissectionweidentifysomeofthedesignaspects.
Inthenextsectionwecontinuetosetforthourchoices,and
Itisimportanttonoticethatauthenticationisimpossi-
thereasonsbehindthem.
bleinanumberofsitutations. Forexample,inapure
adhocnetworktheremaynotbeanypriorinformation
• Centralization. Does the architecture rely on some
aboutthecommunicatingpeers.
centralized servers or authorities? Are they required
• Secure principal attributes. In many circumstances, tobeon-lineduringserviceaccess?
human readable and recognizable names are required
Centralized security architecture probably makes ad-
forauthentication. Servicesmightalsohaveotherat-
ministration in large networks easier. On the other
tributes such as security level (for example, a printer
hand,itdoesn’tworkwellfor,e.g. mobileadhocnet-
for printing classified documents) or the “owner” of
works. Furthermore, there are several somewhat in-
the service (for example, “Alice’s calendar”). Users
dependent features which could be centralized or de-
might have other attributes such as memberships in
centralized. For example, we could have decentral-
groupsorroles.
izedaccesscontrolwitheithercentralizednaming(CA
Notallclientsorservicesnecessarilyhavenameswith type)ordecentralizednaming(forexample,PGP-style
any uniqueness beyond one client or server. For ex- “weboftrust”).
ample,gettingaCA-signedcertificateforthedoorbell
oursideyourdoorsothatitcancontactaserverinside • Trustedcomponents. Doesthesystemrelyonthese-
yourhousetoplayatunedoesn’tseemverysensible. curityofthelookupservice,orsomeotheron-linese-
curityserver?
• Serviceaccesscontrol. Basedontheresultofprinci-
palauthenticationand/orcapabilitiespresentedbythe • Protocol independence. Is the solution tied to some
client and/or other circumstances, the service should transportprotocol,suchastheRMIwireprotocolover
allowsomeoperationsanddenyothers. TLSorIIOP?Iftheprotocolisfixed,itcanbeimple-
mentedusingtrustedcode,whichsimplifiesthesecu-
• Protection from applications. The client Java Virtual
ritysitutation.
Machine(JVM)mightrunmultipleapplications,some
of which are not fully trusted, such as applets and • Service access control model. How flexible and fine-
games. Untrusted applications should not be able to grained is the access control mechanism? What kind
accessserviceswiththeuser’sprivileges. of policies can it support? For example, applica-
• Protectionfromproxies. Thedownloadedproxycode tionswhichaccessmedicaldataprobablyrequiremore
complicatedpoliciesthananofficeenvironment.
needssomespecialpermissions(forexample,tomake
network connections) when running inside the client Thisisinfluencedbyotherchoices.Forexample,ifthe
JVM.Someproxiesmayneedmorepermissionsthan access control is managed by a “container” of some
others. Theseshouldbecontrolledsomehow. Java,of kind,thegranularityisprobablyatmostper-method.
course, provides some facilities for this, but they are
• Application protection model. How flexibly can the
somewhatinsufficientformanyapplications.
user decide which client applications are allowed to
On a lower level, protocol-related aspects such as mes- dowhat? Forexample, ifthesystemusesTLSclient
sageconfidentialityandintegrity,replayprevention,perfect authentication and a server-side access control list
forwardsecrecyofkeying,andsoforth,arealsodesirable. (ACL),therestrictionscan’tprobablybemorespecific
We do not consider these further, since appropriate solu- than per service (i.e., application can use key X only
tionsarewidelyknown. toaccessserviceY).
The actual requirements, of course, vary from case to
case. For example, if the client runs only trusted appli- • Delegation. Doesthesystemsupportdelegation? Can
cations,protectionfromapplicationsmightnotbeneeded. thedelegatedrightsberestrictedsomehow?Howflex-
Someofthese,suchasprotectionfromproxies,couldalso iblearetheserestrictions?
beaddressedseparatelyfromtherest.
• Transparency. Howtransparentthesecuritysystemis
forserviceorclientsoftware?
2.1 Otherdesignaspects
Forexample,inEnterpriseJavaBeanssecurityisman-
The requirements outlined above still leave a lot of free- agedbythe“container”, soitissortoftransparentto
dom for the implementor. The design choices made will the service software. It is probably a good idea tomake the security as transparent as possible to client
User’s key
applications.
Configuration file
3 Solution architecture Hash verification
OurgoalwastoprovideaccesscontrolforJiniclients,ser- Very tl oim si ete rvd i ca eccess Limited access Pro dx ay t ac o hd ae s hand Nam ki en yg authority
vices,andproxieswithoutsacrificinganyessentialJinifea-
tures, such as protocol independence. In our architecture
JAR signature
trust assumptions are made visible by using authorization
certificatesinsteadoftraditionalnamecertificates. Thisal- Proxy key Service admin
key
lowsustoidentifywhatleveloftrustisreallyrequiredby Code signing
key
theapplication,whichisimportantin,e.g.,adhocenviron-
mentswhereafullytrustedthirdpartycan’tbeassumedto
exist. Authentication Full access "My data" "My code"
protocol
3.1 Ourdesignchoices
Name = "Service name"
Whendesigningthesystem,ourtargetenvironmentwasad
Service key
hoc mobilenetworks. Forexample, sucha networkmight
consists of PDAs communicating with a short range radio
network such as Bluetooth [24]. Such an environment re-
Figure 1: Typical certificate chains; the authorization
quiresthatthesolutionisdecentralized,oratleastdoesnot
chain(verifiedbytheservice)isshowninbold,theau-
relyonanyon-linethirdparty,sincesuchapartymightnot
thenticationchain(verifiedbytheuser)indashedline.
be available at all times in an ad hoc network. Therefore,
we also assume that the lookup service isn’t secure. We
alsoearlyrejectedacentralizedoff-linetrustedthirdparty
forsigningthecodeas“trustworthy”,sincewebelievethat tion. Forexample,theusermighttrustawordprocessorto
that kind of solutions are better for assigning blame after- print correctly, and she would delegate the corresponding
wardsthanpreventingwrongthingsfromhappeninginthe permission it. However, the user probably won’t give the
first place. Considering the communication, reliance on a wordprocessorthepermissiontoaccesspersonalcalendar
fixedcommunicationsprotocolwasalsodeemedanunsat- files,becausetheapplicationdoesnotreallyneedit,andit
isfactorysolutionfromthestart. justmightcontaincodethatmisbehaves.
Our solution provides a way for the application to use
SincewehadpriorexperienceinusingSPKIcertificates,
theseauthorizationswithaserviceinJinienvironment.One
wedecidedtousethemfordecentralizingtrust. Inoursys-
of the problems to be solved is how to prove these autho-
tem,clientsandservicesareidentifiedbypublickeys. Un-
rizations through the Jini proxy which is loaded from the
likeinsomeotherarchitectures,namesboundtothesekeys
networkandcannotbefullytrustedbytheuser. Theuser’s
arenotimportant.Thatis,whenperformingtheaccesscon-
secretkeyisrequiredtoprovetheuser’sauthorizationsbut
trol decision, names are not used—names and other secu-
itmustnotbegiventotheproxy.
rityattributesmaybe,ofcourse,usedbytheapplication.
TypicalcertificatechainsareshowninFigure1. Thede-
tailsofproxyverificationsareexplainedbelow.
3.2 Usingauthorization
Wenextdescribeatypicalauthorizationscenarioinourso- 4 Implementation
lution. Theservicekeytypicallydelegatesfullpermissions
fortheservicetotheadministrator’skey,whocanthenau-
Our prototype implementation is responsible for proving
thorizeordinaryuserstousetheservice. Theauthorization
userauthorizationstoservices,authenticatingproxies,and
isexpressedasaSPKIcertificate, wheretheadministrator
verifying authorizations. It is implemented completely in
delegatestheaccessrighttouser’spublickey. Thecertifi-
Java, and consists of about 10000 lines of code. The im-
catesarestoredbyclient.
plementationconsistsofthefollowingcomponents:
The user can delegate a subset of her authorizations to
localapplications. Theauthorizationsdelegatedtotheap- • SPKI certificate library (siesta.security.spki) is used
plication depend on how much the user trusts the applica- forencodinganddecodingSPKIcertificates.Client JVM Client JVM
1. Lookup(Printer) Jini lookup service 1. Lookup(Printer) Jini lookup service
Application Application
2. Proxy download 5. print(doc)
3. print(doc) 2. Proxy download
4. Authenticate
proxy Proxy 7. print(doc, creds)
Proxy 4. print(doc)
Printer
3. Verify 6. Get authorization Printer
Jini security manager
Figure2:AccessingaJiniservice,withoutanysecurity
features.
Figure 3: Accessing a Jini service with our security
modifications.
• Server-sidemodule(siesta.security.authorization)ver-
ifiesSPKIcertificatechains. Itcouldbeconsidereda
sortof“trustmanagementengine”,likeKeyNote,but 3. The application calls some method on the proxy ob-
itissomewhatsimpler. Thispackageanditsconnec- ject, requestingittodowhatevertheservicedoes. In
tionwiththestandardJava2securityarchitectureare ourexample,itaskstheproxytheprintadocument.
describedinSection4.6.
4. The proxy sends the request to the service, which
• Certificate repository (siesta.security.repository) pro- printsthedocument.
videsasimplelocalcertificaterepositorywhereautho-
rization certificates are stored, and a certificate gath- Inthenextsectionwedescribethemodificationsneeded
erer which tries to find a complete certificate chain. inoursecuritysolution.
This could be extended to support of retrieval of cer-
tificatesfromthenetworkusingDNS[18], LDAP,or
4.2 Overviewofthemodifiedprotocol
someotherdirectoryaccessprotocol.
• Client-sidesecuritymoduleisresponsibleforcontrol- WhensecurityisappliedtotypicalJiniscenario,anumber
lingaccesstouser’sprivatekeys,authenticatingprox- ofadditionalstepsareneeded.Ontheclientside,wehavea
ies,andenforcingapplicationaccesscontrol. “Jinisecuritymanager”whichisresponsibleforcontrolling
accesstotheuser’sprivatekeys.Italsoenforcesapplication
• Utilitiestosimplifywritingservicesandclients,such access control. The mechanisms needed at server side de-
assigningproxies,verifyingnamecertificates,etc. pendontherequirementsoftheservice. Thetypicalsteps
takenwhenaccessingaservicearedescribedbelow,andare
• RMI over TLS [10] module supports using client au-
illustratedinFigure3.
thenticationoverTLSsockets,asdescribedinSection
4.7.
1. An application, wishing to use a Jini service, con-
tacts thelookup service, andperforms an appropriate
4.1 Anexamplescenario
lookup (for example, searching for printer services).
Alistofisreturnedtotheapplication. Nospecialse-
The default behavior of a Jini client application and a ser-
curityfeaturesareassumedhere.
vice is shown in Figure 2, where an application prints a
document.
2. The user selects one of the listed services. A serial-
1. An application, wishing to use a Jini service, con- ized proxy object is transported to the client, and the
tacts thelookup service, andperforms an appropriate corresponding bytecode is downloaded (again, using
lookup(forexample,searchingforprinterservices).A standardJinifacilities).
listofavailableservicesisreturnedtotheapplication.
3. The Jini security module asks the proxy for the ser-
2. The user (or the application itself) selects one of the vice’s public key, and checks that this proxy indeed
listedservices.Aserializedproxyobjectistransported represents that service. This is done by checking the
totheclient,andthecorrespondingbytecodeisdown- signatureofthecodeanddataasdescribedinSection
loaded. 4.3.4. Next we have an optional authentication step. If the date,butitisnotpossibletoproducesignatureswhichhave
application knows an identity of the desired service, ashorterlifetimethanthecertificate. Wewantedthatpos-
itcannowasktheJinisecurityservicetoauthenticate siblity (to make sure we are using the right version of the
theservicekey.Authenticatingtheactualidentity(e.g. proxycode),sowehadtomakesomemodifications.
ahumanreadablename)mightinvolvecertificatesob- Therearebasicallytwowaysofachievingtheexpiration.
tainedfromthelookupserviceortheproxyitself,and TheJARfilesignaturecouldbemodifiedtocontainanexpi-
isdescribedbelowinSection4.4. rationdate. Thiswould,however,requiremodificationsto
theJARfileloadingcode. Thisisbynomeansimpossible;
5. The application calls some method on the proxy ob-
it has been done in the TeSSA project to allow delegation
ject, requestingittodowhatevertheservicedoes. In
ofcodepermissionswithSPKIcertificates[27].
ourexample,itaskstheproxytheprintadocument.
Our approach splits the signature to two parts. We sign
the JAR file (using standard Java facilities) using a newly
6. TheproxythenaskstheJinisecuritylibraryforautho-
generated key, whose private half is then destroyed. The
rization. TheJinisecuritymanagerchecksthat(1)the
servicethensuppliesaSPKIcertificatechainfromtheser-
proxyistryingtoreallyaccesstheserviceitrepresents
vice key to this code signing key (usually just one certifi-
and(2)thattheapplicationisallowedtoperformthis
cate). Thiscertificatechainisstoredinthedatapartofthe
operation on behalf of the user. Application access
proxy. Thisapproachhascoupleofadvantages:
controlisdescribedinSection4.5.
Toenforcetheselocalrestrictions,wegenerateatem- • We don’t have to re-sign the JAR file if it hasn’t
porary key for the proxy, and delegate the restricted
changed. Since the JAR files are stored on a web
rights to this temporary key1. A handle to this key is
server, theservicemightnotbeabletoeasilymodify
then given to the proxy. The proxy can’t get the ac-
them.
tual key material through this handle, but it can use
it for signing data (this allows us to “revoke” the key • Wedon’thavetomodifytheJARfileloadingcode.
immediately,ifnecessary).
• WecanuseexistingJDKtoolsforsigningtheJAR.
Thecertificaterepositoriesarethensearchedforother
certificates which might be relevant to the case, and
thecertificatesarereturnedtotheproxy. The main drawback is that the signature expiry date isn’t
visibletothestandardJavacomponents.
7. Using the key handle, the proxy can open a secure In addition to verifying the authenticity of the proxy
connection to the server. The proxy can implement bytecode, we would like verify the proxy object as well.
any protocol it chooses. Our library provides a mod- The straight-forward way would be to calculate the mes-
ulewhichusesRMIoverTLS,asdescribedinSection sage digest of the serialized proxy object. However, this
4.7. failsbecausewedon’treallyknowwhatpartofthedatais
After proving possession of the temporary key, the fixed state worth signing and which is just transient state.
proxysendsthecertificatesandtheservicerequestto Also,theproxymightbecomposedofmultipleobjects.
theserver. Theserverchecksthecertificatechain,and Wesolvedthisbyaskingtheproxyobjecttocalculateits
thenperformstheoperation. Thisaspectisdiscussed ownmessagedigest. Theproxybytecodehasbeenverified
moreinSection4.6. in this point, so the proxy isn’t completely untrusted, and
it isn’t in the service’s interest to return a wrong message
digest.Ontheotherhand,alazyservicewritercoulddefeat
4.3 Proxyverification
thischeckbyalwaysreturningthesamemessagedigest(for
Usuallywewishtoverifythattheproxyreallycamefrom example,zero).
theservicewewant. Sinceservicesareidentifiedbypublic The service then supplies a SPKI certificate chain from
keys,thiscanbearrangedbyhavingboththecodeanddata the service key to the message digest object-hash, and
signedbytheservicekey. However,itshouldbenotedthat stores it in the proxy’s data part. Usually this certificate
due to the ad hoc nature of the network, we do not neces- chainisjustonecertificate.
sarilyknowanythingaboutthe“authenticity”oftheservice
key,atleastnotyet. 1. Wecertainlywishtowriteacertificatethatcanonlybeusedatthe
Duringtheimplementationwediscoveredwhatwecon- servicetheproxyrepresents. However,wenoticedthattherewasn’tany
elegantwaytorestrictthedelegatedcertificateonlytoparticularservice
siderasmalldeficiencyinJava’sfacilitiesforsignedcode.
inSPKI.AlthoughweconsideredaddinganewelementtotheSPKIcer-
It is not possible to give expiration dates for code signa-
tificate(say,named(valid-at (public-key service-key))),
tures. The associated X.509 certificate has an expiration wedecidedtoencodethisinformationatafixedpositioninthetagfield.4.4 Service/proxyauthentication Section4.3).
When the proxy requests some permissions to be dele-
After we have verified the signatures of proxy code and
gated to its temporary key, the Jini security manager con-
state,weknowwhichservicetheproxyrepresents(asiden-
structs the corresponding RemotePermission instance. It
tifiedbytheservice’spublickey).Nowtheapplicationmay
thenusestheJava2stackinspectionfeatures(AccessCon-
wishtoverifyothersecurityattributesoftheservice, such
troller) [37] to verify that the application is authorized for
ashuman-readablenames.
thisaction.
We argue that this is a function best left to the applica-
tion,sincethetrustmodelsareveryapplicationspecific. In
some cases, a traditional solution based on a trusted third
partyisthemostappropriate(e.g.,namingprintersonacor- 4.6 Authorizationchecking
porate network). In many cases, a PGP-style web of trust
maybemoreappropriate. Whentheserverhasreceivedarequestfromtheproxyand
StajanoandAnderson[29]describeanexampleofanad verifiedtheproxy’skey,itgivesthekeyandthecertificates
hoc networking situation where a completely different so- to a SPKI certificate chain verifier module. The verifier
lutionsarerequired.Considerathermometer,havingavery thenverifiescertificatesignaturesandvalidityandfindsall
smalldisplayandcommunicatingusingashort-rangeradio. certificate chains from the service key to the proxy key.
If we have a bowl of disinfectant containing many unused ThesechainsarethenstoredinsideaPermissionCollection
thermometers, it doesn’t really matter which we choose; instance (PermissionCollections are used in the Java 2 se-
but we want to make sure we communicate with the one curityarchitecturetostoreasetofrelatedpermissions).
we have picked from the bowl. The thermometers could,
Theservicesoftwarecanthencalltheimplies()method
ofcourse,begivenartificialnames(suchasserialnumbers,
of the collection, giving a parameter corresponding to
whichcouldbeengravedonthecase),butthissolutionisn’t
the client request (the method then returns either true
veryuserfriendly. Instead,ifwehaveasecure(freeofac-
or false). Storing the authorizations inside a Permis-
tive middle-men) communications channel, such as short-
sionCollection gives the service software another pos-
rangeinfraredorphysicalcontact, wecansimplytransmit
sibility. It can use the AccessController.doPrivileged
thepublickeyoverthischannel.
call to associate the permissions with the Java call
To help application developers in verifying human
stack. Permissions are then checked using normal
readable properties, our utility library provides support
System.getSecurityManager().checkPermission() call. In
for two common cases: names signed by some cen-
many cases, this is a cleaner solution than passing a Per-
tral authority, and ownership of services (such as “John’s
missionCollection object through a long chain of method
siesta.pim.Calendar” service). The properties are repre-
calls,orstoringitinavisiblevariable. Italsoallowscom-
sentedbysubclassesofjava.security.Principal.
municatingthesepermissionstocodewhichdoesn’tknow
theoriginalcallwasaremotecall.
4.5 Applicationaccesscontrol
When designing our system, the environment we had in
4.7 RMIoverTLS
mindwasaPDAusingasinglekeypairstoredonasmart-
card. Thiskeywouldbeusedforaccessingdozensofdif-
ferent services (using many different client applications). Our architecture allows the proxy to implement any pro-
Therefore,wewantedtorestrictwhatapplicationscoulddo tocolforcommunicatingwiththeservice. Inourtests,we
withthekey. Wecallthisfeature“applicationaccesscon- haveusedRMI.ThedefaultRMIconfigurationusesnormal
trol”. TCPsockets,butitispossibletooverridethisbehaviourby
Since we use SPKI certificate chains for authorizations, supplyingapairofsocketfactoriestobeusedontheserver
we can implement more complex restrictions than simply and client side of the communication. This is meant for
allowing or denying access to the key. Our implementa- plugginginTransportLayerSecurity(TLS)sockets.
tion stores these restrictions as a subclass of Permission. Using these facilities, we implemented socket factories
The restrictions are associated with applications using the forTLSclientauthenticationusingtheJavaSecuritySocket
standardJava2policymechanisms[15]. Theonlycasere- Extension (JSSE) libraries [33]. During the implementa-
quiringspecialtreatmentistheproxyclass. Sincethekey tion we found some slight deficiencies in the current RMI
usedforsigningthecodeisn’tthesameastheservicekey, implementation. Hopefully, most of these will be fixed in
thismustbeassociatedwiththepermissionlater(whenthe thenextreleaseofRMI,andintheRMIsecurityextension
proxy state and code have been verified, as described in [32].4.7.1 Problemswithclientauthentication Measurement average(ms) stddev
StandardJini/RMIcall 30 2
Although the socket factories were originally intended for
WithSPKIandTLSapplied 6180 80
plugginginTLSsockets, thedesignsupportscleanlyonly
Withpre-generatedkeys 983 130
serverauthentication. Thesocketfactoriesaregiventothe
constructorofjava.rmi.server.UnicastRemoteObjectwhich Table 1: The results of performance measurements,
is the base class of RMI server objects. The application measuringthetimerequiredforthefirstremotemethod
hasnofurthercontroloftheremotemethodinvocationpro- call through an already authenticated proxy. The sec-
cess. The network connections are formed automatically ondandsubsequentcallstakeabout300msinthese-
whenever the client invokes a remote method and a server curecase.
method is automatically executed with the arguments sent
overthenetwork.Neithertheclientnortheserverhasdirect
quiresquitealotoftime. MostofthetimeisspentinJava
accesstotheunderlyingsocket.
cryptographicprimitives. However,ourcurrentimplemen-
Ontheclientside,itisdifficulttoactuallyverifythatthe tation is quite unoptimized. In particular, the process re-
stub is using the secure socket factory. Even more diffi- quires that a separate public key pair is created on the fly;
cultiscommunicatingthecorrectkeytothesocketfactory, these keys can be generated beforehand, and taken from a
sincethesocketmightbeopenedevenbeforeanymethods poolofpre-generatedkeysduringtheprotocolrun. Asthe
arecalled(duetodistributedgarbagecollection). tableshows,thiscutsthetimerequiredtoamorereasonable
Similarproblemsappearalsoontheserverside. Oncea value.
callisreceived, thereitnowaytogetaccesstothesocket We used Sun’s JDK 1.2.2 under Red Hat Linux 6.2 to
instance it came from. In the case of TLS sockets, the doourmeasurements. Boththeclientandtheserverwere
socketwouldcontainmethodstogettheclient’skey. runonthesamemachine, whichwasequippedwitha750
We worked around these problems (sort of) by commu- MHz AMD Athlon CPU and 256 MB of RAM. The mea-
nicatingthekeysusingthread-localvariables,andcontrol- surementswereruntentimes,andtheaverageandstandard
ling the deserialization of the stub by wrapping it inside a deviationwerecalculated.
MarshalledObject. We later found out that Balfanz et al.
hadindependentlydiscoveredasimilarworkaround[2].
5 Related work
4.7.2 Codebases
5.1 Javasecurity
We also encountered a limitation in the way RMI serial-
izes stubs. When sending a serialized object to a remote Most work in Java security has focused on protecting the
system, a codebase URL is included with it. The URL hostfrommaliciouscode. TheoriginalJDK1.0featureda
specifies the location where the bytecode can be down- sandboxwhichlimitedtheoperationsuntrustedcodecould
loaded. The current RMI implementation gets this code- invoke. Since then, the Java 2 security architecture [15]
base URL from a global system configuration property added more flexible and fine-grained access control. A
named “java.rmi.server.codebase”. This makes running numberofothersolutionshavebeenproposed[36,38,19].
multipleservicesinsidethesameJVMmoredifficult. The Java 2 security architecture has been extended with
Fortunately, if the proxy was originally loaded with a decentralized trust management in [27]. The concept of
subclassofjava.net.URLClassLoader,itsgetURLsmethod "whoisrunningthecode"hasbeenimplementedintheJava
iscalledtogetthecodebaseURL.Ifweloadtheproxyfrom Authentication and Authorization Services (JAAS) [21],
theURLontheserversideaswell,andinstantiateandini- and has been extended with roles in [14]. Controlling the
tialize it using the reflection API, the codebase gets set to amount of resources (computational cycles, memory, etc.)
thecorrectvalue. Wemust,ofcourse,verifythesignature aprogramcanuseisdiscussedin[8].
onthebytecodeontheserversidetomakesurewegotthe
rightproxy.
5.2 Distributed object security, mobile
agents
4.8 Performance
Mostworkrelatedtoremoteobjectsecurityhasfocusedon
Table 1 shows our initial performance figures. Basically, CORBA(forexample,[3,22,31]). Althoughtheconcepts
themeasurementrepresentsthetimerequiredtodelegatea in CORBA security are similar than in Jini, the problem
permissionfromtheclienttotheserverthroughtheproxy. of untrusted proxy code requires different solutions. This
Asthemeasurementsshow,currentlytheauthorizationre- issueisdiscussedinSection5.3below.Themobileagentresearchcommunityhasalsoproduced integratesJiniwithJAASatJavaOne2000[30]. Itisbased
a lot of results related to mobile code and security. Most on a centralized security server, and a certificate authority
ofthatworkhasfocusedonprotectingsitesfrommalicious (CA)signingallproxycode. ItissomewhatsimilartoGe-
agents,andalsoonprotectingagentsfrommalicioushosts. offreyClements’sUsersecurityproject[7].
OftenthesituationisthereverseofthatinJini:ausersends Hasselmeyer et al. have developed a Jini security solu-
an agent to the service site, where it performs some func- tionbasedonacentralizedsecurelookupserver[17]. Sim-
tionsonbehalfoftheuser. InJini,thecodemovesfromthe ilarsecureservicedirectoryinnon-Jinienvironmentisde-
servicetotheclient. scribedbyCzerwinskietal. in[9].
Sun’s future solution for Jini security is the RMI secu-
5.3 Solutionsfordownloadedproxycode rityextension,currentlyindraftstage[32],whichprovides
atleastsomesupportforintelligentproxies. However,the
As explained in Section 1.3, communicating securely initial implementation of it only supports TLS based au-
through downloaded proxy code presents new security thentication, which, in turn, relies on a centralized certifi-
challenges. There are a couple of solutions for this prob- catearchitecture,andseparatesthemechanismsforauthen-
lem,andthefollowingarereportedintheliterature. ticationandaccesscontrol. Furthermore,atrustedcompo-
• Fixed protocol. If the communication protocol is nent(notdownloadedfromthenetwork)isresponsiblefor
opening the network connections and implementing some
fixed, proxies can be generated on the client side, ei-
authenticationprotocol,sothismightlimittheprotocolin-
therstatically(usinganIDLcompiler),ordynamically
dependenceofferedbyJini.
on-the-fly (cf. RMI security extension draft [32]).
Thereisalsoa“JiniandFriendsatWork”projectgoing
Staticallygeneratedproxiesareusedby,e.g.,Balfanz
on at Eurescom, but no results have been published so far
etal. [2].
[13].
• Centrally signed proxies. The proxy code is signed
bysomecentralauthority,andifthesignatureisvalid,
the code is considered fully trusted. This is used by 6 Evaluation and future work
Hasselmeyeretal. [17]andintheSundemonstration
solutionpresentedatJavaOne2000[30]. In this project, our goal was to provide a Jini security so-
• Mixedapproach. IntheRMIsecurityextensiondraft lution that does not unnecessarily restrict the possibilities
for creating secure Jini services. In particular, we wanted
[32], it is also possible to combine dynamically gen-
oursolutiontobeprotocolindependent,torelyonexisting
erated proxies (implementing a fixed protocol) with
Java security mechanisms to the greatest extent possible,
signedhand-writtenproxies.
tobereasonablytransparenttotheclients,serviceproxies,
The hand-written proxy code and data are signed by
andservices,andnottorequireanycentralizedservers.
someone,usuallytheservice. The“trustverifier”ob-
Wefeelthatwehavemostlyreachedthesegoals.Theim-
jectisobtainedfromtheserviceusingthedynamically
plementation allows Jini services to implement any proto-
generatedRMIstub.
colbetweentheproxyandtheservice.Thesolutionutilizes
All of these approaches have their own benefits and the possibilities created by the underlying Java 2 security
drawbacks. Fixing the protocol eliminates the need to architecture and, if used, the existing Java Secure Socket
download the proxies and allow communicating with any Extension (JSSE). Furthermore, there is no need for any
service, but also lose the ability to implement part of the centralized security or other servers. On the other hand,
proxy functionality on the client side. On the other hand, in order to support permission delegation, the proxy and
requiring that the proxies are signed by some central au- theservermusttakeanumberofadditionalsteps,andthey
thorityrestrictsspontaneousnetworking. must transport SPKI certificates in the whatever protocol
The mixed approach seems most promising of these they use. Thus, our solution is not fully transparent to the
three,andresemblesourapproachinthatthedataandcode proxy or the service implementations. But, given the re-
areeffectivelysignedbytheservice(thoughthedetailsare quirementofprotocolindependence,oursolutionseemsto
quitedifferent). However,itlosessomeoftheprotocolin- bereasonablyeasytoutilize, anditisinfullconformance
dependence. withthecentraltoolboxapproachofJini.
Compared to the other proposed solutions, our solution
issimilartotheotherJinisecurityinthesensethatitmainly
5.4 Jini-specificsecurity
addresses the proxy security problem, focusing on the au-
ThesecurityofspecificallyJinisystemshasn’tbeenstudied thentication of the clients and the services, and on autho-
much yet. Sun presented a demonstration solution which rization at the method call level. On the other hand, our7 Conclusions
solutionhasanumberofadditionalbenefits.Themainben-
efitscanbeenumeratedasfollows.
TheJiniapproachprovidesanumberofmethodsandtools
for building distributed applications for decentralized, ad
• The solution does not place any unnecessary restric-
hoc network environments. However, the current state of
tions on the implementation of Jini services. In par-
thetechnologydoesnotadequatelyaddressthesecurityre-
ticular,thesolutionisprotocolindependent,basically
quirementspresentinmanyofsuchenvironments.
allowinganyprotocoltobeusedbetweenaJiniproxy
Inthispaper,wehavebrieflyanalyzedtheclient–service
andthecorrespondingserver.
related security requirements relevant to typical Jini envi-
ronments,anddescribedasoftwarearchitecture,backedup
• Thesolutiondoesnotrequireanycentralizedsecurity byanimplementation,thatprovidesdecentralizedsolutions
services, and therefore it can be easily utilized in ad to these requirements. Our approach is based on apply-
hocnetworks. ingSPKIbasedtrustmanagementtocontrollingJiniprox-
iesanddelegatingJava2permissionsbetweenJiniclients,
proxies,andservices. Ourexperienceindicatesthatitisin-
• ThesolutionallowsfinegrainedJava2permissionsto
deed possible to build a completely decentralized security
be separately applied in the client, proxy, and server.
solution,andapplyittoJiniwithoutlosinganyoftheintrin-
In particular, a client application that requests a Jini
sic Jini properties. In particular, our implementation does
service runs in a separate protection domain than the
not restrict the methods and protocols that can be used to
proxy, thereby restricting the permissions the proxy
implementcommunicationbetweenaserviceanditsprox-
has access to. Furthermore, permissions are explic-
ies. Our initial performance measurements indicate that,
itlydelegatedfromtheapplicationtotheproxy. Thus,
onceoptimized,theapproachshouldprovideadequatepe-
in addition to restricting the permission of the proxy
formanceinpractice.
itself,thisallowstheproxytoprovidetheservicewith
aproofthattheapplicationdoeshavethepermissions
requiredbytheserviceandthattheapplicationreally Acknowledgements
wantstousethepermissionstoaccesstheservice.
Thisworkwouldnothavebeenpossiblewithouttherestof
Sincethepermissionscanbedelegatedtotheservice
theSIESTAteam: JohannesLehtinen,AnttiMannisto,Pe-
(ifdesired),andsincetheycanbepresentedasgenuine
traPietiläinen,SatuVirtanen,andJukkaZitting. Wewould
Java permissions at the service JVM, the service can
also like to thank Yki Kortesniemi, Jonna Särs, and the
furtherusethemwhencallingunrelatedJavacode. In
anonymousreviewersfortheirvaluablecommentsandsug-
otherwords,wehavebasicallyextendedtheJava2ac-
gestions,andPekkaKanervaforhelpinginthepreparation
cesscontrolmechanismstodistributedenvironments,
ofthismanuscript.
allowinganapplicationtopassanyJava2permissions
toaJiniservicethroughtheserviceproxy.2
References
Considering our future directions, there are two major [1] Ken Arnold, Bryan O’Sullivan, Robert W. Scheifler, Jim
branches. First,wewanttotesttheapplicabilityofourso- Waldo,andAnnWollrath. TheJiniSpecification. Addison-
lution to the security of other Jini mechanisms, including Wesley,June1999.
leases, distributed events, and transactions. In particular,
[2] DirkBalfanz, Drew Dean, andMike Spreitzer. Asecurity
we would like to provide a kind of toolbox that would al- infrastructurefordistributedJavaapplications. InProceed-
lowJiniserviceimplementorstoeasilyaddstrong,crypto- ingsofthe2000IEEESymposiumonSecurityandPrivacy,
graphical security to these mechanisms without adversely pages15–26,Oakland,California,May2000.
affecting the environmental requirements of the services.
[3] Konstantin Beznosov, Yi Deng, Bob Blakley, Carol Burt,
Second, we plan to study how to integrate our approach
and John Barkley. A resource access decision service for
with additional Java security mechanisms, including the CORBA-based distributed systems. In Proceedings of the
forthcomingJavaAuthenticationandAuthorizationService
(JAAS)[21]andtheplannedRMISecurityExtension[32]. 2. Astheastutereaderquicklyunderstands,theactualsolutionisnot
Another important aspect which requires further work quitethateasyduetotherequirementofkeepingtherelevantcertificates
alongallthetime. Thatis,inadditiontorepresentingthepermissionsas
is the integration of a certificate revocation or validation
Javaobjects,theymustalsobepresentintheformofproperlyauthorized
mechanism. TherevocationandvalidationofSPKIcertifi-
certificates.Onlythatcreatesapropercertificatechainthattheservercan
catesarediscussedine.g. [20]. usetoverifytheaccesspermissionsoftheclientapplication.15th Annual Computer Security Applications Conference [17] PeerHasselmeyer,RogerKehr,andMarcoVoß. Trade-offs
(ACSAC’99),pages310–319,Phoenix,Arizona,December in a secure Jini service architecture. In Claudia Linnhoff-
1999. Popien and Heinz-Gerd Hegering, editors, Trends in Dis-
tributed Systems: Towards a Universal Service Market.
[4] Matt Blaze, Joan Feigenbaum, John Ioannidis, and Ange-
Third International IFIP/GI working conference proceed-
losD.Keromytis. TheKeyNotetrust-managementsystem
ings(USM2000),LectureNotesinComputerSciencevol-
version2. RFC2704,IETF,September1999.
ume 1890, pages 190–201, Munich, Germany, September
[5] Matt Blaze, Joan Feigenbaum, John Ioannidis, and Ange- 2000.Springer.
los D. Keromytis. The role of trust management in dis-
[18] TeroHasu. StorageandretrievalofSPKIcertificatesusing
tributedsystemssecurity.InJanBosch,JanVitek,andChris-
theDNS. Master’sthesis, HelsinkiUniversityofTechnol-
tian D. Jensen, editors, Secure Internet Programming: Se-
ogy,April1999.
curity Issues for Mobile and Distributed Objects, Lecture
Notes in Computer Science volume 1603, pages 185–210. [19] Trent Jaeger, Atul Prakash, Jochen Liedtke, and Nayeem
Springer,1999. Islam. Flexible control of downloaded executable con-
tent.ACMTransactionsonInformationandSystemSecurity,
[6] MattBlaze,JoanFeigenbaum,andJackLacy.Decentralized
2(2):177–228,May1999.
trustmanagement. InProceedingsofthe1996IEEESym-
posiumonSecurityandPrivacy, pages164–173, Oakland, [20] YkiKortesniemi,TeroHasu,andJonnaSärs. Arevocation,
California,May1996. validation and authentication protocol for SPKI based del-
egationsystems. InProceedings of the 2000 Network and
[7] Geoffrey Clements. Jini Usersecurity project home page.
DistributedSystemSecuritySymposium(NDSS2000),pages
http://www.bald-mountain.com/jini.html,2000.
85–101,SanDiego,California,February2000.
[8] Grzegorz Czajkowski and Thorsten von Eicken. JRes: a
[21] CharlieLai, LiGong, LarryKoved, AnthonyNadalin, and
resource accounting interface for Java. In Proceedings of
RolandSchemers. Userauthenticationandauthorizationin
theConferenceonObject-orientedProgramming, Systems,
theJavaplatform. InProceedingsofthe15thAnnualCom-
Languages,andApplications(OOPSLA’98),pages21–35,
puterSecurityApplicationsConference(ACSAC’99),pages
Vancouver,Canada,October1998.
285–290,Phoenix,Arizona,December1999.
[9] Steven E. Czerwinski, Ben Y. Zhao, Todd D. Hodes, An-
[22] Tuomo Lampinen. Using SPKI certificates for authoriza-
thony D. Joseph, and Randy H. Katz. An architecture for
tion in CORBA based distributed object-oriented systems.
a secure service discovery service. In Proceedings of the
InProceedingsofthe4thNordicWorkshoponSecureITsys-
5th Annual ACM/IEEE International Conference on Mo-
tems(NordSec’99),pages61–81,Kista,Sweden,November
bileComputingandNetworks(MobiCom’99),pages24–35,
1999.
Seattle,Washington,August1999.
[23] Sanna Liimatainen et al. Tessa project home page.
[10] TimDierksandChristopherAllen. TheTLSprotocol,ver-
http://www.tml.hut.fi/Research/TeSSA/,2000.
sion1.0. RFC2246,IETF,January1999.
[24] RikuMettälä. Bluetoothprotocolarchitecturewhitepaper,
[11] CarlEllison,BillFrantz,ButlerLampson,RonRivest,Brian version1.0.BluetoothSpecialInterestGroup,August1999.
Thomas, and Tatu Ylönen. SPKI certificate theory. RFC
[25] Pekka Nikander. An Architecture for Authorization and
2693,IETF,September1999.
Delegation in Distributed Object-Oriented Agent Systems.
[12] Pasi Eronen, Johannes Lehtinen, Jukka Zitting, and Pekka Ph.D. thesis, Helsinki University of Technology, March
Nikander. ExtendingJiniwithdecentralizedtrustmanage- 1999.
ment. In Short paper proceedings of the 3rd IEEE Con-
[26] PekkaNikander.Faulttoleranceindecentralizedandloosely
ference on Open Architectures and Network Programming
coupled systems. In Proceedings of Ericsson Conference
(OPENARCH2000), pages 25–29, Tel Aviv, Israel, March
on Software Engineering, Stockholm, Sweden, September
2000.
2000.
[13] Eurescom. Jini and friends at work project home page.
[27] Pekka Nikander and Jonna Partanen. Distributed policy
http://www.eurescom.de/Public/Projects/P1000-series/
managementforJDK1.2. InProceedingsofthe1999Net-
P1005/P1005.htm,2000.
work and Distributed System Security Symposium (NDSS
[14] Luigi Giuri. Role-based access control on the web using ’99),pages91–101,SanDiego,California,February1999.
Java. In Proceedings of the 4th ACM workshop on Role-
[28] Salutation Consortium. Salutation home page.
basedaccesscontrol(RBAC’99),pages11–18,Fairfax,Vir-
http://www.salutation.org/,2000.
ginia,October1999.
[29] FrankStajanoandRossAnderson. Theresurrectingduck-
[15] LiGong.InsideJava2PlatformSecurity:Architecture,API
ling: Security issues for ad-hoc wireless networks. In
design,andimplementation. Addison-Wesley,June1999.
BruceChristianson,BrunoCrispo,JamesA.Malcolm,and
[16] ErikGuttman,CharlesPerkins,JohnVeizades,andMichael MichaelRoe,editors,SecurityProtocols,7thInternational
Day. Servicelocationprotocol,version2. RFC2608,IETF, WorkshopProceedings,LectureNotesinComputerScience
June1999. volume1796,Cambridge,UK,April1999.Springer.[30] Christopher Steel. Securing Jini connection technology.
Technical presentation 573 at the JavaOne 2000 confer-
ence, San Francisco, California. Slides available from
http://java.sun.com/javaone/javaone00/,June2000.
[31] Daniel F. Sterne, Gregg W. Tally, C. Durward McDonell,
DavidL.Sherman,DavidL.Sames,PierreX.Pasturel,and
E.JohnSebes. Scalableaccesscontrolfordistributedobject
systems. InProceedingsofthe8thUSENIXSecuritySym-
posium,pages201–214,Washington,D.C.,August1999.
[32] Sun Microsystems. Java remote method invocation secu-
rity extension. Technical specification, early look draft
3, http://java.sun.com/products/jdk/rmi/rmisec-doc/, April
2000.
[33] SunMicrosystems.Javasecuresocketextensionhomepage.
http://java.sun.com/products/jsse/,2000.
[34] Universal Plug and Play Forum. Universal plug and play
homepage. http://www.upnp.org/,2000.
[35] JimWaldo,GeoffWyant,AnnWollrath,andSamKendall.
A note on distributed computing. Technical Report
SMLITR-94-29, SunMicrosystemsLaboratories, Novem-
ber1994.
[36] DanS.Wallach,DirkBalfanz,DrewDean,andEdwardW.
Felten. Extensible security architectures for Java. In Pro-
ceedingsofthe16thACMSymposiumonOperatingSystems
Principles(SOSP’97),pages116–128,Saint-Malo,France,
October1997.
[37] DanS.WallachandEdwardW.Felten. UnderstandingJava
stackinspection. InProceedingsofthe1998IEEESympo-
siumonSecurityandPrivacy,pages52–63,Oakland,Cali-
fornia,May1998.
[38] IanWelchandRobertJ.Stroud. Supportingrealworldse-
curitymodelsinJava.InProceedingsofthe7thIEEEWork-
shop on Future Trends of Distributed Computing Systems,
pages155–159,CapeTown,SouthAfrica,December1999.